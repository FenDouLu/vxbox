{"map":"{\"version\":3,\"sources\":[\"webpack/bootstrap\"],\"names\":[\"installedModules\",\"__webpack_require__\",\"moduleId\",\"exports\",\"module\",\"i\",\"l\",\"modules\",\"call\",\"m\",\"c\",\"d\",\"name\",\"getter\",\"o\",\"Object\",\"defineProperty\",\"enumerable\",\"get\",\"r\",\"Symbol\",\"toStringTag\",\"value\",\"t\",\"mode\",\"__esModule\",\"ns\",\"create\",\"key\",\"bind\",\"n\",\"object\",\"property\",\"prototype\",\"hasOwnProperty\",\"p\",\"s\"],\"mappings\":\"aACA,IAAAA,KAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAC,QAGA,IAAAC,EAAAJ,EAAAE,IACAG,EAAAH,EACAI,GAAA,EACAH,YAUA,OANAI,EAAAL,GAAAM,KAAAJ,EAAAD,QAAAC,EAAAA,EAAAD,QAAAF,GAGAG,EAAAE,GAAA,EAGAF,EAAAD,QAKAF,EAAAQ,EAAAF,EAGAN,EAAAS,EAAAV,EAGAC,EAAAU,EAAA,SAAAR,EAAAS,EAAAC,GACAZ,EAAAa,EAAAX,EAAAS,IACAG,OAAAC,eAAAb,EAAAS,GAA0CK,YAAA,EAAAC,IAAAL,KAK1CZ,EAAAkB,EAAA,SAAAhB,GACA,oBAAAiB,QAAAA,OAAAC,aACAN,OAAAC,eAAAb,EAAAiB,OAAAC,aAAwDC,MAAA,WAExDP,OAAAC,eAAAb,EAAA,cAAiDmB,OAAA,KAQjDrB,EAAAsB,EAAA,SAAAD,EAAAE,GAEA,GADA,EAAAA,IAAAF,EAAArB,EAAAqB,IACA,EAAAE,EAAA,OAAAF,EACA,GAAA,EAAAE,GAAA,iBAAAF,GAAAA,GAAAA,EAAAG,WAAA,OAAAH,EACA,IAAAI,EAAAX,OAAAY,OAAA,MAGA,GAFA1B,EAAAkB,EAAAO,GACAX,OAAAC,eAAAU,EAAA,WAAyCT,YAAA,EAAAK,MAAAA,IACzC,EAAAE,GAAA,iBAAAF,EAAA,IAAA,IAAAM,KAAAN,EAAArB,EAAAU,EAAAe,EAAAE,EAAA,SAAAA,GAAgH,OAAAN,EAAAM,IAAqBC,KAAA,KAAAD,IACrI,OAAAF,GAIAzB,EAAA6B,EAAA,SAAA1B,GACA,IAAAS,EAAAT,GAAAA,EAAAqB,WACA,WAA2B,OAAArB,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAH,EAAAU,EAAAE,EAAA,IAAAA,GACAA,GAIAZ,EAAAa,EAAA,SAAAiB,EAAAC,GAAsD,OAAAjB,OAAAkB,UAAAC,eAAA1B,KAAAuB,EAAAC,IAGtD/B,EAAAkC,EAAA,GAIAlC,EAAAA,EAAAmC,EAAA\",\"sourcesContent\":[\" \\t// The module cache\\n \\tvar installedModules = {};\\n\\n \\t// The require function\\n \\tfunction __webpack_require__(moduleId) {\\n\\n \\t\\t// Check if module is in cache\\n \\t\\tif(installedModules[moduleId]) {\\n \\t\\t\\treturn installedModules[moduleId].exports;\\n \\t\\t}\\n \\t\\t// Create a new module (and put it into the cache)\\n \\t\\tvar module = installedModules[moduleId] = {\\n \\t\\t\\ti: moduleId,\\n \\t\\t\\tl: false,\\n \\t\\t\\texports: {}\\n \\t\\t};\\n\\n \\t\\t// Execute the module function\\n \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n\\n \\t\\t// Flag the module as loaded\\n \\t\\tmodule.l = true;\\n\\n \\t\\t// Return the exports of the module\\n \\t\\treturn module.exports;\\n \\t}\\n\\n\\n \\t// expose the modules object (__webpack_modules__)\\n \\t__webpack_require__.m = modules;\\n\\n \\t// expose the module cache\\n \\t__webpack_require__.c = installedModules;\\n\\n \\t// define getter function for harmony exports\\n \\t__webpack_require__.d = function(exports, name, getter) {\\n \\t\\tif(!__webpack_require__.o(exports, name)) {\\n \\t\\t\\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\\n \\t\\t}\\n \\t};\\n\\n \\t// define __esModule on exports\\n \\t__webpack_require__.r = function(exports) {\\n \\t\\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\\n \\t\\t\\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\\n \\t\\t}\\n \\t\\tObject.defineProperty(exports, '__esModule', { value: true });\\n \\t};\\n\\n \\t// create a fake namespace object\\n \\t// mode & 1: value is a module id, require it\\n \\t// mode & 2: merge all properties of value into the ns\\n \\t// mode & 4: return value when already ns object\\n \\t// mode & 8|1: behave like require\\n \\t__webpack_require__.t = function(value, mode) {\\n \\t\\tif(mode & 1) value = __webpack_require__(value);\\n \\t\\tif(mode & 8) return value;\\n \\t\\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\\n \\t\\tvar ns = Object.create(null);\\n \\t\\t__webpack_require__.r(ns);\\n \\t\\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\\n \\t\\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\\n \\t\\treturn ns;\\n \\t};\\n\\n \\t// getDefaultExport function for compatibility with non-harmony modules\\n \\t__webpack_require__.n = function(module) {\\n \\t\\tvar getter = module && module.__esModule ?\\n \\t\\t\\tfunction getDefault() { return module['default']; } :\\n \\t\\t\\tfunction getModuleExports() { return module; };\\n \\t\\t__webpack_require__.d(getter, 'a', getter);\\n \\t\\treturn getter;\\n \\t};\\n\\n \\t// Object.prototype.hasOwnProperty.call\\n \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n\\n \\t// __webpack_public_path__\\n \\t__webpack_require__.p = \\\"\\\";\\n\\n\\n \\t// Load entry module and return exports\\n \\treturn __webpack_require__(__webpack_require__.s = 34);\\n\"]}","code":"!function(n){var B={};function I(g){if(B[g])return B[g].exports;var e=B[g]={i:g,l:!1,exports:{}};return n[g].call(e.exports,e,e.exports,I),e.l=!0,e.exports}I.m=n,I.c=B,I.d=function(n,B,g){I.o(n,B)||Object.defineProperty(n,B,{enumerable:!0,get:g})},I.r=function(n){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(n,\"__esModule\",{value:!0})},I.t=function(n,B){if(1&B&&(n=I(n)),8&B)return n;if(4&B&&\"object\"==typeof n&&n&&n.__esModule)return n;var g=Object.create(null);if(I.r(g),Object.defineProperty(g,\"default\",{enumerable:!0,value:n}),2&B&&\"string\"!=typeof n)for(var e in n)I.d(g,e,function(B){return n[B]}.bind(null,e));return g},I.n=function(n){var B=n&&n.__esModule?function(){return n.default}:function(){return n};return I.d(B,\"a\",B),B},I.o=function(n,B){return Object.prototype.hasOwnProperty.call(n,B)},I.p=\"\",I(I.s=34)}([function(module,exports){eval('var g;\\n\\n// This works in non-strict mode\\ng = (function() {\\n\\treturn this;\\n})();\\n\\ntry {\\n\\t// This works if eval is allowed (see CSP)\\n\\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\\n} catch (e) {\\n\\t// This works if the window reference is available\\n\\tif (typeof window === \"object\") g = window;\\n}\\n\\n// g can still be undefined, but nothing to do about it...\\n// We return undefined, instead of nothing here, so it\\'s\\n// easier to handle this case. if(!global) { ...}\\n\\nmodule.exports = g;\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSwgZXZhbCkoXCJ0aGlzXCIpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///0\\n')},function(module,exports){eval(\"var ENTITIES = [['Aacute', [193]], ['aacute', [225]], ['Abreve', [258]], ['abreve', [259]], ['ac', [8766]], ['acd', [8767]], ['acE', [8766, 819]], ['Acirc', [194]], ['acirc', [226]], ['acute', [180]], ['Acy', [1040]], ['acy', [1072]], ['AElig', [198]], ['aelig', [230]], ['af', [8289]], ['Afr', [120068]], ['afr', [120094]], ['Agrave', [192]], ['agrave', [224]], ['alefsym', [8501]], ['aleph', [8501]], ['Alpha', [913]], ['alpha', [945]], ['Amacr', [256]], ['amacr', [257]], ['amalg', [10815]], ['amp', [38]], ['AMP', [38]], ['andand', [10837]], ['And', [10835]], ['and', [8743]], ['andd', [10844]], ['andslope', [10840]], ['andv', [10842]], ['ang', [8736]], ['ange', [10660]], ['angle', [8736]], ['angmsdaa', [10664]], ['angmsdab', [10665]], ['angmsdac', [10666]], ['angmsdad', [10667]], ['angmsdae', [10668]], ['angmsdaf', [10669]], ['angmsdag', [10670]], ['angmsdah', [10671]], ['angmsd', [8737]], ['angrt', [8735]], ['angrtvb', [8894]], ['angrtvbd', [10653]], ['angsph', [8738]], ['angst', [197]], ['angzarr', [9084]], ['Aogon', [260]], ['aogon', [261]], ['Aopf', [120120]], ['aopf', [120146]], ['apacir', [10863]], ['ap', [8776]], ['apE', [10864]], ['ape', [8778]], ['apid', [8779]], ['apos', [39]], ['ApplyFunction', [8289]], ['approx', [8776]], ['approxeq', [8778]], ['Aring', [197]], ['aring', [229]], ['Ascr', [119964]], ['ascr', [119990]], ['Assign', [8788]], ['ast', [42]], ['asymp', [8776]], ['asympeq', [8781]], ['Atilde', [195]], ['atilde', [227]], ['Auml', [196]], ['auml', [228]], ['awconint', [8755]], ['awint', [10769]], ['backcong', [8780]], ['backepsilon', [1014]], ['backprime', [8245]], ['backsim', [8765]], ['backsimeq', [8909]], ['Backslash', [8726]], ['Barv', [10983]], ['barvee', [8893]], ['barwed', [8965]], ['Barwed', [8966]], ['barwedge', [8965]], ['bbrk', [9141]], ['bbrktbrk', [9142]], ['bcong', [8780]], ['Bcy', [1041]], ['bcy', [1073]], ['bdquo', [8222]], ['becaus', [8757]], ['because', [8757]], ['Because', [8757]], ['bemptyv', [10672]], ['bepsi', [1014]], ['bernou', [8492]], ['Bernoullis', [8492]], ['Beta', [914]], ['beta', [946]], ['beth', [8502]], ['between', [8812]], ['Bfr', [120069]], ['bfr', [120095]], ['bigcap', [8898]], ['bigcirc', [9711]], ['bigcup', [8899]], ['bigodot', [10752]], ['bigoplus', [10753]], ['bigotimes', [10754]], ['bigsqcup', [10758]], ['bigstar', [9733]], ['bigtriangledown', [9661]], ['bigtriangleup', [9651]], ['biguplus', [10756]], ['bigvee', [8897]], ['bigwedge', [8896]], ['bkarow', [10509]], ['blacklozenge', [10731]], ['blacksquare', [9642]], ['blacktriangle', [9652]], ['blacktriangledown', [9662]], ['blacktriangleleft', [9666]], ['blacktriangleright', [9656]], ['blank', [9251]], ['blk12', [9618]], ['blk14', [9617]], ['blk34', [9619]], ['block', [9608]], ['bne', [61, 8421]], ['bnequiv', [8801, 8421]], ['bNot', [10989]], ['bnot', [8976]], ['Bopf', [120121]], ['bopf', [120147]], ['bot', [8869]], ['bottom', [8869]], ['bowtie', [8904]], ['boxbox', [10697]], ['boxdl', [9488]], ['boxdL', [9557]], ['boxDl', [9558]], ['boxDL', [9559]], ['boxdr', [9484]], ['boxdR', [9554]], ['boxDr', [9555]], ['boxDR', [9556]], ['boxh', [9472]], ['boxH', [9552]], ['boxhd', [9516]], ['boxHd', [9572]], ['boxhD', [9573]], ['boxHD', [9574]], ['boxhu', [9524]], ['boxHu', [9575]], ['boxhU', [9576]], ['boxHU', [9577]], ['boxminus', [8863]], ['boxplus', [8862]], ['boxtimes', [8864]], ['boxul', [9496]], ['boxuL', [9563]], ['boxUl', [9564]], ['boxUL', [9565]], ['boxur', [9492]], ['boxuR', [9560]], ['boxUr', [9561]], ['boxUR', [9562]], ['boxv', [9474]], ['boxV', [9553]], ['boxvh', [9532]], ['boxvH', [9578]], ['boxVh', [9579]], ['boxVH', [9580]], ['boxvl', [9508]], ['boxvL', [9569]], ['boxVl', [9570]], ['boxVL', [9571]], ['boxvr', [9500]], ['boxvR', [9566]], ['boxVr', [9567]], ['boxVR', [9568]], ['bprime', [8245]], ['breve', [728]], ['Breve', [728]], ['brvbar', [166]], ['bscr', [119991]], ['Bscr', [8492]], ['bsemi', [8271]], ['bsim', [8765]], ['bsime', [8909]], ['bsolb', [10693]], ['bsol', [92]], ['bsolhsub', [10184]], ['bull', [8226]], ['bullet', [8226]], ['bump', [8782]], ['bumpE', [10926]], ['bumpe', [8783]], ['Bumpeq', [8782]], ['bumpeq', [8783]], ['Cacute', [262]], ['cacute', [263]], ['capand', [10820]], ['capbrcup', [10825]], ['capcap', [10827]], ['cap', [8745]], ['Cap', [8914]], ['capcup', [10823]], ['capdot', [10816]], ['CapitalDifferentialD', [8517]], ['caps', [8745, 65024]], ['caret', [8257]], ['caron', [711]], ['Cayleys', [8493]], ['ccaps', [10829]], ['Ccaron', [268]], ['ccaron', [269]], ['Ccedil', [199]], ['ccedil', [231]], ['Ccirc', [264]], ['ccirc', [265]], ['Cconint', [8752]], ['ccups', [10828]], ['ccupssm', [10832]], ['Cdot', [266]], ['cdot', [267]], ['cedil', [184]], ['Cedilla', [184]], ['cemptyv', [10674]], ['cent', [162]], ['centerdot', [183]], ['CenterDot', [183]], ['cfr', [120096]], ['Cfr', [8493]], ['CHcy', [1063]], ['chcy', [1095]], ['check', [10003]], ['checkmark', [10003]], ['Chi', [935]], ['chi', [967]], ['circ', [710]], ['circeq', [8791]], ['circlearrowleft', [8634]], ['circlearrowright', [8635]], ['circledast', [8859]], ['circledcirc', [8858]], ['circleddash', [8861]], ['CircleDot', [8857]], ['circledR', [174]], ['circledS', [9416]], ['CircleMinus', [8854]], ['CirclePlus', [8853]], ['CircleTimes', [8855]], ['cir', [9675]], ['cirE', [10691]], ['cire', [8791]], ['cirfnint', [10768]], ['cirmid', [10991]], ['cirscir', [10690]], ['ClockwiseContourIntegral', [8754]], ['clubs', [9827]], ['clubsuit', [9827]], ['colon', [58]], ['Colon', [8759]], ['Colone', [10868]], ['colone', [8788]], ['coloneq', [8788]], ['comma', [44]], ['commat', [64]], ['comp', [8705]], ['compfn', [8728]], ['complement', [8705]], ['complexes', [8450]], ['cong', [8773]], ['congdot', [10861]], ['Congruent', [8801]], ['conint', [8750]], ['Conint', [8751]], ['ContourIntegral', [8750]], ['copf', [120148]], ['Copf', [8450]], ['coprod', [8720]], ['Coproduct', [8720]], ['copy', [169]], ['COPY', [169]], ['copysr', [8471]], ['CounterClockwiseContourIntegral', [8755]], ['crarr', [8629]], ['cross', [10007]], ['Cross', [10799]], ['Cscr', [119966]], ['cscr', [119992]], ['csub', [10959]], ['csube', [10961]], ['csup', [10960]], ['csupe', [10962]], ['ctdot', [8943]], ['cudarrl', [10552]], ['cudarrr', [10549]], ['cuepr', [8926]], ['cuesc', [8927]], ['cularr', [8630]], ['cularrp', [10557]], ['cupbrcap', [10824]], ['cupcap', [10822]], ['CupCap', [8781]], ['cup', [8746]], ['Cup', [8915]], ['cupcup', [10826]], ['cupdot', [8845]], ['cupor', [10821]], ['cups', [8746, 65024]], ['curarr', [8631]], ['curarrm', [10556]], ['curlyeqprec', [8926]], ['curlyeqsucc', [8927]], ['curlyvee', [8910]], ['curlywedge', [8911]], ['curren', [164]], ['curvearrowleft', [8630]], ['curvearrowright', [8631]], ['cuvee', [8910]], ['cuwed', [8911]], ['cwconint', [8754]], ['cwint', [8753]], ['cylcty', [9005]], ['dagger', [8224]], ['Dagger', [8225]], ['daleth', [8504]], ['darr', [8595]], ['Darr', [8609]], ['dArr', [8659]], ['dash', [8208]], ['Dashv', [10980]], ['dashv', [8867]], ['dbkarow', [10511]], ['dblac', [733]], ['Dcaron', [270]], ['dcaron', [271]], ['Dcy', [1044]], ['dcy', [1076]], ['ddagger', [8225]], ['ddarr', [8650]], ['DD', [8517]], ['dd', [8518]], ['DDotrahd', [10513]], ['ddotseq', [10871]], ['deg', [176]], ['Del', [8711]], ['Delta', [916]], ['delta', [948]], ['demptyv', [10673]], ['dfisht', [10623]], ['Dfr', [120071]], ['dfr', [120097]], ['dHar', [10597]], ['dharl', [8643]], ['dharr', [8642]], ['DiacriticalAcute', [180]], ['DiacriticalDot', [729]], ['DiacriticalDoubleAcute', [733]], ['DiacriticalGrave', [96]], ['DiacriticalTilde', [732]], ['diam', [8900]], ['diamond', [8900]], ['Diamond', [8900]], ['diamondsuit', [9830]], ['diams', [9830]], ['die', [168]], ['DifferentialD', [8518]], ['digamma', [989]], ['disin', [8946]], ['div', [247]], ['divide', [247]], ['divideontimes', [8903]], ['divonx', [8903]], ['DJcy', [1026]], ['djcy', [1106]], ['dlcorn', [8990]], ['dlcrop', [8973]], ['dollar', [36]], ['Dopf', [120123]], ['dopf', [120149]], ['Dot', [168]], ['dot', [729]], ['DotDot', [8412]], ['doteq', [8784]], ['doteqdot', [8785]], ['DotEqual', [8784]], ['dotminus', [8760]], ['dotplus', [8724]], ['dotsquare', [8865]], ['doublebarwedge', [8966]], ['DoubleContourIntegral', [8751]], ['DoubleDot', [168]], ['DoubleDownArrow', [8659]], ['DoubleLeftArrow', [8656]], ['DoubleLeftRightArrow', [8660]], ['DoubleLeftTee', [10980]], ['DoubleLongLeftArrow', [10232]], ['DoubleLongLeftRightArrow', [10234]], ['DoubleLongRightArrow', [10233]], ['DoubleRightArrow', [8658]], ['DoubleRightTee', [8872]], ['DoubleUpArrow', [8657]], ['DoubleUpDownArrow', [8661]], ['DoubleVerticalBar', [8741]], ['DownArrowBar', [10515]], ['downarrow', [8595]], ['DownArrow', [8595]], ['Downarrow', [8659]], ['DownArrowUpArrow', [8693]], ['DownBreve', [785]], ['downdownarrows', [8650]], ['downharpoonleft', [8643]], ['downharpoonright', [8642]], ['DownLeftRightVector', [10576]], ['DownLeftTeeVector', [10590]], ['DownLeftVectorBar', [10582]], ['DownLeftVector', [8637]], ['DownRightTeeVector', [10591]], ['DownRightVectorBar', [10583]], ['DownRightVector', [8641]], ['DownTeeArrow', [8615]], ['DownTee', [8868]], ['drbkarow', [10512]], ['drcorn', [8991]], ['drcrop', [8972]], ['Dscr', [119967]], ['dscr', [119993]], ['DScy', [1029]], ['dscy', [1109]], ['dsol', [10742]], ['Dstrok', [272]], ['dstrok', [273]], ['dtdot', [8945]], ['dtri', [9663]], ['dtrif', [9662]], ['duarr', [8693]], ['duhar', [10607]], ['dwangle', [10662]], ['DZcy', [1039]], ['dzcy', [1119]], ['dzigrarr', [10239]], ['Eacute', [201]], ['eacute', [233]], ['easter', [10862]], ['Ecaron', [282]], ['ecaron', [283]], ['Ecirc', [202]], ['ecirc', [234]], ['ecir', [8790]], ['ecolon', [8789]], ['Ecy', [1069]], ['ecy', [1101]], ['eDDot', [10871]], ['Edot', [278]], ['edot', [279]], ['eDot', [8785]], ['ee', [8519]], ['efDot', [8786]], ['Efr', [120072]], ['efr', [120098]], ['eg', [10906]], ['Egrave', [200]], ['egrave', [232]], ['egs', [10902]], ['egsdot', [10904]], ['el', [10905]], ['Element', [8712]], ['elinters', [9191]], ['ell', [8467]], ['els', [10901]], ['elsdot', [10903]], ['Emacr', [274]], ['emacr', [275]], ['empty', [8709]], ['emptyset', [8709]], ['EmptySmallSquare', [9723]], ['emptyv', [8709]], ['EmptyVerySmallSquare', [9643]], ['emsp13', [8196]], ['emsp14', [8197]], ['emsp', [8195]], ['ENG', [330]], ['eng', [331]], ['ensp', [8194]], ['Eogon', [280]], ['eogon', [281]], ['Eopf', [120124]], ['eopf', [120150]], ['epar', [8917]], ['eparsl', [10723]], ['eplus', [10865]], ['epsi', [949]], ['Epsilon', [917]], ['epsilon', [949]], ['epsiv', [1013]], ['eqcirc', [8790]], ['eqcolon', [8789]], ['eqsim', [8770]], ['eqslantgtr', [10902]], ['eqslantless', [10901]], ['Equal', [10869]], ['equals', [61]], ['EqualTilde', [8770]], ['equest', [8799]], ['Equilibrium', [8652]], ['equiv', [8801]], ['equivDD', [10872]], ['eqvparsl', [10725]], ['erarr', [10609]], ['erDot', [8787]], ['escr', [8495]], ['Escr', [8496]], ['esdot', [8784]], ['Esim', [10867]], ['esim', [8770]], ['Eta', [919]], ['eta', [951]], ['ETH', [208]], ['eth', [240]], ['Euml', [203]], ['euml', [235]], ['euro', [8364]], ['excl', [33]], ['exist', [8707]], ['Exists', [8707]], ['expectation', [8496]], ['exponentiale', [8519]], ['ExponentialE', [8519]], ['fallingdotseq', [8786]], ['Fcy', [1060]], ['fcy', [1092]], ['female', [9792]], ['ffilig', [64259]], ['fflig', [64256]], ['ffllig', [64260]], ['Ffr', [120073]], ['ffr', [120099]], ['filig', [64257]], ['FilledSmallSquare', [9724]], ['FilledVerySmallSquare', [9642]], ['fjlig', [102, 106]], ['flat', [9837]], ['fllig', [64258]], ['fltns', [9649]], ['fnof', [402]], ['Fopf', [120125]], ['fopf', [120151]], ['forall', [8704]], ['ForAll', [8704]], ['fork', [8916]], ['forkv', [10969]], ['Fouriertrf', [8497]], ['fpartint', [10765]], ['frac12', [189]], ['frac13', [8531]], ['frac14', [188]], ['frac15', [8533]], ['frac16', [8537]], ['frac18', [8539]], ['frac23', [8532]], ['frac25', [8534]], ['frac34', [190]], ['frac35', [8535]], ['frac38', [8540]], ['frac45', [8536]], ['frac56', [8538]], ['frac58', [8541]], ['frac78', [8542]], ['frasl', [8260]], ['frown', [8994]], ['fscr', [119995]], ['Fscr', [8497]], ['gacute', [501]], ['Gamma', [915]], ['gamma', [947]], ['Gammad', [988]], ['gammad', [989]], ['gap', [10886]], ['Gbreve', [286]], ['gbreve', [287]], ['Gcedil', [290]], ['Gcirc', [284]], ['gcirc', [285]], ['Gcy', [1043]], ['gcy', [1075]], ['Gdot', [288]], ['gdot', [289]], ['ge', [8805]], ['gE', [8807]], ['gEl', [10892]], ['gel', [8923]], ['geq', [8805]], ['geqq', [8807]], ['geqslant', [10878]], ['gescc', [10921]], ['ges', [10878]], ['gesdot', [10880]], ['gesdoto', [10882]], ['gesdotol', [10884]], ['gesl', [8923, 65024]], ['gesles', [10900]], ['Gfr', [120074]], ['gfr', [120100]], ['gg', [8811]], ['Gg', [8921]], ['ggg', [8921]], ['gimel', [8503]], ['GJcy', [1027]], ['gjcy', [1107]], ['gla', [10917]], ['gl', [8823]], ['glE', [10898]], ['glj', [10916]], ['gnap', [10890]], ['gnapprox', [10890]], ['gne', [10888]], ['gnE', [8809]], ['gneq', [10888]], ['gneqq', [8809]], ['gnsim', [8935]], ['Gopf', [120126]], ['gopf', [120152]], ['grave', [96]], ['GreaterEqual', [8805]], ['GreaterEqualLess', [8923]], ['GreaterFullEqual', [8807]], ['GreaterGreater', [10914]], ['GreaterLess', [8823]], ['GreaterSlantEqual', [10878]], ['GreaterTilde', [8819]], ['Gscr', [119970]], ['gscr', [8458]], ['gsim', [8819]], ['gsime', [10894]], ['gsiml', [10896]], ['gtcc', [10919]], ['gtcir', [10874]], ['gt', [62]], ['GT', [62]], ['Gt', [8811]], ['gtdot', [8919]], ['gtlPar', [10645]], ['gtquest', [10876]], ['gtrapprox', [10886]], ['gtrarr', [10616]], ['gtrdot', [8919]], ['gtreqless', [8923]], ['gtreqqless', [10892]], ['gtrless', [8823]], ['gtrsim', [8819]], ['gvertneqq', [8809, 65024]], ['gvnE', [8809, 65024]], ['Hacek', [711]], ['hairsp', [8202]], ['half', [189]], ['hamilt', [8459]], ['HARDcy', [1066]], ['hardcy', [1098]], ['harrcir', [10568]], ['harr', [8596]], ['hArr', [8660]], ['harrw', [8621]], ['Hat', [94]], ['hbar', [8463]], ['Hcirc', [292]], ['hcirc', [293]], ['hearts', [9829]], ['heartsuit', [9829]], ['hellip', [8230]], ['hercon', [8889]], ['hfr', [120101]], ['Hfr', [8460]], ['HilbertSpace', [8459]], ['hksearow', [10533]], ['hkswarow', [10534]], ['hoarr', [8703]], ['homtht', [8763]], ['hookleftarrow', [8617]], ['hookrightarrow', [8618]], ['hopf', [120153]], ['Hopf', [8461]], ['horbar', [8213]], ['HorizontalLine', [9472]], ['hscr', [119997]], ['Hscr', [8459]], ['hslash', [8463]], ['Hstrok', [294]], ['hstrok', [295]], ['HumpDownHump', [8782]], ['HumpEqual', [8783]], ['hybull', [8259]], ['hyphen', [8208]], ['Iacute', [205]], ['iacute', [237]], ['ic', [8291]], ['Icirc', [206]], ['icirc', [238]], ['Icy', [1048]], ['icy', [1080]], ['Idot', [304]], ['IEcy', [1045]], ['iecy', [1077]], ['iexcl', [161]], ['iff', [8660]], ['ifr', [120102]], ['Ifr', [8465]], ['Igrave', [204]], ['igrave', [236]], ['ii', [8520]], ['iiiint', [10764]], ['iiint', [8749]], ['iinfin', [10716]], ['iiota', [8489]], ['IJlig', [306]], ['ijlig', [307]], ['Imacr', [298]], ['imacr', [299]], ['image', [8465]], ['ImaginaryI', [8520]], ['imagline', [8464]], ['imagpart', [8465]], ['imath', [305]], ['Im', [8465]], ['imof', [8887]], ['imped', [437]], ['Implies', [8658]], ['incare', [8453]], ['in', [8712]], ['infin', [8734]], ['infintie', [10717]], ['inodot', [305]], ['intcal', [8890]], ['int', [8747]], ['Int', [8748]], ['integers', [8484]], ['Integral', [8747]], ['intercal', [8890]], ['Intersection', [8898]], ['intlarhk', [10775]], ['intprod', [10812]], ['InvisibleComma', [8291]], ['InvisibleTimes', [8290]], ['IOcy', [1025]], ['iocy', [1105]], ['Iogon', [302]], ['iogon', [303]], ['Iopf', [120128]], ['iopf', [120154]], ['Iota', [921]], ['iota', [953]], ['iprod', [10812]], ['iquest', [191]], ['iscr', [119998]], ['Iscr', [8464]], ['isin', [8712]], ['isindot', [8949]], ['isinE', [8953]], ['isins', [8948]], ['isinsv', [8947]], ['isinv', [8712]], ['it', [8290]], ['Itilde', [296]], ['itilde', [297]], ['Iukcy', [1030]], ['iukcy', [1110]], ['Iuml', [207]], ['iuml', [239]], ['Jcirc', [308]], ['jcirc', [309]], ['Jcy', [1049]], ['jcy', [1081]], ['Jfr', [120077]], ['jfr', [120103]], ['jmath', [567]], ['Jopf', [120129]], ['jopf', [120155]], ['Jscr', [119973]], ['jscr', [119999]], ['Jsercy', [1032]], ['jsercy', [1112]], ['Jukcy', [1028]], ['jukcy', [1108]], ['Kappa', [922]], ['kappa', [954]], ['kappav', [1008]], ['Kcedil', [310]], ['kcedil', [311]], ['Kcy', [1050]], ['kcy', [1082]], ['Kfr', [120078]], ['kfr', [120104]], ['kgreen', [312]], ['KHcy', [1061]], ['khcy', [1093]], ['KJcy', [1036]], ['kjcy', [1116]], ['Kopf', [120130]], ['kopf', [120156]], ['Kscr', [119974]], ['kscr', [120000]], ['lAarr', [8666]], ['Lacute', [313]], ['lacute', [314]], ['laemptyv', [10676]], ['lagran', [8466]], ['Lambda', [923]], ['lambda', [955]], ['lang', [10216]], ['Lang', [10218]], ['langd', [10641]], ['langle', [10216]], ['lap', [10885]], ['Laplacetrf', [8466]], ['laquo', [171]], ['larrb', [8676]], ['larrbfs', [10527]], ['larr', [8592]], ['Larr', [8606]], ['lArr', [8656]], ['larrfs', [10525]], ['larrhk', [8617]], ['larrlp', [8619]], ['larrpl', [10553]], ['larrsim', [10611]], ['larrtl', [8610]], ['latail', [10521]], ['lAtail', [10523]], ['lat', [10923]], ['late', [10925]], ['lates', [10925, 65024]], ['lbarr', [10508]], ['lBarr', [10510]], ['lbbrk', [10098]], ['lbrace', [123]], ['lbrack', [91]], ['lbrke', [10635]], ['lbrksld', [10639]], ['lbrkslu', [10637]], ['Lcaron', [317]], ['lcaron', [318]], ['Lcedil', [315]], ['lcedil', [316]], ['lceil', [8968]], ['lcub', [123]], ['Lcy', [1051]], ['lcy', [1083]], ['ldca', [10550]], ['ldquo', [8220]], ['ldquor', [8222]], ['ldrdhar', [10599]], ['ldrushar', [10571]], ['ldsh', [8626]], ['le', [8804]], ['lE', [8806]], ['LeftAngleBracket', [10216]], ['LeftArrowBar', [8676]], ['leftarrow', [8592]], ['LeftArrow', [8592]], ['Leftarrow', [8656]], ['LeftArrowRightArrow', [8646]], ['leftarrowtail', [8610]], ['LeftCeiling', [8968]], ['LeftDoubleBracket', [10214]], ['LeftDownTeeVector', [10593]], ['LeftDownVectorBar', [10585]], ['LeftDownVector', [8643]], ['LeftFloor', [8970]], ['leftharpoondown', [8637]], ['leftharpoonup', [8636]], ['leftleftarrows', [8647]], ['leftrightarrow', [8596]], ['LeftRightArrow', [8596]], ['Leftrightarrow', [8660]], ['leftrightarrows', [8646]], ['leftrightharpoons', [8651]], ['leftrightsquigarrow', [8621]], ['LeftRightVector', [10574]], ['LeftTeeArrow', [8612]], ['LeftTee', [8867]], ['LeftTeeVector', [10586]], ['leftthreetimes', [8907]], ['LeftTriangleBar', [10703]], ['LeftTriangle', [8882]], ['LeftTriangleEqual', [8884]], ['LeftUpDownVector', [10577]], ['LeftUpTeeVector', [10592]], ['LeftUpVectorBar', [10584]], ['LeftUpVector', [8639]], ['LeftVectorBar', [10578]], ['LeftVector', [8636]], ['lEg', [10891]], ['leg', [8922]], ['leq', [8804]], ['leqq', [8806]], ['leqslant', [10877]], ['lescc', [10920]], ['les', [10877]], ['lesdot', [10879]], ['lesdoto', [10881]], ['lesdotor', [10883]], ['lesg', [8922, 65024]], ['lesges', [10899]], ['lessapprox', [10885]], ['lessdot', [8918]], ['lesseqgtr', [8922]], ['lesseqqgtr', [10891]], ['LessEqualGreater', [8922]], ['LessFullEqual', [8806]], ['LessGreater', [8822]], ['lessgtr', [8822]], ['LessLess', [10913]], ['lesssim', [8818]], ['LessSlantEqual', [10877]], ['LessTilde', [8818]], ['lfisht', [10620]], ['lfloor', [8970]], ['Lfr', [120079]], ['lfr', [120105]], ['lg', [8822]], ['lgE', [10897]], ['lHar', [10594]], ['lhard', [8637]], ['lharu', [8636]], ['lharul', [10602]], ['lhblk', [9604]], ['LJcy', [1033]], ['ljcy', [1113]], ['llarr', [8647]], ['ll', [8810]], ['Ll', [8920]], ['llcorner', [8990]], ['Lleftarrow', [8666]], ['llhard', [10603]], ['lltri', [9722]], ['Lmidot', [319]], ['lmidot', [320]], ['lmoustache', [9136]], ['lmoust', [9136]], ['lnap', [10889]], ['lnapprox', [10889]], ['lne', [10887]], ['lnE', [8808]], ['lneq', [10887]], ['lneqq', [8808]], ['lnsim', [8934]], ['loang', [10220]], ['loarr', [8701]], ['lobrk', [10214]], ['longleftarrow', [10229]], ['LongLeftArrow', [10229]], ['Longleftarrow', [10232]], ['longleftrightarrow', [10231]], ['LongLeftRightArrow', [10231]], ['Longleftrightarrow', [10234]], ['longmapsto', [10236]], ['longrightarrow', [10230]], ['LongRightArrow', [10230]], ['Longrightarrow', [10233]], ['looparrowleft', [8619]], ['looparrowright', [8620]], ['lopar', [10629]], ['Lopf', [120131]], ['lopf', [120157]], ['loplus', [10797]], ['lotimes', [10804]], ['lowast', [8727]], ['lowbar', [95]], ['LowerLeftArrow', [8601]], ['LowerRightArrow', [8600]], ['loz', [9674]], ['lozenge', [9674]], ['lozf', [10731]], ['lpar', [40]], ['lparlt', [10643]], ['lrarr', [8646]], ['lrcorner', [8991]], ['lrhar', [8651]], ['lrhard', [10605]], ['lrm', [8206]], ['lrtri', [8895]], ['lsaquo', [8249]], ['lscr', [120001]], ['Lscr', [8466]], ['lsh', [8624]], ['Lsh', [8624]], ['lsim', [8818]], ['lsime', [10893]], ['lsimg', [10895]], ['lsqb', [91]], ['lsquo', [8216]], ['lsquor', [8218]], ['Lstrok', [321]], ['lstrok', [322]], ['ltcc', [10918]], ['ltcir', [10873]], ['lt', [60]], ['LT', [60]], ['Lt', [8810]], ['ltdot', [8918]], ['lthree', [8907]], ['ltimes', [8905]], ['ltlarr', [10614]], ['ltquest', [10875]], ['ltri', [9667]], ['ltrie', [8884]], ['ltrif', [9666]], ['ltrPar', [10646]], ['lurdshar', [10570]], ['luruhar', [10598]], ['lvertneqq', [8808, 65024]], ['lvnE', [8808, 65024]], ['macr', [175]], ['male', [9794]], ['malt', [10016]], ['maltese', [10016]], ['Map', [10501]], ['map', [8614]], ['mapsto', [8614]], ['mapstodown', [8615]], ['mapstoleft', [8612]], ['mapstoup', [8613]], ['marker', [9646]], ['mcomma', [10793]], ['Mcy', [1052]], ['mcy', [1084]], ['mdash', [8212]], ['mDDot', [8762]], ['measuredangle', [8737]], ['MediumSpace', [8287]], ['Mellintrf', [8499]], ['Mfr', [120080]], ['mfr', [120106]], ['mho', [8487]], ['micro', [181]], ['midast', [42]], ['midcir', [10992]], ['mid', [8739]], ['middot', [183]], ['minusb', [8863]], ['minus', [8722]], ['minusd', [8760]], ['minusdu', [10794]], ['MinusPlus', [8723]], ['mlcp', [10971]], ['mldr', [8230]], ['mnplus', [8723]], ['models', [8871]], ['Mopf', [120132]], ['mopf', [120158]], ['mp', [8723]], ['mscr', [120002]], ['Mscr', [8499]], ['mstpos', [8766]], ['Mu', [924]], ['mu', [956]], ['multimap', [8888]], ['mumap', [8888]], ['nabla', [8711]], ['Nacute', [323]], ['nacute', [324]], ['nang', [8736, 8402]], ['nap', [8777]], ['napE', [10864, 824]], ['napid', [8779, 824]], ['napos', [329]], ['napprox', [8777]], ['natural', [9838]], ['naturals', [8469]], ['natur', [9838]], ['nbsp', [160]], ['nbump', [8782, 824]], ['nbumpe', [8783, 824]], ['ncap', [10819]], ['Ncaron', [327]], ['ncaron', [328]], ['Ncedil', [325]], ['ncedil', [326]], ['ncong', [8775]], ['ncongdot', [10861, 824]], ['ncup', [10818]], ['Ncy', [1053]], ['ncy', [1085]], ['ndash', [8211]], ['nearhk', [10532]], ['nearr', [8599]], ['neArr', [8663]], ['nearrow', [8599]], ['ne', [8800]], ['nedot', [8784, 824]], ['NegativeMediumSpace', [8203]], ['NegativeThickSpace', [8203]], ['NegativeThinSpace', [8203]], ['NegativeVeryThinSpace', [8203]], ['nequiv', [8802]], ['nesear', [10536]], ['nesim', [8770, 824]], ['NestedGreaterGreater', [8811]], ['NestedLessLess', [8810]], ['nexist', [8708]], ['nexists', [8708]], ['Nfr', [120081]], ['nfr', [120107]], ['ngE', [8807, 824]], ['nge', [8817]], ['ngeq', [8817]], ['ngeqq', [8807, 824]], ['ngeqslant', [10878, 824]], ['nges', [10878, 824]], ['nGg', [8921, 824]], ['ngsim', [8821]], ['nGt', [8811, 8402]], ['ngt', [8815]], ['ngtr', [8815]], ['nGtv', [8811, 824]], ['nharr', [8622]], ['nhArr', [8654]], ['nhpar', [10994]], ['ni', [8715]], ['nis', [8956]], ['nisd', [8954]], ['niv', [8715]], ['NJcy', [1034]], ['njcy', [1114]], ['nlarr', [8602]], ['nlArr', [8653]], ['nldr', [8229]], ['nlE', [8806, 824]], ['nle', [8816]], ['nleftarrow', [8602]], ['nLeftarrow', [8653]], ['nleftrightarrow', [8622]], ['nLeftrightarrow', [8654]], ['nleq', [8816]], ['nleqq', [8806, 824]], ['nleqslant', [10877, 824]], ['nles', [10877, 824]], ['nless', [8814]], ['nLl', [8920, 824]], ['nlsim', [8820]], ['nLt', [8810, 8402]], ['nlt', [8814]], ['nltri', [8938]], ['nltrie', [8940]], ['nLtv', [8810, 824]], ['nmid', [8740]], ['NoBreak', [8288]], ['NonBreakingSpace', [160]], ['nopf', [120159]], ['Nopf', [8469]], ['Not', [10988]], ['not', [172]], ['NotCongruent', [8802]], ['NotCupCap', [8813]], ['NotDoubleVerticalBar', [8742]], ['NotElement', [8713]], ['NotEqual', [8800]], ['NotEqualTilde', [8770, 824]], ['NotExists', [8708]], ['NotGreater', [8815]], ['NotGreaterEqual', [8817]], ['NotGreaterFullEqual', [8807, 824]], ['NotGreaterGreater', [8811, 824]], ['NotGreaterLess', [8825]], ['NotGreaterSlantEqual', [10878, 824]], ['NotGreaterTilde', [8821]], ['NotHumpDownHump', [8782, 824]], ['NotHumpEqual', [8783, 824]], ['notin', [8713]], ['notindot', [8949, 824]], ['notinE', [8953, 824]], ['notinva', [8713]], ['notinvb', [8951]], ['notinvc', [8950]], ['NotLeftTriangleBar', [10703, 824]], ['NotLeftTriangle', [8938]], ['NotLeftTriangleEqual', [8940]], ['NotLess', [8814]], ['NotLessEqual', [8816]], ['NotLessGreater', [8824]], ['NotLessLess', [8810, 824]], ['NotLessSlantEqual', [10877, 824]], ['NotLessTilde', [8820]], ['NotNestedGreaterGreater', [10914, 824]], ['NotNestedLessLess', [10913, 824]], ['notni', [8716]], ['notniva', [8716]], ['notnivb', [8958]], ['notnivc', [8957]], ['NotPrecedes', [8832]], ['NotPrecedesEqual', [10927, 824]], ['NotPrecedesSlantEqual', [8928]], ['NotReverseElement', [8716]], ['NotRightTriangleBar', [10704, 824]], ['NotRightTriangle', [8939]], ['NotRightTriangleEqual', [8941]], ['NotSquareSubset', [8847, 824]], ['NotSquareSubsetEqual', [8930]], ['NotSquareSuperset', [8848, 824]], ['NotSquareSupersetEqual', [8931]], ['NotSubset', [8834, 8402]], ['NotSubsetEqual', [8840]], ['NotSucceeds', [8833]], ['NotSucceedsEqual', [10928, 824]], ['NotSucceedsSlantEqual', [8929]], ['NotSucceedsTilde', [8831, 824]], ['NotSuperset', [8835, 8402]], ['NotSupersetEqual', [8841]], ['NotTilde', [8769]], ['NotTildeEqual', [8772]], ['NotTildeFullEqual', [8775]], ['NotTildeTilde', [8777]], ['NotVerticalBar', [8740]], ['nparallel', [8742]], ['npar', [8742]], ['nparsl', [11005, 8421]], ['npart', [8706, 824]], ['npolint', [10772]], ['npr', [8832]], ['nprcue', [8928]], ['nprec', [8832]], ['npreceq', [10927, 824]], ['npre', [10927, 824]], ['nrarrc', [10547, 824]], ['nrarr', [8603]], ['nrArr', [8655]], ['nrarrw', [8605, 824]], ['nrightarrow', [8603]], ['nRightarrow', [8655]], ['nrtri', [8939]], ['nrtrie', [8941]], ['nsc', [8833]], ['nsccue', [8929]], ['nsce', [10928, 824]], ['Nscr', [119977]], ['nscr', [120003]], ['nshortmid', [8740]], ['nshortparallel', [8742]], ['nsim', [8769]], ['nsime', [8772]], ['nsimeq', [8772]], ['nsmid', [8740]], ['nspar', [8742]], ['nsqsube', [8930]], ['nsqsupe', [8931]], ['nsub', [8836]], ['nsubE', [10949, 824]], ['nsube', [8840]], ['nsubset', [8834, 8402]], ['nsubseteq', [8840]], ['nsubseteqq', [10949, 824]], ['nsucc', [8833]], ['nsucceq', [10928, 824]], ['nsup', [8837]], ['nsupE', [10950, 824]], ['nsupe', [8841]], ['nsupset', [8835, 8402]], ['nsupseteq', [8841]], ['nsupseteqq', [10950, 824]], ['ntgl', [8825]], ['Ntilde', [209]], ['ntilde', [241]], ['ntlg', [8824]], ['ntriangleleft', [8938]], ['ntrianglelefteq', [8940]], ['ntriangleright', [8939]], ['ntrianglerighteq', [8941]], ['Nu', [925]], ['nu', [957]], ['num', [35]], ['numero', [8470]], ['numsp', [8199]], ['nvap', [8781, 8402]], ['nvdash', [8876]], ['nvDash', [8877]], ['nVdash', [8878]], ['nVDash', [8879]], ['nvge', [8805, 8402]], ['nvgt', [62, 8402]], ['nvHarr', [10500]], ['nvinfin', [10718]], ['nvlArr', [10498]], ['nvle', [8804, 8402]], ['nvlt', [60, 8402]], ['nvltrie', [8884, 8402]], ['nvrArr', [10499]], ['nvrtrie', [8885, 8402]], ['nvsim', [8764, 8402]], ['nwarhk', [10531]], ['nwarr', [8598]], ['nwArr', [8662]], ['nwarrow', [8598]], ['nwnear', [10535]], ['Oacute', [211]], ['oacute', [243]], ['oast', [8859]], ['Ocirc', [212]], ['ocirc', [244]], ['ocir', [8858]], ['Ocy', [1054]], ['ocy', [1086]], ['odash', [8861]], ['Odblac', [336]], ['odblac', [337]], ['odiv', [10808]], ['odot', [8857]], ['odsold', [10684]], ['OElig', [338]], ['oelig', [339]], ['ofcir', [10687]], ['Ofr', [120082]], ['ofr', [120108]], ['ogon', [731]], ['Ograve', [210]], ['ograve', [242]], ['ogt', [10689]], ['ohbar', [10677]], ['ohm', [937]], ['oint', [8750]], ['olarr', [8634]], ['olcir', [10686]], ['olcross', [10683]], ['oline', [8254]], ['olt', [10688]], ['Omacr', [332]], ['omacr', [333]], ['Omega', [937]], ['omega', [969]], ['Omicron', [927]], ['omicron', [959]], ['omid', [10678]], ['ominus', [8854]], ['Oopf', [120134]], ['oopf', [120160]], ['opar', [10679]], ['OpenCurlyDoubleQuote', [8220]], ['OpenCurlyQuote', [8216]], ['operp', [10681]], ['oplus', [8853]], ['orarr', [8635]], ['Or', [10836]], ['or', [8744]], ['ord', [10845]], ['order', [8500]], ['orderof', [8500]], ['ordf', [170]], ['ordm', [186]], ['origof', [8886]], ['oror', [10838]], ['orslope', [10839]], ['orv', [10843]], ['oS', [9416]], ['Oscr', [119978]], ['oscr', [8500]], ['Oslash', [216]], ['oslash', [248]], ['osol', [8856]], ['Otilde', [213]], ['otilde', [245]], ['otimesas', [10806]], ['Otimes', [10807]], ['otimes', [8855]], ['Ouml', [214]], ['ouml', [246]], ['ovbar', [9021]], ['OverBar', [8254]], ['OverBrace', [9182]], ['OverBracket', [9140]], ['OverParenthesis', [9180]], ['para', [182]], ['parallel', [8741]], ['par', [8741]], ['parsim', [10995]], ['parsl', [11005]], ['part', [8706]], ['PartialD', [8706]], ['Pcy', [1055]], ['pcy', [1087]], ['percnt', [37]], ['period', [46]], ['permil', [8240]], ['perp', [8869]], ['pertenk', [8241]], ['Pfr', [120083]], ['pfr', [120109]], ['Phi', [934]], ['phi', [966]], ['phiv', [981]], ['phmmat', [8499]], ['phone', [9742]], ['Pi', [928]], ['pi', [960]], ['pitchfork', [8916]], ['piv', [982]], ['planck', [8463]], ['planckh', [8462]], ['plankv', [8463]], ['plusacir', [10787]], ['plusb', [8862]], ['pluscir', [10786]], ['plus', [43]], ['plusdo', [8724]], ['plusdu', [10789]], ['pluse', [10866]], ['PlusMinus', [177]], ['plusmn', [177]], ['plussim', [10790]], ['plustwo', [10791]], ['pm', [177]], ['Poincareplane', [8460]], ['pointint', [10773]], ['popf', [120161]], ['Popf', [8473]], ['pound', [163]], ['prap', [10935]], ['Pr', [10939]], ['pr', [8826]], ['prcue', [8828]], ['precapprox', [10935]], ['prec', [8826]], ['preccurlyeq', [8828]], ['Precedes', [8826]], ['PrecedesEqual', [10927]], ['PrecedesSlantEqual', [8828]], ['PrecedesTilde', [8830]], ['preceq', [10927]], ['precnapprox', [10937]], ['precneqq', [10933]], ['precnsim', [8936]], ['pre', [10927]], ['prE', [10931]], ['precsim', [8830]], ['prime', [8242]], ['Prime', [8243]], ['primes', [8473]], ['prnap', [10937]], ['prnE', [10933]], ['prnsim', [8936]], ['prod', [8719]], ['Product', [8719]], ['profalar', [9006]], ['profline', [8978]], ['profsurf', [8979]], ['prop', [8733]], ['Proportional', [8733]], ['Proportion', [8759]], ['propto', [8733]], ['prsim', [8830]], ['prurel', [8880]], ['Pscr', [119979]], ['pscr', [120005]], ['Psi', [936]], ['psi', [968]], ['puncsp', [8200]], ['Qfr', [120084]], ['qfr', [120110]], ['qint', [10764]], ['qopf', [120162]], ['Qopf', [8474]], ['qprime', [8279]], ['Qscr', [119980]], ['qscr', [120006]], ['quaternions', [8461]], ['quatint', [10774]], ['quest', [63]], ['questeq', [8799]], ['quot', [34]], ['QUOT', [34]], ['rAarr', [8667]], ['race', [8765, 817]], ['Racute', [340]], ['racute', [341]], ['radic', [8730]], ['raemptyv', [10675]], ['rang', [10217]], ['Rang', [10219]], ['rangd', [10642]], ['range', [10661]], ['rangle', [10217]], ['raquo', [187]], ['rarrap', [10613]], ['rarrb', [8677]], ['rarrbfs', [10528]], ['rarrc', [10547]], ['rarr', [8594]], ['Rarr', [8608]], ['rArr', [8658]], ['rarrfs', [10526]], ['rarrhk', [8618]], ['rarrlp', [8620]], ['rarrpl', [10565]], ['rarrsim', [10612]], ['Rarrtl', [10518]], ['rarrtl', [8611]], ['rarrw', [8605]], ['ratail', [10522]], ['rAtail', [10524]], ['ratio', [8758]], ['rationals', [8474]], ['rbarr', [10509]], ['rBarr', [10511]], ['RBarr', [10512]], ['rbbrk', [10099]], ['rbrace', [125]], ['rbrack', [93]], ['rbrke', [10636]], ['rbrksld', [10638]], ['rbrkslu', [10640]], ['Rcaron', [344]], ['rcaron', [345]], ['Rcedil', [342]], ['rcedil', [343]], ['rceil', [8969]], ['rcub', [125]], ['Rcy', [1056]], ['rcy', [1088]], ['rdca', [10551]], ['rdldhar', [10601]], ['rdquo', [8221]], ['rdquor', [8221]], ['CloseCurlyDoubleQuote', [8221]], ['rdsh', [8627]], ['real', [8476]], ['realine', [8475]], ['realpart', [8476]], ['reals', [8477]], ['Re', [8476]], ['rect', [9645]], ['reg', [174]], ['REG', [174]], ['ReverseElement', [8715]], ['ReverseEquilibrium', [8651]], ['ReverseUpEquilibrium', [10607]], ['rfisht', [10621]], ['rfloor', [8971]], ['rfr', [120111]], ['Rfr', [8476]], ['rHar', [10596]], ['rhard', [8641]], ['rharu', [8640]], ['rharul', [10604]], ['Rho', [929]], ['rho', [961]], ['rhov', [1009]], ['RightAngleBracket', [10217]], ['RightArrowBar', [8677]], ['rightarrow', [8594]], ['RightArrow', [8594]], ['Rightarrow', [8658]], ['RightArrowLeftArrow', [8644]], ['rightarrowtail', [8611]], ['RightCeiling', [8969]], ['RightDoubleBracket', [10215]], ['RightDownTeeVector', [10589]], ['RightDownVectorBar', [10581]], ['RightDownVector', [8642]], ['RightFloor', [8971]], ['rightharpoondown', [8641]], ['rightharpoonup', [8640]], ['rightleftarrows', [8644]], ['rightleftharpoons', [8652]], ['rightrightarrows', [8649]], ['rightsquigarrow', [8605]], ['RightTeeArrow', [8614]], ['RightTee', [8866]], ['RightTeeVector', [10587]], ['rightthreetimes', [8908]], ['RightTriangleBar', [10704]], ['RightTriangle', [8883]], ['RightTriangleEqual', [8885]], ['RightUpDownVector', [10575]], ['RightUpTeeVector', [10588]], ['RightUpVectorBar', [10580]], ['RightUpVector', [8638]], ['RightVectorBar', [10579]], ['RightVector', [8640]], ['ring', [730]], ['risingdotseq', [8787]], ['rlarr', [8644]], ['rlhar', [8652]], ['rlm', [8207]], ['rmoustache', [9137]], ['rmoust', [9137]], ['rnmid', [10990]], ['roang', [10221]], ['roarr', [8702]], ['robrk', [10215]], ['ropar', [10630]], ['ropf', [120163]], ['Ropf', [8477]], ['roplus', [10798]], ['rotimes', [10805]], ['RoundImplies', [10608]], ['rpar', [41]], ['rpargt', [10644]], ['rppolint', [10770]], ['rrarr', [8649]], ['Rrightarrow', [8667]], ['rsaquo', [8250]], ['rscr', [120007]], ['Rscr', [8475]], ['rsh', [8625]], ['Rsh', [8625]], ['rsqb', [93]], ['rsquo', [8217]], ['rsquor', [8217]], ['CloseCurlyQuote', [8217]], ['rthree', [8908]], ['rtimes', [8906]], ['rtri', [9657]], ['rtrie', [8885]], ['rtrif', [9656]], ['rtriltri', [10702]], ['RuleDelayed', [10740]], ['ruluhar', [10600]], ['rx', [8478]], ['Sacute', [346]], ['sacute', [347]], ['sbquo', [8218]], ['scap', [10936]], ['Scaron', [352]], ['scaron', [353]], ['Sc', [10940]], ['sc', [8827]], ['sccue', [8829]], ['sce', [10928]], ['scE', [10932]], ['Scedil', [350]], ['scedil', [351]], ['Scirc', [348]], ['scirc', [349]], ['scnap', [10938]], ['scnE', [10934]], ['scnsim', [8937]], ['scpolint', [10771]], ['scsim', [8831]], ['Scy', [1057]], ['scy', [1089]], ['sdotb', [8865]], ['sdot', [8901]], ['sdote', [10854]], ['searhk', [10533]], ['searr', [8600]], ['seArr', [8664]], ['searrow', [8600]], ['sect', [167]], ['semi', [59]], ['seswar', [10537]], ['setminus', [8726]], ['setmn', [8726]], ['sext', [10038]], ['Sfr', [120086]], ['sfr', [120112]], ['sfrown', [8994]], ['sharp', [9839]], ['SHCHcy', [1065]], ['shchcy', [1097]], ['SHcy', [1064]], ['shcy', [1096]], ['ShortDownArrow', [8595]], ['ShortLeftArrow', [8592]], ['shortmid', [8739]], ['shortparallel', [8741]], ['ShortRightArrow', [8594]], ['ShortUpArrow', [8593]], ['shy', [173]], ['Sigma', [931]], ['sigma', [963]], ['sigmaf', [962]], ['sigmav', [962]], ['sim', [8764]], ['simdot', [10858]], ['sime', [8771]], ['simeq', [8771]], ['simg', [10910]], ['simgE', [10912]], ['siml', [10909]], ['simlE', [10911]], ['simne', [8774]], ['simplus', [10788]], ['simrarr', [10610]], ['slarr', [8592]], ['SmallCircle', [8728]], ['smallsetminus', [8726]], ['smashp', [10803]], ['smeparsl', [10724]], ['smid', [8739]], ['smile', [8995]], ['smt', [10922]], ['smte', [10924]], ['smtes', [10924, 65024]], ['SOFTcy', [1068]], ['softcy', [1100]], ['solbar', [9023]], ['solb', [10692]], ['sol', [47]], ['Sopf', [120138]], ['sopf', [120164]], ['spades', [9824]], ['spadesuit', [9824]], ['spar', [8741]], ['sqcap', [8851]], ['sqcaps', [8851, 65024]], ['sqcup', [8852]], ['sqcups', [8852, 65024]], ['Sqrt', [8730]], ['sqsub', [8847]], ['sqsube', [8849]], ['sqsubset', [8847]], ['sqsubseteq', [8849]], ['sqsup', [8848]], ['sqsupe', [8850]], ['sqsupset', [8848]], ['sqsupseteq', [8850]], ['square', [9633]], ['Square', [9633]], ['SquareIntersection', [8851]], ['SquareSubset', [8847]], ['SquareSubsetEqual', [8849]], ['SquareSuperset', [8848]], ['SquareSupersetEqual', [8850]], ['SquareUnion', [8852]], ['squarf', [9642]], ['squ', [9633]], ['squf', [9642]], ['srarr', [8594]], ['Sscr', [119982]], ['sscr', [120008]], ['ssetmn', [8726]], ['ssmile', [8995]], ['sstarf', [8902]], ['Star', [8902]], ['star', [9734]], ['starf', [9733]], ['straightepsilon', [1013]], ['straightphi', [981]], ['strns', [175]], ['sub', [8834]], ['Sub', [8912]], ['subdot', [10941]], ['subE', [10949]], ['sube', [8838]], ['subedot', [10947]], ['submult', [10945]], ['subnE', [10955]], ['subne', [8842]], ['subplus', [10943]], ['subrarr', [10617]], ['subset', [8834]], ['Subset', [8912]], ['subseteq', [8838]], ['subseteqq', [10949]], ['SubsetEqual', [8838]], ['subsetneq', [8842]], ['subsetneqq', [10955]], ['subsim', [10951]], ['subsub', [10965]], ['subsup', [10963]], ['succapprox', [10936]], ['succ', [8827]], ['succcurlyeq', [8829]], ['Succeeds', [8827]], ['SucceedsEqual', [10928]], ['SucceedsSlantEqual', [8829]], ['SucceedsTilde', [8831]], ['succeq', [10928]], ['succnapprox', [10938]], ['succneqq', [10934]], ['succnsim', [8937]], ['succsim', [8831]], ['SuchThat', [8715]], ['sum', [8721]], ['Sum', [8721]], ['sung', [9834]], ['sup1', [185]], ['sup2', [178]], ['sup3', [179]], ['sup', [8835]], ['Sup', [8913]], ['supdot', [10942]], ['supdsub', [10968]], ['supE', [10950]], ['supe', [8839]], ['supedot', [10948]], ['Superset', [8835]], ['SupersetEqual', [8839]], ['suphsol', [10185]], ['suphsub', [10967]], ['suplarr', [10619]], ['supmult', [10946]], ['supnE', [10956]], ['supne', [8843]], ['supplus', [10944]], ['supset', [8835]], ['Supset', [8913]], ['supseteq', [8839]], ['supseteqq', [10950]], ['supsetneq', [8843]], ['supsetneqq', [10956]], ['supsim', [10952]], ['supsub', [10964]], ['supsup', [10966]], ['swarhk', [10534]], ['swarr', [8601]], ['swArr', [8665]], ['swarrow', [8601]], ['swnwar', [10538]], ['szlig', [223]], ['Tab', [9]], ['target', [8982]], ['Tau', [932]], ['tau', [964]], ['tbrk', [9140]], ['Tcaron', [356]], ['tcaron', [357]], ['Tcedil', [354]], ['tcedil', [355]], ['Tcy', [1058]], ['tcy', [1090]], ['tdot', [8411]], ['telrec', [8981]], ['Tfr', [120087]], ['tfr', [120113]], ['there4', [8756]], ['therefore', [8756]], ['Therefore', [8756]], ['Theta', [920]], ['theta', [952]], ['thetasym', [977]], ['thetav', [977]], ['thickapprox', [8776]], ['thicksim', [8764]], ['ThickSpace', [8287, 8202]], ['ThinSpace', [8201]], ['thinsp', [8201]], ['thkap', [8776]], ['thksim', [8764]], ['THORN', [222]], ['thorn', [254]], ['tilde', [732]], ['Tilde', [8764]], ['TildeEqual', [8771]], ['TildeFullEqual', [8773]], ['TildeTilde', [8776]], ['timesbar', [10801]], ['timesb', [8864]], ['times', [215]], ['timesd', [10800]], ['tint', [8749]], ['toea', [10536]], ['topbot', [9014]], ['topcir', [10993]], ['top', [8868]], ['Topf', [120139]], ['topf', [120165]], ['topfork', [10970]], ['tosa', [10537]], ['tprime', [8244]], ['trade', [8482]], ['TRADE', [8482]], ['triangle', [9653]], ['triangledown', [9663]], ['triangleleft', [9667]], ['trianglelefteq', [8884]], ['triangleq', [8796]], ['triangleright', [9657]], ['trianglerighteq', [8885]], ['tridot', [9708]], ['trie', [8796]], ['triminus', [10810]], ['TripleDot', [8411]], ['triplus', [10809]], ['trisb', [10701]], ['tritime', [10811]], ['trpezium', [9186]], ['Tscr', [119983]], ['tscr', [120009]], ['TScy', [1062]], ['tscy', [1094]], ['TSHcy', [1035]], ['tshcy', [1115]], ['Tstrok', [358]], ['tstrok', [359]], ['twixt', [8812]], ['twoheadleftarrow', [8606]], ['twoheadrightarrow', [8608]], ['Uacute', [218]], ['uacute', [250]], ['uarr', [8593]], ['Uarr', [8607]], ['uArr', [8657]], ['Uarrocir', [10569]], ['Ubrcy', [1038]], ['ubrcy', [1118]], ['Ubreve', [364]], ['ubreve', [365]], ['Ucirc', [219]], ['ucirc', [251]], ['Ucy', [1059]], ['ucy', [1091]], ['udarr', [8645]], ['Udblac', [368]], ['udblac', [369]], ['udhar', [10606]], ['ufisht', [10622]], ['Ufr', [120088]], ['ufr', [120114]], ['Ugrave', [217]], ['ugrave', [249]], ['uHar', [10595]], ['uharl', [8639]], ['uharr', [8638]], ['uhblk', [9600]], ['ulcorn', [8988]], ['ulcorner', [8988]], ['ulcrop', [8975]], ['ultri', [9720]], ['Umacr', [362]], ['umacr', [363]], ['uml', [168]], ['UnderBar', [95]], ['UnderBrace', [9183]], ['UnderBracket', [9141]], ['UnderParenthesis', [9181]], ['Union', [8899]], ['UnionPlus', [8846]], ['Uogon', [370]], ['uogon', [371]], ['Uopf', [120140]], ['uopf', [120166]], ['UpArrowBar', [10514]], ['uparrow', [8593]], ['UpArrow', [8593]], ['Uparrow', [8657]], ['UpArrowDownArrow', [8645]], ['updownarrow', [8597]], ['UpDownArrow', [8597]], ['Updownarrow', [8661]], ['UpEquilibrium', [10606]], ['upharpoonleft', [8639]], ['upharpoonright', [8638]], ['uplus', [8846]], ['UpperLeftArrow', [8598]], ['UpperRightArrow', [8599]], ['upsi', [965]], ['Upsi', [978]], ['upsih', [978]], ['Upsilon', [933]], ['upsilon', [965]], ['UpTeeArrow', [8613]], ['UpTee', [8869]], ['upuparrows', [8648]], ['urcorn', [8989]], ['urcorner', [8989]], ['urcrop', [8974]], ['Uring', [366]], ['uring', [367]], ['urtri', [9721]], ['Uscr', [119984]], ['uscr', [120010]], ['utdot', [8944]], ['Utilde', [360]], ['utilde', [361]], ['utri', [9653]], ['utrif', [9652]], ['uuarr', [8648]], ['Uuml', [220]], ['uuml', [252]], ['uwangle', [10663]], ['vangrt', [10652]], ['varepsilon', [1013]], ['varkappa', [1008]], ['varnothing', [8709]], ['varphi', [981]], ['varpi', [982]], ['varpropto', [8733]], ['varr', [8597]], ['vArr', [8661]], ['varrho', [1009]], ['varsigma', [962]], ['varsubsetneq', [8842, 65024]], ['varsubsetneqq', [10955, 65024]], ['varsupsetneq', [8843, 65024]], ['varsupsetneqq', [10956, 65024]], ['vartheta', [977]], ['vartriangleleft', [8882]], ['vartriangleright', [8883]], ['vBar', [10984]], ['Vbar', [10987]], ['vBarv', [10985]], ['Vcy', [1042]], ['vcy', [1074]], ['vdash', [8866]], ['vDash', [8872]], ['Vdash', [8873]], ['VDash', [8875]], ['Vdashl', [10982]], ['veebar', [8891]], ['vee', [8744]], ['Vee', [8897]], ['veeeq', [8794]], ['vellip', [8942]], ['verbar', [124]], ['Verbar', [8214]], ['vert', [124]], ['Vert', [8214]], ['VerticalBar', [8739]], ['VerticalLine', [124]], ['VerticalSeparator', [10072]], ['VerticalTilde', [8768]], ['VeryThinSpace', [8202]], ['Vfr', [120089]], ['vfr', [120115]], ['vltri', [8882]], ['vnsub', [8834, 8402]], ['vnsup', [8835, 8402]], ['Vopf', [120141]], ['vopf', [120167]], ['vprop', [8733]], ['vrtri', [8883]], ['Vscr', [119985]], ['vscr', [120011]], ['vsubnE', [10955, 65024]], ['vsubne', [8842, 65024]], ['vsupnE', [10956, 65024]], ['vsupne', [8843, 65024]], ['Vvdash', [8874]], ['vzigzag', [10650]], ['Wcirc', [372]], ['wcirc', [373]], ['wedbar', [10847]], ['wedge', [8743]], ['Wedge', [8896]], ['wedgeq', [8793]], ['weierp', [8472]], ['Wfr', [120090]], ['wfr', [120116]], ['Wopf', [120142]], ['wopf', [120168]], ['wp', [8472]], ['wr', [8768]], ['wreath', [8768]], ['Wscr', [119986]], ['wscr', [120012]], ['xcap', [8898]], ['xcirc', [9711]], ['xcup', [8899]], ['xdtri', [9661]], ['Xfr', [120091]], ['xfr', [120117]], ['xharr', [10231]], ['xhArr', [10234]], ['Xi', [926]], ['xi', [958]], ['xlarr', [10229]], ['xlArr', [10232]], ['xmap', [10236]], ['xnis', [8955]], ['xodot', [10752]], ['Xopf', [120143]], ['xopf', [120169]], ['xoplus', [10753]], ['xotime', [10754]], ['xrarr', [10230]], ['xrArr', [10233]], ['Xscr', [119987]], ['xscr', [120013]], ['xsqcup', [10758]], ['xuplus', [10756]], ['xutri', [9651]], ['xvee', [8897]], ['xwedge', [8896]], ['Yacute', [221]], ['yacute', [253]], ['YAcy', [1071]], ['yacy', [1103]], ['Ycirc', [374]], ['ycirc', [375]], ['Ycy', [1067]], ['ycy', [1099]], ['yen', [165]], ['Yfr', [120092]], ['yfr', [120118]], ['YIcy', [1031]], ['yicy', [1111]], ['Yopf', [120144]], ['yopf', [120170]], ['Yscr', [119988]], ['yscr', [120014]], ['YUcy', [1070]], ['yucy', [1102]], ['yuml', [255]], ['Yuml', [376]], ['Zacute', [377]], ['zacute', [378]], ['Zcaron', [381]], ['zcaron', [382]], ['Zcy', [1047]], ['zcy', [1079]], ['Zdot', [379]], ['zdot', [380]], ['zeetrf', [8488]], ['ZeroWidthSpace', [8203]], ['Zeta', [918]], ['zeta', [950]], ['zfr', [120119]], ['Zfr', [8488]], ['ZHcy', [1046]], ['zhcy', [1078]], ['zigrarr', [8669]], ['zopf', [120171]], ['Zopf', [8484]], ['Zscr', [119989]], ['zscr', [120015]], ['zwj', [8205]], ['zwnj', [8204]]];\\n\\nvar alphaIndex = {};\\nvar charIndex = {};\\n\\ncreateIndexes(alphaIndex, charIndex);\\n\\n/**\\n * @constructor\\n */\\nfunction Html5Entities() {}\\n\\n/**\\n * @param {String} str\\n * @returns {String}\\n */\\nHtml5Entities.prototype.decode = function(str) {\\n    if (!str || !str.length) {\\n        return '';\\n    }\\n    return str.replace(/&(#?[\\\\w\\\\d]+);?/g, function(s, entity) {\\n        var chr;\\n        if (entity.charAt(0) === \\\"#\\\") {\\n            var code = entity.charAt(1) === 'x' ?\\n                parseInt(entity.substr(2).toLowerCase(), 16) :\\n                parseInt(entity.substr(1));\\n\\n            if (!(isNaN(code) || code < -32768 || code > 65535)) {\\n                chr = String.fromCharCode(code);\\n            }\\n        } else {\\n            chr = alphaIndex[entity];\\n        }\\n        return chr || s;\\n    });\\n};\\n\\n/**\\n * @param {String} str\\n * @returns {String}\\n */\\n Html5Entities.decode = function(str) {\\n    return new Html5Entities().decode(str);\\n };\\n\\n/**\\n * @param {String} str\\n * @returns {String}\\n */\\nHtml5Entities.prototype.encode = function(str) {\\n    if (!str || !str.length) {\\n        return '';\\n    }\\n    var strLength = str.length;\\n    var result = '';\\n    var i = 0;\\n    while (i < strLength) {\\n        var charInfo = charIndex[str.charCodeAt(i)];\\n        if (charInfo) {\\n            var alpha = charInfo[str.charCodeAt(i + 1)];\\n            if (alpha) {\\n                i++;\\n            } else {\\n                alpha = charInfo[''];\\n            }\\n            if (alpha) {\\n                result += \\\"&\\\" + alpha + \\\";\\\";\\n                i++;\\n                continue;\\n            }\\n        }\\n        result += str.charAt(i);\\n        i++;\\n    }\\n    return result;\\n};\\n\\n/**\\n * @param {String} str\\n * @returns {String}\\n */\\n Html5Entities.encode = function(str) {\\n    return new Html5Entities().encode(str);\\n };\\n\\n/**\\n * @param {String} str\\n * @returns {String}\\n */\\nHtml5Entities.prototype.encodeNonUTF = function(str) {\\n    if (!str || !str.length) {\\n        return '';\\n    }\\n    var strLength = str.length;\\n    var result = '';\\n    var i = 0;\\n    while (i < strLength) {\\n        var c = str.charCodeAt(i);\\n        var charInfo = charIndex[c];\\n        if (charInfo) {\\n            var alpha = charInfo[str.charCodeAt(i + 1)];\\n            if (alpha) {\\n                i++;\\n            } else {\\n                alpha = charInfo[''];\\n            }\\n            if (alpha) {\\n                result += \\\"&\\\" + alpha + \\\";\\\";\\n                i++;\\n                continue;\\n            }\\n        }\\n        if (c < 32 || c > 126) {\\n            result += '&#' + c + ';';\\n        } else {\\n            result += str.charAt(i);\\n        }\\n        i++;\\n    }\\n    return result;\\n};\\n\\n/**\\n * @param {String} str\\n * @returns {String}\\n */\\n Html5Entities.encodeNonUTF = function(str) {\\n    return new Html5Entities().encodeNonUTF(str);\\n };\\n\\n/**\\n * @param {String} str\\n * @returns {String}\\n */\\nHtml5Entities.prototype.encodeNonASCII = function(str) {\\n    if (!str || !str.length) {\\n        return '';\\n    }\\n    var strLength = str.length;\\n    var result = '';\\n    var i = 0;\\n    while (i < strLength) {\\n        var c = str.charCodeAt(i);\\n        if (c <= 255) {\\n            result += str[i++];\\n            continue;\\n        }\\n        result += '&#' + c + ';';\\n        i++\\n    }\\n    return result;\\n};\\n\\n/**\\n * @param {String} str\\n * @returns {String}\\n */\\n Html5Entities.encodeNonASCII = function(str) {\\n    return new Html5Entities().encodeNonASCII(str);\\n };\\n\\n/**\\n * @param {Object} alphaIndex Passed by reference.\\n * @param {Object} charIndex Passed by reference.\\n */\\nfunction createIndexes(alphaIndex, charIndex) {\\n    var i = ENTITIES.length;\\n    var _results = [];\\n    while (i--) {\\n        var e = ENTITIES[i];\\n        var alpha = e[0];\\n        var chars = e[1];\\n        var chr = chars[0];\\n        var addChar = (chr < 32 || chr > 126) || chr === 62 || chr === 60 || chr === 38 || chr === 34 || chr === 39;\\n        var charInfo;\\n        if (addChar) {\\n            charInfo = charIndex[chr] = charIndex[chr] || {};\\n        }\\n        if (chars[1]) {\\n            var chr2 = chars[1];\\n            alphaIndex[alpha] = String.fromCharCode(chr) + String.fromCharCode(chr2);\\n            _results.push(addChar && (charInfo[chr2] = alpha));\\n        } else {\\n            alphaIndex[alpha] = String.fromCharCode(chr);\\n            _results.push(addChar && (charInfo[''] = alpha));\\n        }\\n    }\\n}\\n\\nmodule.exports = Html5Entities;\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvbGliL2h0bWw1LWVudGl0aWVzLmpzPzRjODEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEVOVElUSUVTID0gW1snQWFjdXRlJywgWzE5M11dLCBbJ2FhY3V0ZScsIFsyMjVdXSwgWydBYnJldmUnLCBbMjU4XV0sIFsnYWJyZXZlJywgWzI1OV1dLCBbJ2FjJywgWzg3NjZdXSwgWydhY2QnLCBbODc2N11dLCBbJ2FjRScsIFs4NzY2LCA4MTldXSwgWydBY2lyYycsIFsxOTRdXSwgWydhY2lyYycsIFsyMjZdXSwgWydhY3V0ZScsIFsxODBdXSwgWydBY3knLCBbMTA0MF1dLCBbJ2FjeScsIFsxMDcyXV0sIFsnQUVsaWcnLCBbMTk4XV0sIFsnYWVsaWcnLCBbMjMwXV0sIFsnYWYnLCBbODI4OV1dLCBbJ0FmcicsIFsxMjAwNjhdXSwgWydhZnInLCBbMTIwMDk0XV0sIFsnQWdyYXZlJywgWzE5Ml1dLCBbJ2FncmF2ZScsIFsyMjRdXSwgWydhbGVmc3ltJywgWzg1MDFdXSwgWydhbGVwaCcsIFs4NTAxXV0sIFsnQWxwaGEnLCBbOTEzXV0sIFsnYWxwaGEnLCBbOTQ1XV0sIFsnQW1hY3InLCBbMjU2XV0sIFsnYW1hY3InLCBbMjU3XV0sIFsnYW1hbGcnLCBbMTA4MTVdXSwgWydhbXAnLCBbMzhdXSwgWydBTVAnLCBbMzhdXSwgWydhbmRhbmQnLCBbMTA4MzddXSwgWydBbmQnLCBbMTA4MzVdXSwgWydhbmQnLCBbODc0M11dLCBbJ2FuZGQnLCBbMTA4NDRdXSwgWydhbmRzbG9wZScsIFsxMDg0MF1dLCBbJ2FuZHYnLCBbMTA4NDJdXSwgWydhbmcnLCBbODczNl1dLCBbJ2FuZ2UnLCBbMTA2NjBdXSwgWydhbmdsZScsIFs4NzM2XV0sIFsnYW5nbXNkYWEnLCBbMTA2NjRdXSwgWydhbmdtc2RhYicsIFsxMDY2NV1dLCBbJ2FuZ21zZGFjJywgWzEwNjY2XV0sIFsnYW5nbXNkYWQnLCBbMTA2NjddXSwgWydhbmdtc2RhZScsIFsxMDY2OF1dLCBbJ2FuZ21zZGFmJywgWzEwNjY5XV0sIFsnYW5nbXNkYWcnLCBbMTA2NzBdXSwgWydhbmdtc2RhaCcsIFsxMDY3MV1dLCBbJ2FuZ21zZCcsIFs4NzM3XV0sIFsnYW5ncnQnLCBbODczNV1dLCBbJ2FuZ3J0dmInLCBbODg5NF1dLCBbJ2FuZ3J0dmJkJywgWzEwNjUzXV0sIFsnYW5nc3BoJywgWzg3MzhdXSwgWydhbmdzdCcsIFsxOTddXSwgWydhbmd6YXJyJywgWzkwODRdXSwgWydBb2dvbicsIFsyNjBdXSwgWydhb2dvbicsIFsyNjFdXSwgWydBb3BmJywgWzEyMDEyMF1dLCBbJ2FvcGYnLCBbMTIwMTQ2XV0sIFsnYXBhY2lyJywgWzEwODYzXV0sIFsnYXAnLCBbODc3Nl1dLCBbJ2FwRScsIFsxMDg2NF1dLCBbJ2FwZScsIFs4Nzc4XV0sIFsnYXBpZCcsIFs4Nzc5XV0sIFsnYXBvcycsIFszOV1dLCBbJ0FwcGx5RnVuY3Rpb24nLCBbODI4OV1dLCBbJ2FwcHJveCcsIFs4Nzc2XV0sIFsnYXBwcm94ZXEnLCBbODc3OF1dLCBbJ0FyaW5nJywgWzE5N11dLCBbJ2FyaW5nJywgWzIyOV1dLCBbJ0FzY3InLCBbMTE5OTY0XV0sIFsnYXNjcicsIFsxMTk5OTBdXSwgWydBc3NpZ24nLCBbODc4OF1dLCBbJ2FzdCcsIFs0Ml1dLCBbJ2FzeW1wJywgWzg3NzZdXSwgWydhc3ltcGVxJywgWzg3ODFdXSwgWydBdGlsZGUnLCBbMTk1XV0sIFsnYXRpbGRlJywgWzIyN11dLCBbJ0F1bWwnLCBbMTk2XV0sIFsnYXVtbCcsIFsyMjhdXSwgWydhd2NvbmludCcsIFs4NzU1XV0sIFsnYXdpbnQnLCBbMTA3NjldXSwgWydiYWNrY29uZycsIFs4NzgwXV0sIFsnYmFja2Vwc2lsb24nLCBbMTAxNF1dLCBbJ2JhY2twcmltZScsIFs4MjQ1XV0sIFsnYmFja3NpbScsIFs4NzY1XV0sIFsnYmFja3NpbWVxJywgWzg5MDldXSwgWydCYWNrc2xhc2gnLCBbODcyNl1dLCBbJ0JhcnYnLCBbMTA5ODNdXSwgWydiYXJ2ZWUnLCBbODg5M11dLCBbJ2JhcndlZCcsIFs4OTY1XV0sIFsnQmFyd2VkJywgWzg5NjZdXSwgWydiYXJ3ZWRnZScsIFs4OTY1XV0sIFsnYmJyaycsIFs5MTQxXV0sIFsnYmJya3RicmsnLCBbOTE0Ml1dLCBbJ2Jjb25nJywgWzg3ODBdXSwgWydCY3knLCBbMTA0MV1dLCBbJ2JjeScsIFsxMDczXV0sIFsnYmRxdW8nLCBbODIyMl1dLCBbJ2JlY2F1cycsIFs4NzU3XV0sIFsnYmVjYXVzZScsIFs4NzU3XV0sIFsnQmVjYXVzZScsIFs4NzU3XV0sIFsnYmVtcHR5dicsIFsxMDY3Ml1dLCBbJ2JlcHNpJywgWzEwMTRdXSwgWydiZXJub3UnLCBbODQ5Ml1dLCBbJ0Jlcm5vdWxsaXMnLCBbODQ5Ml1dLCBbJ0JldGEnLCBbOTE0XV0sIFsnYmV0YScsIFs5NDZdXSwgWydiZXRoJywgWzg1MDJdXSwgWydiZXR3ZWVuJywgWzg4MTJdXSwgWydCZnInLCBbMTIwMDY5XV0sIFsnYmZyJywgWzEyMDA5NV1dLCBbJ2JpZ2NhcCcsIFs4ODk4XV0sIFsnYmlnY2lyYycsIFs5NzExXV0sIFsnYmlnY3VwJywgWzg4OTldXSwgWydiaWdvZG90JywgWzEwNzUyXV0sIFsnYmlnb3BsdXMnLCBbMTA3NTNdXSwgWydiaWdvdGltZXMnLCBbMTA3NTRdXSwgWydiaWdzcWN1cCcsIFsxMDc1OF1dLCBbJ2JpZ3N0YXInLCBbOTczM11dLCBbJ2JpZ3RyaWFuZ2xlZG93bicsIFs5NjYxXV0sIFsnYmlndHJpYW5nbGV1cCcsIFs5NjUxXV0sIFsnYmlndXBsdXMnLCBbMTA3NTZdXSwgWydiaWd2ZWUnLCBbODg5N11dLCBbJ2JpZ3dlZGdlJywgWzg4OTZdXSwgWydia2Fyb3cnLCBbMTA1MDldXSwgWydibGFja2xvemVuZ2UnLCBbMTA3MzFdXSwgWydibGFja3NxdWFyZScsIFs5NjQyXV0sIFsnYmxhY2t0cmlhbmdsZScsIFs5NjUyXV0sIFsnYmxhY2t0cmlhbmdsZWRvd24nLCBbOTY2Ml1dLCBbJ2JsYWNrdHJpYW5nbGVsZWZ0JywgWzk2NjZdXSwgWydibGFja3RyaWFuZ2xlcmlnaHQnLCBbOTY1Nl1dLCBbJ2JsYW5rJywgWzkyNTFdXSwgWydibGsxMicsIFs5NjE4XV0sIFsnYmxrMTQnLCBbOTYxN11dLCBbJ2JsazM0JywgWzk2MTldXSwgWydibG9jaycsIFs5NjA4XV0sIFsnYm5lJywgWzYxLCA4NDIxXV0sIFsnYm5lcXVpdicsIFs4ODAxLCA4NDIxXV0sIFsnYk5vdCcsIFsxMDk4OV1dLCBbJ2Jub3QnLCBbODk3Nl1dLCBbJ0JvcGYnLCBbMTIwMTIxXV0sIFsnYm9wZicsIFsxMjAxNDddXSwgWydib3QnLCBbODg2OV1dLCBbJ2JvdHRvbScsIFs4ODY5XV0sIFsnYm93dGllJywgWzg5MDRdXSwgWydib3hib3gnLCBbMTA2OTddXSwgWydib3hkbCcsIFs5NDg4XV0sIFsnYm94ZEwnLCBbOTU1N11dLCBbJ2JveERsJywgWzk1NThdXSwgWydib3hETCcsIFs5NTU5XV0sIFsnYm94ZHInLCBbOTQ4NF1dLCBbJ2JveGRSJywgWzk1NTRdXSwgWydib3hEcicsIFs5NTU1XV0sIFsnYm94RFInLCBbOTU1Nl1dLCBbJ2JveGgnLCBbOTQ3Ml1dLCBbJ2JveEgnLCBbOTU1Ml1dLCBbJ2JveGhkJywgWzk1MTZdXSwgWydib3hIZCcsIFs5NTcyXV0sIFsnYm94aEQnLCBbOTU3M11dLCBbJ2JveEhEJywgWzk1NzRdXSwgWydib3hodScsIFs5NTI0XV0sIFsnYm94SHUnLCBbOTU3NV1dLCBbJ2JveGhVJywgWzk1NzZdXSwgWydib3hIVScsIFs5NTc3XV0sIFsnYm94bWludXMnLCBbODg2M11dLCBbJ2JveHBsdXMnLCBbODg2Ml1dLCBbJ2JveHRpbWVzJywgWzg4NjRdXSwgWydib3h1bCcsIFs5NDk2XV0sIFsnYm94dUwnLCBbOTU2M11dLCBbJ2JveFVsJywgWzk1NjRdXSwgWydib3hVTCcsIFs5NTY1XV0sIFsnYm94dXInLCBbOTQ5Ml1dLCBbJ2JveHVSJywgWzk1NjBdXSwgWydib3hVcicsIFs5NTYxXV0sIFsnYm94VVInLCBbOTU2Ml1dLCBbJ2JveHYnLCBbOTQ3NF1dLCBbJ2JveFYnLCBbOTU1M11dLCBbJ2JveHZoJywgWzk1MzJdXSwgWydib3h2SCcsIFs5NTc4XV0sIFsnYm94VmgnLCBbOTU3OV1dLCBbJ2JveFZIJywgWzk1ODBdXSwgWydib3h2bCcsIFs5NTA4XV0sIFsnYm94dkwnLCBbOTU2OV1dLCBbJ2JveFZsJywgWzk1NzBdXSwgWydib3hWTCcsIFs5NTcxXV0sIFsnYm94dnInLCBbOTUwMF1dLCBbJ2JveHZSJywgWzk1NjZdXSwgWydib3hWcicsIFs5NTY3XV0sIFsnYm94VlInLCBbOTU2OF1dLCBbJ2JwcmltZScsIFs4MjQ1XV0sIFsnYnJldmUnLCBbNzI4XV0sIFsnQnJldmUnLCBbNzI4XV0sIFsnYnJ2YmFyJywgWzE2Nl1dLCBbJ2JzY3InLCBbMTE5OTkxXV0sIFsnQnNjcicsIFs4NDkyXV0sIFsnYnNlbWknLCBbODI3MV1dLCBbJ2JzaW0nLCBbODc2NV1dLCBbJ2JzaW1lJywgWzg5MDldXSwgWydic29sYicsIFsxMDY5M11dLCBbJ2Jzb2wnLCBbOTJdXSwgWydic29saHN1YicsIFsxMDE4NF1dLCBbJ2J1bGwnLCBbODIyNl1dLCBbJ2J1bGxldCcsIFs4MjI2XV0sIFsnYnVtcCcsIFs4NzgyXV0sIFsnYnVtcEUnLCBbMTA5MjZdXSwgWydidW1wZScsIFs4NzgzXV0sIFsnQnVtcGVxJywgWzg3ODJdXSwgWydidW1wZXEnLCBbODc4M11dLCBbJ0NhY3V0ZScsIFsyNjJdXSwgWydjYWN1dGUnLCBbMjYzXV0sIFsnY2FwYW5kJywgWzEwODIwXV0sIFsnY2FwYnJjdXAnLCBbMTA4MjVdXSwgWydjYXBjYXAnLCBbMTA4MjddXSwgWydjYXAnLCBbODc0NV1dLCBbJ0NhcCcsIFs4OTE0XV0sIFsnY2FwY3VwJywgWzEwODIzXV0sIFsnY2FwZG90JywgWzEwODE2XV0sIFsnQ2FwaXRhbERpZmZlcmVudGlhbEQnLCBbODUxN11dLCBbJ2NhcHMnLCBbODc0NSwgNjUwMjRdXSwgWydjYXJldCcsIFs4MjU3XV0sIFsnY2Fyb24nLCBbNzExXV0sIFsnQ2F5bGV5cycsIFs4NDkzXV0sIFsnY2NhcHMnLCBbMTA4MjldXSwgWydDY2Fyb24nLCBbMjY4XV0sIFsnY2Nhcm9uJywgWzI2OV1dLCBbJ0NjZWRpbCcsIFsxOTldXSwgWydjY2VkaWwnLCBbMjMxXV0sIFsnQ2NpcmMnLCBbMjY0XV0sIFsnY2NpcmMnLCBbMjY1XV0sIFsnQ2NvbmludCcsIFs4NzUyXV0sIFsnY2N1cHMnLCBbMTA4MjhdXSwgWydjY3Vwc3NtJywgWzEwODMyXV0sIFsnQ2RvdCcsIFsyNjZdXSwgWydjZG90JywgWzI2N11dLCBbJ2NlZGlsJywgWzE4NF1dLCBbJ0NlZGlsbGEnLCBbMTg0XV0sIFsnY2VtcHR5dicsIFsxMDY3NF1dLCBbJ2NlbnQnLCBbMTYyXV0sIFsnY2VudGVyZG90JywgWzE4M11dLCBbJ0NlbnRlckRvdCcsIFsxODNdXSwgWydjZnInLCBbMTIwMDk2XV0sIFsnQ2ZyJywgWzg0OTNdXSwgWydDSGN5JywgWzEwNjNdXSwgWydjaGN5JywgWzEwOTVdXSwgWydjaGVjaycsIFsxMDAwM11dLCBbJ2NoZWNrbWFyaycsIFsxMDAwM11dLCBbJ0NoaScsIFs5MzVdXSwgWydjaGknLCBbOTY3XV0sIFsnY2lyYycsIFs3MTBdXSwgWydjaXJjZXEnLCBbODc5MV1dLCBbJ2NpcmNsZWFycm93bGVmdCcsIFs4NjM0XV0sIFsnY2lyY2xlYXJyb3dyaWdodCcsIFs4NjM1XV0sIFsnY2lyY2xlZGFzdCcsIFs4ODU5XV0sIFsnY2lyY2xlZGNpcmMnLCBbODg1OF1dLCBbJ2NpcmNsZWRkYXNoJywgWzg4NjFdXSwgWydDaXJjbGVEb3QnLCBbODg1N11dLCBbJ2NpcmNsZWRSJywgWzE3NF1dLCBbJ2NpcmNsZWRTJywgWzk0MTZdXSwgWydDaXJjbGVNaW51cycsIFs4ODU0XV0sIFsnQ2lyY2xlUGx1cycsIFs4ODUzXV0sIFsnQ2lyY2xlVGltZXMnLCBbODg1NV1dLCBbJ2NpcicsIFs5Njc1XV0sIFsnY2lyRScsIFsxMDY5MV1dLCBbJ2NpcmUnLCBbODc5MV1dLCBbJ2NpcmZuaW50JywgWzEwNzY4XV0sIFsnY2lybWlkJywgWzEwOTkxXV0sIFsnY2lyc2NpcicsIFsxMDY5MF1dLCBbJ0Nsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbCcsIFs4NzU0XV0sIFsnY2x1YnMnLCBbOTgyN11dLCBbJ2NsdWJzdWl0JywgWzk4MjddXSwgWydjb2xvbicsIFs1OF1dLCBbJ0NvbG9uJywgWzg3NTldXSwgWydDb2xvbmUnLCBbMTA4NjhdXSwgWydjb2xvbmUnLCBbODc4OF1dLCBbJ2NvbG9uZXEnLCBbODc4OF1dLCBbJ2NvbW1hJywgWzQ0XV0sIFsnY29tbWF0JywgWzY0XV0sIFsnY29tcCcsIFs4NzA1XV0sIFsnY29tcGZuJywgWzg3MjhdXSwgWydjb21wbGVtZW50JywgWzg3MDVdXSwgWydjb21wbGV4ZXMnLCBbODQ1MF1dLCBbJ2NvbmcnLCBbODc3M11dLCBbJ2Nvbmdkb3QnLCBbMTA4NjFdXSwgWydDb25ncnVlbnQnLCBbODgwMV1dLCBbJ2NvbmludCcsIFs4NzUwXV0sIFsnQ29uaW50JywgWzg3NTFdXSwgWydDb250b3VySW50ZWdyYWwnLCBbODc1MF1dLCBbJ2NvcGYnLCBbMTIwMTQ4XV0sIFsnQ29wZicsIFs4NDUwXV0sIFsnY29wcm9kJywgWzg3MjBdXSwgWydDb3Byb2R1Y3QnLCBbODcyMF1dLCBbJ2NvcHknLCBbMTY5XV0sIFsnQ09QWScsIFsxNjldXSwgWydjb3B5c3InLCBbODQ3MV1dLCBbJ0NvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWwnLCBbODc1NV1dLCBbJ2NyYXJyJywgWzg2MjldXSwgWydjcm9zcycsIFsxMDAwN11dLCBbJ0Nyb3NzJywgWzEwNzk5XV0sIFsnQ3NjcicsIFsxMTk5NjZdXSwgWydjc2NyJywgWzExOTk5Ml1dLCBbJ2NzdWInLCBbMTA5NTldXSwgWydjc3ViZScsIFsxMDk2MV1dLCBbJ2NzdXAnLCBbMTA5NjBdXSwgWydjc3VwZScsIFsxMDk2Ml1dLCBbJ2N0ZG90JywgWzg5NDNdXSwgWydjdWRhcnJsJywgWzEwNTUyXV0sIFsnY3VkYXJycicsIFsxMDU0OV1dLCBbJ2N1ZXByJywgWzg5MjZdXSwgWydjdWVzYycsIFs4OTI3XV0sIFsnY3VsYXJyJywgWzg2MzBdXSwgWydjdWxhcnJwJywgWzEwNTU3XV0sIFsnY3VwYnJjYXAnLCBbMTA4MjRdXSwgWydjdXBjYXAnLCBbMTA4MjJdXSwgWydDdXBDYXAnLCBbODc4MV1dLCBbJ2N1cCcsIFs4NzQ2XV0sIFsnQ3VwJywgWzg5MTVdXSwgWydjdXBjdXAnLCBbMTA4MjZdXSwgWydjdXBkb3QnLCBbODg0NV1dLCBbJ2N1cG9yJywgWzEwODIxXV0sIFsnY3VwcycsIFs4NzQ2LCA2NTAyNF1dLCBbJ2N1cmFycicsIFs4NjMxXV0sIFsnY3VyYXJybScsIFsxMDU1Nl1dLCBbJ2N1cmx5ZXFwcmVjJywgWzg5MjZdXSwgWydjdXJseWVxc3VjYycsIFs4OTI3XV0sIFsnY3VybHl2ZWUnLCBbODkxMF1dLCBbJ2N1cmx5d2VkZ2UnLCBbODkxMV1dLCBbJ2N1cnJlbicsIFsxNjRdXSwgWydjdXJ2ZWFycm93bGVmdCcsIFs4NjMwXV0sIFsnY3VydmVhcnJvd3JpZ2h0JywgWzg2MzFdXSwgWydjdXZlZScsIFs4OTEwXV0sIFsnY3V3ZWQnLCBbODkxMV1dLCBbJ2N3Y29uaW50JywgWzg3NTRdXSwgWydjd2ludCcsIFs4NzUzXV0sIFsnY3lsY3R5JywgWzkwMDVdXSwgWydkYWdnZXInLCBbODIyNF1dLCBbJ0RhZ2dlcicsIFs4MjI1XV0sIFsnZGFsZXRoJywgWzg1MDRdXSwgWydkYXJyJywgWzg1OTVdXSwgWydEYXJyJywgWzg2MDldXSwgWydkQXJyJywgWzg2NTldXSwgWydkYXNoJywgWzgyMDhdXSwgWydEYXNodicsIFsxMDk4MF1dLCBbJ2Rhc2h2JywgWzg4NjddXSwgWydkYmthcm93JywgWzEwNTExXV0sIFsnZGJsYWMnLCBbNzMzXV0sIFsnRGNhcm9uJywgWzI3MF1dLCBbJ2RjYXJvbicsIFsyNzFdXSwgWydEY3knLCBbMTA0NF1dLCBbJ2RjeScsIFsxMDc2XV0sIFsnZGRhZ2dlcicsIFs4MjI1XV0sIFsnZGRhcnInLCBbODY1MF1dLCBbJ0REJywgWzg1MTddXSwgWydkZCcsIFs4NTE4XV0sIFsnRERvdHJhaGQnLCBbMTA1MTNdXSwgWydkZG90c2VxJywgWzEwODcxXV0sIFsnZGVnJywgWzE3Nl1dLCBbJ0RlbCcsIFs4NzExXV0sIFsnRGVsdGEnLCBbOTE2XV0sIFsnZGVsdGEnLCBbOTQ4XV0sIFsnZGVtcHR5dicsIFsxMDY3M11dLCBbJ2RmaXNodCcsIFsxMDYyM11dLCBbJ0RmcicsIFsxMjAwNzFdXSwgWydkZnInLCBbMTIwMDk3XV0sIFsnZEhhcicsIFsxMDU5N11dLCBbJ2RoYXJsJywgWzg2NDNdXSwgWydkaGFycicsIFs4NjQyXV0sIFsnRGlhY3JpdGljYWxBY3V0ZScsIFsxODBdXSwgWydEaWFjcml0aWNhbERvdCcsIFs3MjldXSwgWydEaWFjcml0aWNhbERvdWJsZUFjdXRlJywgWzczM11dLCBbJ0RpYWNyaXRpY2FsR3JhdmUnLCBbOTZdXSwgWydEaWFjcml0aWNhbFRpbGRlJywgWzczMl1dLCBbJ2RpYW0nLCBbODkwMF1dLCBbJ2RpYW1vbmQnLCBbODkwMF1dLCBbJ0RpYW1vbmQnLCBbODkwMF1dLCBbJ2RpYW1vbmRzdWl0JywgWzk4MzBdXSwgWydkaWFtcycsIFs5ODMwXV0sIFsnZGllJywgWzE2OF1dLCBbJ0RpZmZlcmVudGlhbEQnLCBbODUxOF1dLCBbJ2RpZ2FtbWEnLCBbOTg5XV0sIFsnZGlzaW4nLCBbODk0Nl1dLCBbJ2RpdicsIFsyNDddXSwgWydkaXZpZGUnLCBbMjQ3XV0sIFsnZGl2aWRlb250aW1lcycsIFs4OTAzXV0sIFsnZGl2b254JywgWzg5MDNdXSwgWydESmN5JywgWzEwMjZdXSwgWydkamN5JywgWzExMDZdXSwgWydkbGNvcm4nLCBbODk5MF1dLCBbJ2RsY3JvcCcsIFs4OTczXV0sIFsnZG9sbGFyJywgWzM2XV0sIFsnRG9wZicsIFsxMjAxMjNdXSwgWydkb3BmJywgWzEyMDE0OV1dLCBbJ0RvdCcsIFsxNjhdXSwgWydkb3QnLCBbNzI5XV0sIFsnRG90RG90JywgWzg0MTJdXSwgWydkb3RlcScsIFs4Nzg0XV0sIFsnZG90ZXFkb3QnLCBbODc4NV1dLCBbJ0RvdEVxdWFsJywgWzg3ODRdXSwgWydkb3RtaW51cycsIFs4NzYwXV0sIFsnZG90cGx1cycsIFs4NzI0XV0sIFsnZG90c3F1YXJlJywgWzg4NjVdXSwgWydkb3VibGViYXJ3ZWRnZScsIFs4OTY2XV0sIFsnRG91YmxlQ29udG91ckludGVncmFsJywgWzg3NTFdXSwgWydEb3VibGVEb3QnLCBbMTY4XV0sIFsnRG91YmxlRG93bkFycm93JywgWzg2NTldXSwgWydEb3VibGVMZWZ0QXJyb3cnLCBbODY1Nl1dLCBbJ0RvdWJsZUxlZnRSaWdodEFycm93JywgWzg2NjBdXSwgWydEb3VibGVMZWZ0VGVlJywgWzEwOTgwXV0sIFsnRG91YmxlTG9uZ0xlZnRBcnJvdycsIFsxMDIzMl1dLCBbJ0RvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvdycsIFsxMDIzNF1dLCBbJ0RvdWJsZUxvbmdSaWdodEFycm93JywgWzEwMjMzXV0sIFsnRG91YmxlUmlnaHRBcnJvdycsIFs4NjU4XV0sIFsnRG91YmxlUmlnaHRUZWUnLCBbODg3Ml1dLCBbJ0RvdWJsZVVwQXJyb3cnLCBbODY1N11dLCBbJ0RvdWJsZVVwRG93bkFycm93JywgWzg2NjFdXSwgWydEb3VibGVWZXJ0aWNhbEJhcicsIFs4NzQxXV0sIFsnRG93bkFycm93QmFyJywgWzEwNTE1XV0sIFsnZG93bmFycm93JywgWzg1OTVdXSwgWydEb3duQXJyb3cnLCBbODU5NV1dLCBbJ0Rvd25hcnJvdycsIFs4NjU5XV0sIFsnRG93bkFycm93VXBBcnJvdycsIFs4NjkzXV0sIFsnRG93bkJyZXZlJywgWzc4NV1dLCBbJ2Rvd25kb3duYXJyb3dzJywgWzg2NTBdXSwgWydkb3duaGFycG9vbmxlZnQnLCBbODY0M11dLCBbJ2Rvd25oYXJwb29ucmlnaHQnLCBbODY0Ml1dLCBbJ0Rvd25MZWZ0UmlnaHRWZWN0b3InLCBbMTA1NzZdXSwgWydEb3duTGVmdFRlZVZlY3RvcicsIFsxMDU5MF1dLCBbJ0Rvd25MZWZ0VmVjdG9yQmFyJywgWzEwNTgyXV0sIFsnRG93bkxlZnRWZWN0b3InLCBbODYzN11dLCBbJ0Rvd25SaWdodFRlZVZlY3RvcicsIFsxMDU5MV1dLCBbJ0Rvd25SaWdodFZlY3RvckJhcicsIFsxMDU4M11dLCBbJ0Rvd25SaWdodFZlY3RvcicsIFs4NjQxXV0sIFsnRG93blRlZUFycm93JywgWzg2MTVdXSwgWydEb3duVGVlJywgWzg4NjhdXSwgWydkcmJrYXJvdycsIFsxMDUxMl1dLCBbJ2RyY29ybicsIFs4OTkxXV0sIFsnZHJjcm9wJywgWzg5NzJdXSwgWydEc2NyJywgWzExOTk2N11dLCBbJ2RzY3InLCBbMTE5OTkzXV0sIFsnRFNjeScsIFsxMDI5XV0sIFsnZHNjeScsIFsxMTA5XV0sIFsnZHNvbCcsIFsxMDc0Ml1dLCBbJ0RzdHJvaycsIFsyNzJdXSwgWydkc3Ryb2snLCBbMjczXV0sIFsnZHRkb3QnLCBbODk0NV1dLCBbJ2R0cmknLCBbOTY2M11dLCBbJ2R0cmlmJywgWzk2NjJdXSwgWydkdWFycicsIFs4NjkzXV0sIFsnZHVoYXInLCBbMTA2MDddXSwgWydkd2FuZ2xlJywgWzEwNjYyXV0sIFsnRFpjeScsIFsxMDM5XV0sIFsnZHpjeScsIFsxMTE5XV0sIFsnZHppZ3JhcnInLCBbMTAyMzldXSwgWydFYWN1dGUnLCBbMjAxXV0sIFsnZWFjdXRlJywgWzIzM11dLCBbJ2Vhc3RlcicsIFsxMDg2Ml1dLCBbJ0VjYXJvbicsIFsyODJdXSwgWydlY2Fyb24nLCBbMjgzXV0sIFsnRWNpcmMnLCBbMjAyXV0sIFsnZWNpcmMnLCBbMjM0XV0sIFsnZWNpcicsIFs4NzkwXV0sIFsnZWNvbG9uJywgWzg3ODldXSwgWydFY3knLCBbMTA2OV1dLCBbJ2VjeScsIFsxMTAxXV0sIFsnZUREb3QnLCBbMTA4NzFdXSwgWydFZG90JywgWzI3OF1dLCBbJ2Vkb3QnLCBbMjc5XV0sIFsnZURvdCcsIFs4Nzg1XV0sIFsnZWUnLCBbODUxOV1dLCBbJ2VmRG90JywgWzg3ODZdXSwgWydFZnInLCBbMTIwMDcyXV0sIFsnZWZyJywgWzEyMDA5OF1dLCBbJ2VnJywgWzEwOTA2XV0sIFsnRWdyYXZlJywgWzIwMF1dLCBbJ2VncmF2ZScsIFsyMzJdXSwgWydlZ3MnLCBbMTA5MDJdXSwgWydlZ3Nkb3QnLCBbMTA5MDRdXSwgWydlbCcsIFsxMDkwNV1dLCBbJ0VsZW1lbnQnLCBbODcxMl1dLCBbJ2VsaW50ZXJzJywgWzkxOTFdXSwgWydlbGwnLCBbODQ2N11dLCBbJ2VscycsIFsxMDkwMV1dLCBbJ2Vsc2RvdCcsIFsxMDkwM11dLCBbJ0VtYWNyJywgWzI3NF1dLCBbJ2VtYWNyJywgWzI3NV1dLCBbJ2VtcHR5JywgWzg3MDldXSwgWydlbXB0eXNldCcsIFs4NzA5XV0sIFsnRW1wdHlTbWFsbFNxdWFyZScsIFs5NzIzXV0sIFsnZW1wdHl2JywgWzg3MDldXSwgWydFbXB0eVZlcnlTbWFsbFNxdWFyZScsIFs5NjQzXV0sIFsnZW1zcDEzJywgWzgxOTZdXSwgWydlbXNwMTQnLCBbODE5N11dLCBbJ2Vtc3AnLCBbODE5NV1dLCBbJ0VORycsIFszMzBdXSwgWydlbmcnLCBbMzMxXV0sIFsnZW5zcCcsIFs4MTk0XV0sIFsnRW9nb24nLCBbMjgwXV0sIFsnZW9nb24nLCBbMjgxXV0sIFsnRW9wZicsIFsxMjAxMjRdXSwgWydlb3BmJywgWzEyMDE1MF1dLCBbJ2VwYXInLCBbODkxN11dLCBbJ2VwYXJzbCcsIFsxMDcyM11dLCBbJ2VwbHVzJywgWzEwODY1XV0sIFsnZXBzaScsIFs5NDldXSwgWydFcHNpbG9uJywgWzkxN11dLCBbJ2Vwc2lsb24nLCBbOTQ5XV0sIFsnZXBzaXYnLCBbMTAxM11dLCBbJ2VxY2lyYycsIFs4NzkwXV0sIFsnZXFjb2xvbicsIFs4Nzg5XV0sIFsnZXFzaW0nLCBbODc3MF1dLCBbJ2Vxc2xhbnRndHInLCBbMTA5MDJdXSwgWydlcXNsYW50bGVzcycsIFsxMDkwMV1dLCBbJ0VxdWFsJywgWzEwODY5XV0sIFsnZXF1YWxzJywgWzYxXV0sIFsnRXF1YWxUaWxkZScsIFs4NzcwXV0sIFsnZXF1ZXN0JywgWzg3OTldXSwgWydFcXVpbGlicml1bScsIFs4NjUyXV0sIFsnZXF1aXYnLCBbODgwMV1dLCBbJ2VxdWl2REQnLCBbMTA4NzJdXSwgWydlcXZwYXJzbCcsIFsxMDcyNV1dLCBbJ2VyYXJyJywgWzEwNjA5XV0sIFsnZXJEb3QnLCBbODc4N11dLCBbJ2VzY3InLCBbODQ5NV1dLCBbJ0VzY3InLCBbODQ5Nl1dLCBbJ2VzZG90JywgWzg3ODRdXSwgWydFc2ltJywgWzEwODY3XV0sIFsnZXNpbScsIFs4NzcwXV0sIFsnRXRhJywgWzkxOV1dLCBbJ2V0YScsIFs5NTFdXSwgWydFVEgnLCBbMjA4XV0sIFsnZXRoJywgWzI0MF1dLCBbJ0V1bWwnLCBbMjAzXV0sIFsnZXVtbCcsIFsyMzVdXSwgWydldXJvJywgWzgzNjRdXSwgWydleGNsJywgWzMzXV0sIFsnZXhpc3QnLCBbODcwN11dLCBbJ0V4aXN0cycsIFs4NzA3XV0sIFsnZXhwZWN0YXRpb24nLCBbODQ5Nl1dLCBbJ2V4cG9uZW50aWFsZScsIFs4NTE5XV0sIFsnRXhwb25lbnRpYWxFJywgWzg1MTldXSwgWydmYWxsaW5nZG90c2VxJywgWzg3ODZdXSwgWydGY3knLCBbMTA2MF1dLCBbJ2ZjeScsIFsxMDkyXV0sIFsnZmVtYWxlJywgWzk3OTJdXSwgWydmZmlsaWcnLCBbNjQyNTldXSwgWydmZmxpZycsIFs2NDI1Nl1dLCBbJ2ZmbGxpZycsIFs2NDI2MF1dLCBbJ0ZmcicsIFsxMjAwNzNdXSwgWydmZnInLCBbMTIwMDk5XV0sIFsnZmlsaWcnLCBbNjQyNTddXSwgWydGaWxsZWRTbWFsbFNxdWFyZScsIFs5NzI0XV0sIFsnRmlsbGVkVmVyeVNtYWxsU3F1YXJlJywgWzk2NDJdXSwgWydmamxpZycsIFsxMDIsIDEwNl1dLCBbJ2ZsYXQnLCBbOTgzN11dLCBbJ2ZsbGlnJywgWzY0MjU4XV0sIFsnZmx0bnMnLCBbOTY0OV1dLCBbJ2Zub2YnLCBbNDAyXV0sIFsnRm9wZicsIFsxMjAxMjVdXSwgWydmb3BmJywgWzEyMDE1MV1dLCBbJ2ZvcmFsbCcsIFs4NzA0XV0sIFsnRm9yQWxsJywgWzg3MDRdXSwgWydmb3JrJywgWzg5MTZdXSwgWydmb3JrdicsIFsxMDk2OV1dLCBbJ0ZvdXJpZXJ0cmYnLCBbODQ5N11dLCBbJ2ZwYXJ0aW50JywgWzEwNzY1XV0sIFsnZnJhYzEyJywgWzE4OV1dLCBbJ2ZyYWMxMycsIFs4NTMxXV0sIFsnZnJhYzE0JywgWzE4OF1dLCBbJ2ZyYWMxNScsIFs4NTMzXV0sIFsnZnJhYzE2JywgWzg1MzddXSwgWydmcmFjMTgnLCBbODUzOV1dLCBbJ2ZyYWMyMycsIFs4NTMyXV0sIFsnZnJhYzI1JywgWzg1MzRdXSwgWydmcmFjMzQnLCBbMTkwXV0sIFsnZnJhYzM1JywgWzg1MzVdXSwgWydmcmFjMzgnLCBbODU0MF1dLCBbJ2ZyYWM0NScsIFs4NTM2XV0sIFsnZnJhYzU2JywgWzg1MzhdXSwgWydmcmFjNTgnLCBbODU0MV1dLCBbJ2ZyYWM3OCcsIFs4NTQyXV0sIFsnZnJhc2wnLCBbODI2MF1dLCBbJ2Zyb3duJywgWzg5OTRdXSwgWydmc2NyJywgWzExOTk5NV1dLCBbJ0ZzY3InLCBbODQ5N11dLCBbJ2dhY3V0ZScsIFs1MDFdXSwgWydHYW1tYScsIFs5MTVdXSwgWydnYW1tYScsIFs5NDddXSwgWydHYW1tYWQnLCBbOTg4XV0sIFsnZ2FtbWFkJywgWzk4OV1dLCBbJ2dhcCcsIFsxMDg4Nl1dLCBbJ0dicmV2ZScsIFsyODZdXSwgWydnYnJldmUnLCBbMjg3XV0sIFsnR2NlZGlsJywgWzI5MF1dLCBbJ0djaXJjJywgWzI4NF1dLCBbJ2djaXJjJywgWzI4NV1dLCBbJ0djeScsIFsxMDQzXV0sIFsnZ2N5JywgWzEwNzVdXSwgWydHZG90JywgWzI4OF1dLCBbJ2dkb3QnLCBbMjg5XV0sIFsnZ2UnLCBbODgwNV1dLCBbJ2dFJywgWzg4MDddXSwgWydnRWwnLCBbMTA4OTJdXSwgWydnZWwnLCBbODkyM11dLCBbJ2dlcScsIFs4ODA1XV0sIFsnZ2VxcScsIFs4ODA3XV0sIFsnZ2Vxc2xhbnQnLCBbMTA4NzhdXSwgWydnZXNjYycsIFsxMDkyMV1dLCBbJ2dlcycsIFsxMDg3OF1dLCBbJ2dlc2RvdCcsIFsxMDg4MF1dLCBbJ2dlc2RvdG8nLCBbMTA4ODJdXSwgWydnZXNkb3RvbCcsIFsxMDg4NF1dLCBbJ2dlc2wnLCBbODkyMywgNjUwMjRdXSwgWydnZXNsZXMnLCBbMTA5MDBdXSwgWydHZnInLCBbMTIwMDc0XV0sIFsnZ2ZyJywgWzEyMDEwMF1dLCBbJ2dnJywgWzg4MTFdXSwgWydHZycsIFs4OTIxXV0sIFsnZ2dnJywgWzg5MjFdXSwgWydnaW1lbCcsIFs4NTAzXV0sIFsnR0pjeScsIFsxMDI3XV0sIFsnZ2pjeScsIFsxMTA3XV0sIFsnZ2xhJywgWzEwOTE3XV0sIFsnZ2wnLCBbODgyM11dLCBbJ2dsRScsIFsxMDg5OF1dLCBbJ2dsaicsIFsxMDkxNl1dLCBbJ2duYXAnLCBbMTA4OTBdXSwgWydnbmFwcHJveCcsIFsxMDg5MF1dLCBbJ2duZScsIFsxMDg4OF1dLCBbJ2duRScsIFs4ODA5XV0sIFsnZ25lcScsIFsxMDg4OF1dLCBbJ2duZXFxJywgWzg4MDldXSwgWydnbnNpbScsIFs4OTM1XV0sIFsnR29wZicsIFsxMjAxMjZdXSwgWydnb3BmJywgWzEyMDE1Ml1dLCBbJ2dyYXZlJywgWzk2XV0sIFsnR3JlYXRlckVxdWFsJywgWzg4MDVdXSwgWydHcmVhdGVyRXF1YWxMZXNzJywgWzg5MjNdXSwgWydHcmVhdGVyRnVsbEVxdWFsJywgWzg4MDddXSwgWydHcmVhdGVyR3JlYXRlcicsIFsxMDkxNF1dLCBbJ0dyZWF0ZXJMZXNzJywgWzg4MjNdXSwgWydHcmVhdGVyU2xhbnRFcXVhbCcsIFsxMDg3OF1dLCBbJ0dyZWF0ZXJUaWxkZScsIFs4ODE5XV0sIFsnR3NjcicsIFsxMTk5NzBdXSwgWydnc2NyJywgWzg0NThdXSwgWydnc2ltJywgWzg4MTldXSwgWydnc2ltZScsIFsxMDg5NF1dLCBbJ2dzaW1sJywgWzEwODk2XV0sIFsnZ3RjYycsIFsxMDkxOV1dLCBbJ2d0Y2lyJywgWzEwODc0XV0sIFsnZ3QnLCBbNjJdXSwgWydHVCcsIFs2Ml1dLCBbJ0d0JywgWzg4MTFdXSwgWydndGRvdCcsIFs4OTE5XV0sIFsnZ3RsUGFyJywgWzEwNjQ1XV0sIFsnZ3RxdWVzdCcsIFsxMDg3Nl1dLCBbJ2d0cmFwcHJveCcsIFsxMDg4Nl1dLCBbJ2d0cmFycicsIFsxMDYxNl1dLCBbJ2d0cmRvdCcsIFs4OTE5XV0sIFsnZ3RyZXFsZXNzJywgWzg5MjNdXSwgWydndHJlcXFsZXNzJywgWzEwODkyXV0sIFsnZ3RybGVzcycsIFs4ODIzXV0sIFsnZ3Ryc2ltJywgWzg4MTldXSwgWydndmVydG5lcXEnLCBbODgwOSwgNjUwMjRdXSwgWydndm5FJywgWzg4MDksIDY1MDI0XV0sIFsnSGFjZWsnLCBbNzExXV0sIFsnaGFpcnNwJywgWzgyMDJdXSwgWydoYWxmJywgWzE4OV1dLCBbJ2hhbWlsdCcsIFs4NDU5XV0sIFsnSEFSRGN5JywgWzEwNjZdXSwgWydoYXJkY3knLCBbMTA5OF1dLCBbJ2hhcnJjaXInLCBbMTA1NjhdXSwgWydoYXJyJywgWzg1OTZdXSwgWydoQXJyJywgWzg2NjBdXSwgWydoYXJydycsIFs4NjIxXV0sIFsnSGF0JywgWzk0XV0sIFsnaGJhcicsIFs4NDYzXV0sIFsnSGNpcmMnLCBbMjkyXV0sIFsnaGNpcmMnLCBbMjkzXV0sIFsnaGVhcnRzJywgWzk4MjldXSwgWydoZWFydHN1aXQnLCBbOTgyOV1dLCBbJ2hlbGxpcCcsIFs4MjMwXV0sIFsnaGVyY29uJywgWzg4ODldXSwgWydoZnInLCBbMTIwMTAxXV0sIFsnSGZyJywgWzg0NjBdXSwgWydIaWxiZXJ0U3BhY2UnLCBbODQ1OV1dLCBbJ2hrc2Vhcm93JywgWzEwNTMzXV0sIFsnaGtzd2Fyb3cnLCBbMTA1MzRdXSwgWydob2FycicsIFs4NzAzXV0sIFsnaG9tdGh0JywgWzg3NjNdXSwgWydob29rbGVmdGFycm93JywgWzg2MTddXSwgWydob29rcmlnaHRhcnJvdycsIFs4NjE4XV0sIFsnaG9wZicsIFsxMjAxNTNdXSwgWydIb3BmJywgWzg0NjFdXSwgWydob3JiYXInLCBbODIxM11dLCBbJ0hvcml6b250YWxMaW5lJywgWzk0NzJdXSwgWydoc2NyJywgWzExOTk5N11dLCBbJ0hzY3InLCBbODQ1OV1dLCBbJ2hzbGFzaCcsIFs4NDYzXV0sIFsnSHN0cm9rJywgWzI5NF1dLCBbJ2hzdHJvaycsIFsyOTVdXSwgWydIdW1wRG93bkh1bXAnLCBbODc4Ml1dLCBbJ0h1bXBFcXVhbCcsIFs4NzgzXV0sIFsnaHlidWxsJywgWzgyNTldXSwgWydoeXBoZW4nLCBbODIwOF1dLCBbJ0lhY3V0ZScsIFsyMDVdXSwgWydpYWN1dGUnLCBbMjM3XV0sIFsnaWMnLCBbODI5MV1dLCBbJ0ljaXJjJywgWzIwNl1dLCBbJ2ljaXJjJywgWzIzOF1dLCBbJ0ljeScsIFsxMDQ4XV0sIFsnaWN5JywgWzEwODBdXSwgWydJZG90JywgWzMwNF1dLCBbJ0lFY3knLCBbMTA0NV1dLCBbJ2llY3knLCBbMTA3N11dLCBbJ2lleGNsJywgWzE2MV1dLCBbJ2lmZicsIFs4NjYwXV0sIFsnaWZyJywgWzEyMDEwMl1dLCBbJ0lmcicsIFs4NDY1XV0sIFsnSWdyYXZlJywgWzIwNF1dLCBbJ2lncmF2ZScsIFsyMzZdXSwgWydpaScsIFs4NTIwXV0sIFsnaWlpaW50JywgWzEwNzY0XV0sIFsnaWlpbnQnLCBbODc0OV1dLCBbJ2lpbmZpbicsIFsxMDcxNl1dLCBbJ2lpb3RhJywgWzg0ODldXSwgWydJSmxpZycsIFszMDZdXSwgWydpamxpZycsIFszMDddXSwgWydJbWFjcicsIFsyOThdXSwgWydpbWFjcicsIFsyOTldXSwgWydpbWFnZScsIFs4NDY1XV0sIFsnSW1hZ2luYXJ5SScsIFs4NTIwXV0sIFsnaW1hZ2xpbmUnLCBbODQ2NF1dLCBbJ2ltYWdwYXJ0JywgWzg0NjVdXSwgWydpbWF0aCcsIFszMDVdXSwgWydJbScsIFs4NDY1XV0sIFsnaW1vZicsIFs4ODg3XV0sIFsnaW1wZWQnLCBbNDM3XV0sIFsnSW1wbGllcycsIFs4NjU4XV0sIFsnaW5jYXJlJywgWzg0NTNdXSwgWydpbicsIFs4NzEyXV0sIFsnaW5maW4nLCBbODczNF1dLCBbJ2luZmludGllJywgWzEwNzE3XV0sIFsnaW5vZG90JywgWzMwNV1dLCBbJ2ludGNhbCcsIFs4ODkwXV0sIFsnaW50JywgWzg3NDddXSwgWydJbnQnLCBbODc0OF1dLCBbJ2ludGVnZXJzJywgWzg0ODRdXSwgWydJbnRlZ3JhbCcsIFs4NzQ3XV0sIFsnaW50ZXJjYWwnLCBbODg5MF1dLCBbJ0ludGVyc2VjdGlvbicsIFs4ODk4XV0sIFsnaW50bGFyaGsnLCBbMTA3NzVdXSwgWydpbnRwcm9kJywgWzEwODEyXV0sIFsnSW52aXNpYmxlQ29tbWEnLCBbODI5MV1dLCBbJ0ludmlzaWJsZVRpbWVzJywgWzgyOTBdXSwgWydJT2N5JywgWzEwMjVdXSwgWydpb2N5JywgWzExMDVdXSwgWydJb2dvbicsIFszMDJdXSwgWydpb2dvbicsIFszMDNdXSwgWydJb3BmJywgWzEyMDEyOF1dLCBbJ2lvcGYnLCBbMTIwMTU0XV0sIFsnSW90YScsIFs5MjFdXSwgWydpb3RhJywgWzk1M11dLCBbJ2lwcm9kJywgWzEwODEyXV0sIFsnaXF1ZXN0JywgWzE5MV1dLCBbJ2lzY3InLCBbMTE5OTk4XV0sIFsnSXNjcicsIFs4NDY0XV0sIFsnaXNpbicsIFs4NzEyXV0sIFsnaXNpbmRvdCcsIFs4OTQ5XV0sIFsnaXNpbkUnLCBbODk1M11dLCBbJ2lzaW5zJywgWzg5NDhdXSwgWydpc2luc3YnLCBbODk0N11dLCBbJ2lzaW52JywgWzg3MTJdXSwgWydpdCcsIFs4MjkwXV0sIFsnSXRpbGRlJywgWzI5Nl1dLCBbJ2l0aWxkZScsIFsyOTddXSwgWydJdWtjeScsIFsxMDMwXV0sIFsnaXVrY3knLCBbMTExMF1dLCBbJ0l1bWwnLCBbMjA3XV0sIFsnaXVtbCcsIFsyMzldXSwgWydKY2lyYycsIFszMDhdXSwgWydqY2lyYycsIFszMDldXSwgWydKY3knLCBbMTA0OV1dLCBbJ2pjeScsIFsxMDgxXV0sIFsnSmZyJywgWzEyMDA3N11dLCBbJ2pmcicsIFsxMjAxMDNdXSwgWydqbWF0aCcsIFs1NjddXSwgWydKb3BmJywgWzEyMDEyOV1dLCBbJ2pvcGYnLCBbMTIwMTU1XV0sIFsnSnNjcicsIFsxMTk5NzNdXSwgWydqc2NyJywgWzExOTk5OV1dLCBbJ0pzZXJjeScsIFsxMDMyXV0sIFsnanNlcmN5JywgWzExMTJdXSwgWydKdWtjeScsIFsxMDI4XV0sIFsnanVrY3knLCBbMTEwOF1dLCBbJ0thcHBhJywgWzkyMl1dLCBbJ2thcHBhJywgWzk1NF1dLCBbJ2thcHBhdicsIFsxMDA4XV0sIFsnS2NlZGlsJywgWzMxMF1dLCBbJ2tjZWRpbCcsIFszMTFdXSwgWydLY3knLCBbMTA1MF1dLCBbJ2tjeScsIFsxMDgyXV0sIFsnS2ZyJywgWzEyMDA3OF1dLCBbJ2tmcicsIFsxMjAxMDRdXSwgWydrZ3JlZW4nLCBbMzEyXV0sIFsnS0hjeScsIFsxMDYxXV0sIFsna2hjeScsIFsxMDkzXV0sIFsnS0pjeScsIFsxMDM2XV0sIFsna2pjeScsIFsxMTE2XV0sIFsnS29wZicsIFsxMjAxMzBdXSwgWydrb3BmJywgWzEyMDE1Nl1dLCBbJ0tzY3InLCBbMTE5OTc0XV0sIFsna3NjcicsIFsxMjAwMDBdXSwgWydsQWFycicsIFs4NjY2XV0sIFsnTGFjdXRlJywgWzMxM11dLCBbJ2xhY3V0ZScsIFszMTRdXSwgWydsYWVtcHR5dicsIFsxMDY3Nl1dLCBbJ2xhZ3JhbicsIFs4NDY2XV0sIFsnTGFtYmRhJywgWzkyM11dLCBbJ2xhbWJkYScsIFs5NTVdXSwgWydsYW5nJywgWzEwMjE2XV0sIFsnTGFuZycsIFsxMDIxOF1dLCBbJ2xhbmdkJywgWzEwNjQxXV0sIFsnbGFuZ2xlJywgWzEwMjE2XV0sIFsnbGFwJywgWzEwODg1XV0sIFsnTGFwbGFjZXRyZicsIFs4NDY2XV0sIFsnbGFxdW8nLCBbMTcxXV0sIFsnbGFycmInLCBbODY3Nl1dLCBbJ2xhcnJiZnMnLCBbMTA1MjddXSwgWydsYXJyJywgWzg1OTJdXSwgWydMYXJyJywgWzg2MDZdXSwgWydsQXJyJywgWzg2NTZdXSwgWydsYXJyZnMnLCBbMTA1MjVdXSwgWydsYXJyaGsnLCBbODYxN11dLCBbJ2xhcnJscCcsIFs4NjE5XV0sIFsnbGFycnBsJywgWzEwNTUzXV0sIFsnbGFycnNpbScsIFsxMDYxMV1dLCBbJ2xhcnJ0bCcsIFs4NjEwXV0sIFsnbGF0YWlsJywgWzEwNTIxXV0sIFsnbEF0YWlsJywgWzEwNTIzXV0sIFsnbGF0JywgWzEwOTIzXV0sIFsnbGF0ZScsIFsxMDkyNV1dLCBbJ2xhdGVzJywgWzEwOTI1LCA2NTAyNF1dLCBbJ2xiYXJyJywgWzEwNTA4XV0sIFsnbEJhcnInLCBbMTA1MTBdXSwgWydsYmJyaycsIFsxMDA5OF1dLCBbJ2xicmFjZScsIFsxMjNdXSwgWydsYnJhY2snLCBbOTFdXSwgWydsYnJrZScsIFsxMDYzNV1dLCBbJ2xicmtzbGQnLCBbMTA2MzldXSwgWydsYnJrc2x1JywgWzEwNjM3XV0sIFsnTGNhcm9uJywgWzMxN11dLCBbJ2xjYXJvbicsIFszMThdXSwgWydMY2VkaWwnLCBbMzE1XV0sIFsnbGNlZGlsJywgWzMxNl1dLCBbJ2xjZWlsJywgWzg5NjhdXSwgWydsY3ViJywgWzEyM11dLCBbJ0xjeScsIFsxMDUxXV0sIFsnbGN5JywgWzEwODNdXSwgWydsZGNhJywgWzEwNTUwXV0sIFsnbGRxdW8nLCBbODIyMF1dLCBbJ2xkcXVvcicsIFs4MjIyXV0sIFsnbGRyZGhhcicsIFsxMDU5OV1dLCBbJ2xkcnVzaGFyJywgWzEwNTcxXV0sIFsnbGRzaCcsIFs4NjI2XV0sIFsnbGUnLCBbODgwNF1dLCBbJ2xFJywgWzg4MDZdXSwgWydMZWZ0QW5nbGVCcmFja2V0JywgWzEwMjE2XV0sIFsnTGVmdEFycm93QmFyJywgWzg2NzZdXSwgWydsZWZ0YXJyb3cnLCBbODU5Ml1dLCBbJ0xlZnRBcnJvdycsIFs4NTkyXV0sIFsnTGVmdGFycm93JywgWzg2NTZdXSwgWydMZWZ0QXJyb3dSaWdodEFycm93JywgWzg2NDZdXSwgWydsZWZ0YXJyb3d0YWlsJywgWzg2MTBdXSwgWydMZWZ0Q2VpbGluZycsIFs4OTY4XV0sIFsnTGVmdERvdWJsZUJyYWNrZXQnLCBbMTAyMTRdXSwgWydMZWZ0RG93blRlZVZlY3RvcicsIFsxMDU5M11dLCBbJ0xlZnREb3duVmVjdG9yQmFyJywgWzEwNTg1XV0sIFsnTGVmdERvd25WZWN0b3InLCBbODY0M11dLCBbJ0xlZnRGbG9vcicsIFs4OTcwXV0sIFsnbGVmdGhhcnBvb25kb3duJywgWzg2MzddXSwgWydsZWZ0aGFycG9vbnVwJywgWzg2MzZdXSwgWydsZWZ0bGVmdGFycm93cycsIFs4NjQ3XV0sIFsnbGVmdHJpZ2h0YXJyb3cnLCBbODU5Nl1dLCBbJ0xlZnRSaWdodEFycm93JywgWzg1OTZdXSwgWydMZWZ0cmlnaHRhcnJvdycsIFs4NjYwXV0sIFsnbGVmdHJpZ2h0YXJyb3dzJywgWzg2NDZdXSwgWydsZWZ0cmlnaHRoYXJwb29ucycsIFs4NjUxXV0sIFsnbGVmdHJpZ2h0c3F1aWdhcnJvdycsIFs4NjIxXV0sIFsnTGVmdFJpZ2h0VmVjdG9yJywgWzEwNTc0XV0sIFsnTGVmdFRlZUFycm93JywgWzg2MTJdXSwgWydMZWZ0VGVlJywgWzg4NjddXSwgWydMZWZ0VGVlVmVjdG9yJywgWzEwNTg2XV0sIFsnbGVmdHRocmVldGltZXMnLCBbODkwN11dLCBbJ0xlZnRUcmlhbmdsZUJhcicsIFsxMDcwM11dLCBbJ0xlZnRUcmlhbmdsZScsIFs4ODgyXV0sIFsnTGVmdFRyaWFuZ2xlRXF1YWwnLCBbODg4NF1dLCBbJ0xlZnRVcERvd25WZWN0b3InLCBbMTA1NzddXSwgWydMZWZ0VXBUZWVWZWN0b3InLCBbMTA1OTJdXSwgWydMZWZ0VXBWZWN0b3JCYXInLCBbMTA1ODRdXSwgWydMZWZ0VXBWZWN0b3InLCBbODYzOV1dLCBbJ0xlZnRWZWN0b3JCYXInLCBbMTA1NzhdXSwgWydMZWZ0VmVjdG9yJywgWzg2MzZdXSwgWydsRWcnLCBbMTA4OTFdXSwgWydsZWcnLCBbODkyMl1dLCBbJ2xlcScsIFs4ODA0XV0sIFsnbGVxcScsIFs4ODA2XV0sIFsnbGVxc2xhbnQnLCBbMTA4NzddXSwgWydsZXNjYycsIFsxMDkyMF1dLCBbJ2xlcycsIFsxMDg3N11dLCBbJ2xlc2RvdCcsIFsxMDg3OV1dLCBbJ2xlc2RvdG8nLCBbMTA4ODFdXSwgWydsZXNkb3RvcicsIFsxMDg4M11dLCBbJ2xlc2cnLCBbODkyMiwgNjUwMjRdXSwgWydsZXNnZXMnLCBbMTA4OTldXSwgWydsZXNzYXBwcm94JywgWzEwODg1XV0sIFsnbGVzc2RvdCcsIFs4OTE4XV0sIFsnbGVzc2VxZ3RyJywgWzg5MjJdXSwgWydsZXNzZXFxZ3RyJywgWzEwODkxXV0sIFsnTGVzc0VxdWFsR3JlYXRlcicsIFs4OTIyXV0sIFsnTGVzc0Z1bGxFcXVhbCcsIFs4ODA2XV0sIFsnTGVzc0dyZWF0ZXInLCBbODgyMl1dLCBbJ2xlc3NndHInLCBbODgyMl1dLCBbJ0xlc3NMZXNzJywgWzEwOTEzXV0sIFsnbGVzc3NpbScsIFs4ODE4XV0sIFsnTGVzc1NsYW50RXF1YWwnLCBbMTA4NzddXSwgWydMZXNzVGlsZGUnLCBbODgxOF1dLCBbJ2xmaXNodCcsIFsxMDYyMF1dLCBbJ2xmbG9vcicsIFs4OTcwXV0sIFsnTGZyJywgWzEyMDA3OV1dLCBbJ2xmcicsIFsxMjAxMDVdXSwgWydsZycsIFs4ODIyXV0sIFsnbGdFJywgWzEwODk3XV0sIFsnbEhhcicsIFsxMDU5NF1dLCBbJ2xoYXJkJywgWzg2MzddXSwgWydsaGFydScsIFs4NjM2XV0sIFsnbGhhcnVsJywgWzEwNjAyXV0sIFsnbGhibGsnLCBbOTYwNF1dLCBbJ0xKY3knLCBbMTAzM11dLCBbJ2xqY3knLCBbMTExM11dLCBbJ2xsYXJyJywgWzg2NDddXSwgWydsbCcsIFs4ODEwXV0sIFsnTGwnLCBbODkyMF1dLCBbJ2xsY29ybmVyJywgWzg5OTBdXSwgWydMbGVmdGFycm93JywgWzg2NjZdXSwgWydsbGhhcmQnLCBbMTA2MDNdXSwgWydsbHRyaScsIFs5NzIyXV0sIFsnTG1pZG90JywgWzMxOV1dLCBbJ2xtaWRvdCcsIFszMjBdXSwgWydsbW91c3RhY2hlJywgWzkxMzZdXSwgWydsbW91c3QnLCBbOTEzNl1dLCBbJ2xuYXAnLCBbMTA4ODldXSwgWydsbmFwcHJveCcsIFsxMDg4OV1dLCBbJ2xuZScsIFsxMDg4N11dLCBbJ2xuRScsIFs4ODA4XV0sIFsnbG5lcScsIFsxMDg4N11dLCBbJ2xuZXFxJywgWzg4MDhdXSwgWydsbnNpbScsIFs4OTM0XV0sIFsnbG9hbmcnLCBbMTAyMjBdXSwgWydsb2FycicsIFs4NzAxXV0sIFsnbG9icmsnLCBbMTAyMTRdXSwgWydsb25nbGVmdGFycm93JywgWzEwMjI5XV0sIFsnTG9uZ0xlZnRBcnJvdycsIFsxMDIyOV1dLCBbJ0xvbmdsZWZ0YXJyb3cnLCBbMTAyMzJdXSwgWydsb25nbGVmdHJpZ2h0YXJyb3cnLCBbMTAyMzFdXSwgWydMb25nTGVmdFJpZ2h0QXJyb3cnLCBbMTAyMzFdXSwgWydMb25nbGVmdHJpZ2h0YXJyb3cnLCBbMTAyMzRdXSwgWydsb25nbWFwc3RvJywgWzEwMjM2XV0sIFsnbG9uZ3JpZ2h0YXJyb3cnLCBbMTAyMzBdXSwgWydMb25nUmlnaHRBcnJvdycsIFsxMDIzMF1dLCBbJ0xvbmdyaWdodGFycm93JywgWzEwMjMzXV0sIFsnbG9vcGFycm93bGVmdCcsIFs4NjE5XV0sIFsnbG9vcGFycm93cmlnaHQnLCBbODYyMF1dLCBbJ2xvcGFyJywgWzEwNjI5XV0sIFsnTG9wZicsIFsxMjAxMzFdXSwgWydsb3BmJywgWzEyMDE1N11dLCBbJ2xvcGx1cycsIFsxMDc5N11dLCBbJ2xvdGltZXMnLCBbMTA4MDRdXSwgWydsb3dhc3QnLCBbODcyN11dLCBbJ2xvd2JhcicsIFs5NV1dLCBbJ0xvd2VyTGVmdEFycm93JywgWzg2MDFdXSwgWydMb3dlclJpZ2h0QXJyb3cnLCBbODYwMF1dLCBbJ2xveicsIFs5Njc0XV0sIFsnbG96ZW5nZScsIFs5Njc0XV0sIFsnbG96ZicsIFsxMDczMV1dLCBbJ2xwYXInLCBbNDBdXSwgWydscGFybHQnLCBbMTA2NDNdXSwgWydscmFycicsIFs4NjQ2XV0sIFsnbHJjb3JuZXInLCBbODk5MV1dLCBbJ2xyaGFyJywgWzg2NTFdXSwgWydscmhhcmQnLCBbMTA2MDVdXSwgWydscm0nLCBbODIwNl1dLCBbJ2xydHJpJywgWzg4OTVdXSwgWydsc2FxdW8nLCBbODI0OV1dLCBbJ2xzY3InLCBbMTIwMDAxXV0sIFsnTHNjcicsIFs4NDY2XV0sIFsnbHNoJywgWzg2MjRdXSwgWydMc2gnLCBbODYyNF1dLCBbJ2xzaW0nLCBbODgxOF1dLCBbJ2xzaW1lJywgWzEwODkzXV0sIFsnbHNpbWcnLCBbMTA4OTVdXSwgWydsc3FiJywgWzkxXV0sIFsnbHNxdW8nLCBbODIxNl1dLCBbJ2xzcXVvcicsIFs4MjE4XV0sIFsnTHN0cm9rJywgWzMyMV1dLCBbJ2xzdHJvaycsIFszMjJdXSwgWydsdGNjJywgWzEwOTE4XV0sIFsnbHRjaXInLCBbMTA4NzNdXSwgWydsdCcsIFs2MF1dLCBbJ0xUJywgWzYwXV0sIFsnTHQnLCBbODgxMF1dLCBbJ2x0ZG90JywgWzg5MThdXSwgWydsdGhyZWUnLCBbODkwN11dLCBbJ2x0aW1lcycsIFs4OTA1XV0sIFsnbHRsYXJyJywgWzEwNjE0XV0sIFsnbHRxdWVzdCcsIFsxMDg3NV1dLCBbJ2x0cmknLCBbOTY2N11dLCBbJ2x0cmllJywgWzg4ODRdXSwgWydsdHJpZicsIFs5NjY2XV0sIFsnbHRyUGFyJywgWzEwNjQ2XV0sIFsnbHVyZHNoYXInLCBbMTA1NzBdXSwgWydsdXJ1aGFyJywgWzEwNTk4XV0sIFsnbHZlcnRuZXFxJywgWzg4MDgsIDY1MDI0XV0sIFsnbHZuRScsIFs4ODA4LCA2NTAyNF1dLCBbJ21hY3InLCBbMTc1XV0sIFsnbWFsZScsIFs5Nzk0XV0sIFsnbWFsdCcsIFsxMDAxNl1dLCBbJ21hbHRlc2UnLCBbMTAwMTZdXSwgWydNYXAnLCBbMTA1MDFdXSwgWydtYXAnLCBbODYxNF1dLCBbJ21hcHN0bycsIFs4NjE0XV0sIFsnbWFwc3RvZG93bicsIFs4NjE1XV0sIFsnbWFwc3RvbGVmdCcsIFs4NjEyXV0sIFsnbWFwc3RvdXAnLCBbODYxM11dLCBbJ21hcmtlcicsIFs5NjQ2XV0sIFsnbWNvbW1hJywgWzEwNzkzXV0sIFsnTWN5JywgWzEwNTJdXSwgWydtY3knLCBbMTA4NF1dLCBbJ21kYXNoJywgWzgyMTJdXSwgWydtRERvdCcsIFs4NzYyXV0sIFsnbWVhc3VyZWRhbmdsZScsIFs4NzM3XV0sIFsnTWVkaXVtU3BhY2UnLCBbODI4N11dLCBbJ01lbGxpbnRyZicsIFs4NDk5XV0sIFsnTWZyJywgWzEyMDA4MF1dLCBbJ21mcicsIFsxMjAxMDZdXSwgWydtaG8nLCBbODQ4N11dLCBbJ21pY3JvJywgWzE4MV1dLCBbJ21pZGFzdCcsIFs0Ml1dLCBbJ21pZGNpcicsIFsxMDk5Ml1dLCBbJ21pZCcsIFs4NzM5XV0sIFsnbWlkZG90JywgWzE4M11dLCBbJ21pbnVzYicsIFs4ODYzXV0sIFsnbWludXMnLCBbODcyMl1dLCBbJ21pbnVzZCcsIFs4NzYwXV0sIFsnbWludXNkdScsIFsxMDc5NF1dLCBbJ01pbnVzUGx1cycsIFs4NzIzXV0sIFsnbWxjcCcsIFsxMDk3MV1dLCBbJ21sZHInLCBbODIzMF1dLCBbJ21ucGx1cycsIFs4NzIzXV0sIFsnbW9kZWxzJywgWzg4NzFdXSwgWydNb3BmJywgWzEyMDEzMl1dLCBbJ21vcGYnLCBbMTIwMTU4XV0sIFsnbXAnLCBbODcyM11dLCBbJ21zY3InLCBbMTIwMDAyXV0sIFsnTXNjcicsIFs4NDk5XV0sIFsnbXN0cG9zJywgWzg3NjZdXSwgWydNdScsIFs5MjRdXSwgWydtdScsIFs5NTZdXSwgWydtdWx0aW1hcCcsIFs4ODg4XV0sIFsnbXVtYXAnLCBbODg4OF1dLCBbJ25hYmxhJywgWzg3MTFdXSwgWydOYWN1dGUnLCBbMzIzXV0sIFsnbmFjdXRlJywgWzMyNF1dLCBbJ25hbmcnLCBbODczNiwgODQwMl1dLCBbJ25hcCcsIFs4Nzc3XV0sIFsnbmFwRScsIFsxMDg2NCwgODI0XV0sIFsnbmFwaWQnLCBbODc3OSwgODI0XV0sIFsnbmFwb3MnLCBbMzI5XV0sIFsnbmFwcHJveCcsIFs4Nzc3XV0sIFsnbmF0dXJhbCcsIFs5ODM4XV0sIFsnbmF0dXJhbHMnLCBbODQ2OV1dLCBbJ25hdHVyJywgWzk4MzhdXSwgWyduYnNwJywgWzE2MF1dLCBbJ25idW1wJywgWzg3ODIsIDgyNF1dLCBbJ25idW1wZScsIFs4NzgzLCA4MjRdXSwgWyduY2FwJywgWzEwODE5XV0sIFsnTmNhcm9uJywgWzMyN11dLCBbJ25jYXJvbicsIFszMjhdXSwgWydOY2VkaWwnLCBbMzI1XV0sIFsnbmNlZGlsJywgWzMyNl1dLCBbJ25jb25nJywgWzg3NzVdXSwgWyduY29uZ2RvdCcsIFsxMDg2MSwgODI0XV0sIFsnbmN1cCcsIFsxMDgxOF1dLCBbJ05jeScsIFsxMDUzXV0sIFsnbmN5JywgWzEwODVdXSwgWyduZGFzaCcsIFs4MjExXV0sIFsnbmVhcmhrJywgWzEwNTMyXV0sIFsnbmVhcnInLCBbODU5OV1dLCBbJ25lQXJyJywgWzg2NjNdXSwgWyduZWFycm93JywgWzg1OTldXSwgWyduZScsIFs4ODAwXV0sIFsnbmVkb3QnLCBbODc4NCwgODI0XV0sIFsnTmVnYXRpdmVNZWRpdW1TcGFjZScsIFs4MjAzXV0sIFsnTmVnYXRpdmVUaGlja1NwYWNlJywgWzgyMDNdXSwgWydOZWdhdGl2ZVRoaW5TcGFjZScsIFs4MjAzXV0sIFsnTmVnYXRpdmVWZXJ5VGhpblNwYWNlJywgWzgyMDNdXSwgWyduZXF1aXYnLCBbODgwMl1dLCBbJ25lc2VhcicsIFsxMDUzNl1dLCBbJ25lc2ltJywgWzg3NzAsIDgyNF1dLCBbJ05lc3RlZEdyZWF0ZXJHcmVhdGVyJywgWzg4MTFdXSwgWydOZXN0ZWRMZXNzTGVzcycsIFs4ODEwXV0sIFsnbmV4aXN0JywgWzg3MDhdXSwgWyduZXhpc3RzJywgWzg3MDhdXSwgWydOZnInLCBbMTIwMDgxXV0sIFsnbmZyJywgWzEyMDEwN11dLCBbJ25nRScsIFs4ODA3LCA4MjRdXSwgWyduZ2UnLCBbODgxN11dLCBbJ25nZXEnLCBbODgxN11dLCBbJ25nZXFxJywgWzg4MDcsIDgyNF1dLCBbJ25nZXFzbGFudCcsIFsxMDg3OCwgODI0XV0sIFsnbmdlcycsIFsxMDg3OCwgODI0XV0sIFsnbkdnJywgWzg5MjEsIDgyNF1dLCBbJ25nc2ltJywgWzg4MjFdXSwgWyduR3QnLCBbODgxMSwgODQwMl1dLCBbJ25ndCcsIFs4ODE1XV0sIFsnbmd0cicsIFs4ODE1XV0sIFsnbkd0dicsIFs4ODExLCA4MjRdXSwgWyduaGFycicsIFs4NjIyXV0sIFsnbmhBcnInLCBbODY1NF1dLCBbJ25ocGFyJywgWzEwOTk0XV0sIFsnbmknLCBbODcxNV1dLCBbJ25pcycsIFs4OTU2XV0sIFsnbmlzZCcsIFs4OTU0XV0sIFsnbml2JywgWzg3MTVdXSwgWydOSmN5JywgWzEwMzRdXSwgWyduamN5JywgWzExMTRdXSwgWydubGFycicsIFs4NjAyXV0sIFsnbmxBcnInLCBbODY1M11dLCBbJ25sZHInLCBbODIyOV1dLCBbJ25sRScsIFs4ODA2LCA4MjRdXSwgWydubGUnLCBbODgxNl1dLCBbJ25sZWZ0YXJyb3cnLCBbODYwMl1dLCBbJ25MZWZ0YXJyb3cnLCBbODY1M11dLCBbJ25sZWZ0cmlnaHRhcnJvdycsIFs4NjIyXV0sIFsnbkxlZnRyaWdodGFycm93JywgWzg2NTRdXSwgWydubGVxJywgWzg4MTZdXSwgWydubGVxcScsIFs4ODA2LCA4MjRdXSwgWydubGVxc2xhbnQnLCBbMTA4NzcsIDgyNF1dLCBbJ25sZXMnLCBbMTA4NzcsIDgyNF1dLCBbJ25sZXNzJywgWzg4MTRdXSwgWyduTGwnLCBbODkyMCwgODI0XV0sIFsnbmxzaW0nLCBbODgyMF1dLCBbJ25MdCcsIFs4ODEwLCA4NDAyXV0sIFsnbmx0JywgWzg4MTRdXSwgWydubHRyaScsIFs4OTM4XV0sIFsnbmx0cmllJywgWzg5NDBdXSwgWyduTHR2JywgWzg4MTAsIDgyNF1dLCBbJ25taWQnLCBbODc0MF1dLCBbJ05vQnJlYWsnLCBbODI4OF1dLCBbJ05vbkJyZWFraW5nU3BhY2UnLCBbMTYwXV0sIFsnbm9wZicsIFsxMjAxNTldXSwgWydOb3BmJywgWzg0NjldXSwgWydOb3QnLCBbMTA5ODhdXSwgWydub3QnLCBbMTcyXV0sIFsnTm90Q29uZ3J1ZW50JywgWzg4MDJdXSwgWydOb3RDdXBDYXAnLCBbODgxM11dLCBbJ05vdERvdWJsZVZlcnRpY2FsQmFyJywgWzg3NDJdXSwgWydOb3RFbGVtZW50JywgWzg3MTNdXSwgWydOb3RFcXVhbCcsIFs4ODAwXV0sIFsnTm90RXF1YWxUaWxkZScsIFs4NzcwLCA4MjRdXSwgWydOb3RFeGlzdHMnLCBbODcwOF1dLCBbJ05vdEdyZWF0ZXInLCBbODgxNV1dLCBbJ05vdEdyZWF0ZXJFcXVhbCcsIFs4ODE3XV0sIFsnTm90R3JlYXRlckZ1bGxFcXVhbCcsIFs4ODA3LCA4MjRdXSwgWydOb3RHcmVhdGVyR3JlYXRlcicsIFs4ODExLCA4MjRdXSwgWydOb3RHcmVhdGVyTGVzcycsIFs4ODI1XV0sIFsnTm90R3JlYXRlclNsYW50RXF1YWwnLCBbMTA4NzgsIDgyNF1dLCBbJ05vdEdyZWF0ZXJUaWxkZScsIFs4ODIxXV0sIFsnTm90SHVtcERvd25IdW1wJywgWzg3ODIsIDgyNF1dLCBbJ05vdEh1bXBFcXVhbCcsIFs4NzgzLCA4MjRdXSwgWydub3RpbicsIFs4NzEzXV0sIFsnbm90aW5kb3QnLCBbODk0OSwgODI0XV0sIFsnbm90aW5FJywgWzg5NTMsIDgyNF1dLCBbJ25vdGludmEnLCBbODcxM11dLCBbJ25vdGludmInLCBbODk1MV1dLCBbJ25vdGludmMnLCBbODk1MF1dLCBbJ05vdExlZnRUcmlhbmdsZUJhcicsIFsxMDcwMywgODI0XV0sIFsnTm90TGVmdFRyaWFuZ2xlJywgWzg5MzhdXSwgWydOb3RMZWZ0VHJpYW5nbGVFcXVhbCcsIFs4OTQwXV0sIFsnTm90TGVzcycsIFs4ODE0XV0sIFsnTm90TGVzc0VxdWFsJywgWzg4MTZdXSwgWydOb3RMZXNzR3JlYXRlcicsIFs4ODI0XV0sIFsnTm90TGVzc0xlc3MnLCBbODgxMCwgODI0XV0sIFsnTm90TGVzc1NsYW50RXF1YWwnLCBbMTA4NzcsIDgyNF1dLCBbJ05vdExlc3NUaWxkZScsIFs4ODIwXV0sIFsnTm90TmVzdGVkR3JlYXRlckdyZWF0ZXInLCBbMTA5MTQsIDgyNF1dLCBbJ05vdE5lc3RlZExlc3NMZXNzJywgWzEwOTEzLCA4MjRdXSwgWydub3RuaScsIFs4NzE2XV0sIFsnbm90bml2YScsIFs4NzE2XV0sIFsnbm90bml2YicsIFs4OTU4XV0sIFsnbm90bml2YycsIFs4OTU3XV0sIFsnTm90UHJlY2VkZXMnLCBbODgzMl1dLCBbJ05vdFByZWNlZGVzRXF1YWwnLCBbMTA5MjcsIDgyNF1dLCBbJ05vdFByZWNlZGVzU2xhbnRFcXVhbCcsIFs4OTI4XV0sIFsnTm90UmV2ZXJzZUVsZW1lbnQnLCBbODcxNl1dLCBbJ05vdFJpZ2h0VHJpYW5nbGVCYXInLCBbMTA3MDQsIDgyNF1dLCBbJ05vdFJpZ2h0VHJpYW5nbGUnLCBbODkzOV1dLCBbJ05vdFJpZ2h0VHJpYW5nbGVFcXVhbCcsIFs4OTQxXV0sIFsnTm90U3F1YXJlU3Vic2V0JywgWzg4NDcsIDgyNF1dLCBbJ05vdFNxdWFyZVN1YnNldEVxdWFsJywgWzg5MzBdXSwgWydOb3RTcXVhcmVTdXBlcnNldCcsIFs4ODQ4LCA4MjRdXSwgWydOb3RTcXVhcmVTdXBlcnNldEVxdWFsJywgWzg5MzFdXSwgWydOb3RTdWJzZXQnLCBbODgzNCwgODQwMl1dLCBbJ05vdFN1YnNldEVxdWFsJywgWzg4NDBdXSwgWydOb3RTdWNjZWVkcycsIFs4ODMzXV0sIFsnTm90U3VjY2VlZHNFcXVhbCcsIFsxMDkyOCwgODI0XV0sIFsnTm90U3VjY2VlZHNTbGFudEVxdWFsJywgWzg5MjldXSwgWydOb3RTdWNjZWVkc1RpbGRlJywgWzg4MzEsIDgyNF1dLCBbJ05vdFN1cGVyc2V0JywgWzg4MzUsIDg0MDJdXSwgWydOb3RTdXBlcnNldEVxdWFsJywgWzg4NDFdXSwgWydOb3RUaWxkZScsIFs4NzY5XV0sIFsnTm90VGlsZGVFcXVhbCcsIFs4NzcyXV0sIFsnTm90VGlsZGVGdWxsRXF1YWwnLCBbODc3NV1dLCBbJ05vdFRpbGRlVGlsZGUnLCBbODc3N11dLCBbJ05vdFZlcnRpY2FsQmFyJywgWzg3NDBdXSwgWyducGFyYWxsZWwnLCBbODc0Ml1dLCBbJ25wYXInLCBbODc0Ml1dLCBbJ25wYXJzbCcsIFsxMTAwNSwgODQyMV1dLCBbJ25wYXJ0JywgWzg3MDYsIDgyNF1dLCBbJ25wb2xpbnQnLCBbMTA3NzJdXSwgWyducHInLCBbODgzMl1dLCBbJ25wcmN1ZScsIFs4OTI4XV0sIFsnbnByZWMnLCBbODgzMl1dLCBbJ25wcmVjZXEnLCBbMTA5MjcsIDgyNF1dLCBbJ25wcmUnLCBbMTA5MjcsIDgyNF1dLCBbJ25yYXJyYycsIFsxMDU0NywgODI0XV0sIFsnbnJhcnInLCBbODYwM11dLCBbJ25yQXJyJywgWzg2NTVdXSwgWyducmFycncnLCBbODYwNSwgODI0XV0sIFsnbnJpZ2h0YXJyb3cnLCBbODYwM11dLCBbJ25SaWdodGFycm93JywgWzg2NTVdXSwgWyducnRyaScsIFs4OTM5XV0sIFsnbnJ0cmllJywgWzg5NDFdXSwgWyduc2MnLCBbODgzM11dLCBbJ25zY2N1ZScsIFs4OTI5XV0sIFsnbnNjZScsIFsxMDkyOCwgODI0XV0sIFsnTnNjcicsIFsxMTk5NzddXSwgWyduc2NyJywgWzEyMDAwM11dLCBbJ25zaG9ydG1pZCcsIFs4NzQwXV0sIFsnbnNob3J0cGFyYWxsZWwnLCBbODc0Ml1dLCBbJ25zaW0nLCBbODc2OV1dLCBbJ25zaW1lJywgWzg3NzJdXSwgWyduc2ltZXEnLCBbODc3Ml1dLCBbJ25zbWlkJywgWzg3NDBdXSwgWyduc3BhcicsIFs4NzQyXV0sIFsnbnNxc3ViZScsIFs4OTMwXV0sIFsnbnNxc3VwZScsIFs4OTMxXV0sIFsnbnN1YicsIFs4ODM2XV0sIFsnbnN1YkUnLCBbMTA5NDksIDgyNF1dLCBbJ25zdWJlJywgWzg4NDBdXSwgWyduc3Vic2V0JywgWzg4MzQsIDg0MDJdXSwgWyduc3Vic2V0ZXEnLCBbODg0MF1dLCBbJ25zdWJzZXRlcXEnLCBbMTA5NDksIDgyNF1dLCBbJ25zdWNjJywgWzg4MzNdXSwgWyduc3VjY2VxJywgWzEwOTI4LCA4MjRdXSwgWyduc3VwJywgWzg4MzddXSwgWyduc3VwRScsIFsxMDk1MCwgODI0XV0sIFsnbnN1cGUnLCBbODg0MV1dLCBbJ25zdXBzZXQnLCBbODgzNSwgODQwMl1dLCBbJ25zdXBzZXRlcScsIFs4ODQxXV0sIFsnbnN1cHNldGVxcScsIFsxMDk1MCwgODI0XV0sIFsnbnRnbCcsIFs4ODI1XV0sIFsnTnRpbGRlJywgWzIwOV1dLCBbJ250aWxkZScsIFsyNDFdXSwgWydudGxnJywgWzg4MjRdXSwgWydudHJpYW5nbGVsZWZ0JywgWzg5MzhdXSwgWydudHJpYW5nbGVsZWZ0ZXEnLCBbODk0MF1dLCBbJ250cmlhbmdsZXJpZ2h0JywgWzg5MzldXSwgWydudHJpYW5nbGVyaWdodGVxJywgWzg5NDFdXSwgWydOdScsIFs5MjVdXSwgWydudScsIFs5NTddXSwgWydudW0nLCBbMzVdXSwgWydudW1lcm8nLCBbODQ3MF1dLCBbJ251bXNwJywgWzgxOTldXSwgWydudmFwJywgWzg3ODEsIDg0MDJdXSwgWydudmRhc2gnLCBbODg3Nl1dLCBbJ252RGFzaCcsIFs4ODc3XV0sIFsnblZkYXNoJywgWzg4NzhdXSwgWyduVkRhc2gnLCBbODg3OV1dLCBbJ252Z2UnLCBbODgwNSwgODQwMl1dLCBbJ252Z3QnLCBbNjIsIDg0MDJdXSwgWydudkhhcnInLCBbMTA1MDBdXSwgWydudmluZmluJywgWzEwNzE4XV0sIFsnbnZsQXJyJywgWzEwNDk4XV0sIFsnbnZsZScsIFs4ODA0LCA4NDAyXV0sIFsnbnZsdCcsIFs2MCwgODQwMl1dLCBbJ252bHRyaWUnLCBbODg4NCwgODQwMl1dLCBbJ252ckFycicsIFsxMDQ5OV1dLCBbJ252cnRyaWUnLCBbODg4NSwgODQwMl1dLCBbJ252c2ltJywgWzg3NjQsIDg0MDJdXSwgWydud2FyaGsnLCBbMTA1MzFdXSwgWydud2FycicsIFs4NTk4XV0sIFsnbndBcnInLCBbODY2Ml1dLCBbJ253YXJyb3cnLCBbODU5OF1dLCBbJ253bmVhcicsIFsxMDUzNV1dLCBbJ09hY3V0ZScsIFsyMTFdXSwgWydvYWN1dGUnLCBbMjQzXV0sIFsnb2FzdCcsIFs4ODU5XV0sIFsnT2NpcmMnLCBbMjEyXV0sIFsnb2NpcmMnLCBbMjQ0XV0sIFsnb2NpcicsIFs4ODU4XV0sIFsnT2N5JywgWzEwNTRdXSwgWydvY3knLCBbMTA4Nl1dLCBbJ29kYXNoJywgWzg4NjFdXSwgWydPZGJsYWMnLCBbMzM2XV0sIFsnb2RibGFjJywgWzMzN11dLCBbJ29kaXYnLCBbMTA4MDhdXSwgWydvZG90JywgWzg4NTddXSwgWydvZHNvbGQnLCBbMTA2ODRdXSwgWydPRWxpZycsIFszMzhdXSwgWydvZWxpZycsIFszMzldXSwgWydvZmNpcicsIFsxMDY4N11dLCBbJ09mcicsIFsxMjAwODJdXSwgWydvZnInLCBbMTIwMTA4XV0sIFsnb2dvbicsIFs3MzFdXSwgWydPZ3JhdmUnLCBbMjEwXV0sIFsnb2dyYXZlJywgWzI0Ml1dLCBbJ29ndCcsIFsxMDY4OV1dLCBbJ29oYmFyJywgWzEwNjc3XV0sIFsnb2htJywgWzkzN11dLCBbJ29pbnQnLCBbODc1MF1dLCBbJ29sYXJyJywgWzg2MzRdXSwgWydvbGNpcicsIFsxMDY4Nl1dLCBbJ29sY3Jvc3MnLCBbMTA2ODNdXSwgWydvbGluZScsIFs4MjU0XV0sIFsnb2x0JywgWzEwNjg4XV0sIFsnT21hY3InLCBbMzMyXV0sIFsnb21hY3InLCBbMzMzXV0sIFsnT21lZ2EnLCBbOTM3XV0sIFsnb21lZ2EnLCBbOTY5XV0sIFsnT21pY3JvbicsIFs5MjddXSwgWydvbWljcm9uJywgWzk1OV1dLCBbJ29taWQnLCBbMTA2NzhdXSwgWydvbWludXMnLCBbODg1NF1dLCBbJ09vcGYnLCBbMTIwMTM0XV0sIFsnb29wZicsIFsxMjAxNjBdXSwgWydvcGFyJywgWzEwNjc5XV0sIFsnT3BlbkN1cmx5RG91YmxlUXVvdGUnLCBbODIyMF1dLCBbJ09wZW5DdXJseVF1b3RlJywgWzgyMTZdXSwgWydvcGVycCcsIFsxMDY4MV1dLCBbJ29wbHVzJywgWzg4NTNdXSwgWydvcmFycicsIFs4NjM1XV0sIFsnT3InLCBbMTA4MzZdXSwgWydvcicsIFs4NzQ0XV0sIFsnb3JkJywgWzEwODQ1XV0sIFsnb3JkZXInLCBbODUwMF1dLCBbJ29yZGVyb2YnLCBbODUwMF1dLCBbJ29yZGYnLCBbMTcwXV0sIFsnb3JkbScsIFsxODZdXSwgWydvcmlnb2YnLCBbODg4Nl1dLCBbJ29yb3InLCBbMTA4MzhdXSwgWydvcnNsb3BlJywgWzEwODM5XV0sIFsnb3J2JywgWzEwODQzXV0sIFsnb1MnLCBbOTQxNl1dLCBbJ09zY3InLCBbMTE5OTc4XV0sIFsnb3NjcicsIFs4NTAwXV0sIFsnT3NsYXNoJywgWzIxNl1dLCBbJ29zbGFzaCcsIFsyNDhdXSwgWydvc29sJywgWzg4NTZdXSwgWydPdGlsZGUnLCBbMjEzXV0sIFsnb3RpbGRlJywgWzI0NV1dLCBbJ290aW1lc2FzJywgWzEwODA2XV0sIFsnT3RpbWVzJywgWzEwODA3XV0sIFsnb3RpbWVzJywgWzg4NTVdXSwgWydPdW1sJywgWzIxNF1dLCBbJ291bWwnLCBbMjQ2XV0sIFsnb3ZiYXInLCBbOTAyMV1dLCBbJ092ZXJCYXInLCBbODI1NF1dLCBbJ092ZXJCcmFjZScsIFs5MTgyXV0sIFsnT3ZlckJyYWNrZXQnLCBbOTE0MF1dLCBbJ092ZXJQYXJlbnRoZXNpcycsIFs5MTgwXV0sIFsncGFyYScsIFsxODJdXSwgWydwYXJhbGxlbCcsIFs4NzQxXV0sIFsncGFyJywgWzg3NDFdXSwgWydwYXJzaW0nLCBbMTA5OTVdXSwgWydwYXJzbCcsIFsxMTAwNV1dLCBbJ3BhcnQnLCBbODcwNl1dLCBbJ1BhcnRpYWxEJywgWzg3MDZdXSwgWydQY3knLCBbMTA1NV1dLCBbJ3BjeScsIFsxMDg3XV0sIFsncGVyY250JywgWzM3XV0sIFsncGVyaW9kJywgWzQ2XV0sIFsncGVybWlsJywgWzgyNDBdXSwgWydwZXJwJywgWzg4NjldXSwgWydwZXJ0ZW5rJywgWzgyNDFdXSwgWydQZnInLCBbMTIwMDgzXV0sIFsncGZyJywgWzEyMDEwOV1dLCBbJ1BoaScsIFs5MzRdXSwgWydwaGknLCBbOTY2XV0sIFsncGhpdicsIFs5ODFdXSwgWydwaG1tYXQnLCBbODQ5OV1dLCBbJ3Bob25lJywgWzk3NDJdXSwgWydQaScsIFs5MjhdXSwgWydwaScsIFs5NjBdXSwgWydwaXRjaGZvcmsnLCBbODkxNl1dLCBbJ3BpdicsIFs5ODJdXSwgWydwbGFuY2snLCBbODQ2M11dLCBbJ3BsYW5ja2gnLCBbODQ2Ml1dLCBbJ3BsYW5rdicsIFs4NDYzXV0sIFsncGx1c2FjaXInLCBbMTA3ODddXSwgWydwbHVzYicsIFs4ODYyXV0sIFsncGx1c2NpcicsIFsxMDc4Nl1dLCBbJ3BsdXMnLCBbNDNdXSwgWydwbHVzZG8nLCBbODcyNF1dLCBbJ3BsdXNkdScsIFsxMDc4OV1dLCBbJ3BsdXNlJywgWzEwODY2XV0sIFsnUGx1c01pbnVzJywgWzE3N11dLCBbJ3BsdXNtbicsIFsxNzddXSwgWydwbHVzc2ltJywgWzEwNzkwXV0sIFsncGx1c3R3bycsIFsxMDc5MV1dLCBbJ3BtJywgWzE3N11dLCBbJ1BvaW5jYXJlcGxhbmUnLCBbODQ2MF1dLCBbJ3BvaW50aW50JywgWzEwNzczXV0sIFsncG9wZicsIFsxMjAxNjFdXSwgWydQb3BmJywgWzg0NzNdXSwgWydwb3VuZCcsIFsxNjNdXSwgWydwcmFwJywgWzEwOTM1XV0sIFsnUHInLCBbMTA5MzldXSwgWydwcicsIFs4ODI2XV0sIFsncHJjdWUnLCBbODgyOF1dLCBbJ3ByZWNhcHByb3gnLCBbMTA5MzVdXSwgWydwcmVjJywgWzg4MjZdXSwgWydwcmVjY3VybHllcScsIFs4ODI4XV0sIFsnUHJlY2VkZXMnLCBbODgyNl1dLCBbJ1ByZWNlZGVzRXF1YWwnLCBbMTA5MjddXSwgWydQcmVjZWRlc1NsYW50RXF1YWwnLCBbODgyOF1dLCBbJ1ByZWNlZGVzVGlsZGUnLCBbODgzMF1dLCBbJ3ByZWNlcScsIFsxMDkyN11dLCBbJ3ByZWNuYXBwcm94JywgWzEwOTM3XV0sIFsncHJlY25lcXEnLCBbMTA5MzNdXSwgWydwcmVjbnNpbScsIFs4OTM2XV0sIFsncHJlJywgWzEwOTI3XV0sIFsncHJFJywgWzEwOTMxXV0sIFsncHJlY3NpbScsIFs4ODMwXV0sIFsncHJpbWUnLCBbODI0Ml1dLCBbJ1ByaW1lJywgWzgyNDNdXSwgWydwcmltZXMnLCBbODQ3M11dLCBbJ3BybmFwJywgWzEwOTM3XV0sIFsncHJuRScsIFsxMDkzM11dLCBbJ3BybnNpbScsIFs4OTM2XV0sIFsncHJvZCcsIFs4NzE5XV0sIFsnUHJvZHVjdCcsIFs4NzE5XV0sIFsncHJvZmFsYXInLCBbOTAwNl1dLCBbJ3Byb2ZsaW5lJywgWzg5NzhdXSwgWydwcm9mc3VyZicsIFs4OTc5XV0sIFsncHJvcCcsIFs4NzMzXV0sIFsnUHJvcG9ydGlvbmFsJywgWzg3MzNdXSwgWydQcm9wb3J0aW9uJywgWzg3NTldXSwgWydwcm9wdG8nLCBbODczM11dLCBbJ3Byc2ltJywgWzg4MzBdXSwgWydwcnVyZWwnLCBbODg4MF1dLCBbJ1BzY3InLCBbMTE5OTc5XV0sIFsncHNjcicsIFsxMjAwMDVdXSwgWydQc2knLCBbOTM2XV0sIFsncHNpJywgWzk2OF1dLCBbJ3B1bmNzcCcsIFs4MjAwXV0sIFsnUWZyJywgWzEyMDA4NF1dLCBbJ3FmcicsIFsxMjAxMTBdXSwgWydxaW50JywgWzEwNzY0XV0sIFsncW9wZicsIFsxMjAxNjJdXSwgWydRb3BmJywgWzg0NzRdXSwgWydxcHJpbWUnLCBbODI3OV1dLCBbJ1FzY3InLCBbMTE5OTgwXV0sIFsncXNjcicsIFsxMjAwMDZdXSwgWydxdWF0ZXJuaW9ucycsIFs4NDYxXV0sIFsncXVhdGludCcsIFsxMDc3NF1dLCBbJ3F1ZXN0JywgWzYzXV0sIFsncXVlc3RlcScsIFs4Nzk5XV0sIFsncXVvdCcsIFszNF1dLCBbJ1FVT1QnLCBbMzRdXSwgWydyQWFycicsIFs4NjY3XV0sIFsncmFjZScsIFs4NzY1LCA4MTddXSwgWydSYWN1dGUnLCBbMzQwXV0sIFsncmFjdXRlJywgWzM0MV1dLCBbJ3JhZGljJywgWzg3MzBdXSwgWydyYWVtcHR5dicsIFsxMDY3NV1dLCBbJ3JhbmcnLCBbMTAyMTddXSwgWydSYW5nJywgWzEwMjE5XV0sIFsncmFuZ2QnLCBbMTA2NDJdXSwgWydyYW5nZScsIFsxMDY2MV1dLCBbJ3JhbmdsZScsIFsxMDIxN11dLCBbJ3JhcXVvJywgWzE4N11dLCBbJ3JhcnJhcCcsIFsxMDYxM11dLCBbJ3JhcnJiJywgWzg2NzddXSwgWydyYXJyYmZzJywgWzEwNTI4XV0sIFsncmFycmMnLCBbMTA1NDddXSwgWydyYXJyJywgWzg1OTRdXSwgWydSYXJyJywgWzg2MDhdXSwgWydyQXJyJywgWzg2NThdXSwgWydyYXJyZnMnLCBbMTA1MjZdXSwgWydyYXJyaGsnLCBbODYxOF1dLCBbJ3JhcnJscCcsIFs4NjIwXV0sIFsncmFycnBsJywgWzEwNTY1XV0sIFsncmFycnNpbScsIFsxMDYxMl1dLCBbJ1JhcnJ0bCcsIFsxMDUxOF1dLCBbJ3JhcnJ0bCcsIFs4NjExXV0sIFsncmFycncnLCBbODYwNV1dLCBbJ3JhdGFpbCcsIFsxMDUyMl1dLCBbJ3JBdGFpbCcsIFsxMDUyNF1dLCBbJ3JhdGlvJywgWzg3NThdXSwgWydyYXRpb25hbHMnLCBbODQ3NF1dLCBbJ3JiYXJyJywgWzEwNTA5XV0sIFsnckJhcnInLCBbMTA1MTFdXSwgWydSQmFycicsIFsxMDUxMl1dLCBbJ3JiYnJrJywgWzEwMDk5XV0sIFsncmJyYWNlJywgWzEyNV1dLCBbJ3JicmFjaycsIFs5M11dLCBbJ3JicmtlJywgWzEwNjM2XV0sIFsncmJya3NsZCcsIFsxMDYzOF1dLCBbJ3JicmtzbHUnLCBbMTA2NDBdXSwgWydSY2Fyb24nLCBbMzQ0XV0sIFsncmNhcm9uJywgWzM0NV1dLCBbJ1JjZWRpbCcsIFszNDJdXSwgWydyY2VkaWwnLCBbMzQzXV0sIFsncmNlaWwnLCBbODk2OV1dLCBbJ3JjdWInLCBbMTI1XV0sIFsnUmN5JywgWzEwNTZdXSwgWydyY3knLCBbMTA4OF1dLCBbJ3JkY2EnLCBbMTA1NTFdXSwgWydyZGxkaGFyJywgWzEwNjAxXV0sIFsncmRxdW8nLCBbODIyMV1dLCBbJ3JkcXVvcicsIFs4MjIxXV0sIFsnQ2xvc2VDdXJseURvdWJsZVF1b3RlJywgWzgyMjFdXSwgWydyZHNoJywgWzg2MjddXSwgWydyZWFsJywgWzg0NzZdXSwgWydyZWFsaW5lJywgWzg0NzVdXSwgWydyZWFscGFydCcsIFs4NDc2XV0sIFsncmVhbHMnLCBbODQ3N11dLCBbJ1JlJywgWzg0NzZdXSwgWydyZWN0JywgWzk2NDVdXSwgWydyZWcnLCBbMTc0XV0sIFsnUkVHJywgWzE3NF1dLCBbJ1JldmVyc2VFbGVtZW50JywgWzg3MTVdXSwgWydSZXZlcnNlRXF1aWxpYnJpdW0nLCBbODY1MV1dLCBbJ1JldmVyc2VVcEVxdWlsaWJyaXVtJywgWzEwNjA3XV0sIFsncmZpc2h0JywgWzEwNjIxXV0sIFsncmZsb29yJywgWzg5NzFdXSwgWydyZnInLCBbMTIwMTExXV0sIFsnUmZyJywgWzg0NzZdXSwgWydySGFyJywgWzEwNTk2XV0sIFsncmhhcmQnLCBbODY0MV1dLCBbJ3JoYXJ1JywgWzg2NDBdXSwgWydyaGFydWwnLCBbMTA2MDRdXSwgWydSaG8nLCBbOTI5XV0sIFsncmhvJywgWzk2MV1dLCBbJ3Job3YnLCBbMTAwOV1dLCBbJ1JpZ2h0QW5nbGVCcmFja2V0JywgWzEwMjE3XV0sIFsnUmlnaHRBcnJvd0JhcicsIFs4Njc3XV0sIFsncmlnaHRhcnJvdycsIFs4NTk0XV0sIFsnUmlnaHRBcnJvdycsIFs4NTk0XV0sIFsnUmlnaHRhcnJvdycsIFs4NjU4XV0sIFsnUmlnaHRBcnJvd0xlZnRBcnJvdycsIFs4NjQ0XV0sIFsncmlnaHRhcnJvd3RhaWwnLCBbODYxMV1dLCBbJ1JpZ2h0Q2VpbGluZycsIFs4OTY5XV0sIFsnUmlnaHREb3VibGVCcmFja2V0JywgWzEwMjE1XV0sIFsnUmlnaHREb3duVGVlVmVjdG9yJywgWzEwNTg5XV0sIFsnUmlnaHREb3duVmVjdG9yQmFyJywgWzEwNTgxXV0sIFsnUmlnaHREb3duVmVjdG9yJywgWzg2NDJdXSwgWydSaWdodEZsb29yJywgWzg5NzFdXSwgWydyaWdodGhhcnBvb25kb3duJywgWzg2NDFdXSwgWydyaWdodGhhcnBvb251cCcsIFs4NjQwXV0sIFsncmlnaHRsZWZ0YXJyb3dzJywgWzg2NDRdXSwgWydyaWdodGxlZnRoYXJwb29ucycsIFs4NjUyXV0sIFsncmlnaHRyaWdodGFycm93cycsIFs4NjQ5XV0sIFsncmlnaHRzcXVpZ2Fycm93JywgWzg2MDVdXSwgWydSaWdodFRlZUFycm93JywgWzg2MTRdXSwgWydSaWdodFRlZScsIFs4ODY2XV0sIFsnUmlnaHRUZWVWZWN0b3InLCBbMTA1ODddXSwgWydyaWdodHRocmVldGltZXMnLCBbODkwOF1dLCBbJ1JpZ2h0VHJpYW5nbGVCYXInLCBbMTA3MDRdXSwgWydSaWdodFRyaWFuZ2xlJywgWzg4ODNdXSwgWydSaWdodFRyaWFuZ2xlRXF1YWwnLCBbODg4NV1dLCBbJ1JpZ2h0VXBEb3duVmVjdG9yJywgWzEwNTc1XV0sIFsnUmlnaHRVcFRlZVZlY3RvcicsIFsxMDU4OF1dLCBbJ1JpZ2h0VXBWZWN0b3JCYXInLCBbMTA1ODBdXSwgWydSaWdodFVwVmVjdG9yJywgWzg2MzhdXSwgWydSaWdodFZlY3RvckJhcicsIFsxMDU3OV1dLCBbJ1JpZ2h0VmVjdG9yJywgWzg2NDBdXSwgWydyaW5nJywgWzczMF1dLCBbJ3Jpc2luZ2RvdHNlcScsIFs4Nzg3XV0sIFsncmxhcnInLCBbODY0NF1dLCBbJ3JsaGFyJywgWzg2NTJdXSwgWydybG0nLCBbODIwN11dLCBbJ3Jtb3VzdGFjaGUnLCBbOTEzN11dLCBbJ3Jtb3VzdCcsIFs5MTM3XV0sIFsncm5taWQnLCBbMTA5OTBdXSwgWydyb2FuZycsIFsxMDIyMV1dLCBbJ3JvYXJyJywgWzg3MDJdXSwgWydyb2JyaycsIFsxMDIxNV1dLCBbJ3JvcGFyJywgWzEwNjMwXV0sIFsncm9wZicsIFsxMjAxNjNdXSwgWydSb3BmJywgWzg0NzddXSwgWydyb3BsdXMnLCBbMTA3OThdXSwgWydyb3RpbWVzJywgWzEwODA1XV0sIFsnUm91bmRJbXBsaWVzJywgWzEwNjA4XV0sIFsncnBhcicsIFs0MV1dLCBbJ3JwYXJndCcsIFsxMDY0NF1dLCBbJ3JwcG9saW50JywgWzEwNzcwXV0sIFsncnJhcnInLCBbODY0OV1dLCBbJ1JyaWdodGFycm93JywgWzg2NjddXSwgWydyc2FxdW8nLCBbODI1MF1dLCBbJ3JzY3InLCBbMTIwMDA3XV0sIFsnUnNjcicsIFs4NDc1XV0sIFsncnNoJywgWzg2MjVdXSwgWydSc2gnLCBbODYyNV1dLCBbJ3JzcWInLCBbOTNdXSwgWydyc3F1bycsIFs4MjE3XV0sIFsncnNxdW9yJywgWzgyMTddXSwgWydDbG9zZUN1cmx5UXVvdGUnLCBbODIxN11dLCBbJ3J0aHJlZScsIFs4OTA4XV0sIFsncnRpbWVzJywgWzg5MDZdXSwgWydydHJpJywgWzk2NTddXSwgWydydHJpZScsIFs4ODg1XV0sIFsncnRyaWYnLCBbOTY1Nl1dLCBbJ3J0cmlsdHJpJywgWzEwNzAyXV0sIFsnUnVsZURlbGF5ZWQnLCBbMTA3NDBdXSwgWydydWx1aGFyJywgWzEwNjAwXV0sIFsncngnLCBbODQ3OF1dLCBbJ1NhY3V0ZScsIFszNDZdXSwgWydzYWN1dGUnLCBbMzQ3XV0sIFsnc2JxdW8nLCBbODIxOF1dLCBbJ3NjYXAnLCBbMTA5MzZdXSwgWydTY2Fyb24nLCBbMzUyXV0sIFsnc2Nhcm9uJywgWzM1M11dLCBbJ1NjJywgWzEwOTQwXV0sIFsnc2MnLCBbODgyN11dLCBbJ3NjY3VlJywgWzg4MjldXSwgWydzY2UnLCBbMTA5MjhdXSwgWydzY0UnLCBbMTA5MzJdXSwgWydTY2VkaWwnLCBbMzUwXV0sIFsnc2NlZGlsJywgWzM1MV1dLCBbJ1NjaXJjJywgWzM0OF1dLCBbJ3NjaXJjJywgWzM0OV1dLCBbJ3NjbmFwJywgWzEwOTM4XV0sIFsnc2NuRScsIFsxMDkzNF1dLCBbJ3NjbnNpbScsIFs4OTM3XV0sIFsnc2Nwb2xpbnQnLCBbMTA3NzFdXSwgWydzY3NpbScsIFs4ODMxXV0sIFsnU2N5JywgWzEwNTddXSwgWydzY3knLCBbMTA4OV1dLCBbJ3Nkb3RiJywgWzg4NjVdXSwgWydzZG90JywgWzg5MDFdXSwgWydzZG90ZScsIFsxMDg1NF1dLCBbJ3NlYXJoaycsIFsxMDUzM11dLCBbJ3NlYXJyJywgWzg2MDBdXSwgWydzZUFycicsIFs4NjY0XV0sIFsnc2VhcnJvdycsIFs4NjAwXV0sIFsnc2VjdCcsIFsxNjddXSwgWydzZW1pJywgWzU5XV0sIFsnc2Vzd2FyJywgWzEwNTM3XV0sIFsnc2V0bWludXMnLCBbODcyNl1dLCBbJ3NldG1uJywgWzg3MjZdXSwgWydzZXh0JywgWzEwMDM4XV0sIFsnU2ZyJywgWzEyMDA4Nl1dLCBbJ3NmcicsIFsxMjAxMTJdXSwgWydzZnJvd24nLCBbODk5NF1dLCBbJ3NoYXJwJywgWzk4MzldXSwgWydTSENIY3knLCBbMTA2NV1dLCBbJ3NoY2hjeScsIFsxMDk3XV0sIFsnU0hjeScsIFsxMDY0XV0sIFsnc2hjeScsIFsxMDk2XV0sIFsnU2hvcnREb3duQXJyb3cnLCBbODU5NV1dLCBbJ1Nob3J0TGVmdEFycm93JywgWzg1OTJdXSwgWydzaG9ydG1pZCcsIFs4NzM5XV0sIFsnc2hvcnRwYXJhbGxlbCcsIFs4NzQxXV0sIFsnU2hvcnRSaWdodEFycm93JywgWzg1OTRdXSwgWydTaG9ydFVwQXJyb3cnLCBbODU5M11dLCBbJ3NoeScsIFsxNzNdXSwgWydTaWdtYScsIFs5MzFdXSwgWydzaWdtYScsIFs5NjNdXSwgWydzaWdtYWYnLCBbOTYyXV0sIFsnc2lnbWF2JywgWzk2Ml1dLCBbJ3NpbScsIFs4NzY0XV0sIFsnc2ltZG90JywgWzEwODU4XV0sIFsnc2ltZScsIFs4NzcxXV0sIFsnc2ltZXEnLCBbODc3MV1dLCBbJ3NpbWcnLCBbMTA5MTBdXSwgWydzaW1nRScsIFsxMDkxMl1dLCBbJ3NpbWwnLCBbMTA5MDldXSwgWydzaW1sRScsIFsxMDkxMV1dLCBbJ3NpbW5lJywgWzg3NzRdXSwgWydzaW1wbHVzJywgWzEwNzg4XV0sIFsnc2ltcmFycicsIFsxMDYxMF1dLCBbJ3NsYXJyJywgWzg1OTJdXSwgWydTbWFsbENpcmNsZScsIFs4NzI4XV0sIFsnc21hbGxzZXRtaW51cycsIFs4NzI2XV0sIFsnc21hc2hwJywgWzEwODAzXV0sIFsnc21lcGFyc2wnLCBbMTA3MjRdXSwgWydzbWlkJywgWzg3MzldXSwgWydzbWlsZScsIFs4OTk1XV0sIFsnc210JywgWzEwOTIyXV0sIFsnc210ZScsIFsxMDkyNF1dLCBbJ3NtdGVzJywgWzEwOTI0LCA2NTAyNF1dLCBbJ1NPRlRjeScsIFsxMDY4XV0sIFsnc29mdGN5JywgWzExMDBdXSwgWydzb2xiYXInLCBbOTAyM11dLCBbJ3NvbGInLCBbMTA2OTJdXSwgWydzb2wnLCBbNDddXSwgWydTb3BmJywgWzEyMDEzOF1dLCBbJ3NvcGYnLCBbMTIwMTY0XV0sIFsnc3BhZGVzJywgWzk4MjRdXSwgWydzcGFkZXN1aXQnLCBbOTgyNF1dLCBbJ3NwYXInLCBbODc0MV1dLCBbJ3NxY2FwJywgWzg4NTFdXSwgWydzcWNhcHMnLCBbODg1MSwgNjUwMjRdXSwgWydzcWN1cCcsIFs4ODUyXV0sIFsnc3FjdXBzJywgWzg4NTIsIDY1MDI0XV0sIFsnU3FydCcsIFs4NzMwXV0sIFsnc3FzdWInLCBbODg0N11dLCBbJ3Nxc3ViZScsIFs4ODQ5XV0sIFsnc3FzdWJzZXQnLCBbODg0N11dLCBbJ3Nxc3Vic2V0ZXEnLCBbODg0OV1dLCBbJ3Nxc3VwJywgWzg4NDhdXSwgWydzcXN1cGUnLCBbODg1MF1dLCBbJ3Nxc3Vwc2V0JywgWzg4NDhdXSwgWydzcXN1cHNldGVxJywgWzg4NTBdXSwgWydzcXVhcmUnLCBbOTYzM11dLCBbJ1NxdWFyZScsIFs5NjMzXV0sIFsnU3F1YXJlSW50ZXJzZWN0aW9uJywgWzg4NTFdXSwgWydTcXVhcmVTdWJzZXQnLCBbODg0N11dLCBbJ1NxdWFyZVN1YnNldEVxdWFsJywgWzg4NDldXSwgWydTcXVhcmVTdXBlcnNldCcsIFs4ODQ4XV0sIFsnU3F1YXJlU3VwZXJzZXRFcXVhbCcsIFs4ODUwXV0sIFsnU3F1YXJlVW5pb24nLCBbODg1Ml1dLCBbJ3NxdWFyZicsIFs5NjQyXV0sIFsnc3F1JywgWzk2MzNdXSwgWydzcXVmJywgWzk2NDJdXSwgWydzcmFycicsIFs4NTk0XV0sIFsnU3NjcicsIFsxMTk5ODJdXSwgWydzc2NyJywgWzEyMDAwOF1dLCBbJ3NzZXRtbicsIFs4NzI2XV0sIFsnc3NtaWxlJywgWzg5OTVdXSwgWydzc3RhcmYnLCBbODkwMl1dLCBbJ1N0YXInLCBbODkwMl1dLCBbJ3N0YXInLCBbOTczNF1dLCBbJ3N0YXJmJywgWzk3MzNdXSwgWydzdHJhaWdodGVwc2lsb24nLCBbMTAxM11dLCBbJ3N0cmFpZ2h0cGhpJywgWzk4MV1dLCBbJ3N0cm5zJywgWzE3NV1dLCBbJ3N1YicsIFs4ODM0XV0sIFsnU3ViJywgWzg5MTJdXSwgWydzdWJkb3QnLCBbMTA5NDFdXSwgWydzdWJFJywgWzEwOTQ5XV0sIFsnc3ViZScsIFs4ODM4XV0sIFsnc3ViZWRvdCcsIFsxMDk0N11dLCBbJ3N1Ym11bHQnLCBbMTA5NDVdXSwgWydzdWJuRScsIFsxMDk1NV1dLCBbJ3N1Ym5lJywgWzg4NDJdXSwgWydzdWJwbHVzJywgWzEwOTQzXV0sIFsnc3VicmFycicsIFsxMDYxN11dLCBbJ3N1YnNldCcsIFs4ODM0XV0sIFsnU3Vic2V0JywgWzg5MTJdXSwgWydzdWJzZXRlcScsIFs4ODM4XV0sIFsnc3Vic2V0ZXFxJywgWzEwOTQ5XV0sIFsnU3Vic2V0RXF1YWwnLCBbODgzOF1dLCBbJ3N1YnNldG5lcScsIFs4ODQyXV0sIFsnc3Vic2V0bmVxcScsIFsxMDk1NV1dLCBbJ3N1YnNpbScsIFsxMDk1MV1dLCBbJ3N1YnN1YicsIFsxMDk2NV1dLCBbJ3N1YnN1cCcsIFsxMDk2M11dLCBbJ3N1Y2NhcHByb3gnLCBbMTA5MzZdXSwgWydzdWNjJywgWzg4MjddXSwgWydzdWNjY3VybHllcScsIFs4ODI5XV0sIFsnU3VjY2VlZHMnLCBbODgyN11dLCBbJ1N1Y2NlZWRzRXF1YWwnLCBbMTA5MjhdXSwgWydTdWNjZWVkc1NsYW50RXF1YWwnLCBbODgyOV1dLCBbJ1N1Y2NlZWRzVGlsZGUnLCBbODgzMV1dLCBbJ3N1Y2NlcScsIFsxMDkyOF1dLCBbJ3N1Y2NuYXBwcm94JywgWzEwOTM4XV0sIFsnc3VjY25lcXEnLCBbMTA5MzRdXSwgWydzdWNjbnNpbScsIFs4OTM3XV0sIFsnc3VjY3NpbScsIFs4ODMxXV0sIFsnU3VjaFRoYXQnLCBbODcxNV1dLCBbJ3N1bScsIFs4NzIxXV0sIFsnU3VtJywgWzg3MjFdXSwgWydzdW5nJywgWzk4MzRdXSwgWydzdXAxJywgWzE4NV1dLCBbJ3N1cDInLCBbMTc4XV0sIFsnc3VwMycsIFsxNzldXSwgWydzdXAnLCBbODgzNV1dLCBbJ1N1cCcsIFs4OTEzXV0sIFsnc3VwZG90JywgWzEwOTQyXV0sIFsnc3VwZHN1YicsIFsxMDk2OF1dLCBbJ3N1cEUnLCBbMTA5NTBdXSwgWydzdXBlJywgWzg4MzldXSwgWydzdXBlZG90JywgWzEwOTQ4XV0sIFsnU3VwZXJzZXQnLCBbODgzNV1dLCBbJ1N1cGVyc2V0RXF1YWwnLCBbODgzOV1dLCBbJ3N1cGhzb2wnLCBbMTAxODVdXSwgWydzdXBoc3ViJywgWzEwOTY3XV0sIFsnc3VwbGFycicsIFsxMDYxOV1dLCBbJ3N1cG11bHQnLCBbMTA5NDZdXSwgWydzdXBuRScsIFsxMDk1Nl1dLCBbJ3N1cG5lJywgWzg4NDNdXSwgWydzdXBwbHVzJywgWzEwOTQ0XV0sIFsnc3Vwc2V0JywgWzg4MzVdXSwgWydTdXBzZXQnLCBbODkxM11dLCBbJ3N1cHNldGVxJywgWzg4MzldXSwgWydzdXBzZXRlcXEnLCBbMTA5NTBdXSwgWydzdXBzZXRuZXEnLCBbODg0M11dLCBbJ3N1cHNldG5lcXEnLCBbMTA5NTZdXSwgWydzdXBzaW0nLCBbMTA5NTJdXSwgWydzdXBzdWInLCBbMTA5NjRdXSwgWydzdXBzdXAnLCBbMTA5NjZdXSwgWydzd2FyaGsnLCBbMTA1MzRdXSwgWydzd2FycicsIFs4NjAxXV0sIFsnc3dBcnInLCBbODY2NV1dLCBbJ3N3YXJyb3cnLCBbODYwMV1dLCBbJ3N3bndhcicsIFsxMDUzOF1dLCBbJ3N6bGlnJywgWzIyM11dLCBbJ1RhYicsIFs5XV0sIFsndGFyZ2V0JywgWzg5ODJdXSwgWydUYXUnLCBbOTMyXV0sIFsndGF1JywgWzk2NF1dLCBbJ3RicmsnLCBbOTE0MF1dLCBbJ1RjYXJvbicsIFszNTZdXSwgWyd0Y2Fyb24nLCBbMzU3XV0sIFsnVGNlZGlsJywgWzM1NF1dLCBbJ3RjZWRpbCcsIFszNTVdXSwgWydUY3knLCBbMTA1OF1dLCBbJ3RjeScsIFsxMDkwXV0sIFsndGRvdCcsIFs4NDExXV0sIFsndGVscmVjJywgWzg5ODFdXSwgWydUZnInLCBbMTIwMDg3XV0sIFsndGZyJywgWzEyMDExM11dLCBbJ3RoZXJlNCcsIFs4NzU2XV0sIFsndGhlcmVmb3JlJywgWzg3NTZdXSwgWydUaGVyZWZvcmUnLCBbODc1Nl1dLCBbJ1RoZXRhJywgWzkyMF1dLCBbJ3RoZXRhJywgWzk1Ml1dLCBbJ3RoZXRhc3ltJywgWzk3N11dLCBbJ3RoZXRhdicsIFs5NzddXSwgWyd0aGlja2FwcHJveCcsIFs4Nzc2XV0sIFsndGhpY2tzaW0nLCBbODc2NF1dLCBbJ1RoaWNrU3BhY2UnLCBbODI4NywgODIwMl1dLCBbJ1RoaW5TcGFjZScsIFs4MjAxXV0sIFsndGhpbnNwJywgWzgyMDFdXSwgWyd0aGthcCcsIFs4Nzc2XV0sIFsndGhrc2ltJywgWzg3NjRdXSwgWydUSE9STicsIFsyMjJdXSwgWyd0aG9ybicsIFsyNTRdXSwgWyd0aWxkZScsIFs3MzJdXSwgWydUaWxkZScsIFs4NzY0XV0sIFsnVGlsZGVFcXVhbCcsIFs4NzcxXV0sIFsnVGlsZGVGdWxsRXF1YWwnLCBbODc3M11dLCBbJ1RpbGRlVGlsZGUnLCBbODc3Nl1dLCBbJ3RpbWVzYmFyJywgWzEwODAxXV0sIFsndGltZXNiJywgWzg4NjRdXSwgWyd0aW1lcycsIFsyMTVdXSwgWyd0aW1lc2QnLCBbMTA4MDBdXSwgWyd0aW50JywgWzg3NDldXSwgWyd0b2VhJywgWzEwNTM2XV0sIFsndG9wYm90JywgWzkwMTRdXSwgWyd0b3BjaXInLCBbMTA5OTNdXSwgWyd0b3AnLCBbODg2OF1dLCBbJ1RvcGYnLCBbMTIwMTM5XV0sIFsndG9wZicsIFsxMjAxNjVdXSwgWyd0b3Bmb3JrJywgWzEwOTcwXV0sIFsndG9zYScsIFsxMDUzN11dLCBbJ3RwcmltZScsIFs4MjQ0XV0sIFsndHJhZGUnLCBbODQ4Ml1dLCBbJ1RSQURFJywgWzg0ODJdXSwgWyd0cmlhbmdsZScsIFs5NjUzXV0sIFsndHJpYW5nbGVkb3duJywgWzk2NjNdXSwgWyd0cmlhbmdsZWxlZnQnLCBbOTY2N11dLCBbJ3RyaWFuZ2xlbGVmdGVxJywgWzg4ODRdXSwgWyd0cmlhbmdsZXEnLCBbODc5Nl1dLCBbJ3RyaWFuZ2xlcmlnaHQnLCBbOTY1N11dLCBbJ3RyaWFuZ2xlcmlnaHRlcScsIFs4ODg1XV0sIFsndHJpZG90JywgWzk3MDhdXSwgWyd0cmllJywgWzg3OTZdXSwgWyd0cmltaW51cycsIFsxMDgxMF1dLCBbJ1RyaXBsZURvdCcsIFs4NDExXV0sIFsndHJpcGx1cycsIFsxMDgwOV1dLCBbJ3RyaXNiJywgWzEwNzAxXV0sIFsndHJpdGltZScsIFsxMDgxMV1dLCBbJ3RycGV6aXVtJywgWzkxODZdXSwgWydUc2NyJywgWzExOTk4M11dLCBbJ3RzY3InLCBbMTIwMDA5XV0sIFsnVFNjeScsIFsxMDYyXV0sIFsndHNjeScsIFsxMDk0XV0sIFsnVFNIY3knLCBbMTAzNV1dLCBbJ3RzaGN5JywgWzExMTVdXSwgWydUc3Ryb2snLCBbMzU4XV0sIFsndHN0cm9rJywgWzM1OV1dLCBbJ3R3aXh0JywgWzg4MTJdXSwgWyd0d29oZWFkbGVmdGFycm93JywgWzg2MDZdXSwgWyd0d29oZWFkcmlnaHRhcnJvdycsIFs4NjA4XV0sIFsnVWFjdXRlJywgWzIxOF1dLCBbJ3VhY3V0ZScsIFsyNTBdXSwgWyd1YXJyJywgWzg1OTNdXSwgWydVYXJyJywgWzg2MDddXSwgWyd1QXJyJywgWzg2NTddXSwgWydVYXJyb2NpcicsIFsxMDU2OV1dLCBbJ1VicmN5JywgWzEwMzhdXSwgWyd1YnJjeScsIFsxMTE4XV0sIFsnVWJyZXZlJywgWzM2NF1dLCBbJ3VicmV2ZScsIFszNjVdXSwgWydVY2lyYycsIFsyMTldXSwgWyd1Y2lyYycsIFsyNTFdXSwgWydVY3knLCBbMTA1OV1dLCBbJ3VjeScsIFsxMDkxXV0sIFsndWRhcnInLCBbODY0NV1dLCBbJ1VkYmxhYycsIFszNjhdXSwgWyd1ZGJsYWMnLCBbMzY5XV0sIFsndWRoYXInLCBbMTA2MDZdXSwgWyd1ZmlzaHQnLCBbMTA2MjJdXSwgWydVZnInLCBbMTIwMDg4XV0sIFsndWZyJywgWzEyMDExNF1dLCBbJ1VncmF2ZScsIFsyMTddXSwgWyd1Z3JhdmUnLCBbMjQ5XV0sIFsndUhhcicsIFsxMDU5NV1dLCBbJ3VoYXJsJywgWzg2MzldXSwgWyd1aGFycicsIFs4NjM4XV0sIFsndWhibGsnLCBbOTYwMF1dLCBbJ3VsY29ybicsIFs4OTg4XV0sIFsndWxjb3JuZXInLCBbODk4OF1dLCBbJ3VsY3JvcCcsIFs4OTc1XV0sIFsndWx0cmknLCBbOTcyMF1dLCBbJ1VtYWNyJywgWzM2Ml1dLCBbJ3VtYWNyJywgWzM2M11dLCBbJ3VtbCcsIFsxNjhdXSwgWydVbmRlckJhcicsIFs5NV1dLCBbJ1VuZGVyQnJhY2UnLCBbOTE4M11dLCBbJ1VuZGVyQnJhY2tldCcsIFs5MTQxXV0sIFsnVW5kZXJQYXJlbnRoZXNpcycsIFs5MTgxXV0sIFsnVW5pb24nLCBbODg5OV1dLCBbJ1VuaW9uUGx1cycsIFs4ODQ2XV0sIFsnVW9nb24nLCBbMzcwXV0sIFsndW9nb24nLCBbMzcxXV0sIFsnVW9wZicsIFsxMjAxNDBdXSwgWyd1b3BmJywgWzEyMDE2Nl1dLCBbJ1VwQXJyb3dCYXInLCBbMTA1MTRdXSwgWyd1cGFycm93JywgWzg1OTNdXSwgWydVcEFycm93JywgWzg1OTNdXSwgWydVcGFycm93JywgWzg2NTddXSwgWydVcEFycm93RG93bkFycm93JywgWzg2NDVdXSwgWyd1cGRvd25hcnJvdycsIFs4NTk3XV0sIFsnVXBEb3duQXJyb3cnLCBbODU5N11dLCBbJ1VwZG93bmFycm93JywgWzg2NjFdXSwgWydVcEVxdWlsaWJyaXVtJywgWzEwNjA2XV0sIFsndXBoYXJwb29ubGVmdCcsIFs4NjM5XV0sIFsndXBoYXJwb29ucmlnaHQnLCBbODYzOF1dLCBbJ3VwbHVzJywgWzg4NDZdXSwgWydVcHBlckxlZnRBcnJvdycsIFs4NTk4XV0sIFsnVXBwZXJSaWdodEFycm93JywgWzg1OTldXSwgWyd1cHNpJywgWzk2NV1dLCBbJ1Vwc2knLCBbOTc4XV0sIFsndXBzaWgnLCBbOTc4XV0sIFsnVXBzaWxvbicsIFs5MzNdXSwgWyd1cHNpbG9uJywgWzk2NV1dLCBbJ1VwVGVlQXJyb3cnLCBbODYxM11dLCBbJ1VwVGVlJywgWzg4NjldXSwgWyd1cHVwYXJyb3dzJywgWzg2NDhdXSwgWyd1cmNvcm4nLCBbODk4OV1dLCBbJ3VyY29ybmVyJywgWzg5ODldXSwgWyd1cmNyb3AnLCBbODk3NF1dLCBbJ1VyaW5nJywgWzM2Nl1dLCBbJ3VyaW5nJywgWzM2N11dLCBbJ3VydHJpJywgWzk3MjFdXSwgWydVc2NyJywgWzExOTk4NF1dLCBbJ3VzY3InLCBbMTIwMDEwXV0sIFsndXRkb3QnLCBbODk0NF1dLCBbJ1V0aWxkZScsIFszNjBdXSwgWyd1dGlsZGUnLCBbMzYxXV0sIFsndXRyaScsIFs5NjUzXV0sIFsndXRyaWYnLCBbOTY1Ml1dLCBbJ3V1YXJyJywgWzg2NDhdXSwgWydVdW1sJywgWzIyMF1dLCBbJ3V1bWwnLCBbMjUyXV0sIFsndXdhbmdsZScsIFsxMDY2M11dLCBbJ3ZhbmdydCcsIFsxMDY1Ml1dLCBbJ3ZhcmVwc2lsb24nLCBbMTAxM11dLCBbJ3ZhcmthcHBhJywgWzEwMDhdXSwgWyd2YXJub3RoaW5nJywgWzg3MDldXSwgWyd2YXJwaGknLCBbOTgxXV0sIFsndmFycGknLCBbOTgyXV0sIFsndmFycHJvcHRvJywgWzg3MzNdXSwgWyd2YXJyJywgWzg1OTddXSwgWyd2QXJyJywgWzg2NjFdXSwgWyd2YXJyaG8nLCBbMTAwOV1dLCBbJ3ZhcnNpZ21hJywgWzk2Ml1dLCBbJ3ZhcnN1YnNldG5lcScsIFs4ODQyLCA2NTAyNF1dLCBbJ3ZhcnN1YnNldG5lcXEnLCBbMTA5NTUsIDY1MDI0XV0sIFsndmFyc3Vwc2V0bmVxJywgWzg4NDMsIDY1MDI0XV0sIFsndmFyc3Vwc2V0bmVxcScsIFsxMDk1NiwgNjUwMjRdXSwgWyd2YXJ0aGV0YScsIFs5NzddXSwgWyd2YXJ0cmlhbmdsZWxlZnQnLCBbODg4Ml1dLCBbJ3ZhcnRyaWFuZ2xlcmlnaHQnLCBbODg4M11dLCBbJ3ZCYXInLCBbMTA5ODRdXSwgWydWYmFyJywgWzEwOTg3XV0sIFsndkJhcnYnLCBbMTA5ODVdXSwgWydWY3knLCBbMTA0Ml1dLCBbJ3ZjeScsIFsxMDc0XV0sIFsndmRhc2gnLCBbODg2Nl1dLCBbJ3ZEYXNoJywgWzg4NzJdXSwgWydWZGFzaCcsIFs4ODczXV0sIFsnVkRhc2gnLCBbODg3NV1dLCBbJ1ZkYXNobCcsIFsxMDk4Ml1dLCBbJ3ZlZWJhcicsIFs4ODkxXV0sIFsndmVlJywgWzg3NDRdXSwgWydWZWUnLCBbODg5N11dLCBbJ3ZlZWVxJywgWzg3OTRdXSwgWyd2ZWxsaXAnLCBbODk0Ml1dLCBbJ3ZlcmJhcicsIFsxMjRdXSwgWydWZXJiYXInLCBbODIxNF1dLCBbJ3ZlcnQnLCBbMTI0XV0sIFsnVmVydCcsIFs4MjE0XV0sIFsnVmVydGljYWxCYXInLCBbODczOV1dLCBbJ1ZlcnRpY2FsTGluZScsIFsxMjRdXSwgWydWZXJ0aWNhbFNlcGFyYXRvcicsIFsxMDA3Ml1dLCBbJ1ZlcnRpY2FsVGlsZGUnLCBbODc2OF1dLCBbJ1ZlcnlUaGluU3BhY2UnLCBbODIwMl1dLCBbJ1ZmcicsIFsxMjAwODldXSwgWyd2ZnInLCBbMTIwMTE1XV0sIFsndmx0cmknLCBbODg4Ml1dLCBbJ3Zuc3ViJywgWzg4MzQsIDg0MDJdXSwgWyd2bnN1cCcsIFs4ODM1LCA4NDAyXV0sIFsnVm9wZicsIFsxMjAxNDFdXSwgWyd2b3BmJywgWzEyMDE2N11dLCBbJ3Zwcm9wJywgWzg3MzNdXSwgWyd2cnRyaScsIFs4ODgzXV0sIFsnVnNjcicsIFsxMTk5ODVdXSwgWyd2c2NyJywgWzEyMDAxMV1dLCBbJ3ZzdWJuRScsIFsxMDk1NSwgNjUwMjRdXSwgWyd2c3VibmUnLCBbODg0MiwgNjUwMjRdXSwgWyd2c3VwbkUnLCBbMTA5NTYsIDY1MDI0XV0sIFsndnN1cG5lJywgWzg4NDMsIDY1MDI0XV0sIFsnVnZkYXNoJywgWzg4NzRdXSwgWyd2emlnemFnJywgWzEwNjUwXV0sIFsnV2NpcmMnLCBbMzcyXV0sIFsnd2NpcmMnLCBbMzczXV0sIFsnd2VkYmFyJywgWzEwODQ3XV0sIFsnd2VkZ2UnLCBbODc0M11dLCBbJ1dlZGdlJywgWzg4OTZdXSwgWyd3ZWRnZXEnLCBbODc5M11dLCBbJ3dlaWVycCcsIFs4NDcyXV0sIFsnV2ZyJywgWzEyMDA5MF1dLCBbJ3dmcicsIFsxMjAxMTZdXSwgWydXb3BmJywgWzEyMDE0Ml1dLCBbJ3dvcGYnLCBbMTIwMTY4XV0sIFsnd3AnLCBbODQ3Ml1dLCBbJ3dyJywgWzg3NjhdXSwgWyd3cmVhdGgnLCBbODc2OF1dLCBbJ1dzY3InLCBbMTE5OTg2XV0sIFsnd3NjcicsIFsxMjAwMTJdXSwgWyd4Y2FwJywgWzg4OThdXSwgWyd4Y2lyYycsIFs5NzExXV0sIFsneGN1cCcsIFs4ODk5XV0sIFsneGR0cmknLCBbOTY2MV1dLCBbJ1hmcicsIFsxMjAwOTFdXSwgWyd4ZnInLCBbMTIwMTE3XV0sIFsneGhhcnInLCBbMTAyMzFdXSwgWyd4aEFycicsIFsxMDIzNF1dLCBbJ1hpJywgWzkyNl1dLCBbJ3hpJywgWzk1OF1dLCBbJ3hsYXJyJywgWzEwMjI5XV0sIFsneGxBcnInLCBbMTAyMzJdXSwgWyd4bWFwJywgWzEwMjM2XV0sIFsneG5pcycsIFs4OTU1XV0sIFsneG9kb3QnLCBbMTA3NTJdXSwgWydYb3BmJywgWzEyMDE0M11dLCBbJ3hvcGYnLCBbMTIwMTY5XV0sIFsneG9wbHVzJywgWzEwNzUzXV0sIFsneG90aW1lJywgWzEwNzU0XV0sIFsneHJhcnInLCBbMTAyMzBdXSwgWyd4ckFycicsIFsxMDIzM11dLCBbJ1hzY3InLCBbMTE5OTg3XV0sIFsneHNjcicsIFsxMjAwMTNdXSwgWyd4c3FjdXAnLCBbMTA3NThdXSwgWyd4dXBsdXMnLCBbMTA3NTZdXSwgWyd4dXRyaScsIFs5NjUxXV0sIFsneHZlZScsIFs4ODk3XV0sIFsneHdlZGdlJywgWzg4OTZdXSwgWydZYWN1dGUnLCBbMjIxXV0sIFsneWFjdXRlJywgWzI1M11dLCBbJ1lBY3knLCBbMTA3MV1dLCBbJ3lhY3knLCBbMTEwM11dLCBbJ1ljaXJjJywgWzM3NF1dLCBbJ3ljaXJjJywgWzM3NV1dLCBbJ1ljeScsIFsxMDY3XV0sIFsneWN5JywgWzEwOTldXSwgWyd5ZW4nLCBbMTY1XV0sIFsnWWZyJywgWzEyMDA5Ml1dLCBbJ3lmcicsIFsxMjAxMThdXSwgWydZSWN5JywgWzEwMzFdXSwgWyd5aWN5JywgWzExMTFdXSwgWydZb3BmJywgWzEyMDE0NF1dLCBbJ3lvcGYnLCBbMTIwMTcwXV0sIFsnWXNjcicsIFsxMTk5ODhdXSwgWyd5c2NyJywgWzEyMDAxNF1dLCBbJ1lVY3knLCBbMTA3MF1dLCBbJ3l1Y3knLCBbMTEwMl1dLCBbJ3l1bWwnLCBbMjU1XV0sIFsnWXVtbCcsIFszNzZdXSwgWydaYWN1dGUnLCBbMzc3XV0sIFsnemFjdXRlJywgWzM3OF1dLCBbJ1pjYXJvbicsIFszODFdXSwgWyd6Y2Fyb24nLCBbMzgyXV0sIFsnWmN5JywgWzEwNDddXSwgWyd6Y3knLCBbMTA3OV1dLCBbJ1pkb3QnLCBbMzc5XV0sIFsnemRvdCcsIFszODBdXSwgWyd6ZWV0cmYnLCBbODQ4OF1dLCBbJ1plcm9XaWR0aFNwYWNlJywgWzgyMDNdXSwgWydaZXRhJywgWzkxOF1dLCBbJ3pldGEnLCBbOTUwXV0sIFsnemZyJywgWzEyMDExOV1dLCBbJ1pmcicsIFs4NDg4XV0sIFsnWkhjeScsIFsxMDQ2XV0sIFsnemhjeScsIFsxMDc4XV0sIFsnemlncmFycicsIFs4NjY5XV0sIFsnem9wZicsIFsxMjAxNzFdXSwgWydab3BmJywgWzg0ODRdXSwgWydac2NyJywgWzExOTk4OV1dLCBbJ3pzY3InLCBbMTIwMDE1XV0sIFsnendqJywgWzgyMDVdXSwgWyd6d25qJywgWzgyMDRdXV07XG5cbnZhciBhbHBoYUluZGV4ID0ge307XG52YXIgY2hhckluZGV4ID0ge307XG5cbmNyZWF0ZUluZGV4ZXMoYWxwaGFJbmRleCwgY2hhckluZGV4KTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSHRtbDVFbnRpdGllcygpIHt9XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDVFbnRpdGllcy5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyYoIz9bXFx3XFxkXSspOz8vZywgZnVuY3Rpb24ocywgZW50aXR5KSB7XG4gICAgICAgIHZhciBjaHI7XG4gICAgICAgIGlmIChlbnRpdHkuY2hhckF0KDApID09PSBcIiNcIikge1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBlbnRpdHkuY2hhckF0KDEpID09PSAneCcgP1xuICAgICAgICAgICAgICAgIHBhcnNlSW50KGVudGl0eS5zdWJzdHIoMikudG9Mb3dlckNhc2UoKSwgMTYpIDpcbiAgICAgICAgICAgICAgICBwYXJzZUludChlbnRpdHkuc3Vic3RyKDEpKTtcblxuICAgICAgICAgICAgaWYgKCEoaXNOYU4oY29kZSkgfHwgY29kZSA8IC0zMjc2OCB8fCBjb2RlID4gNjU1MzUpKSB7XG4gICAgICAgICAgICAgICAgY2hyID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNociA9IGFscGhhSW5kZXhbZW50aXR5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hyIHx8IHM7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBIdG1sNUVudGl0aWVzLmRlY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDVFbnRpdGllcygpLmRlY29kZShzdHIpO1xuIH07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDVFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjaGFySW5mbyA9IGNoYXJJbmRleFtzdHIuY2hhckNvZGVBdChpKV07XG4gICAgICAgIGlmIChjaGFySW5mbykge1xuICAgICAgICAgICAgdmFyIGFscGhhID0gY2hhckluZm9bc3RyLmNoYXJDb2RlQXQoaSArIDEpXTtcbiAgICAgICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWxwaGEgPSBjaGFySW5mb1snJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCImXCIgKyBhbHBoYSArIFwiO1wiO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gSHRtbDVFbnRpdGllcy5lbmNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw1RW50aXRpZXMoKS5lbmNvZGUoc3RyKTtcbiB9O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw1RW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB2YXIgY2hhckluZm8gPSBjaGFySW5kZXhbY107XG4gICAgICAgIGlmIChjaGFySW5mbykge1xuICAgICAgICAgICAgdmFyIGFscGhhID0gY2hhckluZm9bc3RyLmNoYXJDb2RlQXQoaSArIDEpXTtcbiAgICAgICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWxwaGEgPSBjaGFySW5mb1snJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCImXCIgKyBhbHBoYSArIFwiO1wiO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA8IDMyIHx8IGMgPiAxMjYpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnJiMnICsgYyArICc7JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIEh0bWw1RW50aXRpZXMuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNUVudGl0aWVzKCkuZW5jb2RlTm9uVVRGKHN0cik7XG4gfTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNUVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8PSAyNTUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzdHJbaSsrXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSAnJiMnICsgYyArICc7JztcbiAgICAgICAgaSsrXG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBIdG1sNUVudGl0aWVzLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNUVudGl0aWVzKCkuZW5jb2RlTm9uQVNDSUkoc3RyKTtcbiB9O1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBhbHBoYUluZGV4IFBhc3NlZCBieSByZWZlcmVuY2UuXG4gKiBAcGFyYW0ge09iamVjdH0gY2hhckluZGV4IFBhc3NlZCBieSByZWZlcmVuY2UuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluZGV4ZXMoYWxwaGFJbmRleCwgY2hhckluZGV4KSB7XG4gICAgdmFyIGkgPSBFTlRJVElFUy5sZW5ndGg7XG4gICAgdmFyIF9yZXN1bHRzID0gW107XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICB2YXIgZSA9IEVOVElUSUVTW2ldO1xuICAgICAgICB2YXIgYWxwaGEgPSBlWzBdO1xuICAgICAgICB2YXIgY2hhcnMgPSBlWzFdO1xuICAgICAgICB2YXIgY2hyID0gY2hhcnNbMF07XG4gICAgICAgIHZhciBhZGRDaGFyID0gKGNociA8IDMyIHx8IGNociA+IDEyNikgfHwgY2hyID09PSA2MiB8fCBjaHIgPT09IDYwIHx8IGNociA9PT0gMzggfHwgY2hyID09PSAzNCB8fCBjaHIgPT09IDM5O1xuICAgICAgICB2YXIgY2hhckluZm87XG4gICAgICAgIGlmIChhZGRDaGFyKSB7XG4gICAgICAgICAgICBjaGFySW5mbyA9IGNoYXJJbmRleFtjaHJdID0gY2hhckluZGV4W2Nocl0gfHwge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXJzWzFdKSB7XG4gICAgICAgICAgICB2YXIgY2hyMiA9IGNoYXJzWzFdO1xuICAgICAgICAgICAgYWxwaGFJbmRleFthbHBoYV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocikgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocjIpO1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChhZGRDaGFyICYmIChjaGFySW5mb1tjaHIyXSA9IGFscGhhKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbHBoYUluZGV4W2FscGhhXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKTtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goYWRkQ2hhciAmJiAoY2hhckluZm9bJyddID0gYWxwaGEpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBIdG1sNUVudGl0aWVzO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///1\\n\")},function(module,exports){eval(\"// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\nfunction EventEmitter() {\\n  this._events = this._events || {};\\n  this._maxListeners = this._maxListeners || undefined;\\n}\\nmodule.exports = EventEmitter;\\n\\n// Backwards-compat with node 0.10.x\\nEventEmitter.EventEmitter = EventEmitter;\\n\\nEventEmitter.prototype._events = undefined;\\nEventEmitter.prototype._maxListeners = undefined;\\n\\n// By default EventEmitters will print a warning if more than 10 listeners are\\n// added to it. This is a useful default which helps finding memory leaks.\\nEventEmitter.defaultMaxListeners = 10;\\n\\n// Obviously not all Emitters should be limited to 10. This function allows\\n// that to be increased. Set to zero for unlimited.\\nEventEmitter.prototype.setMaxListeners = function(n) {\\n  if (!isNumber(n) || n < 0 || isNaN(n))\\n    throw TypeError('n must be a positive number');\\n  this._maxListeners = n;\\n  return this;\\n};\\n\\nEventEmitter.prototype.emit = function(type) {\\n  var er, handler, len, args, i, listeners;\\n\\n  if (!this._events)\\n    this._events = {};\\n\\n  // If there is no 'error' event listener then throw.\\n  if (type === 'error') {\\n    if (!this._events.error ||\\n        (isObject(this._events.error) && !this._events.error.length)) {\\n      er = arguments[1];\\n      if (er instanceof Error) {\\n        throw er; // Unhandled 'error' event\\n      } else {\\n        // At least give some kind of context to the user\\n        var err = new Error('Uncaught, unspecified \\\"error\\\" event. (' + er + ')');\\n        err.context = er;\\n        throw err;\\n      }\\n    }\\n  }\\n\\n  handler = this._events[type];\\n\\n  if (isUndefined(handler))\\n    return false;\\n\\n  if (isFunction(handler)) {\\n    switch (arguments.length) {\\n      // fast cases\\n      case 1:\\n        handler.call(this);\\n        break;\\n      case 2:\\n        handler.call(this, arguments[1]);\\n        break;\\n      case 3:\\n        handler.call(this, arguments[1], arguments[2]);\\n        break;\\n      // slower\\n      default:\\n        args = Array.prototype.slice.call(arguments, 1);\\n        handler.apply(this, args);\\n    }\\n  } else if (isObject(handler)) {\\n    args = Array.prototype.slice.call(arguments, 1);\\n    listeners = handler.slice();\\n    len = listeners.length;\\n    for (i = 0; i < len; i++)\\n      listeners[i].apply(this, args);\\n  }\\n\\n  return true;\\n};\\n\\nEventEmitter.prototype.addListener = function(type, listener) {\\n  var m;\\n\\n  if (!isFunction(listener))\\n    throw TypeError('listener must be a function');\\n\\n  if (!this._events)\\n    this._events = {};\\n\\n  // To avoid recursion in the case that type === \\\"newListener\\\"! Before\\n  // adding it to the listeners, first emit \\\"newListener\\\".\\n  if (this._events.newListener)\\n    this.emit('newListener', type,\\n              isFunction(listener.listener) ?\\n              listener.listener : listener);\\n\\n  if (!this._events[type])\\n    // Optimize the case of one listener. Don't need the extra array object.\\n    this._events[type] = listener;\\n  else if (isObject(this._events[type]))\\n    // If we've already got an array, just append.\\n    this._events[type].push(listener);\\n  else\\n    // Adding the second element, need to change to array.\\n    this._events[type] = [this._events[type], listener];\\n\\n  // Check for listener leak\\n  if (isObject(this._events[type]) && !this._events[type].warned) {\\n    if (!isUndefined(this._maxListeners)) {\\n      m = this._maxListeners;\\n    } else {\\n      m = EventEmitter.defaultMaxListeners;\\n    }\\n\\n    if (m && m > 0 && this._events[type].length > m) {\\n      this._events[type].warned = true;\\n      console.error('(node) warning: possible EventEmitter memory ' +\\n                    'leak detected. %d listeners added. ' +\\n                    'Use emitter.setMaxListeners() to increase limit.',\\n                    this._events[type].length);\\n      if (typeof console.trace === 'function') {\\n        // not supported in IE 10\\n        console.trace();\\n      }\\n    }\\n  }\\n\\n  return this;\\n};\\n\\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\\n\\nEventEmitter.prototype.once = function(type, listener) {\\n  if (!isFunction(listener))\\n    throw TypeError('listener must be a function');\\n\\n  var fired = false;\\n\\n  function g() {\\n    this.removeListener(type, g);\\n\\n    if (!fired) {\\n      fired = true;\\n      listener.apply(this, arguments);\\n    }\\n  }\\n\\n  g.listener = listener;\\n  this.on(type, g);\\n\\n  return this;\\n};\\n\\n// emits a 'removeListener' event iff the listener was removed\\nEventEmitter.prototype.removeListener = function(type, listener) {\\n  var list, position, length, i;\\n\\n  if (!isFunction(listener))\\n    throw TypeError('listener must be a function');\\n\\n  if (!this._events || !this._events[type])\\n    return this;\\n\\n  list = this._events[type];\\n  length = list.length;\\n  position = -1;\\n\\n  if (list === listener ||\\n      (isFunction(list.listener) && list.listener === listener)) {\\n    delete this._events[type];\\n    if (this._events.removeListener)\\n      this.emit('removeListener', type, listener);\\n\\n  } else if (isObject(list)) {\\n    for (i = length; i-- > 0;) {\\n      if (list[i] === listener ||\\n          (list[i].listener && list[i].listener === listener)) {\\n        position = i;\\n        break;\\n      }\\n    }\\n\\n    if (position < 0)\\n      return this;\\n\\n    if (list.length === 1) {\\n      list.length = 0;\\n      delete this._events[type];\\n    } else {\\n      list.splice(position, 1);\\n    }\\n\\n    if (this._events.removeListener)\\n      this.emit('removeListener', type, listener);\\n  }\\n\\n  return this;\\n};\\n\\nEventEmitter.prototype.removeAllListeners = function(type) {\\n  var key, listeners;\\n\\n  if (!this._events)\\n    return this;\\n\\n  // not listening for removeListener, no need to emit\\n  if (!this._events.removeListener) {\\n    if (arguments.length === 0)\\n      this._events = {};\\n    else if (this._events[type])\\n      delete this._events[type];\\n    return this;\\n  }\\n\\n  // emit removeListener for all listeners on all events\\n  if (arguments.length === 0) {\\n    for (key in this._events) {\\n      if (key === 'removeListener') continue;\\n      this.removeAllListeners(key);\\n    }\\n    this.removeAllListeners('removeListener');\\n    this._events = {};\\n    return this;\\n  }\\n\\n  listeners = this._events[type];\\n\\n  if (isFunction(listeners)) {\\n    this.removeListener(type, listeners);\\n  } else if (listeners) {\\n    // LIFO order\\n    while (listeners.length)\\n      this.removeListener(type, listeners[listeners.length - 1]);\\n  }\\n  delete this._events[type];\\n\\n  return this;\\n};\\n\\nEventEmitter.prototype.listeners = function(type) {\\n  var ret;\\n  if (!this._events || !this._events[type])\\n    ret = [];\\n  else if (isFunction(this._events[type]))\\n    ret = [this._events[type]];\\n  else\\n    ret = this._events[type].slice();\\n  return ret;\\n};\\n\\nEventEmitter.prototype.listenerCount = function(type) {\\n  if (this._events) {\\n    var evlistener = this._events[type];\\n\\n    if (isFunction(evlistener))\\n      return 1;\\n    else if (evlistener)\\n      return evlistener.length;\\n  }\\n  return 0;\\n};\\n\\nEventEmitter.listenerCount = function(emitter, type) {\\n  return emitter.listenerCount(type);\\n};\\n\\nfunction isFunction(arg) {\\n  return typeof arg === 'function';\\n}\\n\\nfunction isNumber(arg) {\\n  return typeof arg === 'number';\\n}\\n\\nfunction isObject(arg) {\\n  return typeof arg === 'object' && arg !== null;\\n}\\n\\nfunction isUndefined(arg) {\\n  return arg === void 0;\\n}\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzPzRkYWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0gsb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy5fZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgICBpZiAoaXNGdW5jdGlvbihldmxpc3RlbmVyKSlcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGV2bGlzdGVuZXIpXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///2\\n\")},function(module,exports,__webpack_require__){eval(\"var EventEmitter = __webpack_require__(2);\\r\\nmodule.exports = new EventEmitter();\\r\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2hvdC9lbWl0dGVyLmpzP2E2YmQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCJldmVudHNcIik7XHJcbm1vZHVsZS5leHBvcnRzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///3\\n\")},function(module,exports){eval('var logLevel = \"info\";\\n\\nfunction dummy() {}\\n\\nfunction shouldLog(level) {\\n\\tvar shouldLog =\\n\\t\\t(logLevel === \"info\" && level === \"info\") ||\\n\\t\\t([\"info\", \"warning\"].indexOf(logLevel) >= 0 && level === \"warning\") ||\\n\\t\\t([\"info\", \"warning\", \"error\"].indexOf(logLevel) >= 0 && level === \"error\");\\n\\treturn shouldLog;\\n}\\n\\nfunction logGroup(logFn) {\\n\\treturn function(level, msg) {\\n\\t\\tif (shouldLog(level)) {\\n\\t\\t\\tlogFn(msg);\\n\\t\\t}\\n\\t};\\n}\\n\\nmodule.exports = function(level, msg) {\\n\\tif (shouldLog(level)) {\\n\\t\\tif (level === \"info\") {\\n\\t\\t\\tconsole.log(msg);\\n\\t\\t} else if (level === \"warning\") {\\n\\t\\t\\tconsole.warn(msg);\\n\\t\\t} else if (level === \"error\") {\\n\\t\\t\\tconsole.error(msg);\\n\\t\\t}\\n\\t}\\n};\\n\\nvar group = console.group || dummy;\\nvar groupCollapsed = console.groupCollapsed || dummy;\\nvar groupEnd = console.groupEnd || dummy;\\n\\nmodule.exports.group = logGroup(group);\\n\\nmodule.exports.groupCollapsed = logGroup(groupCollapsed);\\n\\nmodule.exports.groupEnd = logGroup(groupEnd);\\n\\nmodule.exports.setLogLevel = function(level) {\\n\\tlogLevel = level;\\n};\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2hvdC9sb2cuanM/MWFmZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbG9nTGV2ZWwgPSBcImluZm9cIjtcblxuZnVuY3Rpb24gZHVtbXkoKSB7fVxuXG5mdW5jdGlvbiBzaG91bGRMb2cobGV2ZWwpIHtcblx0dmFyIHNob3VsZExvZyA9XG5cdFx0KGxvZ0xldmVsID09PSBcImluZm9cIiAmJiBsZXZlbCA9PT0gXCJpbmZvXCIpIHx8XG5cdFx0KFtcImluZm9cIiwgXCJ3YXJuaW5nXCJdLmluZGV4T2YobG9nTGV2ZWwpID49IDAgJiYgbGV2ZWwgPT09IFwid2FybmluZ1wiKSB8fFxuXHRcdChbXCJpbmZvXCIsIFwid2FybmluZ1wiLCBcImVycm9yXCJdLmluZGV4T2YobG9nTGV2ZWwpID49IDAgJiYgbGV2ZWwgPT09IFwiZXJyb3JcIik7XG5cdHJldHVybiBzaG91bGRMb2c7XG59XG5cbmZ1bmN0aW9uIGxvZ0dyb3VwKGxvZ0ZuKSB7XG5cdHJldHVybiBmdW5jdGlvbihsZXZlbCwgbXNnKSB7XG5cdFx0aWYgKHNob3VsZExvZyhsZXZlbCkpIHtcblx0XHRcdGxvZ0ZuKG1zZyk7XG5cdFx0fVxuXHR9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxldmVsLCBtc2cpIHtcblx0aWYgKHNob3VsZExvZyhsZXZlbCkpIHtcblx0XHRpZiAobGV2ZWwgPT09IFwiaW5mb1wiKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhtc2cpO1xuXHRcdH0gZWxzZSBpZiAobGV2ZWwgPT09IFwid2FybmluZ1wiKSB7XG5cdFx0XHRjb25zb2xlLndhcm4obXNnKTtcblx0XHR9IGVsc2UgaWYgKGxldmVsID09PSBcImVycm9yXCIpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IobXNnKTtcblx0XHR9XG5cdH1cbn07XG5cbnZhciBncm91cCA9IGNvbnNvbGUuZ3JvdXAgfHwgZHVtbXk7XG52YXIgZ3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkIHx8IGR1bW15O1xudmFyIGdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZCB8fCBkdW1teTtcblxubW9kdWxlLmV4cG9ydHMuZ3JvdXAgPSBsb2dHcm91cChncm91cCk7XG5cbm1vZHVsZS5leHBvcnRzLmdyb3VwQ29sbGFwc2VkID0gbG9nR3JvdXAoZ3JvdXBDb2xsYXBzZWQpO1xuXG5tb2R1bGUuZXhwb3J0cy5ncm91cEVuZCA9IGxvZ0dyb3VwKGdyb3VwRW5kKTtcblxubW9kdWxlLmV4cG9ydHMuc2V0TG9nTGV2ZWwgPSBmdW5jdGlvbihsZXZlbCkge1xuXHRsb2dMZXZlbCA9IGxldmVsO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///4\\n')},function(module,exports,__webpack_require__){eval('var map = {\\n\\t\"./log\": 4\\n};\\n\\n\\nfunction webpackContext(req) {\\n\\tvar id = webpackContextResolve(req);\\n\\treturn __webpack_require__(id);\\n}\\nfunction webpackContextResolve(req) {\\n\\tvar id = map[req];\\n\\tif(!(id + 1)) { // check for number or string\\n\\t\\tvar e = new Error(\"Cannot find module \\'\" + req + \"\\'\");\\n\\t\\te.code = \\'MODULE_NOT_FOUND\\';\\n\\t\\tthrow e;\\n\\t}\\n\\treturn id;\\n}\\nwebpackContext.keys = function webpackContextKeys() {\\n\\treturn Object.keys(map);\\n};\\nwebpackContext.resolve = webpackContextResolve;\\nmodule.exports = webpackContext;\\nwebpackContext.id = 5;//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2hvdCBzeW5jIG5vbnJlY3Vyc2l2ZSBeXFwuXFwvbG9nJD8xYzNkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIG1hcCA9IHtcblx0XCIuL2xvZ1wiOiA0XG59O1xuXG5cbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0KHJlcSkge1xuXHR2YXIgaWQgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKTtcblx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oaWQpO1xufVxuZnVuY3Rpb24gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSkge1xuXHR2YXIgaWQgPSBtYXBbcmVxXTtcblx0aWYoIShpZCArIDEpKSB7IC8vIGNoZWNrIGZvciBudW1iZXIgb3Igc3RyaW5nXG5cdFx0dmFyIGUgPSBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInXCIpO1xuXHRcdGUuY29kZSA9ICdNT0RVTEVfTk9UX0ZPVU5EJztcblx0XHR0aHJvdyBlO1xuXHR9XG5cdHJldHVybiBpZDtcbn1cbndlYnBhY2tDb250ZXh0LmtleXMgPSBmdW5jdGlvbiB3ZWJwYWNrQ29udGV4dEtleXMoKSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyhtYXApO1xufTtcbndlYnBhY2tDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmU7XG5tb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tDb250ZXh0O1xud2VicGFja0NvbnRleHQuaWQgPSA1OyJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///5\\n')},function(module,exports){eval(\"var HTML_ALPHA = ['apos', 'nbsp', 'iexcl', 'cent', 'pound', 'curren', 'yen', 'brvbar', 'sect', 'uml', 'copy', 'ordf', 'laquo', 'not', 'shy', 'reg', 'macr', 'deg', 'plusmn', 'sup2', 'sup3', 'acute', 'micro', 'para', 'middot', 'cedil', 'sup1', 'ordm', 'raquo', 'frac14', 'frac12', 'frac34', 'iquest', 'Agrave', 'Aacute', 'Acirc', 'Atilde', 'Auml', 'Aring', 'Aelig', 'Ccedil', 'Egrave', 'Eacute', 'Ecirc', 'Euml', 'Igrave', 'Iacute', 'Icirc', 'Iuml', 'ETH', 'Ntilde', 'Ograve', 'Oacute', 'Ocirc', 'Otilde', 'Ouml', 'times', 'Oslash', 'Ugrave', 'Uacute', 'Ucirc', 'Uuml', 'Yacute', 'THORN', 'szlig', 'agrave', 'aacute', 'acirc', 'atilde', 'auml', 'aring', 'aelig', 'ccedil', 'egrave', 'eacute', 'ecirc', 'euml', 'igrave', 'iacute', 'icirc', 'iuml', 'eth', 'ntilde', 'ograve', 'oacute', 'ocirc', 'otilde', 'ouml', 'divide', 'oslash', 'ugrave', 'uacute', 'ucirc', 'uuml', 'yacute', 'thorn', 'yuml', 'quot', 'amp', 'lt', 'gt', 'OElig', 'oelig', 'Scaron', 'scaron', 'Yuml', 'circ', 'tilde', 'ensp', 'emsp', 'thinsp', 'zwnj', 'zwj', 'lrm', 'rlm', 'ndash', 'mdash', 'lsquo', 'rsquo', 'sbquo', 'ldquo', 'rdquo', 'bdquo', 'dagger', 'Dagger', 'permil', 'lsaquo', 'rsaquo', 'euro', 'fnof', 'Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta', 'Iota', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma', 'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega', 'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigmaf', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega', 'thetasym', 'upsih', 'piv', 'bull', 'hellip', 'prime', 'Prime', 'oline', 'frasl', 'weierp', 'image', 'real', 'trade', 'alefsym', 'larr', 'uarr', 'rarr', 'darr', 'harr', 'crarr', 'lArr', 'uArr', 'rArr', 'dArr', 'hArr', 'forall', 'part', 'exist', 'empty', 'nabla', 'isin', 'notin', 'ni', 'prod', 'sum', 'minus', 'lowast', 'radic', 'prop', 'infin', 'ang', 'and', 'or', 'cap', 'cup', 'int', 'there4', 'sim', 'cong', 'asymp', 'ne', 'equiv', 'le', 'ge', 'sub', 'sup', 'nsub', 'sube', 'supe', 'oplus', 'otimes', 'perp', 'sdot', 'lceil', 'rceil', 'lfloor', 'rfloor', 'lang', 'rang', 'loz', 'spades', 'clubs', 'hearts', 'diams'];\\nvar HTML_CODES = [39, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 34, 38, 60, 62, 338, 339, 352, 353, 376, 710, 732, 8194, 8195, 8201, 8204, 8205, 8206, 8207, 8211, 8212, 8216, 8217, 8218, 8220, 8221, 8222, 8224, 8225, 8240, 8249, 8250, 8364, 402, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 977, 978, 982, 8226, 8230, 8242, 8243, 8254, 8260, 8472, 8465, 8476, 8482, 8501, 8592, 8593, 8594, 8595, 8596, 8629, 8656, 8657, 8658, 8659, 8660, 8704, 8706, 8707, 8709, 8711, 8712, 8713, 8715, 8719, 8721, 8722, 8727, 8730, 8733, 8734, 8736, 8743, 8744, 8745, 8746, 8747, 8756, 8764, 8773, 8776, 8800, 8801, 8804, 8805, 8834, 8835, 8836, 8838, 8839, 8853, 8855, 8869, 8901, 8968, 8969, 8970, 8971, 9001, 9002, 9674, 9824, 9827, 9829, 9830];\\n\\nvar alphaIndex = {};\\nvar numIndex = {};\\n\\nvar i = 0;\\nvar length = HTML_ALPHA.length;\\nwhile (i < length) {\\n    var a = HTML_ALPHA[i];\\n    var c = HTML_CODES[i];\\n    alphaIndex[a] = String.fromCharCode(c);\\n    numIndex[c] = a;\\n    i++;\\n}\\n\\n/**\\n * @constructor\\n */\\nfunction Html4Entities() {}\\n\\n/**\\n * @param {String} str\\n * @returns {String}\\n */\\nHtml4Entities.prototype.decode = function(str) {\\n    if (!str || !str.length) {\\n        return '';\\n    }\\n    return str.replace(/&(#?[\\\\w\\\\d]+);?/g, function(s, entity) {\\n        var chr;\\n        if (entity.charAt(0) === \\\"#\\\") {\\n            var code = entity.charAt(1).toLowerCase() === 'x' ?\\n                parseInt(entity.substr(2), 16) :\\n                parseInt(entity.substr(1));\\n\\n            if (!(isNaN(code) || code < -32768 || code > 65535)) {\\n                chr = String.fromCharCode(code);\\n            }\\n        } else {\\n            chr = alphaIndex[entity];\\n        }\\n        return chr || s;\\n    });\\n};\\n\\n/**\\n * @param {String} str\\n * @returns {String}\\n */\\nHtml4Entities.decode = function(str) {\\n    return new Html4Entities().decode(str);\\n};\\n\\n/**\\n * @param {String} str\\n * @returns {String}\\n */\\nHtml4Entities.prototype.encode = function(str) {\\n    if (!str || !str.length) {\\n        return '';\\n    }\\n    var strLength = str.length;\\n    var result = '';\\n    var i = 0;\\n    while (i < strLength) {\\n        var alpha = numIndex[str.charCodeAt(i)];\\n        result += alpha ? \\\"&\\\" + alpha + \\\";\\\" : str.charAt(i);\\n        i++;\\n    }\\n    return result;\\n};\\n\\n/**\\n * @param {String} str\\n * @returns {String}\\n */\\nHtml4Entities.encode = function(str) {\\n    return new Html4Entities().encode(str);\\n};\\n\\n/**\\n * @param {String} str\\n * @returns {String}\\n */\\nHtml4Entities.prototype.encodeNonUTF = function(str) {\\n    if (!str || !str.length) {\\n        return '';\\n    }\\n    var strLength = str.length;\\n    var result = '';\\n    var i = 0;\\n    while (i < strLength) {\\n        var cc = str.charCodeAt(i);\\n        var alpha = numIndex[cc];\\n        if (alpha) {\\n            result += \\\"&\\\" + alpha + \\\";\\\";\\n        } else if (cc < 32 || cc > 126) {\\n            result += \\\"&#\\\" + cc + \\\";\\\";\\n        } else {\\n            result += str.charAt(i);\\n        }\\n        i++;\\n    }\\n    return result;\\n};\\n\\n/**\\n * @param {String} str\\n * @returns {String}\\n */\\nHtml4Entities.encodeNonUTF = function(str) {\\n    return new Html4Entities().encodeNonUTF(str);\\n};\\n\\n/**\\n * @param {String} str\\n * @returns {String}\\n */\\nHtml4Entities.prototype.encodeNonASCII = function(str) {\\n    if (!str || !str.length) {\\n        return '';\\n    }\\n    var strLength = str.length;\\n    var result = '';\\n    var i = 0;\\n    while (i < strLength) {\\n        var c = str.charCodeAt(i);\\n        if (c <= 255) {\\n            result += str[i++];\\n            continue;\\n        }\\n        result += '&#' + c + ';';\\n        i++;\\n    }\\n    return result;\\n};\\n\\n/**\\n * @param {String} str\\n * @returns {String}\\n */\\nHtml4Entities.encodeNonASCII = function(str) {\\n    return new Html4Entities().encodeNonASCII(str);\\n};\\n\\nmodule.exports = Html4Entities;\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvbGliL2h0bWw0LWVudGl0aWVzLmpzPzc3YzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyxTQUFTO0FBQ1Qsb0NBQW9DO0FBQ3BDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEhUTUxfQUxQSEEgPSBbJ2Fwb3MnLCAnbmJzcCcsICdpZXhjbCcsICdjZW50JywgJ3BvdW5kJywgJ2N1cnJlbicsICd5ZW4nLCAnYnJ2YmFyJywgJ3NlY3QnLCAndW1sJywgJ2NvcHknLCAnb3JkZicsICdsYXF1bycsICdub3QnLCAnc2h5JywgJ3JlZycsICdtYWNyJywgJ2RlZycsICdwbHVzbW4nLCAnc3VwMicsICdzdXAzJywgJ2FjdXRlJywgJ21pY3JvJywgJ3BhcmEnLCAnbWlkZG90JywgJ2NlZGlsJywgJ3N1cDEnLCAnb3JkbScsICdyYXF1bycsICdmcmFjMTQnLCAnZnJhYzEyJywgJ2ZyYWMzNCcsICdpcXVlc3QnLCAnQWdyYXZlJywgJ0FhY3V0ZScsICdBY2lyYycsICdBdGlsZGUnLCAnQXVtbCcsICdBcmluZycsICdBZWxpZycsICdDY2VkaWwnLCAnRWdyYXZlJywgJ0VhY3V0ZScsICdFY2lyYycsICdFdW1sJywgJ0lncmF2ZScsICdJYWN1dGUnLCAnSWNpcmMnLCAnSXVtbCcsICdFVEgnLCAnTnRpbGRlJywgJ09ncmF2ZScsICdPYWN1dGUnLCAnT2NpcmMnLCAnT3RpbGRlJywgJ091bWwnLCAndGltZXMnLCAnT3NsYXNoJywgJ1VncmF2ZScsICdVYWN1dGUnLCAnVWNpcmMnLCAnVXVtbCcsICdZYWN1dGUnLCAnVEhPUk4nLCAnc3psaWcnLCAnYWdyYXZlJywgJ2FhY3V0ZScsICdhY2lyYycsICdhdGlsZGUnLCAnYXVtbCcsICdhcmluZycsICdhZWxpZycsICdjY2VkaWwnLCAnZWdyYXZlJywgJ2VhY3V0ZScsICdlY2lyYycsICdldW1sJywgJ2lncmF2ZScsICdpYWN1dGUnLCAnaWNpcmMnLCAnaXVtbCcsICdldGgnLCAnbnRpbGRlJywgJ29ncmF2ZScsICdvYWN1dGUnLCAnb2NpcmMnLCAnb3RpbGRlJywgJ291bWwnLCAnZGl2aWRlJywgJ29zbGFzaCcsICd1Z3JhdmUnLCAndWFjdXRlJywgJ3VjaXJjJywgJ3V1bWwnLCAneWFjdXRlJywgJ3Rob3JuJywgJ3l1bWwnLCAncXVvdCcsICdhbXAnLCAnbHQnLCAnZ3QnLCAnT0VsaWcnLCAnb2VsaWcnLCAnU2Nhcm9uJywgJ3NjYXJvbicsICdZdW1sJywgJ2NpcmMnLCAndGlsZGUnLCAnZW5zcCcsICdlbXNwJywgJ3RoaW5zcCcsICd6d25qJywgJ3p3aicsICdscm0nLCAncmxtJywgJ25kYXNoJywgJ21kYXNoJywgJ2xzcXVvJywgJ3JzcXVvJywgJ3NicXVvJywgJ2xkcXVvJywgJ3JkcXVvJywgJ2JkcXVvJywgJ2RhZ2dlcicsICdEYWdnZXInLCAncGVybWlsJywgJ2xzYXF1bycsICdyc2FxdW8nLCAnZXVybycsICdmbm9mJywgJ0FscGhhJywgJ0JldGEnLCAnR2FtbWEnLCAnRGVsdGEnLCAnRXBzaWxvbicsICdaZXRhJywgJ0V0YScsICdUaGV0YScsICdJb3RhJywgJ0thcHBhJywgJ0xhbWJkYScsICdNdScsICdOdScsICdYaScsICdPbWljcm9uJywgJ1BpJywgJ1JobycsICdTaWdtYScsICdUYXUnLCAnVXBzaWxvbicsICdQaGknLCAnQ2hpJywgJ1BzaScsICdPbWVnYScsICdhbHBoYScsICdiZXRhJywgJ2dhbW1hJywgJ2RlbHRhJywgJ2Vwc2lsb24nLCAnemV0YScsICdldGEnLCAndGhldGEnLCAnaW90YScsICdrYXBwYScsICdsYW1iZGEnLCAnbXUnLCAnbnUnLCAneGknLCAnb21pY3JvbicsICdwaScsICdyaG8nLCAnc2lnbWFmJywgJ3NpZ21hJywgJ3RhdScsICd1cHNpbG9uJywgJ3BoaScsICdjaGknLCAncHNpJywgJ29tZWdhJywgJ3RoZXRhc3ltJywgJ3Vwc2loJywgJ3BpdicsICdidWxsJywgJ2hlbGxpcCcsICdwcmltZScsICdQcmltZScsICdvbGluZScsICdmcmFzbCcsICd3ZWllcnAnLCAnaW1hZ2UnLCAncmVhbCcsICd0cmFkZScsICdhbGVmc3ltJywgJ2xhcnInLCAndWFycicsICdyYXJyJywgJ2RhcnInLCAnaGFycicsICdjcmFycicsICdsQXJyJywgJ3VBcnInLCAnckFycicsICdkQXJyJywgJ2hBcnInLCAnZm9yYWxsJywgJ3BhcnQnLCAnZXhpc3QnLCAnZW1wdHknLCAnbmFibGEnLCAnaXNpbicsICdub3RpbicsICduaScsICdwcm9kJywgJ3N1bScsICdtaW51cycsICdsb3dhc3QnLCAncmFkaWMnLCAncHJvcCcsICdpbmZpbicsICdhbmcnLCAnYW5kJywgJ29yJywgJ2NhcCcsICdjdXAnLCAnaW50JywgJ3RoZXJlNCcsICdzaW0nLCAnY29uZycsICdhc3ltcCcsICduZScsICdlcXVpdicsICdsZScsICdnZScsICdzdWInLCAnc3VwJywgJ25zdWInLCAnc3ViZScsICdzdXBlJywgJ29wbHVzJywgJ290aW1lcycsICdwZXJwJywgJ3Nkb3QnLCAnbGNlaWwnLCAncmNlaWwnLCAnbGZsb29yJywgJ3JmbG9vcicsICdsYW5nJywgJ3JhbmcnLCAnbG96JywgJ3NwYWRlcycsICdjbHVicycsICdoZWFydHMnLCAnZGlhbXMnXTtcbnZhciBIVE1MX0NPREVTID0gWzM5LCAxNjAsIDE2MSwgMTYyLCAxNjMsIDE2NCwgMTY1LCAxNjYsIDE2NywgMTY4LCAxNjksIDE3MCwgMTcxLCAxNzIsIDE3MywgMTc0LCAxNzUsIDE3NiwgMTc3LCAxNzgsIDE3OSwgMTgwLCAxODEsIDE4MiwgMTgzLCAxODQsIDE4NSwgMTg2LCAxODcsIDE4OCwgMTg5LCAxOTAsIDE5MSwgMTkyLCAxOTMsIDE5NCwgMTk1LCAxOTYsIDE5NywgMTk4LCAxOTksIDIwMCwgMjAxLCAyMDIsIDIwMywgMjA0LCAyMDUsIDIwNiwgMjA3LCAyMDgsIDIwOSwgMjEwLCAyMTEsIDIxMiwgMjEzLCAyMTQsIDIxNSwgMjE2LCAyMTcsIDIxOCwgMjE5LCAyMjAsIDIyMSwgMjIyLCAyMjMsIDIyNCwgMjI1LCAyMjYsIDIyNywgMjI4LCAyMjksIDIzMCwgMjMxLCAyMzIsIDIzMywgMjM0LCAyMzUsIDIzNiwgMjM3LCAyMzgsIDIzOSwgMjQwLCAyNDEsIDI0MiwgMjQzLCAyNDQsIDI0NSwgMjQ2LCAyNDcsIDI0OCwgMjQ5LCAyNTAsIDI1MSwgMjUyLCAyNTMsIDI1NCwgMjU1LCAzNCwgMzgsIDYwLCA2MiwgMzM4LCAzMzksIDM1MiwgMzUzLCAzNzYsIDcxMCwgNzMyLCA4MTk0LCA4MTk1LCA4MjAxLCA4MjA0LCA4MjA1LCA4MjA2LCA4MjA3LCA4MjExLCA4MjEyLCA4MjE2LCA4MjE3LCA4MjE4LCA4MjIwLCA4MjIxLCA4MjIyLCA4MjI0LCA4MjI1LCA4MjQwLCA4MjQ5LCA4MjUwLCA4MzY0LCA0MDIsIDkxMywgOTE0LCA5MTUsIDkxNiwgOTE3LCA5MTgsIDkxOSwgOTIwLCA5MjEsIDkyMiwgOTIzLCA5MjQsIDkyNSwgOTI2LCA5MjcsIDkyOCwgOTI5LCA5MzEsIDkzMiwgOTMzLCA5MzQsIDkzNSwgOTM2LCA5MzcsIDk0NSwgOTQ2LCA5NDcsIDk0OCwgOTQ5LCA5NTAsIDk1MSwgOTUyLCA5NTMsIDk1NCwgOTU1LCA5NTYsIDk1NywgOTU4LCA5NTksIDk2MCwgOTYxLCA5NjIsIDk2MywgOTY0LCA5NjUsIDk2NiwgOTY3LCA5NjgsIDk2OSwgOTc3LCA5NzgsIDk4MiwgODIyNiwgODIzMCwgODI0MiwgODI0MywgODI1NCwgODI2MCwgODQ3MiwgODQ2NSwgODQ3NiwgODQ4MiwgODUwMSwgODU5MiwgODU5MywgODU5NCwgODU5NSwgODU5NiwgODYyOSwgODY1NiwgODY1NywgODY1OCwgODY1OSwgODY2MCwgODcwNCwgODcwNiwgODcwNywgODcwOSwgODcxMSwgODcxMiwgODcxMywgODcxNSwgODcxOSwgODcyMSwgODcyMiwgODcyNywgODczMCwgODczMywgODczNCwgODczNiwgODc0MywgODc0NCwgODc0NSwgODc0NiwgODc0NywgODc1NiwgODc2NCwgODc3MywgODc3NiwgODgwMCwgODgwMSwgODgwNCwgODgwNSwgODgzNCwgODgzNSwgODgzNiwgODgzOCwgODgzOSwgODg1MywgODg1NSwgODg2OSwgODkwMSwgODk2OCwgODk2OSwgODk3MCwgODk3MSwgOTAwMSwgOTAwMiwgOTY3NCwgOTgyNCwgOTgyNywgOTgyOSwgOTgzMF07XG5cbnZhciBhbHBoYUluZGV4ID0ge307XG52YXIgbnVtSW5kZXggPSB7fTtcblxudmFyIGkgPSAwO1xudmFyIGxlbmd0aCA9IEhUTUxfQUxQSEEubGVuZ3RoO1xud2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICB2YXIgYSA9IEhUTUxfQUxQSEFbaV07XG4gICAgdmFyIGMgPSBIVE1MX0NPREVTW2ldO1xuICAgIGFscGhhSW5kZXhbYV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICAgIG51bUluZGV4W2NdID0gYTtcbiAgICBpKys7XG59XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEh0bWw0RW50aXRpZXMoKSB7fVxuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mKCM/W1xcd1xcZF0rKTs/L2csIGZ1bmN0aW9uKHMsIGVudGl0eSkge1xuICAgICAgICB2YXIgY2hyO1xuICAgICAgICBpZiAoZW50aXR5LmNoYXJBdCgwKSA9PT0gXCIjXCIpIHtcbiAgICAgICAgICAgIHZhciBjb2RlID0gZW50aXR5LmNoYXJBdCgxKS50b0xvd2VyQ2FzZSgpID09PSAneCcgP1xuICAgICAgICAgICAgICAgIHBhcnNlSW50KGVudGl0eS5zdWJzdHIoMiksIDE2KSA6XG4gICAgICAgICAgICAgICAgcGFyc2VJbnQoZW50aXR5LnN1YnN0cigxKSk7XG5cbiAgICAgICAgICAgIGlmICghKGlzTmFOKGNvZGUpIHx8IGNvZGUgPCAtMzI3NjggfHwgY29kZSA+IDY1NTM1KSkge1xuICAgICAgICAgICAgICAgIGNociA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaHIgPSBhbHBoYUluZGV4W2VudGl0eV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNociB8fCBzO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLmRlY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDRFbnRpdGllcygpLmRlY29kZShzdHIpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGFscGhhID0gbnVtSW5kZXhbc3RyLmNoYXJDb2RlQXQoaSldO1xuICAgICAgICByZXN1bHQgKz0gYWxwaGEgPyBcIiZcIiArIGFscGhhICsgXCI7XCIgOiBzdHIuY2hhckF0KGkpO1xuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMuZW5jb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNEVudGl0aWVzKCkuZW5jb2RlKHN0cik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICB2YXIgY2MgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgdmFyIGFscGhhID0gbnVtSW5kZXhbY2NdO1xuICAgICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIiZcIiArIGFscGhhICsgXCI7XCI7XG4gICAgICAgIH0gZWxzZSBpZiAoY2MgPCAzMiB8fCBjYyA+IDEyNikge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiJiNcIiArIGNjICsgXCI7XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNEVudGl0aWVzKCkuZW5jb2RlTm9uVVRGKHN0cik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDw9IDI1NSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHN0cltpKytdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBjICsgJzsnO1xuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw0RW50aXRpZXMoKS5lbmNvZGVOb25BU0NJSShzdHIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIdG1sNEVudGl0aWVzO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///6\\n\")},function(module,exports){eval(\"var ALPHA_INDEX = {\\n    '&lt': '<',\\n    '&gt': '>',\\n    '&quot': '\\\"',\\n    '&apos': '\\\\'',\\n    '&amp': '&',\\n    '&lt;': '<',\\n    '&gt;': '>',\\n    '&quot;': '\\\"',\\n    '&apos;': '\\\\'',\\n    '&amp;': '&'\\n};\\n\\nvar CHAR_INDEX = {\\n    60: 'lt',\\n    62: 'gt',\\n    34: 'quot',\\n    39: 'apos',\\n    38: 'amp'\\n};\\n\\nvar CHAR_S_INDEX = {\\n    '<': '&lt;',\\n    '>': '&gt;',\\n    '\\\"': '&quot;',\\n    '\\\\'': '&apos;',\\n    '&': '&amp;'\\n};\\n\\n/**\\n * @constructor\\n */\\nfunction XmlEntities() {}\\n\\n/**\\n * @param {String} str\\n * @returns {String}\\n */\\nXmlEntities.prototype.encode = function(str) {\\n    if (!str || !str.length) {\\n        return '';\\n    }\\n    return str.replace(/<|>|\\\"|'|&/g, function(s) {\\n        return CHAR_S_INDEX[s];\\n    });\\n};\\n\\n/**\\n * @param {String} str\\n * @returns {String}\\n */\\n XmlEntities.encode = function(str) {\\n    return new XmlEntities().encode(str);\\n };\\n\\n/**\\n * @param {String} str\\n * @returns {String}\\n */\\nXmlEntities.prototype.decode = function(str) {\\n    if (!str || !str.length) {\\n        return '';\\n    }\\n    return str.replace(/&#?[0-9a-zA-Z]+;?/g, function(s) {\\n        if (s.charAt(1) === '#') {\\n            var code = s.charAt(2).toLowerCase() === 'x' ?\\n                parseInt(s.substr(3), 16) :\\n                parseInt(s.substr(2));\\n\\n            if (isNaN(code) || code < -32768 || code > 65535) {\\n                return '';\\n            }\\n            return String.fromCharCode(code);\\n        }\\n        return ALPHA_INDEX[s] || s;\\n    });\\n};\\n\\n/**\\n * @param {String} str\\n * @returns {String}\\n */\\n XmlEntities.decode = function(str) {\\n    return new XmlEntities().decode(str);\\n };\\n\\n/**\\n * @param {String} str\\n * @returns {String}\\n */\\nXmlEntities.prototype.encodeNonUTF = function(str) {\\n    if (!str || !str.length) {\\n        return '';\\n    }\\n    var strLength = str.length;\\n    var result = '';\\n    var i = 0;\\n    while (i < strLength) {\\n        var c = str.charCodeAt(i);\\n        var alpha = CHAR_INDEX[c];\\n        if (alpha) {\\n            result += \\\"&\\\" + alpha + \\\";\\\";\\n            i++;\\n            continue;\\n        }\\n        if (c < 32 || c > 126) {\\n            result += '&#' + c + ';';\\n        } else {\\n            result += str.charAt(i);\\n        }\\n        i++;\\n    }\\n    return result;\\n};\\n\\n/**\\n * @param {String} str\\n * @returns {String}\\n */\\n XmlEntities.encodeNonUTF = function(str) {\\n    return new XmlEntities().encodeNonUTF(str);\\n };\\n\\n/**\\n * @param {String} str\\n * @returns {String}\\n */\\nXmlEntities.prototype.encodeNonASCII = function(str) {\\n    if (!str || !str.length) {\\n        return '';\\n    }\\n    var strLenght = str.length;\\n    var result = '';\\n    var i = 0;\\n    while (i < strLenght) {\\n        var c = str.charCodeAt(i);\\n        if (c <= 255) {\\n            result += str[i++];\\n            continue;\\n        }\\n        result += '&#' + c + ';';\\n        i++;\\n    }\\n    return result;\\n};\\n\\n/**\\n * @param {String} str\\n * @returns {String}\\n */\\n XmlEntities.encodeNonASCII = function(str) {\\n    return new XmlEntities().encodeNonASCII(str);\\n };\\n\\nmodule.exports = XmlEntities;\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvbGliL3htbC1lbnRpdGllcy5qcz80ZjIwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxTQUFTO0FBQ1QsV0FBVztBQUNYLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2QsY0FBYztBQUNkLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakIsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEFMUEhBX0lOREVYID0ge1xuICAgICcmbHQnOiAnPCcsXG4gICAgJyZndCc6ICc+JyxcbiAgICAnJnF1b3QnOiAnXCInLFxuICAgICcmYXBvcyc6ICdcXCcnLFxuICAgICcmYW1wJzogJyYnLFxuICAgICcmbHQ7JzogJzwnLFxuICAgICcmZ3Q7JzogJz4nLFxuICAgICcmcXVvdDsnOiAnXCInLFxuICAgICcmYXBvczsnOiAnXFwnJyxcbiAgICAnJmFtcDsnOiAnJidcbn07XG5cbnZhciBDSEFSX0lOREVYID0ge1xuICAgIDYwOiAnbHQnLFxuICAgIDYyOiAnZ3QnLFxuICAgIDM0OiAncXVvdCcsXG4gICAgMzk6ICdhcG9zJyxcbiAgICAzODogJ2FtcCdcbn07XG5cbnZhciBDSEFSX1NfSU5ERVggPSB7XG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgJ1xcJyc6ICcmYXBvczsnLFxuICAgICcmJzogJyZhbXA7J1xufTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gWG1sRW50aXRpZXMoKSB7fVxuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cblhtbEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvPHw+fFwifCd8Ji9nLCBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiBDSEFSX1NfSU5ERVhbc107XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBYbWxFbnRpdGllcy5lbmNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IFhtbEVudGl0aWVzKCkuZW5jb2RlKHN0cik7XG4gfTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5YbWxFbnRpdGllcy5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyYjP1swLTlhLXpBLVpdKzs/L2csIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgaWYgKHMuY2hhckF0KDEpID09PSAnIycpIHtcbiAgICAgICAgICAgIHZhciBjb2RlID0gcy5jaGFyQXQoMikudG9Mb3dlckNhc2UoKSA9PT0gJ3gnID9cbiAgICAgICAgICAgICAgICBwYXJzZUludChzLnN1YnN0cigzKSwgMTYpIDpcbiAgICAgICAgICAgICAgICBwYXJzZUludChzLnN1YnN0cigyKSk7XG5cbiAgICAgICAgICAgIGlmIChpc05hTihjb2RlKSB8fCBjb2RlIDwgLTMyNzY4IHx8IGNvZGUgPiA2NTUzNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBTFBIQV9JTkRFWFtzXSB8fCBzO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gWG1sRW50aXRpZXMuZGVjb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBYbWxFbnRpdGllcygpLmRlY29kZShzdHIpO1xuIH07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuWG1sRW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB2YXIgYWxwaGEgPSBDSEFSX0lOREVYW2NdO1xuICAgICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIiZcIiArIGFscGhhICsgXCI7XCI7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA8IDMyIHx8IGMgPiAxMjYpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnJiMnICsgYyArICc7JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIFhtbEVudGl0aWVzLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgWG1sRW50aXRpZXMoKS5lbmNvZGVOb25VVEYoc3RyKTtcbiB9O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cblhtbEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmdodCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmdodCkge1xuICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8PSAyNTUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzdHJbaSsrXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSAnJiMnICsgYyArICc7JztcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gWG1sRW50aXRpZXMuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IFhtbEVudGl0aWVzKCkuZW5jb2RlTm9uQVNDSUkoc3RyKTtcbiB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhtbEVudGl0aWVzO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///7\\n\")},function(module,exports,__webpack_require__){eval(\"module.exports = {\\n  XmlEntities: __webpack_require__(7),\\n  Html4Entities: __webpack_require__(6),\\n  Html5Entities: __webpack_require__(1),\\n  AllHtmlEntities: __webpack_require__(1)\\n};\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvaW5kZXguanM/ZjhkOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0ge1xuICBYbWxFbnRpdGllczogcmVxdWlyZSgnLi9saWIveG1sLWVudGl0aWVzLmpzJyksXG4gIEh0bWw0RW50aXRpZXM6IHJlcXVpcmUoJy4vbGliL2h0bWw0LWVudGl0aWVzLmpzJyksXG4gIEh0bWw1RW50aXRpZXM6IHJlcXVpcmUoJy4vbGliL2h0bWw1LWVudGl0aWVzLmpzJyksXG4gIEFsbEh0bWxFbnRpdGllczogcmVxdWlyZSgnLi9saWIvaHRtbDUtZW50aXRpZXMuanMnKVxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///8\\n\")},function(module,exports,__webpack_require__){\"use strict\";eval(\"\\n\\nmodule.exports = ansiHTML\\n\\n// Reference to https://github.com/sindresorhus/ansi-regex\\nvar _regANSI = /(?:(?:\\\\u001b\\\\[)|\\\\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\\\\u001b[A-M]/\\n\\nvar _defColors = {\\n  reset: ['fff', '000'], // [FOREGROUD_COLOR, BACKGROUND_COLOR]\\n  black: '000',\\n  red: 'ff0000',\\n  green: '209805',\\n  yellow: 'e8bf03',\\n  blue: '0000ff',\\n  magenta: 'ff00ff',\\n  cyan: '00ffee',\\n  lightgrey: 'f0f0f0',\\n  darkgrey: '888'\\n}\\nvar _styles = {\\n  30: 'black',\\n  31: 'red',\\n  32: 'green',\\n  33: 'yellow',\\n  34: 'blue',\\n  35: 'magenta',\\n  36: 'cyan',\\n  37: 'lightgrey'\\n}\\nvar _openTags = {\\n  '1': 'font-weight:bold', // bold\\n  '2': 'opacity:0.5', // dim\\n  '3': '<i>', // italic\\n  '4': '<u>', // underscore\\n  '8': 'display:none', // hidden\\n  '9': '<del>' // delete\\n}\\nvar _closeTags = {\\n  '23': '</i>', // reset italic\\n  '24': '</u>', // reset underscore\\n  '29': '</del>' // reset delete\\n}\\n\\n;[0, 21, 22, 27, 28, 39, 49].forEach(function (n) {\\n  _closeTags[n] = '</span>'\\n})\\n\\n/**\\n * Converts text with ANSI color codes to HTML markup.\\n * @param {String} text\\n * @returns {*}\\n */\\nfunction ansiHTML (text) {\\n  // Returns the text if the string has no ANSI escape code.\\n  if (!_regANSI.test(text)) {\\n    return text\\n  }\\n\\n  // Cache opened sequence.\\n  var ansiCodes = []\\n  // Replace with markup.\\n  var ret = text.replace(/\\\\033\\\\[(\\\\d+)*m/g, function (match, seq) {\\n    var ot = _openTags[seq]\\n    if (ot) {\\n      // If current sequence has been opened, close it.\\n      if (!!~ansiCodes.indexOf(seq)) { // eslint-disable-line no-extra-boolean-cast\\n        ansiCodes.pop()\\n        return '</span>'\\n      }\\n      // Open tag.\\n      ansiCodes.push(seq)\\n      return ot[0] === '<' ? ot : '<span style=\\\"' + ot + ';\\\">'\\n    }\\n\\n    var ct = _closeTags[seq]\\n    if (ct) {\\n      // Pop sequence\\n      ansiCodes.pop()\\n      return ct\\n    }\\n    return ''\\n  })\\n\\n  // Make sure tags are closed.\\n  var l = ansiCodes.length\\n  ;(l > 0) && (ret += Array(l + 1).join('</span>'))\\n\\n  return ret\\n}\\n\\n/**\\n * Customize colors.\\n * @param {Object} colors reference to _defColors\\n */\\nansiHTML.setColors = function (colors) {\\n  if (typeof colors !== 'object') {\\n    throw new Error('`colors` parameter must be an Object.')\\n  }\\n\\n  var _finalColors = {}\\n  for (var key in _defColors) {\\n    var hex = colors.hasOwnProperty(key) ? colors[key] : null\\n    if (!hex) {\\n      _finalColors[key] = _defColors[key]\\n      continue\\n    }\\n    if ('reset' === key) {\\n      if (typeof hex === 'string') {\\n        hex = [hex]\\n      }\\n      if (!Array.isArray(hex) || hex.length === 0 || hex.some(function (h) {\\n        return typeof h !== 'string'\\n      })) {\\n        throw new Error('The value of `' + key + '` property must be an Array and each item could only be a hex string, e.g.: FF0000')\\n      }\\n      var defHexColor = _defColors[key]\\n      if (!hex[0]) {\\n        hex[0] = defHexColor[0]\\n      }\\n      if (hex.length === 1 || !hex[1]) {\\n        hex = [hex[0]]\\n        hex.push(defHexColor[1])\\n      }\\n\\n      hex = hex.slice(0, 2)\\n    } else if (typeof hex !== 'string') {\\n      throw new Error('The value of `' + key + '` property must be a hex string, e.g.: FF0000')\\n    }\\n    _finalColors[key] = hex\\n  }\\n  _setTags(_finalColors)\\n}\\n\\n/**\\n * Reset colors.\\n */\\nansiHTML.reset = function () {\\n  _setTags(_defColors)\\n}\\n\\n/**\\n * Expose tags, including open and close.\\n * @type {Object}\\n */\\nansiHTML.tags = {}\\n\\nif (Object.defineProperty) {\\n  Object.defineProperty(ansiHTML.tags, 'open', {\\n    get: function () { return _openTags }\\n  })\\n  Object.defineProperty(ansiHTML.tags, 'close', {\\n    get: function () { return _closeTags }\\n  })\\n} else {\\n  ansiHTML.tags.open = _openTags\\n  ansiHTML.tags.close = _closeTags\\n}\\n\\nfunction _setTags (colors) {\\n  // reset all\\n  _openTags['0'] = 'font-weight:normal;opacity:1;color:#' + colors.reset[0] + ';background:#' + colors.reset[1]\\n  // inverse\\n  _openTags['7'] = 'color:#' + colors.reset[1] + ';background:#' + colors.reset[0]\\n  // dark grey\\n  _openTags['90'] = 'color:#' + colors.darkgrey\\n\\n  for (var code in _styles) {\\n    var color = _styles[code]\\n    var oriColor = colors[color] || '000'\\n    _openTags[code] = 'color:#' + oriColor\\n    code = parseInt(code)\\n    _openTags[(code + 10).toString()] = 'background:#' + oriColor\\n  }\\n}\\n\\nansiHTML.reset()\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvbm9kZV9tb2R1bGVzL2Fuc2ktaHRtbC9pbmRleC5qcz9mY2ExIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBO0FBQ0EsbURBQW1ELElBQUksU0FBUyxNQUFNLElBQUk7O0FBRTFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixHQUFHO0FBQ0g7QUFDQSxzQkFBc0I7QUFDdEIsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QyxVQUFVLCtCQUErQjtBQUNoRjtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFuc2lIVE1MXG5cbi8vIFJlZmVyZW5jZSB0byBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL2Fuc2ktcmVnZXhcbnZhciBfcmVnQU5TSSA9IC8oPzooPzpcXHUwMDFiXFxbKXxcXHUwMDliKSg/Oig/OlswLTldezEsM30pPyg/Oig/OjtbMC05XXswLDN9KSopP1tBLU18Zi1tXSl8XFx1MDAxYltBLU1dL1xuXG52YXIgX2RlZkNvbG9ycyA9IHtcbiAgcmVzZXQ6IFsnZmZmJywgJzAwMCddLCAvLyBbRk9SRUdST1VEX0NPTE9SLCBCQUNLR1JPVU5EX0NPTE9SXVxuICBibGFjazogJzAwMCcsXG4gIHJlZDogJ2ZmMDAwMCcsXG4gIGdyZWVuOiAnMjA5ODA1JyxcbiAgeWVsbG93OiAnZThiZjAzJyxcbiAgYmx1ZTogJzAwMDBmZicsXG4gIG1hZ2VudGE6ICdmZjAwZmYnLFxuICBjeWFuOiAnMDBmZmVlJyxcbiAgbGlnaHRncmV5OiAnZjBmMGYwJyxcbiAgZGFya2dyZXk6ICc4ODgnXG59XG52YXIgX3N0eWxlcyA9IHtcbiAgMzA6ICdibGFjaycsXG4gIDMxOiAncmVkJyxcbiAgMzI6ICdncmVlbicsXG4gIDMzOiAneWVsbG93JyxcbiAgMzQ6ICdibHVlJyxcbiAgMzU6ICdtYWdlbnRhJyxcbiAgMzY6ICdjeWFuJyxcbiAgMzc6ICdsaWdodGdyZXknXG59XG52YXIgX29wZW5UYWdzID0ge1xuICAnMSc6ICdmb250LXdlaWdodDpib2xkJywgLy8gYm9sZFxuICAnMic6ICdvcGFjaXR5OjAuNScsIC8vIGRpbVxuICAnMyc6ICc8aT4nLCAvLyBpdGFsaWNcbiAgJzQnOiAnPHU+JywgLy8gdW5kZXJzY29yZVxuICAnOCc6ICdkaXNwbGF5Om5vbmUnLCAvLyBoaWRkZW5cbiAgJzknOiAnPGRlbD4nIC8vIGRlbGV0ZVxufVxudmFyIF9jbG9zZVRhZ3MgPSB7XG4gICcyMyc6ICc8L2k+JywgLy8gcmVzZXQgaXRhbGljXG4gICcyNCc6ICc8L3U+JywgLy8gcmVzZXQgdW5kZXJzY29yZVxuICAnMjknOiAnPC9kZWw+JyAvLyByZXNldCBkZWxldGVcbn1cblxuO1swLCAyMSwgMjIsIDI3LCAyOCwgMzksIDQ5XS5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gIF9jbG9zZVRhZ3Nbbl0gPSAnPC9zcGFuPidcbn0pXG5cbi8qKlxuICogQ29udmVydHMgdGV4dCB3aXRoIEFOU0kgY29sb3IgY29kZXMgdG8gSFRNTCBtYXJrdXAuXG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIGFuc2lIVE1MICh0ZXh0KSB7XG4gIC8vIFJldHVybnMgdGhlIHRleHQgaWYgdGhlIHN0cmluZyBoYXMgbm8gQU5TSSBlc2NhcGUgY29kZS5cbiAgaWYgKCFfcmVnQU5TSS50ZXN0KHRleHQpKSB7XG4gICAgcmV0dXJuIHRleHRcbiAgfVxuXG4gIC8vIENhY2hlIG9wZW5lZCBzZXF1ZW5jZS5cbiAgdmFyIGFuc2lDb2RlcyA9IFtdXG4gIC8vIFJlcGxhY2Ugd2l0aCBtYXJrdXAuXG4gIHZhciByZXQgPSB0ZXh0LnJlcGxhY2UoL1xcMDMzXFxbKFxcZCspKm0vZywgZnVuY3Rpb24gKG1hdGNoLCBzZXEpIHtcbiAgICB2YXIgb3QgPSBfb3BlblRhZ3Nbc2VxXVxuICAgIGlmIChvdCkge1xuICAgICAgLy8gSWYgY3VycmVudCBzZXF1ZW5jZSBoYXMgYmVlbiBvcGVuZWQsIGNsb3NlIGl0LlxuICAgICAgaWYgKCEhfmFuc2lDb2Rlcy5pbmRleE9mKHNlcSkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1leHRyYS1ib29sZWFuLWNhc3RcbiAgICAgICAgYW5zaUNvZGVzLnBvcCgpXG4gICAgICAgIHJldHVybiAnPC9zcGFuPidcbiAgICAgIH1cbiAgICAgIC8vIE9wZW4gdGFnLlxuICAgICAgYW5zaUNvZGVzLnB1c2goc2VxKVxuICAgICAgcmV0dXJuIG90WzBdID09PSAnPCcgPyBvdCA6ICc8c3BhbiBzdHlsZT1cIicgKyBvdCArICc7XCI+J1xuICAgIH1cblxuICAgIHZhciBjdCA9IF9jbG9zZVRhZ3Nbc2VxXVxuICAgIGlmIChjdCkge1xuICAgICAgLy8gUG9wIHNlcXVlbmNlXG4gICAgICBhbnNpQ29kZXMucG9wKClcbiAgICAgIHJldHVybiBjdFxuICAgIH1cbiAgICByZXR1cm4gJydcbiAgfSlcblxuICAvLyBNYWtlIHN1cmUgdGFncyBhcmUgY2xvc2VkLlxuICB2YXIgbCA9IGFuc2lDb2Rlcy5sZW5ndGhcbiAgOyhsID4gMCkgJiYgKHJldCArPSBBcnJheShsICsgMSkuam9pbignPC9zcGFuPicpKVxuXG4gIHJldHVybiByZXRcbn1cblxuLyoqXG4gKiBDdXN0b21pemUgY29sb3JzLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbG9ycyByZWZlcmVuY2UgdG8gX2RlZkNvbG9yc1xuICovXG5hbnNpSFRNTC5zZXRDb2xvcnMgPSBmdW5jdGlvbiAoY29sb3JzKSB7XG4gIGlmICh0eXBlb2YgY29sb3JzICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignYGNvbG9yc2AgcGFyYW1ldGVyIG11c3QgYmUgYW4gT2JqZWN0LicpXG4gIH1cblxuICB2YXIgX2ZpbmFsQ29sb3JzID0ge31cbiAgZm9yICh2YXIga2V5IGluIF9kZWZDb2xvcnMpIHtcbiAgICB2YXIgaGV4ID0gY29sb3JzLmhhc093blByb3BlcnR5KGtleSkgPyBjb2xvcnNba2V5XSA6IG51bGxcbiAgICBpZiAoIWhleCkge1xuICAgICAgX2ZpbmFsQ29sb3JzW2tleV0gPSBfZGVmQ29sb3JzW2tleV1cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmICgncmVzZXQnID09PSBrZXkpIHtcbiAgICAgIGlmICh0eXBlb2YgaGV4ID09PSAnc3RyaW5nJykge1xuICAgICAgICBoZXggPSBbaGV4XVxuICAgICAgfVxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGhleCkgfHwgaGV4Lmxlbmd0aCA9PT0gMCB8fCBoZXguc29tZShmdW5jdGlvbiAoaCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGggIT09ICdzdHJpbmcnXG4gICAgICB9KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB2YWx1ZSBvZiBgJyArIGtleSArICdgIHByb3BlcnR5IG11c3QgYmUgYW4gQXJyYXkgYW5kIGVhY2ggaXRlbSBjb3VsZCBvbmx5IGJlIGEgaGV4IHN0cmluZywgZS5nLjogRkYwMDAwJylcbiAgICAgIH1cbiAgICAgIHZhciBkZWZIZXhDb2xvciA9IF9kZWZDb2xvcnNba2V5XVxuICAgICAgaWYgKCFoZXhbMF0pIHtcbiAgICAgICAgaGV4WzBdID0gZGVmSGV4Q29sb3JbMF1cbiAgICAgIH1cbiAgICAgIGlmIChoZXgubGVuZ3RoID09PSAxIHx8ICFoZXhbMV0pIHtcbiAgICAgICAgaGV4ID0gW2hleFswXV1cbiAgICAgICAgaGV4LnB1c2goZGVmSGV4Q29sb3JbMV0pXG4gICAgICB9XG5cbiAgICAgIGhleCA9IGhleC5zbGljZSgwLCAyKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHZhbHVlIG9mIGAnICsga2V5ICsgJ2AgcHJvcGVydHkgbXVzdCBiZSBhIGhleCBzdHJpbmcsIGUuZy46IEZGMDAwMCcpXG4gICAgfVxuICAgIF9maW5hbENvbG9yc1trZXldID0gaGV4XG4gIH1cbiAgX3NldFRhZ3MoX2ZpbmFsQ29sb3JzKVxufVxuXG4vKipcbiAqIFJlc2V0IGNvbG9ycy5cbiAqL1xuYW5zaUhUTUwucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gIF9zZXRUYWdzKF9kZWZDb2xvcnMpXG59XG5cbi8qKlxuICogRXhwb3NlIHRhZ3MsIGluY2x1ZGluZyBvcGVuIGFuZCBjbG9zZS5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmFuc2lIVE1MLnRhZ3MgPSB7fVxuXG5pZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhbnNpSFRNTC50YWdzLCAnb3BlbicsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9vcGVuVGFncyB9XG4gIH0pXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhbnNpSFRNTC50YWdzLCAnY2xvc2UnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBfY2xvc2VUYWdzIH1cbiAgfSlcbn0gZWxzZSB7XG4gIGFuc2lIVE1MLnRhZ3Mub3BlbiA9IF9vcGVuVGFnc1xuICBhbnNpSFRNTC50YWdzLmNsb3NlID0gX2Nsb3NlVGFnc1xufVxuXG5mdW5jdGlvbiBfc2V0VGFncyAoY29sb3JzKSB7XG4gIC8vIHJlc2V0IGFsbFxuICBfb3BlblRhZ3NbJzAnXSA9ICdmb250LXdlaWdodDpub3JtYWw7b3BhY2l0eToxO2NvbG9yOiMnICsgY29sb3JzLnJlc2V0WzBdICsgJztiYWNrZ3JvdW5kOiMnICsgY29sb3JzLnJlc2V0WzFdXG4gIC8vIGludmVyc2VcbiAgX29wZW5UYWdzWyc3J10gPSAnY29sb3I6IycgKyBjb2xvcnMucmVzZXRbMV0gKyAnO2JhY2tncm91bmQ6IycgKyBjb2xvcnMucmVzZXRbMF1cbiAgLy8gZGFyayBncmV5XG4gIF9vcGVuVGFnc1snOTAnXSA9ICdjb2xvcjojJyArIGNvbG9ycy5kYXJrZ3JleVxuXG4gIGZvciAodmFyIGNvZGUgaW4gX3N0eWxlcykge1xuICAgIHZhciBjb2xvciA9IF9zdHlsZXNbY29kZV1cbiAgICB2YXIgb3JpQ29sb3IgPSBjb2xvcnNbY29sb3JdIHx8ICcwMDAnXG4gICAgX29wZW5UYWdzW2NvZGVdID0gJ2NvbG9yOiMnICsgb3JpQ29sb3JcbiAgICBjb2RlID0gcGFyc2VJbnQoY29kZSlcbiAgICBfb3BlblRhZ3NbKGNvZGUgKyAxMCkudG9TdHJpbmcoKV0gPSAnYmFja2dyb3VuZDojJyArIG9yaUNvbG9yXG4gIH1cbn1cblxuYW5zaUhUTUwucmVzZXQoKVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///9\\n\")},function(module,exports,__webpack_require__){\"use strict\";eval(\"\\n\\n// The error overlay is inspired (and mostly copied) from Create React App (https://github.com/facebookincubator/create-react-app)\\n// They, in turn, got inspired by webpack-hot-middleware (https://github.com/glenjamin/webpack-hot-middleware).\\n\\nvar ansiHTML = __webpack_require__(9);\\nvar Entities = __webpack_require__(8).AllHtmlEntities;\\n\\nvar entities = new Entities();\\n\\nvar colors = {\\n  reset: ['transparent', 'transparent'],\\n  black: '181818',\\n  red: 'E36049',\\n  green: 'B3CB74',\\n  yellow: 'FFD080',\\n  blue: '7CAFC2',\\n  magenta: '7FACCA',\\n  cyan: 'C3C2EF',\\n  lightgrey: 'EBE7E3',\\n  darkgrey: '6D7891'\\n};\\nansiHTML.setColors(colors);\\n\\nfunction createOverlayIframe(onIframeLoad) {\\n  var iframe = document.createElement('iframe');\\n  iframe.id = 'webpack-dev-server-client-overlay';\\n  iframe.src = 'about:blank';\\n  iframe.style.position = 'fixed';\\n  iframe.style.left = 0;\\n  iframe.style.top = 0;\\n  iframe.style.right = 0;\\n  iframe.style.bottom = 0;\\n  iframe.style.width = '100vw';\\n  iframe.style.height = '100vh';\\n  iframe.style.border = 'none';\\n  iframe.style.zIndex = 9999999999;\\n  iframe.onload = onIframeLoad;\\n  return iframe;\\n}\\n\\nfunction addOverlayDivTo(iframe) {\\n  var div = iframe.contentDocument.createElement('div');\\n  div.id = 'webpack-dev-server-client-overlay-div';\\n  div.style.position = 'fixed';\\n  div.style.boxSizing = 'border-box';\\n  div.style.left = 0;\\n  div.style.top = 0;\\n  div.style.right = 0;\\n  div.style.bottom = 0;\\n  div.style.width = '100vw';\\n  div.style.height = '100vh';\\n  div.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';\\n  div.style.color = '#E8E8E8';\\n  div.style.fontFamily = 'Menlo, Consolas, monospace';\\n  div.style.fontSize = 'large';\\n  div.style.padding = '2rem';\\n  div.style.lineHeight = '1.2';\\n  div.style.whiteSpace = 'pre-wrap';\\n  div.style.overflow = 'auto';\\n  iframe.contentDocument.body.appendChild(div);\\n  return div;\\n}\\n\\nvar overlayIframe = null;\\nvar overlayDiv = null;\\nvar lastOnOverlayDivReady = null;\\n\\nfunction ensureOverlayDivExists(onOverlayDivReady) {\\n  if (overlayDiv) {\\n    // Everything is ready, call the callback right away.\\n    onOverlayDivReady(overlayDiv);\\n    return;\\n  }\\n\\n  // Creating an iframe may be asynchronous so we'll schedule the callback.\\n  // In case of multiple calls, last callback wins.\\n  lastOnOverlayDivReady = onOverlayDivReady;\\n\\n  if (overlayIframe) {\\n    // We're already creating it.\\n    return;\\n  }\\n\\n  // Create iframe and, when it is ready, a div inside it.\\n  overlayIframe = createOverlayIframe(function () {\\n    overlayDiv = addOverlayDivTo(overlayIframe);\\n    // Now we can talk!\\n    lastOnOverlayDivReady(overlayDiv);\\n  });\\n\\n  // Zalgo alert: onIframeLoad() will be called either synchronously\\n  // or asynchronously depending on the browser.\\n  // We delay adding it so `overlayIframe` is set when `onIframeLoad` fires.\\n  document.body.appendChild(overlayIframe);\\n}\\n\\nfunction showMessageOverlay(message) {\\n  ensureOverlayDivExists(function (div) {\\n    // Make it look similar to our terminal.\\n    div.innerHTML = '<span style=\\\"color: #' + colors.red + '\\\">Failed to compile.</span><br><br>' + ansiHTML(entities.encode(message));\\n  });\\n}\\n\\nfunction destroyErrorOverlay() {\\n  if (!overlayDiv) {\\n    // It is not there in the first place.\\n    return;\\n  }\\n\\n  // Clean up and reset internal state.\\n  document.body.removeChild(overlayIframe);\\n  overlayDiv = null;\\n  overlayIframe = null;\\n  lastOnOverlayDivReady = null;\\n}\\n\\n// Successful compilation.\\nexports.clear = function handleSuccess() {\\n  destroyErrorOverlay();\\n};\\n\\n// Compilation with errors (e.g. syntax error or missing modules).\\nexports.showMessage = function handleMessage(messages) {\\n  showMessageOverlay(messages[0]);\\n};//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50L292ZXJsYXkuanM/MmFjNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gVGhlIGVycm9yIG92ZXJsYXkgaXMgaW5zcGlyZWQgKGFuZCBtb3N0bHkgY29waWVkKSBmcm9tIENyZWF0ZSBSZWFjdCBBcHAgKGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9va2luY3ViYXRvci9jcmVhdGUtcmVhY3QtYXBwKVxuLy8gVGhleSwgaW4gdHVybiwgZ290IGluc3BpcmVkIGJ5IHdlYnBhY2staG90LW1pZGRsZXdhcmUgKGh0dHBzOi8vZ2l0aHViLmNvbS9nbGVuamFtaW4vd2VicGFjay1ob3QtbWlkZGxld2FyZSkuXG5cbnZhciBhbnNpSFRNTCA9IHJlcXVpcmUoJ2Fuc2ktaHRtbCcpO1xudmFyIEVudGl0aWVzID0gcmVxdWlyZSgnaHRtbC1lbnRpdGllcycpLkFsbEh0bWxFbnRpdGllcztcblxudmFyIGVudGl0aWVzID0gbmV3IEVudGl0aWVzKCk7XG5cbnZhciBjb2xvcnMgPSB7XG4gIHJlc2V0OiBbJ3RyYW5zcGFyZW50JywgJ3RyYW5zcGFyZW50J10sXG4gIGJsYWNrOiAnMTgxODE4JyxcbiAgcmVkOiAnRTM2MDQ5JyxcbiAgZ3JlZW46ICdCM0NCNzQnLFxuICB5ZWxsb3c6ICdGRkQwODAnLFxuICBibHVlOiAnN0NBRkMyJyxcbiAgbWFnZW50YTogJzdGQUNDQScsXG4gIGN5YW46ICdDM0MyRUYnLFxuICBsaWdodGdyZXk6ICdFQkU3RTMnLFxuICBkYXJrZ3JleTogJzZENzg5MSdcbn07XG5hbnNpSFRNTC5zZXRDb2xvcnMoY29sb3JzKTtcblxuZnVuY3Rpb24gY3JlYXRlT3ZlcmxheUlmcmFtZShvbklmcmFtZUxvYWQpIHtcbiAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICBpZnJhbWUuaWQgPSAnd2VicGFjay1kZXYtc2VydmVyLWNsaWVudC1vdmVybGF5JztcbiAgaWZyYW1lLnNyYyA9ICdhYm91dDpibGFuayc7XG4gIGlmcmFtZS5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gIGlmcmFtZS5zdHlsZS5sZWZ0ID0gMDtcbiAgaWZyYW1lLnN0eWxlLnRvcCA9IDA7XG4gIGlmcmFtZS5zdHlsZS5yaWdodCA9IDA7XG4gIGlmcmFtZS5zdHlsZS5ib3R0b20gPSAwO1xuICBpZnJhbWUuc3R5bGUud2lkdGggPSAnMTAwdncnO1xuICBpZnJhbWUuc3R5bGUuaGVpZ2h0ID0gJzEwMHZoJztcbiAgaWZyYW1lLnN0eWxlLmJvcmRlciA9ICdub25lJztcbiAgaWZyYW1lLnN0eWxlLnpJbmRleCA9IDk5OTk5OTk5OTk7XG4gIGlmcmFtZS5vbmxvYWQgPSBvbklmcmFtZUxvYWQ7XG4gIHJldHVybiBpZnJhbWU7XG59XG5cbmZ1bmN0aW9uIGFkZE92ZXJsYXlEaXZUbyhpZnJhbWUpIHtcbiAgdmFyIGRpdiA9IGlmcmFtZS5jb250ZW50RG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi5pZCA9ICd3ZWJwYWNrLWRldi1zZXJ2ZXItY2xpZW50LW92ZXJsYXktZGl2JztcbiAgZGl2LnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgZGl2LnN0eWxlLmJveFNpemluZyA9ICdib3JkZXItYm94JztcbiAgZGl2LnN0eWxlLmxlZnQgPSAwO1xuICBkaXYuc3R5bGUudG9wID0gMDtcbiAgZGl2LnN0eWxlLnJpZ2h0ID0gMDtcbiAgZGl2LnN0eWxlLmJvdHRvbSA9IDA7XG4gIGRpdi5zdHlsZS53aWR0aCA9ICcxMDB2dyc7XG4gIGRpdi5zdHlsZS5oZWlnaHQgPSAnMTAwdmgnO1xuICBkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoMCwgMCwgMCwgMC44NSknO1xuICBkaXYuc3R5bGUuY29sb3IgPSAnI0U4RThFOCc7XG4gIGRpdi5zdHlsZS5mb250RmFtaWx5ID0gJ01lbmxvLCBDb25zb2xhcywgbW9ub3NwYWNlJztcbiAgZGl2LnN0eWxlLmZvbnRTaXplID0gJ2xhcmdlJztcbiAgZGl2LnN0eWxlLnBhZGRpbmcgPSAnMnJlbSc7XG4gIGRpdi5zdHlsZS5saW5lSGVpZ2h0ID0gJzEuMic7XG4gIGRpdi5zdHlsZS53aGl0ZVNwYWNlID0gJ3ByZS13cmFwJztcbiAgZGl2LnN0eWxlLm92ZXJmbG93ID0gJ2F1dG8nO1xuICBpZnJhbWUuY29udGVudERvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgcmV0dXJuIGRpdjtcbn1cblxudmFyIG92ZXJsYXlJZnJhbWUgPSBudWxsO1xudmFyIG92ZXJsYXlEaXYgPSBudWxsO1xudmFyIGxhc3RPbk92ZXJsYXlEaXZSZWFkeSA9IG51bGw7XG5cbmZ1bmN0aW9uIGVuc3VyZU92ZXJsYXlEaXZFeGlzdHMob25PdmVybGF5RGl2UmVhZHkpIHtcbiAgaWYgKG92ZXJsYXlEaXYpIHtcbiAgICAvLyBFdmVyeXRoaW5nIGlzIHJlYWR5LCBjYWxsIHRoZSBjYWxsYmFjayByaWdodCBhd2F5LlxuICAgIG9uT3ZlcmxheURpdlJlYWR5KG92ZXJsYXlEaXYpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIENyZWF0aW5nIGFuIGlmcmFtZSBtYXkgYmUgYXN5bmNocm9ub3VzIHNvIHdlJ2xsIHNjaGVkdWxlIHRoZSBjYWxsYmFjay5cbiAgLy8gSW4gY2FzZSBvZiBtdWx0aXBsZSBjYWxscywgbGFzdCBjYWxsYmFjayB3aW5zLlxuICBsYXN0T25PdmVybGF5RGl2UmVhZHkgPSBvbk92ZXJsYXlEaXZSZWFkeTtcblxuICBpZiAob3ZlcmxheUlmcmFtZSkge1xuICAgIC8vIFdlJ3JlIGFscmVhZHkgY3JlYXRpbmcgaXQuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGlmcmFtZSBhbmQsIHdoZW4gaXQgaXMgcmVhZHksIGEgZGl2IGluc2lkZSBpdC5cbiAgb3ZlcmxheUlmcmFtZSA9IGNyZWF0ZU92ZXJsYXlJZnJhbWUoZnVuY3Rpb24gKCkge1xuICAgIG92ZXJsYXlEaXYgPSBhZGRPdmVybGF5RGl2VG8ob3ZlcmxheUlmcmFtZSk7XG4gICAgLy8gTm93IHdlIGNhbiB0YWxrIVxuICAgIGxhc3RPbk92ZXJsYXlEaXZSZWFkeShvdmVybGF5RGl2KTtcbiAgfSk7XG5cbiAgLy8gWmFsZ28gYWxlcnQ6IG9uSWZyYW1lTG9hZCgpIHdpbGwgYmUgY2FsbGVkIGVpdGhlciBzeW5jaHJvbm91c2x5XG4gIC8vIG9yIGFzeW5jaHJvbm91c2x5IGRlcGVuZGluZyBvbiB0aGUgYnJvd3Nlci5cbiAgLy8gV2UgZGVsYXkgYWRkaW5nIGl0IHNvIGBvdmVybGF5SWZyYW1lYCBpcyBzZXQgd2hlbiBgb25JZnJhbWVMb2FkYCBmaXJlcy5cbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvdmVybGF5SWZyYW1lKTtcbn1cblxuZnVuY3Rpb24gc2hvd01lc3NhZ2VPdmVybGF5KG1lc3NhZ2UpIHtcbiAgZW5zdXJlT3ZlcmxheURpdkV4aXN0cyhmdW5jdGlvbiAoZGl2KSB7XG4gICAgLy8gTWFrZSBpdCBsb29rIHNpbWlsYXIgdG8gb3VyIHRlcm1pbmFsLlxuICAgIGRpdi5pbm5lckhUTUwgPSAnPHNwYW4gc3R5bGU9XCJjb2xvcjogIycgKyBjb2xvcnMucmVkICsgJ1wiPkZhaWxlZCB0byBjb21waWxlLjwvc3Bhbj48YnI+PGJyPicgKyBhbnNpSFRNTChlbnRpdGllcy5lbmNvZGUobWVzc2FnZSkpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVzdHJveUVycm9yT3ZlcmxheSgpIHtcbiAgaWYgKCFvdmVybGF5RGl2KSB7XG4gICAgLy8gSXQgaXMgbm90IHRoZXJlIGluIHRoZSBmaXJzdCBwbGFjZS5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBDbGVhbiB1cCBhbmQgcmVzZXQgaW50ZXJuYWwgc3RhdGUuXG4gIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQob3ZlcmxheUlmcmFtZSk7XG4gIG92ZXJsYXlEaXYgPSBudWxsO1xuICBvdmVybGF5SWZyYW1lID0gbnVsbDtcbiAgbGFzdE9uT3ZlcmxheURpdlJlYWR5ID0gbnVsbDtcbn1cblxuLy8gU3VjY2Vzc2Z1bCBjb21waWxhdGlvbi5cbmV4cG9ydHMuY2xlYXIgPSBmdW5jdGlvbiBoYW5kbGVTdWNjZXNzKCkge1xuICBkZXN0cm95RXJyb3JPdmVybGF5KCk7XG59O1xuXG4vLyBDb21waWxhdGlvbiB3aXRoIGVycm9ycyAoZS5nLiBzeW50YXggZXJyb3Igb3IgbWlzc2luZyBtb2R1bGVzKS5cbmV4cG9ydHMuc2hvd01lc3NhZ2UgPSBmdW5jdGlvbiBoYW5kbGVNZXNzYWdlKG1lc3NhZ2VzKSB7XG4gIHNob3dNZXNzYWdlT3ZlcmxheShtZXNzYWdlc1swXSk7XG59OyJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///10\\n\")},function(module,exports,__webpack_require__){eval(\"/* WEBPACK VAR INJECTION */(function(global) {var require;var require;/* sockjs-client v1.1.4 | http://sockjs.org | MIT license */\\n(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\\\"function\\\"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error(\\\"Cannot find module '\\\"+o+\\\"'\\\");throw f.code=\\\"MODULE_NOT_FOUND\\\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\\\"function\\\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\\n(function (global){\\n'use strict';\\n\\nvar transportList = require('./transport-list');\\n\\nmodule.exports = require('./main')(transportList);\\n\\n// TODO can't get rid of this until all servers do\\nif ('_sockjs_onload' in global) {\\n  setTimeout(global._sockjs_onload, 1);\\n}\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n\\n},{\\\"./main\\\":14,\\\"./transport-list\\\":16}],2:[function(require,module,exports){\\n'use strict';\\n\\nvar inherits = require('inherits')\\n  , Event = require('./event')\\n  ;\\n\\nfunction CloseEvent() {\\n  Event.call(this);\\n  this.initEvent('close', false, false);\\n  this.wasClean = false;\\n  this.code = 0;\\n  this.reason = '';\\n}\\n\\ninherits(CloseEvent, Event);\\n\\nmodule.exports = CloseEvent;\\n\\n},{\\\"./event\\\":4,\\\"inherits\\\":57}],3:[function(require,module,exports){\\n'use strict';\\n\\nvar inherits = require('inherits')\\n  , EventTarget = require('./eventtarget')\\n  ;\\n\\nfunction EventEmitter() {\\n  EventTarget.call(this);\\n}\\n\\ninherits(EventEmitter, EventTarget);\\n\\nEventEmitter.prototype.removeAllListeners = function(type) {\\n  if (type) {\\n    delete this._listeners[type];\\n  } else {\\n    this._listeners = {};\\n  }\\n};\\n\\nEventEmitter.prototype.once = function(type, listener) {\\n  var self = this\\n    , fired = false;\\n\\n  function g() {\\n    self.removeListener(type, g);\\n\\n    if (!fired) {\\n      fired = true;\\n      listener.apply(this, arguments);\\n    }\\n  }\\n\\n  this.on(type, g);\\n};\\n\\nEventEmitter.prototype.emit = function() {\\n  var type = arguments[0];\\n  var listeners = this._listeners[type];\\n  if (!listeners) {\\n    return;\\n  }\\n  // equivalent of Array.prototype.slice.call(arguments, 1);\\n  var l = arguments.length;\\n  var args = new Array(l - 1);\\n  for (var ai = 1; ai < l; ai++) {\\n    args[ai - 1] = arguments[ai];\\n  }\\n  for (var i = 0; i < listeners.length; i++) {\\n    listeners[i].apply(this, args);\\n  }\\n};\\n\\nEventEmitter.prototype.on = EventEmitter.prototype.addListener = EventTarget.prototype.addEventListener;\\nEventEmitter.prototype.removeListener = EventTarget.prototype.removeEventListener;\\n\\nmodule.exports.EventEmitter = EventEmitter;\\n\\n},{\\\"./eventtarget\\\":5,\\\"inherits\\\":57}],4:[function(require,module,exports){\\n'use strict';\\n\\nfunction Event(eventType) {\\n  this.type = eventType;\\n}\\n\\nEvent.prototype.initEvent = function(eventType, canBubble, cancelable) {\\n  this.type = eventType;\\n  this.bubbles = canBubble;\\n  this.cancelable = cancelable;\\n  this.timeStamp = +new Date();\\n  return this;\\n};\\n\\nEvent.prototype.stopPropagation = function() {};\\nEvent.prototype.preventDefault = function() {};\\n\\nEvent.CAPTURING_PHASE = 1;\\nEvent.AT_TARGET = 2;\\nEvent.BUBBLING_PHASE = 3;\\n\\nmodule.exports = Event;\\n\\n},{}],5:[function(require,module,exports){\\n'use strict';\\n\\n/* Simplified implementation of DOM2 EventTarget.\\n *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget\\n */\\n\\nfunction EventTarget() {\\n  this._listeners = {};\\n}\\n\\nEventTarget.prototype.addEventListener = function(eventType, listener) {\\n  if (!(eventType in this._listeners)) {\\n    this._listeners[eventType] = [];\\n  }\\n  var arr = this._listeners[eventType];\\n  // #4\\n  if (arr.indexOf(listener) === -1) {\\n    // Make a copy so as not to interfere with a current dispatchEvent.\\n    arr = arr.concat([listener]);\\n  }\\n  this._listeners[eventType] = arr;\\n};\\n\\nEventTarget.prototype.removeEventListener = function(eventType, listener) {\\n  var arr = this._listeners[eventType];\\n  if (!arr) {\\n    return;\\n  }\\n  var idx = arr.indexOf(listener);\\n  if (idx !== -1) {\\n    if (arr.length > 1) {\\n      // Make a copy so as not to interfere with a current dispatchEvent.\\n      this._listeners[eventType] = arr.slice(0, idx).concat(arr.slice(idx + 1));\\n    } else {\\n      delete this._listeners[eventType];\\n    }\\n    return;\\n  }\\n};\\n\\nEventTarget.prototype.dispatchEvent = function() {\\n  var event = arguments[0];\\n  var t = event.type;\\n  // equivalent of Array.prototype.slice.call(arguments, 0);\\n  var args = arguments.length === 1 ? [event] : Array.apply(null, arguments);\\n  // TODO: This doesn't match the real behavior; per spec, onfoo get\\n  // their place in line from the /first/ time they're set from\\n  // non-null. Although WebKit bumps it to the end every time it's\\n  // set.\\n  if (this['on' + t]) {\\n    this['on' + t].apply(this, args);\\n  }\\n  if (t in this._listeners) {\\n    // Grab a reference to the listeners list. removeEventListener may alter the list.\\n    var listeners = this._listeners[t];\\n    for (var i = 0; i < listeners.length; i++) {\\n      listeners[i].apply(this, args);\\n    }\\n  }\\n};\\n\\nmodule.exports = EventTarget;\\n\\n},{}],6:[function(require,module,exports){\\n'use strict';\\n\\nvar inherits = require('inherits')\\n  , Event = require('./event')\\n  ;\\n\\nfunction TransportMessageEvent(data) {\\n  Event.call(this);\\n  this.initEvent('message', false, false);\\n  this.data = data;\\n}\\n\\ninherits(TransportMessageEvent, Event);\\n\\nmodule.exports = TransportMessageEvent;\\n\\n},{\\\"./event\\\":4,\\\"inherits\\\":57}],7:[function(require,module,exports){\\n'use strict';\\n\\nvar JSON3 = require('json3')\\n  , iframeUtils = require('./utils/iframe')\\n  ;\\n\\nfunction FacadeJS(transport) {\\n  this._transport = transport;\\n  transport.on('message', this._transportMessage.bind(this));\\n  transport.on('close', this._transportClose.bind(this));\\n}\\n\\nFacadeJS.prototype._transportClose = function(code, reason) {\\n  iframeUtils.postMessage('c', JSON3.stringify([code, reason]));\\n};\\nFacadeJS.prototype._transportMessage = function(frame) {\\n  iframeUtils.postMessage('t', frame);\\n};\\nFacadeJS.prototype._send = function(data) {\\n  this._transport.send(data);\\n};\\nFacadeJS.prototype._close = function() {\\n  this._transport.close();\\n  this._transport.removeAllListeners();\\n};\\n\\nmodule.exports = FacadeJS;\\n\\n},{\\\"./utils/iframe\\\":47,\\\"json3\\\":58}],8:[function(require,module,exports){\\n(function (process){\\n'use strict';\\n\\nvar urlUtils = require('./utils/url')\\n  , eventUtils = require('./utils/event')\\n  , JSON3 = require('json3')\\n  , FacadeJS = require('./facade')\\n  , InfoIframeReceiver = require('./info-iframe-receiver')\\n  , iframeUtils = require('./utils/iframe')\\n  , loc = require('./location')\\n  ;\\n\\nvar debug = function() {};\\nif (process.env.NODE_ENV !== 'production') {\\n  debug = require('debug')('sockjs-client:iframe-bootstrap');\\n}\\n\\nmodule.exports = function(SockJS, availableTransports) {\\n  var transportMap = {};\\n  availableTransports.forEach(function(at) {\\n    if (at.facadeTransport) {\\n      transportMap[at.facadeTransport.transportName] = at.facadeTransport;\\n    }\\n  });\\n\\n  // hard-coded for the info iframe\\n  // TODO see if we can make this more dynamic\\n  transportMap[InfoIframeReceiver.transportName] = InfoIframeReceiver;\\n  var parentOrigin;\\n\\n  /* eslint-disable camelcase */\\n  SockJS.bootstrap_iframe = function() {\\n    /* eslint-enable camelcase */\\n    var facade;\\n    iframeUtils.currentWindowId = loc.hash.slice(1);\\n    var onMessage = function(e) {\\n      if (e.source !== parent) {\\n        return;\\n      }\\n      if (typeof parentOrigin === 'undefined') {\\n        parentOrigin = e.origin;\\n      }\\n      if (e.origin !== parentOrigin) {\\n        return;\\n      }\\n\\n      var iframeMessage;\\n      try {\\n        iframeMessage = JSON3.parse(e.data);\\n      } catch (ignored) {\\n        debug('bad json', e.data);\\n        return;\\n      }\\n\\n      if (iframeMessage.windowId !== iframeUtils.currentWindowId) {\\n        return;\\n      }\\n      switch (iframeMessage.type) {\\n      case 's':\\n        var p;\\n        try {\\n          p = JSON3.parse(iframeMessage.data);\\n        } catch (ignored) {\\n          debug('bad json', iframeMessage.data);\\n          break;\\n        }\\n        var version = p[0];\\n        var transport = p[1];\\n        var transUrl = p[2];\\n        var baseUrl = p[3];\\n        debug(version, transport, transUrl, baseUrl);\\n        // change this to semver logic\\n        if (version !== SockJS.version) {\\n          throw new Error('Incompatible SockJS! Main site uses:' +\\n                    ' \\\"' + version + '\\\", the iframe:' +\\n                    ' \\\"' + SockJS.version + '\\\".');\\n        }\\n\\n        if (!urlUtils.isOriginEqual(transUrl, loc.href) ||\\n            !urlUtils.isOriginEqual(baseUrl, loc.href)) {\\n          throw new Error('Can\\\\'t connect to different domain from within an ' +\\n                    'iframe. (' + loc.href + ', ' + transUrl + ', ' + baseUrl + ')');\\n        }\\n        facade = new FacadeJS(new transportMap[transport](transUrl, baseUrl));\\n        break;\\n      case 'm':\\n        facade._send(iframeMessage.data);\\n        break;\\n      case 'c':\\n        if (facade) {\\n          facade._close();\\n        }\\n        facade = null;\\n        break;\\n      }\\n    };\\n\\n    eventUtils.attachEvent('message', onMessage);\\n\\n    // Start\\n    iframeUtils.postMessage('s');\\n  };\\n};\\n\\n}).call(this,{ env: {} })\\n\\n},{\\\"./facade\\\":7,\\\"./info-iframe-receiver\\\":10,\\\"./location\\\":13,\\\"./utils/event\\\":46,\\\"./utils/iframe\\\":47,\\\"./utils/url\\\":52,\\\"debug\\\":55,\\\"json3\\\":58}],9:[function(require,module,exports){\\n(function (process){\\n'use strict';\\n\\nvar EventEmitter = require('events').EventEmitter\\n  , inherits = require('inherits')\\n  , JSON3 = require('json3')\\n  , objectUtils = require('./utils/object')\\n  ;\\n\\nvar debug = function() {};\\nif (process.env.NODE_ENV !== 'production') {\\n  debug = require('debug')('sockjs-client:info-ajax');\\n}\\n\\nfunction InfoAjax(url, AjaxObject) {\\n  EventEmitter.call(this);\\n\\n  var self = this;\\n  var t0 = +new Date();\\n  this.xo = new AjaxObject('GET', url);\\n\\n  this.xo.once('finish', function(status, text) {\\n    var info, rtt;\\n    if (status === 200) {\\n      rtt = (+new Date()) - t0;\\n      if (text) {\\n        try {\\n          info = JSON3.parse(text);\\n        } catch (e) {\\n          debug('bad json', text);\\n        }\\n      }\\n\\n      if (!objectUtils.isObject(info)) {\\n        info = {};\\n      }\\n    }\\n    self.emit('finish', info, rtt);\\n    self.removeAllListeners();\\n  });\\n}\\n\\ninherits(InfoAjax, EventEmitter);\\n\\nInfoAjax.prototype.close = function() {\\n  this.removeAllListeners();\\n  this.xo.close();\\n};\\n\\nmodule.exports = InfoAjax;\\n\\n}).call(this,{ env: {} })\\n\\n},{\\\"./utils/object\\\":49,\\\"debug\\\":55,\\\"events\\\":3,\\\"inherits\\\":57,\\\"json3\\\":58}],10:[function(require,module,exports){\\n'use strict';\\n\\nvar inherits = require('inherits')\\n  , EventEmitter = require('events').EventEmitter\\n  , JSON3 = require('json3')\\n  , XHRLocalObject = require('./transport/sender/xhr-local')\\n  , InfoAjax = require('./info-ajax')\\n  ;\\n\\nfunction InfoReceiverIframe(transUrl) {\\n  var self = this;\\n  EventEmitter.call(this);\\n\\n  this.ir = new InfoAjax(transUrl, XHRLocalObject);\\n  this.ir.once('finish', function(info, rtt) {\\n    self.ir = null;\\n    self.emit('message', JSON3.stringify([info, rtt]));\\n  });\\n}\\n\\ninherits(InfoReceiverIframe, EventEmitter);\\n\\nInfoReceiverIframe.transportName = 'iframe-info-receiver';\\n\\nInfoReceiverIframe.prototype.close = function() {\\n  if (this.ir) {\\n    this.ir.close();\\n    this.ir = null;\\n  }\\n  this.removeAllListeners();\\n};\\n\\nmodule.exports = InfoReceiverIframe;\\n\\n},{\\\"./info-ajax\\\":9,\\\"./transport/sender/xhr-local\\\":37,\\\"events\\\":3,\\\"inherits\\\":57,\\\"json3\\\":58}],11:[function(require,module,exports){\\n(function (process,global){\\n'use strict';\\n\\nvar EventEmitter = require('events').EventEmitter\\n  , inherits = require('inherits')\\n  , JSON3 = require('json3')\\n  , utils = require('./utils/event')\\n  , IframeTransport = require('./transport/iframe')\\n  , InfoReceiverIframe = require('./info-iframe-receiver')\\n  ;\\n\\nvar debug = function() {};\\nif (process.env.NODE_ENV !== 'production') {\\n  debug = require('debug')('sockjs-client:info-iframe');\\n}\\n\\nfunction InfoIframe(baseUrl, url) {\\n  var self = this;\\n  EventEmitter.call(this);\\n\\n  var go = function() {\\n    var ifr = self.ifr = new IframeTransport(InfoReceiverIframe.transportName, url, baseUrl);\\n\\n    ifr.once('message', function(msg) {\\n      if (msg) {\\n        var d;\\n        try {\\n          d = JSON3.parse(msg);\\n        } catch (e) {\\n          debug('bad json', msg);\\n          self.emit('finish');\\n          self.close();\\n          return;\\n        }\\n\\n        var info = d[0], rtt = d[1];\\n        self.emit('finish', info, rtt);\\n      }\\n      self.close();\\n    });\\n\\n    ifr.once('close', function() {\\n      self.emit('finish');\\n      self.close();\\n    });\\n  };\\n\\n  // TODO this seems the same as the 'needBody' from transports\\n  if (!global.document.body) {\\n    utils.attachEvent('load', go);\\n  } else {\\n    go();\\n  }\\n}\\n\\ninherits(InfoIframe, EventEmitter);\\n\\nInfoIframe.enabled = function() {\\n  return IframeTransport.enabled();\\n};\\n\\nInfoIframe.prototype.close = function() {\\n  if (this.ifr) {\\n    this.ifr.close();\\n  }\\n  this.removeAllListeners();\\n  this.ifr = null;\\n};\\n\\nmodule.exports = InfoIframe;\\n\\n}).call(this,{ env: {} },typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n\\n},{\\\"./info-iframe-receiver\\\":10,\\\"./transport/iframe\\\":22,\\\"./utils/event\\\":46,\\\"debug\\\":55,\\\"events\\\":3,\\\"inherits\\\":57,\\\"json3\\\":58}],12:[function(require,module,exports){\\n(function (process){\\n'use strict';\\n\\nvar EventEmitter = require('events').EventEmitter\\n  , inherits = require('inherits')\\n  , urlUtils = require('./utils/url')\\n  , XDR = require('./transport/sender/xdr')\\n  , XHRCors = require('./transport/sender/xhr-cors')\\n  , XHRLocal = require('./transport/sender/xhr-local')\\n  , XHRFake = require('./transport/sender/xhr-fake')\\n  , InfoIframe = require('./info-iframe')\\n  , InfoAjax = require('./info-ajax')\\n  ;\\n\\nvar debug = function() {};\\nif (process.env.NODE_ENV !== 'production') {\\n  debug = require('debug')('sockjs-client:info-receiver');\\n}\\n\\nfunction InfoReceiver(baseUrl, urlInfo) {\\n  debug(baseUrl);\\n  var self = this;\\n  EventEmitter.call(this);\\n\\n  setTimeout(function() {\\n    self.doXhr(baseUrl, urlInfo);\\n  }, 0);\\n}\\n\\ninherits(InfoReceiver, EventEmitter);\\n\\n// TODO this is currently ignoring the list of available transports and the whitelist\\n\\nInfoReceiver._getReceiver = function(baseUrl, url, urlInfo) {\\n  // determine method of CORS support (if needed)\\n  if (urlInfo.sameOrigin) {\\n    return new InfoAjax(url, XHRLocal);\\n  }\\n  if (XHRCors.enabled) {\\n    return new InfoAjax(url, XHRCors);\\n  }\\n  if (XDR.enabled && urlInfo.sameScheme) {\\n    return new InfoAjax(url, XDR);\\n  }\\n  if (InfoIframe.enabled()) {\\n    return new InfoIframe(baseUrl, url);\\n  }\\n  return new InfoAjax(url, XHRFake);\\n};\\n\\nInfoReceiver.prototype.doXhr = function(baseUrl, urlInfo) {\\n  var self = this\\n    , url = urlUtils.addPath(baseUrl, '/info')\\n    ;\\n  debug('doXhr', url);\\n\\n  this.xo = InfoReceiver._getReceiver(baseUrl, url, urlInfo);\\n\\n  this.timeoutRef = setTimeout(function() {\\n    debug('timeout');\\n    self._cleanup(false);\\n    self.emit('finish');\\n  }, InfoReceiver.timeout);\\n\\n  this.xo.once('finish', function(info, rtt) {\\n    debug('finish', info, rtt);\\n    self._cleanup(true);\\n    self.emit('finish', info, rtt);\\n  });\\n};\\n\\nInfoReceiver.prototype._cleanup = function(wasClean) {\\n  debug('_cleanup');\\n  clearTimeout(this.timeoutRef);\\n  this.timeoutRef = null;\\n  if (!wasClean && this.xo) {\\n    this.xo.close();\\n  }\\n  this.xo = null;\\n};\\n\\nInfoReceiver.prototype.close = function() {\\n  debug('close');\\n  this.removeAllListeners();\\n  this._cleanup(false);\\n};\\n\\nInfoReceiver.timeout = 8000;\\n\\nmodule.exports = InfoReceiver;\\n\\n}).call(this,{ env: {} })\\n\\n},{\\\"./info-ajax\\\":9,\\\"./info-iframe\\\":11,\\\"./transport/sender/xdr\\\":34,\\\"./transport/sender/xhr-cors\\\":35,\\\"./transport/sender/xhr-fake\\\":36,\\\"./transport/sender/xhr-local\\\":37,\\\"./utils/url\\\":52,\\\"debug\\\":55,\\\"events\\\":3,\\\"inherits\\\":57}],13:[function(require,module,exports){\\n(function (global){\\n'use strict';\\n\\nmodule.exports = global.location || {\\n  origin: 'http://localhost:80'\\n, protocol: 'http'\\n, host: 'localhost'\\n, port: 80\\n, href: 'http://localhost/'\\n, hash: ''\\n};\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n\\n},{}],14:[function(require,module,exports){\\n(function (process,global){\\n'use strict';\\n\\nrequire('./shims');\\n\\nvar URL = require('url-parse')\\n  , inherits = require('inherits')\\n  , JSON3 = require('json3')\\n  , random = require('./utils/random')\\n  , escape = require('./utils/escape')\\n  , urlUtils = require('./utils/url')\\n  , eventUtils = require('./utils/event')\\n  , transport = require('./utils/transport')\\n  , objectUtils = require('./utils/object')\\n  , browser = require('./utils/browser')\\n  , log = require('./utils/log')\\n  , Event = require('./event/event')\\n  , EventTarget = require('./event/eventtarget')\\n  , loc = require('./location')\\n  , CloseEvent = require('./event/close')\\n  , TransportMessageEvent = require('./event/trans-message')\\n  , InfoReceiver = require('./info-receiver')\\n  ;\\n\\nvar debug = function() {};\\nif (process.env.NODE_ENV !== 'production') {\\n  debug = require('debug')('sockjs-client:main');\\n}\\n\\nvar transports;\\n\\n// follow constructor steps defined at http://dev.w3.org/html5/websockets/#the-websocket-interface\\nfunction SockJS(url, protocols, options) {\\n  if (!(this instanceof SockJS)) {\\n    return new SockJS(url, protocols, options);\\n  }\\n  if (arguments.length < 1) {\\n    throw new TypeError(\\\"Failed to construct 'SockJS: 1 argument required, but only 0 present\\\");\\n  }\\n  EventTarget.call(this);\\n\\n  this.readyState = SockJS.CONNECTING;\\n  this.extensions = '';\\n  this.protocol = '';\\n\\n  // non-standard extension\\n  options = options || {};\\n  if (options.protocols_whitelist) {\\n    log.warn(\\\"'protocols_whitelist' is DEPRECATED. Use 'transports' instead.\\\");\\n  }\\n  this._transportsWhitelist = options.transports;\\n  this._transportOptions = options.transportOptions || {};\\n\\n  var sessionId = options.sessionId || 8;\\n  if (typeof sessionId === 'function') {\\n    this._generateSessionId = sessionId;\\n  } else if (typeof sessionId === 'number') {\\n    this._generateSessionId = function() {\\n      return random.string(sessionId);\\n    };\\n  } else {\\n    throw new TypeError('If sessionId is used in the options, it needs to be a number or a function.');\\n  }\\n\\n  this._server = options.server || random.numberString(1000);\\n\\n  // Step 1 of WS spec - parse and validate the url. Issue #8\\n  var parsedUrl = new URL(url);\\n  if (!parsedUrl.host || !parsedUrl.protocol) {\\n    throw new SyntaxError(\\\"The URL '\\\" + url + \\\"' is invalid\\\");\\n  } else if (parsedUrl.hash) {\\n    throw new SyntaxError('The URL must not contain a fragment');\\n  } else if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {\\n    throw new SyntaxError(\\\"The URL's scheme must be either 'http:' or 'https:'. '\\\" + parsedUrl.protocol + \\\"' is not allowed.\\\");\\n  }\\n\\n  var secure = parsedUrl.protocol === 'https:';\\n  // Step 2 - don't allow secure origin with an insecure protocol\\n  if (loc.protocol === 'https' && !secure) {\\n    throw new Error('SecurityError: An insecure SockJS connection may not be initiated from a page loaded over HTTPS');\\n  }\\n\\n  // Step 3 - check port access - no need here\\n  // Step 4 - parse protocols argument\\n  if (!protocols) {\\n    protocols = [];\\n  } else if (!Array.isArray(protocols)) {\\n    protocols = [protocols];\\n  }\\n\\n  // Step 5 - check protocols argument\\n  var sortedProtocols = protocols.sort();\\n  sortedProtocols.forEach(function(proto, i) {\\n    if (!proto) {\\n      throw new SyntaxError(\\\"The protocols entry '\\\" + proto + \\\"' is invalid.\\\");\\n    }\\n    if (i < (sortedProtocols.length - 1) && proto === sortedProtocols[i + 1]) {\\n      throw new SyntaxError(\\\"The protocols entry '\\\" + proto + \\\"' is duplicated.\\\");\\n    }\\n  });\\n\\n  // Step 6 - convert origin\\n  var o = urlUtils.getOrigin(loc.href);\\n  this._origin = o ? o.toLowerCase() : null;\\n\\n  // remove the trailing slash\\n  parsedUrl.set('pathname', parsedUrl.pathname.replace(/\\\\/+$/, ''));\\n\\n  // store the sanitized url\\n  this.url = parsedUrl.href;\\n  debug('using url', this.url);\\n\\n  // Step 7 - start connection in background\\n  // obtain server info\\n  // http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html#section-26\\n  this._urlInfo = {\\n    nullOrigin: !browser.hasDomain()\\n  , sameOrigin: urlUtils.isOriginEqual(this.url, loc.href)\\n  , sameScheme: urlUtils.isSchemeEqual(this.url, loc.href)\\n  };\\n\\n  this._ir = new InfoReceiver(this.url, this._urlInfo);\\n  this._ir.once('finish', this._receiveInfo.bind(this));\\n}\\n\\ninherits(SockJS, EventTarget);\\n\\nfunction userSetCode(code) {\\n  return code === 1000 || (code >= 3000 && code <= 4999);\\n}\\n\\nSockJS.prototype.close = function(code, reason) {\\n  // Step 1\\n  if (code && !userSetCode(code)) {\\n    throw new Error('InvalidAccessError: Invalid code');\\n  }\\n  // Step 2.4 states the max is 123 bytes, but we are just checking length\\n  if (reason && reason.length > 123) {\\n    throw new SyntaxError('reason argument has an invalid length');\\n  }\\n\\n  // Step 3.1\\n  if (this.readyState === SockJS.CLOSING || this.readyState === SockJS.CLOSED) {\\n    return;\\n  }\\n\\n  // TODO look at docs to determine how to set this\\n  var wasClean = true;\\n  this._close(code || 1000, reason || 'Normal closure', wasClean);\\n};\\n\\nSockJS.prototype.send = function(data) {\\n  // #13 - convert anything non-string to string\\n  // TODO this currently turns objects into [object Object]\\n  if (typeof data !== 'string') {\\n    data = '' + data;\\n  }\\n  if (this.readyState === SockJS.CONNECTING) {\\n    throw new Error('InvalidStateError: The connection has not been established yet');\\n  }\\n  if (this.readyState !== SockJS.OPEN) {\\n    return;\\n  }\\n  this._transport.send(escape.quote(data));\\n};\\n\\nSockJS.version = require('./version');\\n\\nSockJS.CONNECTING = 0;\\nSockJS.OPEN = 1;\\nSockJS.CLOSING = 2;\\nSockJS.CLOSED = 3;\\n\\nSockJS.prototype._receiveInfo = function(info, rtt) {\\n  debug('_receiveInfo', rtt);\\n  this._ir = null;\\n  if (!info) {\\n    this._close(1002, 'Cannot connect to server');\\n    return;\\n  }\\n\\n  // establish a round-trip timeout (RTO) based on the\\n  // round-trip time (RTT)\\n  this._rto = this.countRTO(rtt);\\n  // allow server to override url used for the actual transport\\n  this._transUrl = info.base_url ? info.base_url : this.url;\\n  info = objectUtils.extend(info, this._urlInfo);\\n  debug('info', info);\\n  // determine list of desired and supported transports\\n  var enabledTransports = transports.filterToEnabled(this._transportsWhitelist, info);\\n  this._transports = enabledTransports.main;\\n  debug(this._transports.length + ' enabled transports');\\n\\n  this._connect();\\n};\\n\\nSockJS.prototype._connect = function() {\\n  for (var Transport = this._transports.shift(); Transport; Transport = this._transports.shift()) {\\n    debug('attempt', Transport.transportName);\\n    if (Transport.needBody) {\\n      if (!global.document.body ||\\n          (typeof global.document.readyState !== 'undefined' &&\\n            global.document.readyState !== 'complete' &&\\n            global.document.readyState !== 'interactive')) {\\n        debug('waiting for body');\\n        this._transports.unshift(Transport);\\n        eventUtils.attachEvent('load', this._connect.bind(this));\\n        return;\\n      }\\n    }\\n\\n    // calculate timeout based on RTO and round trips. Default to 5s\\n    var timeoutMs = (this._rto * Transport.roundTrips) || 5000;\\n    this._transportTimeoutId = setTimeout(this._transportTimeout.bind(this), timeoutMs);\\n    debug('using timeout', timeoutMs);\\n\\n    var transportUrl = urlUtils.addPath(this._transUrl, '/' + this._server + '/' + this._generateSessionId());\\n    var options = this._transportOptions[Transport.transportName];\\n    debug('transport url', transportUrl);\\n    var transportObj = new Transport(transportUrl, this._transUrl, options);\\n    transportObj.on('message', this._transportMessage.bind(this));\\n    transportObj.once('close', this._transportClose.bind(this));\\n    transportObj.transportName = Transport.transportName;\\n    this._transport = transportObj;\\n\\n    return;\\n  }\\n  this._close(2000, 'All transports failed', false);\\n};\\n\\nSockJS.prototype._transportTimeout = function() {\\n  debug('_transportTimeout');\\n  if (this.readyState === SockJS.CONNECTING) {\\n    this._transportClose(2007, 'Transport timed out');\\n  }\\n};\\n\\nSockJS.prototype._transportMessage = function(msg) {\\n  debug('_transportMessage', msg);\\n  var self = this\\n    , type = msg.slice(0, 1)\\n    , content = msg.slice(1)\\n    , payload\\n    ;\\n\\n  // first check for messages that don't need a payload\\n  switch (type) {\\n    case 'o':\\n      this._open();\\n      return;\\n    case 'h':\\n      this.dispatchEvent(new Event('heartbeat'));\\n      debug('heartbeat', this.transport);\\n      return;\\n  }\\n\\n  if (content) {\\n    try {\\n      payload = JSON3.parse(content);\\n    } catch (e) {\\n      debug('bad json', content);\\n    }\\n  }\\n\\n  if (typeof payload === 'undefined') {\\n    debug('empty payload', content);\\n    return;\\n  }\\n\\n  switch (type) {\\n    case 'a':\\n      if (Array.isArray(payload)) {\\n        payload.forEach(function(p) {\\n          debug('message', self.transport, p);\\n          self.dispatchEvent(new TransportMessageEvent(p));\\n        });\\n      }\\n      break;\\n    case 'm':\\n      debug('message', this.transport, payload);\\n      this.dispatchEvent(new TransportMessageEvent(payload));\\n      break;\\n    case 'c':\\n      if (Array.isArray(payload) && payload.length === 2) {\\n        this._close(payload[0], payload[1], true);\\n      }\\n      break;\\n  }\\n};\\n\\nSockJS.prototype._transportClose = function(code, reason) {\\n  debug('_transportClose', this.transport, code, reason);\\n  if (this._transport) {\\n    this._transport.removeAllListeners();\\n    this._transport = null;\\n    this.transport = null;\\n  }\\n\\n  if (!userSetCode(code) && code !== 2000 && this.readyState === SockJS.CONNECTING) {\\n    this._connect();\\n    return;\\n  }\\n\\n  this._close(code, reason);\\n};\\n\\nSockJS.prototype._open = function() {\\n  debug('_open', this._transport.transportName, this.readyState);\\n  if (this.readyState === SockJS.CONNECTING) {\\n    if (this._transportTimeoutId) {\\n      clearTimeout(this._transportTimeoutId);\\n      this._transportTimeoutId = null;\\n    }\\n    this.readyState = SockJS.OPEN;\\n    this.transport = this._transport.transportName;\\n    this.dispatchEvent(new Event('open'));\\n    debug('connected', this.transport);\\n  } else {\\n    // The server might have been restarted, and lost track of our\\n    // connection.\\n    this._close(1006, 'Server lost session');\\n  }\\n};\\n\\nSockJS.prototype._close = function(code, reason, wasClean) {\\n  debug('_close', this.transport, code, reason, wasClean, this.readyState);\\n  var forceFail = false;\\n\\n  if (this._ir) {\\n    forceFail = true;\\n    this._ir.close();\\n    this._ir = null;\\n  }\\n  if (this._transport) {\\n    this._transport.close();\\n    this._transport = null;\\n    this.transport = null;\\n  }\\n\\n  if (this.readyState === SockJS.CLOSED) {\\n    throw new Error('InvalidStateError: SockJS has already been closed');\\n  }\\n\\n  this.readyState = SockJS.CLOSING;\\n  setTimeout(function() {\\n    this.readyState = SockJS.CLOSED;\\n\\n    if (forceFail) {\\n      this.dispatchEvent(new Event('error'));\\n    }\\n\\n    var e = new CloseEvent('close');\\n    e.wasClean = wasClean || false;\\n    e.code = code || 1000;\\n    e.reason = reason;\\n\\n    this.dispatchEvent(e);\\n    this.onmessage = this.onclose = this.onerror = null;\\n    debug('disconnected');\\n  }.bind(this), 0);\\n};\\n\\n// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/\\n// and RFC 2988.\\nSockJS.prototype.countRTO = function(rtt) {\\n  // In a local environment, when using IE8/9 and the `jsonp-polling`\\n  // transport the time needed to establish a connection (the time that pass\\n  // from the opening of the transport to the call of `_dispatchOpen`) is\\n  // around 200msec (the lower bound used in the article above) and this\\n  // causes spurious timeouts. For this reason we calculate a value slightly\\n  // larger than that used in the article.\\n  if (rtt > 100) {\\n    return 4 * rtt; // rto > 400msec\\n  }\\n  return 300 + rtt; // 300msec < rto <= 400msec\\n};\\n\\nmodule.exports = function(availableTransports) {\\n  transports = transport(availableTransports);\\n  require('./iframe-bootstrap')(SockJS, availableTransports);\\n  return SockJS;\\n};\\n\\n}).call(this,{ env: {} },typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n\\n},{\\\"./event/close\\\":2,\\\"./event/event\\\":4,\\\"./event/eventtarget\\\":5,\\\"./event/trans-message\\\":6,\\\"./iframe-bootstrap\\\":8,\\\"./info-receiver\\\":12,\\\"./location\\\":13,\\\"./shims\\\":15,\\\"./utils/browser\\\":44,\\\"./utils/escape\\\":45,\\\"./utils/event\\\":46,\\\"./utils/log\\\":48,\\\"./utils/object\\\":49,\\\"./utils/random\\\":50,\\\"./utils/transport\\\":51,\\\"./utils/url\\\":52,\\\"./version\\\":53,\\\"debug\\\":55,\\\"inherits\\\":57,\\\"json3\\\":58,\\\"url-parse\\\":61}],15:[function(require,module,exports){\\n/* eslint-disable */\\n/* jscs: disable */\\n'use strict';\\n\\n// pulled specific shims from https://github.com/es-shims/es5-shim\\n\\nvar ArrayPrototype = Array.prototype;\\nvar ObjectPrototype = Object.prototype;\\nvar FunctionPrototype = Function.prototype;\\nvar StringPrototype = String.prototype;\\nvar array_slice = ArrayPrototype.slice;\\n\\nvar _toString = ObjectPrototype.toString;\\nvar isFunction = function (val) {\\n    return ObjectPrototype.toString.call(val) === '[object Function]';\\n};\\nvar isArray = function isArray(obj) {\\n    return _toString.call(obj) === '[object Array]';\\n};\\nvar isString = function isString(obj) {\\n    return _toString.call(obj) === '[object String]';\\n};\\n\\nvar supportsDescriptors = Object.defineProperty && (function () {\\n    try {\\n        Object.defineProperty({}, 'x', {});\\n        return true;\\n    } catch (e) { /* this is ES3 */\\n        return false;\\n    }\\n}());\\n\\n// Define configurable, writable and non-enumerable props\\n// if they don't exist.\\nvar defineProperty;\\nif (supportsDescriptors) {\\n    defineProperty = function (object, name, method, forceAssign) {\\n        if (!forceAssign && (name in object)) { return; }\\n        Object.defineProperty(object, name, {\\n            configurable: true,\\n            enumerable: false,\\n            writable: true,\\n            value: method\\n        });\\n    };\\n} else {\\n    defineProperty = function (object, name, method, forceAssign) {\\n        if (!forceAssign && (name in object)) { return; }\\n        object[name] = method;\\n    };\\n}\\nvar defineProperties = function (object, map, forceAssign) {\\n    for (var name in map) {\\n        if (ObjectPrototype.hasOwnProperty.call(map, name)) {\\n          defineProperty(object, name, map[name], forceAssign);\\n        }\\n    }\\n};\\n\\nvar toObject = function (o) {\\n    if (o == null) { // this matches both null and undefined\\n        throw new TypeError(\\\"can't convert \\\" + o + ' to object');\\n    }\\n    return Object(o);\\n};\\n\\n//\\n// Util\\n// ======\\n//\\n\\n// ES5 9.4\\n// http://es5.github.com/#x9.4\\n// http://jsperf.com/to-integer\\n\\nfunction toInteger(num) {\\n    var n = +num;\\n    if (n !== n) { // isNaN\\n        n = 0;\\n    } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {\\n        n = (n > 0 || -1) * Math.floor(Math.abs(n));\\n    }\\n    return n;\\n}\\n\\nfunction ToUint32(x) {\\n    return x >>> 0;\\n}\\n\\n//\\n// Function\\n// ========\\n//\\n\\n// ES-5 15.3.4.5\\n// http://es5.github.com/#x15.3.4.5\\n\\nfunction Empty() {}\\n\\ndefineProperties(FunctionPrototype, {\\n    bind: function bind(that) { // .length is 1\\n        // 1. Let Target be the this value.\\n        var target = this;\\n        // 2. If IsCallable(Target) is false, throw a TypeError exception.\\n        if (!isFunction(target)) {\\n            throw new TypeError('Function.prototype.bind called on incompatible ' + target);\\n        }\\n        // 3. Let A be a new (possibly empty) internal list of all of the\\n        //   argument values provided after thisArg (arg1, arg2 etc), in order.\\n        // XXX slicedArgs will stand in for \\\"A\\\" if used\\n        var args = array_slice.call(arguments, 1); // for normal call\\n        // 4. Let F be a new native ECMAScript object.\\n        // 11. Set the [[Prototype]] internal property of F to the standard\\n        //   built-in Function prototype object as specified in 15.3.3.1.\\n        // 12. Set the [[Call]] internal property of F as described in\\n        //   15.3.4.5.1.\\n        // 13. Set the [[Construct]] internal property of F as described in\\n        //   15.3.4.5.2.\\n        // 14. Set the [[HasInstance]] internal property of F as described in\\n        //   15.3.4.5.3.\\n        var binder = function () {\\n\\n            if (this instanceof bound) {\\n                // 15.3.4.5.2 [[Construct]]\\n                // When the [[Construct]] internal method of a function object,\\n                // F that was created using the bind function is called with a\\n                // list of arguments ExtraArgs, the following steps are taken:\\n                // 1. Let target be the value of F's [[TargetFunction]]\\n                //   internal property.\\n                // 2. If target has no [[Construct]] internal method, a\\n                //   TypeError exception is thrown.\\n                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal\\n                //   property.\\n                // 4. Let args be a new list containing the same values as the\\n                //   list boundArgs in the same order followed by the same\\n                //   values as the list ExtraArgs in the same order.\\n                // 5. Return the result of calling the [[Construct]] internal\\n                //   method of target providing args as the arguments.\\n\\n                var result = target.apply(\\n                    this,\\n                    args.concat(array_slice.call(arguments))\\n                );\\n                if (Object(result) === result) {\\n                    return result;\\n                }\\n                return this;\\n\\n            } else {\\n                // 15.3.4.5.1 [[Call]]\\n                // When the [[Call]] internal method of a function object, F,\\n                // which was created using the bind function is called with a\\n                // this value and a list of arguments ExtraArgs, the following\\n                // steps are taken:\\n                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal\\n                //   property.\\n                // 2. Let boundThis be the value of F's [[BoundThis]] internal\\n                //   property.\\n                // 3. Let target be the value of F's [[TargetFunction]] internal\\n                //   property.\\n                // 4. Let args be a new list containing the same values as the\\n                //   list boundArgs in the same order followed by the same\\n                //   values as the list ExtraArgs in the same order.\\n                // 5. Return the result of calling the [[Call]] internal method\\n                //   of target providing boundThis as the this value and\\n                //   providing args as the arguments.\\n\\n                // equiv: target.call(this, ...boundArgs, ...args)\\n                return target.apply(\\n                    that,\\n                    args.concat(array_slice.call(arguments))\\n                );\\n\\n            }\\n\\n        };\\n\\n        // 15. If the [[Class]] internal property of Target is \\\"Function\\\", then\\n        //     a. Let L be the length property of Target minus the length of A.\\n        //     b. Set the length own property of F to either 0 or L, whichever is\\n        //       larger.\\n        // 16. Else set the length own property of F to 0.\\n\\n        var boundLength = Math.max(0, target.length - args.length);\\n\\n        // 17. Set the attributes of the length own property of F to the values\\n        //   specified in 15.3.5.1.\\n        var boundArgs = [];\\n        for (var i = 0; i < boundLength; i++) {\\n            boundArgs.push('$' + i);\\n        }\\n\\n        // XXX Build a dynamic function with desired amount of arguments is the only\\n        // way to set the length property of a function.\\n        // In environments where Content Security Policies enabled (Chrome extensions,\\n        // for ex.) all use of eval or Function costructor throws an exception.\\n        // However in all of these environments Function.prototype.bind exists\\n        // and so this code will never be executed.\\n        var bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);\\n\\n        if (target.prototype) {\\n            Empty.prototype = target.prototype;\\n            bound.prototype = new Empty();\\n            // Clean up dangling references.\\n            Empty.prototype = null;\\n        }\\n\\n        // TODO\\n        // 18. Set the [[Extensible]] internal property of F to true.\\n\\n        // TODO\\n        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).\\n        // 20. Call the [[DefineOwnProperty]] internal method of F with\\n        //   arguments \\\"caller\\\", PropertyDescriptor {[[Get]]: thrower, [[Set]]:\\n        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and\\n        //   false.\\n        // 21. Call the [[DefineOwnProperty]] internal method of F with\\n        //   arguments \\\"arguments\\\", PropertyDescriptor {[[Get]]: thrower,\\n        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},\\n        //   and false.\\n\\n        // TODO\\n        // NOTE Function objects created using Function.prototype.bind do not\\n        // have a prototype property or the [[Code]], [[FormalParameters]], and\\n        // [[Scope]] internal properties.\\n        // XXX can't delete prototype in pure-js.\\n\\n        // 22. Return F.\\n        return bound;\\n    }\\n});\\n\\n//\\n// Array\\n// =====\\n//\\n\\n// ES5 15.4.3.2\\n// http://es5.github.com/#x15.4.3.2\\n// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray\\ndefineProperties(Array, { isArray: isArray });\\n\\n\\nvar boxedString = Object('a');\\nvar splitString = boxedString[0] !== 'a' || !(0 in boxedString);\\n\\nvar properlyBoxesContext = function properlyBoxed(method) {\\n    // Check node 0.6.21 bug where third parameter is not boxed\\n    var properlyBoxesNonStrict = true;\\n    var properlyBoxesStrict = true;\\n    if (method) {\\n        method.call('foo', function (_, __, context) {\\n            if (typeof context !== 'object') { properlyBoxesNonStrict = false; }\\n        });\\n\\n        method.call([1], function () {\\n            'use strict';\\n            properlyBoxesStrict = typeof this === 'string';\\n        }, 'x');\\n    }\\n    return !!method && properlyBoxesNonStrict && properlyBoxesStrict;\\n};\\n\\ndefineProperties(ArrayPrototype, {\\n    forEach: function forEach(fun /*, thisp*/) {\\n        var object = toObject(this),\\n            self = splitString && isString(this) ? this.split('') : object,\\n            thisp = arguments[1],\\n            i = -1,\\n            length = self.length >>> 0;\\n\\n        // If no callback function or if callback is not a callable function\\n        if (!isFunction(fun)) {\\n            throw new TypeError(); // TODO message\\n        }\\n\\n        while (++i < length) {\\n            if (i in self) {\\n                // Invoke the callback function with call, passing arguments:\\n                // context, property value, property key, thisArg object\\n                // context\\n                fun.call(thisp, self[i], i, object);\\n            }\\n        }\\n    }\\n}, !properlyBoxesContext(ArrayPrototype.forEach));\\n\\n// ES5 15.4.4.14\\n// http://es5.github.com/#x15.4.4.14\\n// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf\\nvar hasFirefox2IndexOfBug = Array.prototype.indexOf && [0, 1].indexOf(1, 2) !== -1;\\ndefineProperties(ArrayPrototype, {\\n    indexOf: function indexOf(sought /*, fromIndex */ ) {\\n        var self = splitString && isString(this) ? this.split('') : toObject(this),\\n            length = self.length >>> 0;\\n\\n        if (!length) {\\n            return -1;\\n        }\\n\\n        var i = 0;\\n        if (arguments.length > 1) {\\n            i = toInteger(arguments[1]);\\n        }\\n\\n        // handle negative indices\\n        i = i >= 0 ? i : Math.max(0, length + i);\\n        for (; i < length; i++) {\\n            if (i in self && self[i] === sought) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}, hasFirefox2IndexOfBug);\\n\\n//\\n// String\\n// ======\\n//\\n\\n// ES5 15.5.4.14\\n// http://es5.github.com/#x15.5.4.14\\n\\n// [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]\\n// Many browsers do not split properly with regular expressions or they\\n// do not perform the split correctly under obscure conditions.\\n// See http://blog.stevenlevithan.com/archives/cross-browser-split\\n// I've tested in many browsers and this seems to cover the deviant ones:\\n//    'ab'.split(/(?:ab)*/) should be [\\\"\\\", \\\"\\\"], not [\\\"\\\"]\\n//    '.'.split(/(.?)(.?)/) should be [\\\"\\\", \\\".\\\", \\\"\\\", \\\"\\\"], not [\\\"\\\", \\\"\\\"]\\n//    'tesst'.split(/(s)*/) should be [\\\"t\\\", undefined, \\\"e\\\", \\\"s\\\", \\\"t\\\"], not\\n//       [undefined, \\\"t\\\", undefined, \\\"e\\\", ...]\\n//    ''.split(/.?/) should be [], not [\\\"\\\"]\\n//    '.'.split(/()()/) should be [\\\".\\\"], not [\\\"\\\", \\\"\\\", \\\".\\\"]\\n\\nvar string_split = StringPrototype.split;\\nif (\\n    'ab'.split(/(?:ab)*/).length !== 2 ||\\n    '.'.split(/(.?)(.?)/).length !== 4 ||\\n    'tesst'.split(/(s)*/)[1] === 't' ||\\n    'test'.split(/(?:)/, -1).length !== 4 ||\\n    ''.split(/.?/).length ||\\n    '.'.split(/()()/).length > 1\\n) {\\n    (function () {\\n        var compliantExecNpcg = /()??/.exec('')[1] === void 0; // NPCG: nonparticipating capturing group\\n\\n        StringPrototype.split = function (separator, limit) {\\n            var string = this;\\n            if (separator === void 0 && limit === 0) {\\n                return [];\\n            }\\n\\n            // If `separator` is not a regex, use native split\\n            if (_toString.call(separator) !== '[object RegExp]') {\\n                return string_split.call(this, separator, limit);\\n            }\\n\\n            var output = [],\\n                flags = (separator.ignoreCase ? 'i' : '') +\\n                        (separator.multiline  ? 'm' : '') +\\n                        (separator.extended   ? 'x' : '') + // Proposed for ES6\\n                        (separator.sticky     ? 'y' : ''), // Firefox 3+\\n                lastLastIndex = 0,\\n                // Make `global` and avoid `lastIndex` issues by working with a copy\\n                separator2, match, lastIndex, lastLength;\\n            separator = new RegExp(separator.source, flags + 'g');\\n            string += ''; // Type-convert\\n            if (!compliantExecNpcg) {\\n                // Doesn't need flags gy, but they don't hurt\\n                separator2 = new RegExp('^' + separator.source + '$(?!\\\\\\\\s)', flags);\\n            }\\n            /* Values for `limit`, per the spec:\\n             * If undefined: 4294967295 // Math.pow(2, 32) - 1\\n             * If 0, Infinity, or NaN: 0\\n             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;\\n             * If negative number: 4294967296 - Math.floor(Math.abs(limit))\\n             * If other: Type-convert, then use the above rules\\n             */\\n            limit = limit === void 0 ?\\n                -1 >>> 0 : // Math.pow(2, 32) - 1\\n                ToUint32(limit);\\n            while (match = separator.exec(string)) {\\n                // `separator.lastIndex` is not reliable cross-browser\\n                lastIndex = match.index + match[0].length;\\n                if (lastIndex > lastLastIndex) {\\n                    output.push(string.slice(lastLastIndex, match.index));\\n                    // Fix browsers whose `exec` methods don't consistently return `undefined` for\\n                    // nonparticipating capturing groups\\n                    if (!compliantExecNpcg && match.length > 1) {\\n                        match[0].replace(separator2, function () {\\n                            for (var i = 1; i < arguments.length - 2; i++) {\\n                                if (arguments[i] === void 0) {\\n                                    match[i] = void 0;\\n                                }\\n                            }\\n                        });\\n                    }\\n                    if (match.length > 1 && match.index < string.length) {\\n                        ArrayPrototype.push.apply(output, match.slice(1));\\n                    }\\n                    lastLength = match[0].length;\\n                    lastLastIndex = lastIndex;\\n                    if (output.length >= limit) {\\n                        break;\\n                    }\\n                }\\n                if (separator.lastIndex === match.index) {\\n                    separator.lastIndex++; // Avoid an infinite loop\\n                }\\n            }\\n            if (lastLastIndex === string.length) {\\n                if (lastLength || !separator.test('')) {\\n                    output.push('');\\n                }\\n            } else {\\n                output.push(string.slice(lastLastIndex));\\n            }\\n            return output.length > limit ? output.slice(0, limit) : output;\\n        };\\n    }());\\n\\n// [bugfix, chrome]\\n// If separator is undefined, then the result array contains just one String,\\n// which is the this value (converted to a String). If limit is not undefined,\\n// then the output array is truncated so that it contains no more than limit\\n// elements.\\n// \\\"0\\\".split(undefined, 0) -> []\\n} else if ('0'.split(void 0, 0).length) {\\n    StringPrototype.split = function split(separator, limit) {\\n        if (separator === void 0 && limit === 0) { return []; }\\n        return string_split.call(this, separator, limit);\\n    };\\n}\\n\\n// ECMA-262, 3rd B.2.3\\n// Not an ECMAScript standard, although ECMAScript 3rd Edition has a\\n// non-normative section suggesting uniform semantics and it should be\\n// normalized across all browsers\\n// [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE\\nvar string_substr = StringPrototype.substr;\\nvar hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';\\ndefineProperties(StringPrototype, {\\n    substr: function substr(start, length) {\\n        return string_substr.call(\\n            this,\\n            start < 0 ? ((start = this.length + start) < 0 ? 0 : start) : start,\\n            length\\n        );\\n    }\\n}, hasNegativeSubstrBug);\\n\\n},{}],16:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = [\\n  // streaming transports\\n  require('./transport/websocket')\\n, require('./transport/xhr-streaming')\\n, require('./transport/xdr-streaming')\\n, require('./transport/eventsource')\\n, require('./transport/lib/iframe-wrap')(require('./transport/eventsource'))\\n\\n  // polling transports\\n, require('./transport/htmlfile')\\n, require('./transport/lib/iframe-wrap')(require('./transport/htmlfile'))\\n, require('./transport/xhr-polling')\\n, require('./transport/xdr-polling')\\n, require('./transport/lib/iframe-wrap')(require('./transport/xhr-polling'))\\n, require('./transport/jsonp-polling')\\n];\\n\\n},{\\\"./transport/eventsource\\\":20,\\\"./transport/htmlfile\\\":21,\\\"./transport/jsonp-polling\\\":23,\\\"./transport/lib/iframe-wrap\\\":26,\\\"./transport/websocket\\\":38,\\\"./transport/xdr-polling\\\":39,\\\"./transport/xdr-streaming\\\":40,\\\"./transport/xhr-polling\\\":41,\\\"./transport/xhr-streaming\\\":42}],17:[function(require,module,exports){\\n(function (process,global){\\n'use strict';\\n\\nvar EventEmitter = require('events').EventEmitter\\n  , inherits = require('inherits')\\n  , utils = require('../../utils/event')\\n  , urlUtils = require('../../utils/url')\\n  , XHR = global.XMLHttpRequest\\n  ;\\n\\nvar debug = function() {};\\nif (process.env.NODE_ENV !== 'production') {\\n  debug = require('debug')('sockjs-client:browser:xhr');\\n}\\n\\nfunction AbstractXHRObject(method, url, payload, opts) {\\n  debug(method, url);\\n  var self = this;\\n  EventEmitter.call(this);\\n\\n  setTimeout(function () {\\n    self._start(method, url, payload, opts);\\n  }, 0);\\n}\\n\\ninherits(AbstractXHRObject, EventEmitter);\\n\\nAbstractXHRObject.prototype._start = function(method, url, payload, opts) {\\n  var self = this;\\n\\n  try {\\n    this.xhr = new XHR();\\n  } catch (x) {\\n    // intentionally empty\\n  }\\n\\n  if (!this.xhr) {\\n    debug('no xhr');\\n    this.emit('finish', 0, 'no xhr support');\\n    this._cleanup();\\n    return;\\n  }\\n\\n  // several browsers cache POSTs\\n  url = urlUtils.addQuery(url, 't=' + (+new Date()));\\n\\n  // Explorer tends to keep connection open, even after the\\n  // tab gets closed: http://bugs.jquery.com/ticket/5280\\n  this.unloadRef = utils.unloadAdd(function() {\\n    debug('unload cleanup');\\n    self._cleanup(true);\\n  });\\n  try {\\n    this.xhr.open(method, url, true);\\n    if (this.timeout && 'timeout' in this.xhr) {\\n      this.xhr.timeout = this.timeout;\\n      this.xhr.ontimeout = function() {\\n        debug('xhr timeout');\\n        self.emit('finish', 0, '');\\n        self._cleanup(false);\\n      };\\n    }\\n  } catch (e) {\\n    debug('exception', e);\\n    // IE raises an exception on wrong port.\\n    this.emit('finish', 0, '');\\n    this._cleanup(false);\\n    return;\\n  }\\n\\n  if ((!opts || !opts.noCredentials) && AbstractXHRObject.supportsCORS) {\\n    debug('withCredentials');\\n    // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :\\n    // \\\"This never affects same-site requests.\\\"\\n\\n    this.xhr.withCredentials = 'true';\\n  }\\n  if (opts && opts.headers) {\\n    for (var key in opts.headers) {\\n      this.xhr.setRequestHeader(key, opts.headers[key]);\\n    }\\n  }\\n\\n  this.xhr.onreadystatechange = function() {\\n    if (self.xhr) {\\n      var x = self.xhr;\\n      var text, status;\\n      debug('readyState', x.readyState);\\n      switch (x.readyState) {\\n      case 3:\\n        // IE doesn't like peeking into responseText or status\\n        // on Microsoft.XMLHTTP and readystate=3\\n        try {\\n          status = x.status;\\n          text = x.responseText;\\n        } catch (e) {\\n          // intentionally empty\\n        }\\n        debug('status', status);\\n        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450\\n        if (status === 1223) {\\n          status = 204;\\n        }\\n\\n        // IE does return readystate == 3 for 404 answers.\\n        if (status === 200 && text && text.length > 0) {\\n          debug('chunk');\\n          self.emit('chunk', status, text);\\n        }\\n        break;\\n      case 4:\\n        status = x.status;\\n        debug('status', status);\\n        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450\\n        if (status === 1223) {\\n          status = 204;\\n        }\\n        // IE returns this for a bad port\\n        // http://msdn.microsoft.com/en-us/library/windows/desktop/aa383770(v=vs.85).aspx\\n        if (status === 12005 || status === 12029) {\\n          status = 0;\\n        }\\n\\n        debug('finish', status, x.responseText);\\n        self.emit('finish', status, x.responseText);\\n        self._cleanup(false);\\n        break;\\n      }\\n    }\\n  };\\n\\n  try {\\n    self.xhr.send(payload);\\n  } catch (e) {\\n    self.emit('finish', 0, '');\\n    self._cleanup(false);\\n  }\\n};\\n\\nAbstractXHRObject.prototype._cleanup = function(abort) {\\n  debug('cleanup');\\n  if (!this.xhr) {\\n    return;\\n  }\\n  this.removeAllListeners();\\n  utils.unloadDel(this.unloadRef);\\n\\n  // IE needs this field to be a function\\n  this.xhr.onreadystatechange = function() {};\\n  if (this.xhr.ontimeout) {\\n    this.xhr.ontimeout = null;\\n  }\\n\\n  if (abort) {\\n    try {\\n      this.xhr.abort();\\n    } catch (x) {\\n      // intentionally empty\\n    }\\n  }\\n  this.unloadRef = this.xhr = null;\\n};\\n\\nAbstractXHRObject.prototype.close = function() {\\n  debug('close');\\n  this._cleanup(true);\\n};\\n\\nAbstractXHRObject.enabled = !!XHR;\\n// override XMLHttpRequest for IE6/7\\n// obfuscate to avoid firewalls\\nvar axo = ['Active'].concat('Object').join('X');\\nif (!AbstractXHRObject.enabled && (axo in global)) {\\n  debug('overriding xmlhttprequest');\\n  XHR = function() {\\n    try {\\n      return new global[axo]('Microsoft.XMLHTTP');\\n    } catch (e) {\\n      return null;\\n    }\\n  };\\n  AbstractXHRObject.enabled = !!new XHR();\\n}\\n\\nvar cors = false;\\ntry {\\n  cors = 'withCredentials' in new XHR();\\n} catch (ignored) {\\n  // intentionally empty\\n}\\n\\nAbstractXHRObject.supportsCORS = cors;\\n\\nmodule.exports = AbstractXHRObject;\\n\\n}).call(this,{ env: {} },typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n\\n},{\\\"../../utils/event\\\":46,\\\"../../utils/url\\\":52,\\\"debug\\\":55,\\\"events\\\":3,\\\"inherits\\\":57}],18:[function(require,module,exports){\\n(function (global){\\nmodule.exports = global.EventSource;\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n\\n},{}],19:[function(require,module,exports){\\n(function (global){\\n'use strict';\\n\\nvar Driver = global.WebSocket || global.MozWebSocket;\\nif (Driver) {\\n\\tmodule.exports = function WebSocketBrowserDriver(url) {\\n\\t\\treturn new Driver(url);\\n\\t};\\n} else {\\n\\tmodule.exports = undefined;\\n}\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n\\n},{}],20:[function(require,module,exports){\\n'use strict';\\n\\nvar inherits = require('inherits')\\n  , AjaxBasedTransport = require('./lib/ajax-based')\\n  , EventSourceReceiver = require('./receiver/eventsource')\\n  , XHRCorsObject = require('./sender/xhr-cors')\\n  , EventSourceDriver = require('eventsource')\\n  ;\\n\\nfunction EventSourceTransport(transUrl) {\\n  if (!EventSourceTransport.enabled()) {\\n    throw new Error('Transport created when disabled');\\n  }\\n\\n  AjaxBasedTransport.call(this, transUrl, '/eventsource', EventSourceReceiver, XHRCorsObject);\\n}\\n\\ninherits(EventSourceTransport, AjaxBasedTransport);\\n\\nEventSourceTransport.enabled = function() {\\n  return !!EventSourceDriver;\\n};\\n\\nEventSourceTransport.transportName = 'eventsource';\\nEventSourceTransport.roundTrips = 2;\\n\\nmodule.exports = EventSourceTransport;\\n\\n},{\\\"./lib/ajax-based\\\":24,\\\"./receiver/eventsource\\\":29,\\\"./sender/xhr-cors\\\":35,\\\"eventsource\\\":18,\\\"inherits\\\":57}],21:[function(require,module,exports){\\n'use strict';\\n\\nvar inherits = require('inherits')\\n  , HtmlfileReceiver = require('./receiver/htmlfile')\\n  , XHRLocalObject = require('./sender/xhr-local')\\n  , AjaxBasedTransport = require('./lib/ajax-based')\\n  ;\\n\\nfunction HtmlFileTransport(transUrl) {\\n  if (!HtmlfileReceiver.enabled) {\\n    throw new Error('Transport created when disabled');\\n  }\\n  AjaxBasedTransport.call(this, transUrl, '/htmlfile', HtmlfileReceiver, XHRLocalObject);\\n}\\n\\ninherits(HtmlFileTransport, AjaxBasedTransport);\\n\\nHtmlFileTransport.enabled = function(info) {\\n  return HtmlfileReceiver.enabled && info.sameOrigin;\\n};\\n\\nHtmlFileTransport.transportName = 'htmlfile';\\nHtmlFileTransport.roundTrips = 2;\\n\\nmodule.exports = HtmlFileTransport;\\n\\n},{\\\"./lib/ajax-based\\\":24,\\\"./receiver/htmlfile\\\":30,\\\"./sender/xhr-local\\\":37,\\\"inherits\\\":57}],22:[function(require,module,exports){\\n(function (process){\\n'use strict';\\n\\n// Few cool transports do work only for same-origin. In order to make\\n// them work cross-domain we shall use iframe, served from the\\n// remote domain. New browsers have capabilities to communicate with\\n// cross domain iframe using postMessage(). In IE it was implemented\\n// from IE 8+, but of course, IE got some details wrong:\\n//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx\\n//    http://stevesouders.com/misc/test-postmessage.php\\n\\nvar inherits = require('inherits')\\n  , JSON3 = require('json3')\\n  , EventEmitter = require('events').EventEmitter\\n  , version = require('../version')\\n  , urlUtils = require('../utils/url')\\n  , iframeUtils = require('../utils/iframe')\\n  , eventUtils = require('../utils/event')\\n  , random = require('../utils/random')\\n  ;\\n\\nvar debug = function() {};\\nif (process.env.NODE_ENV !== 'production') {\\n  debug = require('debug')('sockjs-client:transport:iframe');\\n}\\n\\nfunction IframeTransport(transport, transUrl, baseUrl) {\\n  if (!IframeTransport.enabled()) {\\n    throw new Error('Transport created when disabled');\\n  }\\n  EventEmitter.call(this);\\n\\n  var self = this;\\n  this.origin = urlUtils.getOrigin(baseUrl);\\n  this.baseUrl = baseUrl;\\n  this.transUrl = transUrl;\\n  this.transport = transport;\\n  this.windowId = random.string(8);\\n\\n  var iframeUrl = urlUtils.addPath(baseUrl, '/iframe.html') + '#' + this.windowId;\\n  debug(transport, transUrl, iframeUrl);\\n\\n  this.iframeObj = iframeUtils.createIframe(iframeUrl, function(r) {\\n    debug('err callback');\\n    self.emit('close', 1006, 'Unable to load an iframe (' + r + ')');\\n    self.close();\\n  });\\n\\n  this.onmessageCallback = this._message.bind(this);\\n  eventUtils.attachEvent('message', this.onmessageCallback);\\n}\\n\\ninherits(IframeTransport, EventEmitter);\\n\\nIframeTransport.prototype.close = function() {\\n  debug('close');\\n  this.removeAllListeners();\\n  if (this.iframeObj) {\\n    eventUtils.detachEvent('message', this.onmessageCallback);\\n    try {\\n      // When the iframe is not loaded, IE raises an exception\\n      // on 'contentWindow'.\\n      this.postMessage('c');\\n    } catch (x) {\\n      // intentionally empty\\n    }\\n    this.iframeObj.cleanup();\\n    this.iframeObj = null;\\n    this.onmessageCallback = this.iframeObj = null;\\n  }\\n};\\n\\nIframeTransport.prototype._message = function(e) {\\n  debug('message', e.data);\\n  if (!urlUtils.isOriginEqual(e.origin, this.origin)) {\\n    debug('not same origin', e.origin, this.origin);\\n    return;\\n  }\\n\\n  var iframeMessage;\\n  try {\\n    iframeMessage = JSON3.parse(e.data);\\n  } catch (ignored) {\\n    debug('bad json', e.data);\\n    return;\\n  }\\n\\n  if (iframeMessage.windowId !== this.windowId) {\\n    debug('mismatched window id', iframeMessage.windowId, this.windowId);\\n    return;\\n  }\\n\\n  switch (iframeMessage.type) {\\n  case 's':\\n    this.iframeObj.loaded();\\n    // window global dependency\\n    this.postMessage('s', JSON3.stringify([\\n      version\\n    , this.transport\\n    , this.transUrl\\n    , this.baseUrl\\n    ]));\\n    break;\\n  case 't':\\n    this.emit('message', iframeMessage.data);\\n    break;\\n  case 'c':\\n    var cdata;\\n    try {\\n      cdata = JSON3.parse(iframeMessage.data);\\n    } catch (ignored) {\\n      debug('bad json', iframeMessage.data);\\n      return;\\n    }\\n    this.emit('close', cdata[0], cdata[1]);\\n    this.close();\\n    break;\\n  }\\n};\\n\\nIframeTransport.prototype.postMessage = function(type, data) {\\n  debug('postMessage', type, data);\\n  this.iframeObj.post(JSON3.stringify({\\n    windowId: this.windowId\\n  , type: type\\n  , data: data || ''\\n  }), this.origin);\\n};\\n\\nIframeTransport.prototype.send = function(message) {\\n  debug('send', message);\\n  this.postMessage('m', message);\\n};\\n\\nIframeTransport.enabled = function() {\\n  return iframeUtils.iframeEnabled;\\n};\\n\\nIframeTransport.transportName = 'iframe';\\nIframeTransport.roundTrips = 2;\\n\\nmodule.exports = IframeTransport;\\n\\n}).call(this,{ env: {} })\\n\\n},{\\\"../utils/event\\\":46,\\\"../utils/iframe\\\":47,\\\"../utils/random\\\":50,\\\"../utils/url\\\":52,\\\"../version\\\":53,\\\"debug\\\":55,\\\"events\\\":3,\\\"inherits\\\":57,\\\"json3\\\":58}],23:[function(require,module,exports){\\n(function (global){\\n'use strict';\\n\\n// The simplest and most robust transport, using the well-know cross\\n// domain hack - JSONP. This transport is quite inefficient - one\\n// message could use up to one http request. But at least it works almost\\n// everywhere.\\n// Known limitations:\\n//   o you will get a spinning cursor\\n//   o for Konqueror a dumb timer is needed to detect errors\\n\\nvar inherits = require('inherits')\\n  , SenderReceiver = require('./lib/sender-receiver')\\n  , JsonpReceiver = require('./receiver/jsonp')\\n  , jsonpSender = require('./sender/jsonp')\\n  ;\\n\\nfunction JsonPTransport(transUrl) {\\n  if (!JsonPTransport.enabled()) {\\n    throw new Error('Transport created when disabled');\\n  }\\n  SenderReceiver.call(this, transUrl, '/jsonp', jsonpSender, JsonpReceiver);\\n}\\n\\ninherits(JsonPTransport, SenderReceiver);\\n\\nJsonPTransport.enabled = function() {\\n  return !!global.document;\\n};\\n\\nJsonPTransport.transportName = 'jsonp-polling';\\nJsonPTransport.roundTrips = 1;\\nJsonPTransport.needBody = true;\\n\\nmodule.exports = JsonPTransport;\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n\\n},{\\\"./lib/sender-receiver\\\":28,\\\"./receiver/jsonp\\\":31,\\\"./sender/jsonp\\\":33,\\\"inherits\\\":57}],24:[function(require,module,exports){\\n(function (process){\\n'use strict';\\n\\nvar inherits = require('inherits')\\n  , urlUtils = require('../../utils/url')\\n  , SenderReceiver = require('./sender-receiver')\\n  ;\\n\\nvar debug = function() {};\\nif (process.env.NODE_ENV !== 'production') {\\n  debug = require('debug')('sockjs-client:ajax-based');\\n}\\n\\nfunction createAjaxSender(AjaxObject) {\\n  return function(url, payload, callback) {\\n    debug('create ajax sender', url, payload);\\n    var opt = {};\\n    if (typeof payload === 'string') {\\n      opt.headers = {'Content-type': 'text/plain'};\\n    }\\n    var ajaxUrl = urlUtils.addPath(url, '/xhr_send');\\n    var xo = new AjaxObject('POST', ajaxUrl, payload, opt);\\n    xo.once('finish', function(status) {\\n      debug('finish', status);\\n      xo = null;\\n\\n      if (status !== 200 && status !== 204) {\\n        return callback(new Error('http status ' + status));\\n      }\\n      callback();\\n    });\\n    return function() {\\n      debug('abort');\\n      xo.close();\\n      xo = null;\\n\\n      var err = new Error('Aborted');\\n      err.code = 1000;\\n      callback(err);\\n    };\\n  };\\n}\\n\\nfunction AjaxBasedTransport(transUrl, urlSuffix, Receiver, AjaxObject) {\\n  SenderReceiver.call(this, transUrl, urlSuffix, createAjaxSender(AjaxObject), Receiver, AjaxObject);\\n}\\n\\ninherits(AjaxBasedTransport, SenderReceiver);\\n\\nmodule.exports = AjaxBasedTransport;\\n\\n}).call(this,{ env: {} })\\n\\n},{\\\"../../utils/url\\\":52,\\\"./sender-receiver\\\":28,\\\"debug\\\":55,\\\"inherits\\\":57}],25:[function(require,module,exports){\\n(function (process){\\n'use strict';\\n\\nvar inherits = require('inherits')\\n  , EventEmitter = require('events').EventEmitter\\n  ;\\n\\nvar debug = function() {};\\nif (process.env.NODE_ENV !== 'production') {\\n  debug = require('debug')('sockjs-client:buffered-sender');\\n}\\n\\nfunction BufferedSender(url, sender) {\\n  debug(url);\\n  EventEmitter.call(this);\\n  this.sendBuffer = [];\\n  this.sender = sender;\\n  this.url = url;\\n}\\n\\ninherits(BufferedSender, EventEmitter);\\n\\nBufferedSender.prototype.send = function(message) {\\n  debug('send', message);\\n  this.sendBuffer.push(message);\\n  if (!this.sendStop) {\\n    this.sendSchedule();\\n  }\\n};\\n\\n// For polling transports in a situation when in the message callback,\\n// new message is being send. If the sending connection was started\\n// before receiving one, it is possible to saturate the network and\\n// timeout due to the lack of receiving socket. To avoid that we delay\\n// sending messages by some small time, in order to let receiving\\n// connection be started beforehand. This is only a halfmeasure and\\n// does not fix the big problem, but it does make the tests go more\\n// stable on slow networks.\\nBufferedSender.prototype.sendScheduleWait = function() {\\n  debug('sendScheduleWait');\\n  var self = this;\\n  var tref;\\n  this.sendStop = function() {\\n    debug('sendStop');\\n    self.sendStop = null;\\n    clearTimeout(tref);\\n  };\\n  tref = setTimeout(function() {\\n    debug('timeout');\\n    self.sendStop = null;\\n    self.sendSchedule();\\n  }, 25);\\n};\\n\\nBufferedSender.prototype.sendSchedule = function() {\\n  debug('sendSchedule', this.sendBuffer.length);\\n  var self = this;\\n  if (this.sendBuffer.length > 0) {\\n    var payload = '[' + this.sendBuffer.join(',') + ']';\\n    this.sendStop = this.sender(this.url, payload, function(err) {\\n      self.sendStop = null;\\n      if (err) {\\n        debug('error', err);\\n        self.emit('close', err.code || 1006, 'Sending error: ' + err);\\n        self.close();\\n      } else {\\n        self.sendScheduleWait();\\n      }\\n    });\\n    this.sendBuffer = [];\\n  }\\n};\\n\\nBufferedSender.prototype._cleanup = function() {\\n  debug('_cleanup');\\n  this.removeAllListeners();\\n};\\n\\nBufferedSender.prototype.close = function() {\\n  debug('close');\\n  this._cleanup();\\n  if (this.sendStop) {\\n    this.sendStop();\\n    this.sendStop = null;\\n  }\\n};\\n\\nmodule.exports = BufferedSender;\\n\\n}).call(this,{ env: {} })\\n\\n},{\\\"debug\\\":55,\\\"events\\\":3,\\\"inherits\\\":57}],26:[function(require,module,exports){\\n(function (global){\\n'use strict';\\n\\nvar inherits = require('inherits')\\n  , IframeTransport = require('../iframe')\\n  , objectUtils = require('../../utils/object')\\n  ;\\n\\nmodule.exports = function(transport) {\\n\\n  function IframeWrapTransport(transUrl, baseUrl) {\\n    IframeTransport.call(this, transport.transportName, transUrl, baseUrl);\\n  }\\n\\n  inherits(IframeWrapTransport, IframeTransport);\\n\\n  IframeWrapTransport.enabled = function(url, info) {\\n    if (!global.document) {\\n      return false;\\n    }\\n\\n    var iframeInfo = objectUtils.extend({}, info);\\n    iframeInfo.sameOrigin = true;\\n    return transport.enabled(iframeInfo) && IframeTransport.enabled();\\n  };\\n\\n  IframeWrapTransport.transportName = 'iframe-' + transport.transportName;\\n  IframeWrapTransport.needBody = true;\\n  IframeWrapTransport.roundTrips = IframeTransport.roundTrips + transport.roundTrips - 1; // html, javascript (2) + transport - no CORS (1)\\n\\n  IframeWrapTransport.facadeTransport = transport;\\n\\n  return IframeWrapTransport;\\n};\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n\\n},{\\\"../../utils/object\\\":49,\\\"../iframe\\\":22,\\\"inherits\\\":57}],27:[function(require,module,exports){\\n(function (process){\\n'use strict';\\n\\nvar inherits = require('inherits')\\n  , EventEmitter = require('events').EventEmitter\\n  ;\\n\\nvar debug = function() {};\\nif (process.env.NODE_ENV !== 'production') {\\n  debug = require('debug')('sockjs-client:polling');\\n}\\n\\nfunction Polling(Receiver, receiveUrl, AjaxObject) {\\n  debug(receiveUrl);\\n  EventEmitter.call(this);\\n  this.Receiver = Receiver;\\n  this.receiveUrl = receiveUrl;\\n  this.AjaxObject = AjaxObject;\\n  this._scheduleReceiver();\\n}\\n\\ninherits(Polling, EventEmitter);\\n\\nPolling.prototype._scheduleReceiver = function() {\\n  debug('_scheduleReceiver');\\n  var self = this;\\n  var poll = this.poll = new this.Receiver(this.receiveUrl, this.AjaxObject);\\n\\n  poll.on('message', function(msg) {\\n    debug('message', msg);\\n    self.emit('message', msg);\\n  });\\n\\n  poll.once('close', function(code, reason) {\\n    debug('close', code, reason, self.pollIsClosing);\\n    self.poll = poll = null;\\n\\n    if (!self.pollIsClosing) {\\n      if (reason === 'network') {\\n        self._scheduleReceiver();\\n      } else {\\n        self.emit('close', code || 1006, reason);\\n        self.removeAllListeners();\\n      }\\n    }\\n  });\\n};\\n\\nPolling.prototype.abort = function() {\\n  debug('abort');\\n  this.removeAllListeners();\\n  this.pollIsClosing = true;\\n  if (this.poll) {\\n    this.poll.abort();\\n  }\\n};\\n\\nmodule.exports = Polling;\\n\\n}).call(this,{ env: {} })\\n\\n},{\\\"debug\\\":55,\\\"events\\\":3,\\\"inherits\\\":57}],28:[function(require,module,exports){\\n(function (process){\\n'use strict';\\n\\nvar inherits = require('inherits')\\n  , urlUtils = require('../../utils/url')\\n  , BufferedSender = require('./buffered-sender')\\n  , Polling = require('./polling')\\n  ;\\n\\nvar debug = function() {};\\nif (process.env.NODE_ENV !== 'production') {\\n  debug = require('debug')('sockjs-client:sender-receiver');\\n}\\n\\nfunction SenderReceiver(transUrl, urlSuffix, senderFunc, Receiver, AjaxObject) {\\n  var pollUrl = urlUtils.addPath(transUrl, urlSuffix);\\n  debug(pollUrl);\\n  var self = this;\\n  BufferedSender.call(this, transUrl, senderFunc);\\n\\n  this.poll = new Polling(Receiver, pollUrl, AjaxObject);\\n  this.poll.on('message', function(msg) {\\n    debug('poll message', msg);\\n    self.emit('message', msg);\\n  });\\n  this.poll.once('close', function(code, reason) {\\n    debug('poll close', code, reason);\\n    self.poll = null;\\n    self.emit('close', code, reason);\\n    self.close();\\n  });\\n}\\n\\ninherits(SenderReceiver, BufferedSender);\\n\\nSenderReceiver.prototype.close = function() {\\n  BufferedSender.prototype.close.call(this);\\n  debug('close');\\n  this.removeAllListeners();\\n  if (this.poll) {\\n    this.poll.abort();\\n    this.poll = null;\\n  }\\n};\\n\\nmodule.exports = SenderReceiver;\\n\\n}).call(this,{ env: {} })\\n\\n},{\\\"../../utils/url\\\":52,\\\"./buffered-sender\\\":25,\\\"./polling\\\":27,\\\"debug\\\":55,\\\"inherits\\\":57}],29:[function(require,module,exports){\\n(function (process){\\n'use strict';\\n\\nvar inherits = require('inherits')\\n  , EventEmitter = require('events').EventEmitter\\n  , EventSourceDriver = require('eventsource')\\n  ;\\n\\nvar debug = function() {};\\nif (process.env.NODE_ENV !== 'production') {\\n  debug = require('debug')('sockjs-client:receiver:eventsource');\\n}\\n\\nfunction EventSourceReceiver(url) {\\n  debug(url);\\n  EventEmitter.call(this);\\n\\n  var self = this;\\n  var es = this.es = new EventSourceDriver(url);\\n  es.onmessage = function(e) {\\n    debug('message', e.data);\\n    self.emit('message', decodeURI(e.data));\\n  };\\n  es.onerror = function(e) {\\n    debug('error', es.readyState, e);\\n    // ES on reconnection has readyState = 0 or 1.\\n    // on network error it's CLOSED = 2\\n    var reason = (es.readyState !== 2 ? 'network' : 'permanent');\\n    self._cleanup();\\n    self._close(reason);\\n  };\\n}\\n\\ninherits(EventSourceReceiver, EventEmitter);\\n\\nEventSourceReceiver.prototype.abort = function() {\\n  debug('abort');\\n  this._cleanup();\\n  this._close('user');\\n};\\n\\nEventSourceReceiver.prototype._cleanup = function() {\\n  debug('cleanup');\\n  var es = this.es;\\n  if (es) {\\n    es.onmessage = es.onerror = null;\\n    es.close();\\n    this.es = null;\\n  }\\n};\\n\\nEventSourceReceiver.prototype._close = function(reason) {\\n  debug('close', reason);\\n  var self = this;\\n  // Safari and chrome < 15 crash if we close window before\\n  // waiting for ES cleanup. See:\\n  // https://code.google.com/p/chromium/issues/detail?id=89155\\n  setTimeout(function() {\\n    self.emit('close', null, reason);\\n    self.removeAllListeners();\\n  }, 200);\\n};\\n\\nmodule.exports = EventSourceReceiver;\\n\\n}).call(this,{ env: {} })\\n\\n},{\\\"debug\\\":55,\\\"events\\\":3,\\\"eventsource\\\":18,\\\"inherits\\\":57}],30:[function(require,module,exports){\\n(function (process,global){\\n'use strict';\\n\\nvar inherits = require('inherits')\\n  , iframeUtils = require('../../utils/iframe')\\n  , urlUtils = require('../../utils/url')\\n  , EventEmitter = require('events').EventEmitter\\n  , random = require('../../utils/random')\\n  ;\\n\\nvar debug = function() {};\\nif (process.env.NODE_ENV !== 'production') {\\n  debug = require('debug')('sockjs-client:receiver:htmlfile');\\n}\\n\\nfunction HtmlfileReceiver(url) {\\n  debug(url);\\n  EventEmitter.call(this);\\n  var self = this;\\n  iframeUtils.polluteGlobalNamespace();\\n\\n  this.id = 'a' + random.string(6);\\n  url = urlUtils.addQuery(url, 'c=' + decodeURIComponent(iframeUtils.WPrefix + '.' + this.id));\\n\\n  debug('using htmlfile', HtmlfileReceiver.htmlfileEnabled);\\n  var constructFunc = HtmlfileReceiver.htmlfileEnabled ?\\n      iframeUtils.createHtmlfile : iframeUtils.createIframe;\\n\\n  global[iframeUtils.WPrefix][this.id] = {\\n    start: function() {\\n      debug('start');\\n      self.iframeObj.loaded();\\n    }\\n  , message: function(data) {\\n      debug('message', data);\\n      self.emit('message', data);\\n    }\\n  , stop: function() {\\n      debug('stop');\\n      self._cleanup();\\n      self._close('network');\\n    }\\n  };\\n  this.iframeObj = constructFunc(url, function() {\\n    debug('callback');\\n    self._cleanup();\\n    self._close('permanent');\\n  });\\n}\\n\\ninherits(HtmlfileReceiver, EventEmitter);\\n\\nHtmlfileReceiver.prototype.abort = function() {\\n  debug('abort');\\n  this._cleanup();\\n  this._close('user');\\n};\\n\\nHtmlfileReceiver.prototype._cleanup = function() {\\n  debug('_cleanup');\\n  if (this.iframeObj) {\\n    this.iframeObj.cleanup();\\n    this.iframeObj = null;\\n  }\\n  delete global[iframeUtils.WPrefix][this.id];\\n};\\n\\nHtmlfileReceiver.prototype._close = function(reason) {\\n  debug('_close', reason);\\n  this.emit('close', null, reason);\\n  this.removeAllListeners();\\n};\\n\\nHtmlfileReceiver.htmlfileEnabled = false;\\n\\n// obfuscate to avoid firewalls\\nvar axo = ['Active'].concat('Object').join('X');\\nif (axo in global) {\\n  try {\\n    HtmlfileReceiver.htmlfileEnabled = !!new global[axo]('htmlfile');\\n  } catch (x) {\\n    // intentionally empty\\n  }\\n}\\n\\nHtmlfileReceiver.enabled = HtmlfileReceiver.htmlfileEnabled || iframeUtils.iframeEnabled;\\n\\nmodule.exports = HtmlfileReceiver;\\n\\n}).call(this,{ env: {} },typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n\\n},{\\\"../../utils/iframe\\\":47,\\\"../../utils/random\\\":50,\\\"../../utils/url\\\":52,\\\"debug\\\":55,\\\"events\\\":3,\\\"inherits\\\":57}],31:[function(require,module,exports){\\n(function (process,global){\\n'use strict';\\n\\nvar utils = require('../../utils/iframe')\\n  , random = require('../../utils/random')\\n  , browser = require('../../utils/browser')\\n  , urlUtils = require('../../utils/url')\\n  , inherits = require('inherits')\\n  , EventEmitter = require('events').EventEmitter\\n  ;\\n\\nvar debug = function() {};\\nif (process.env.NODE_ENV !== 'production') {\\n  debug = require('debug')('sockjs-client:receiver:jsonp');\\n}\\n\\nfunction JsonpReceiver(url) {\\n  debug(url);\\n  var self = this;\\n  EventEmitter.call(this);\\n\\n  utils.polluteGlobalNamespace();\\n\\n  this.id = 'a' + random.string(6);\\n  var urlWithId = urlUtils.addQuery(url, 'c=' + encodeURIComponent(utils.WPrefix + '.' + this.id));\\n\\n  global[utils.WPrefix][this.id] = this._callback.bind(this);\\n  this._createScript(urlWithId);\\n\\n  // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.\\n  this.timeoutId = setTimeout(function() {\\n    debug('timeout');\\n    self._abort(new Error('JSONP script loaded abnormally (timeout)'));\\n  }, JsonpReceiver.timeout);\\n}\\n\\ninherits(JsonpReceiver, EventEmitter);\\n\\nJsonpReceiver.prototype.abort = function() {\\n  debug('abort');\\n  if (global[utils.WPrefix][this.id]) {\\n    var err = new Error('JSONP user aborted read');\\n    err.code = 1000;\\n    this._abort(err);\\n  }\\n};\\n\\nJsonpReceiver.timeout = 35000;\\nJsonpReceiver.scriptErrorTimeout = 1000;\\n\\nJsonpReceiver.prototype._callback = function(data) {\\n  debug('_callback', data);\\n  this._cleanup();\\n\\n  if (this.aborting) {\\n    return;\\n  }\\n\\n  if (data) {\\n    debug('message', data);\\n    this.emit('message', data);\\n  }\\n  this.emit('close', null, 'network');\\n  this.removeAllListeners();\\n};\\n\\nJsonpReceiver.prototype._abort = function(err) {\\n  debug('_abort', err);\\n  this._cleanup();\\n  this.aborting = true;\\n  this.emit('close', err.code, err.message);\\n  this.removeAllListeners();\\n};\\n\\nJsonpReceiver.prototype._cleanup = function() {\\n  debug('_cleanup');\\n  clearTimeout(this.timeoutId);\\n  if (this.script2) {\\n    this.script2.parentNode.removeChild(this.script2);\\n    this.script2 = null;\\n  }\\n  if (this.script) {\\n    var script = this.script;\\n    // Unfortunately, you can't really abort script loading of\\n    // the script.\\n    script.parentNode.removeChild(script);\\n    script.onreadystatechange = script.onerror =\\n        script.onload = script.onclick = null;\\n    this.script = null;\\n  }\\n  delete global[utils.WPrefix][this.id];\\n};\\n\\nJsonpReceiver.prototype._scriptError = function() {\\n  debug('_scriptError');\\n  var self = this;\\n  if (this.errorTimer) {\\n    return;\\n  }\\n\\n  this.errorTimer = setTimeout(function() {\\n    if (!self.loadedOkay) {\\n      self._abort(new Error('JSONP script loaded abnormally (onerror)'));\\n    }\\n  }, JsonpReceiver.scriptErrorTimeout);\\n};\\n\\nJsonpReceiver.prototype._createScript = function(url) {\\n  debug('_createScript', url);\\n  var self = this;\\n  var script = this.script = global.document.createElement('script');\\n  var script2;  // Opera synchronous load trick.\\n\\n  script.id = 'a' + random.string(8);\\n  script.src = url;\\n  script.type = 'text/javascript';\\n  script.charset = 'UTF-8';\\n  script.onerror = this._scriptError.bind(this);\\n  script.onload = function() {\\n    debug('onload');\\n    self._abort(new Error('JSONP script loaded abnormally (onload)'));\\n  };\\n\\n  // IE9 fires 'error' event after onreadystatechange or before, in random order.\\n  // Use loadedOkay to determine if actually errored\\n  script.onreadystatechange = function() {\\n    debug('onreadystatechange', script.readyState);\\n    if (/loaded|closed/.test(script.readyState)) {\\n      if (script && script.htmlFor && script.onclick) {\\n        self.loadedOkay = true;\\n        try {\\n          // In IE, actually execute the script.\\n          script.onclick();\\n        } catch (x) {\\n          // intentionally empty\\n        }\\n      }\\n      if (script) {\\n        self._abort(new Error('JSONP script loaded abnormally (onreadystatechange)'));\\n      }\\n    }\\n  };\\n  // IE: event/htmlFor/onclick trick.\\n  // One can't rely on proper order for onreadystatechange. In order to\\n  // make sure, set a 'htmlFor' and 'event' properties, so that\\n  // script code will be installed as 'onclick' handler for the\\n  // script object. Later, onreadystatechange, manually execute this\\n  // code. FF and Chrome doesn't work with 'event' and 'htmlFor'\\n  // set. For reference see:\\n  //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html\\n  // Also, read on that about script ordering:\\n  //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order\\n  if (typeof script.async === 'undefined' && global.document.attachEvent) {\\n    // According to mozilla docs, in recent browsers script.async defaults\\n    // to 'true', so we may use it to detect a good browser:\\n    // https://developer.mozilla.org/en/HTML/Element/script\\n    if (!browser.isOpera()) {\\n      // Naively assume we're in IE\\n      try {\\n        script.htmlFor = script.id;\\n        script.event = 'onclick';\\n      } catch (x) {\\n        // intentionally empty\\n      }\\n      script.async = true;\\n    } else {\\n      // Opera, second sync script hack\\n      script2 = this.script2 = global.document.createElement('script');\\n      script2.text = \\\"try{var a = document.getElementById('\\\" + script.id + \\\"'); if(a)a.onerror();}catch(x){};\\\";\\n      script.async = script2.async = false;\\n    }\\n  }\\n  if (typeof script.async !== 'undefined') {\\n    script.async = true;\\n  }\\n\\n  var head = global.document.getElementsByTagName('head')[0];\\n  head.insertBefore(script, head.firstChild);\\n  if (script2) {\\n    head.insertBefore(script2, head.firstChild);\\n  }\\n};\\n\\nmodule.exports = JsonpReceiver;\\n\\n}).call(this,{ env: {} },typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n\\n},{\\\"../../utils/browser\\\":44,\\\"../../utils/iframe\\\":47,\\\"../../utils/random\\\":50,\\\"../../utils/url\\\":52,\\\"debug\\\":55,\\\"events\\\":3,\\\"inherits\\\":57}],32:[function(require,module,exports){\\n(function (process){\\n'use strict';\\n\\nvar inherits = require('inherits')\\n  , EventEmitter = require('events').EventEmitter\\n  ;\\n\\nvar debug = function() {};\\nif (process.env.NODE_ENV !== 'production') {\\n  debug = require('debug')('sockjs-client:receiver:xhr');\\n}\\n\\nfunction XhrReceiver(url, AjaxObject) {\\n  debug(url);\\n  EventEmitter.call(this);\\n  var self = this;\\n\\n  this.bufferPosition = 0;\\n\\n  this.xo = new AjaxObject('POST', url, null);\\n  this.xo.on('chunk', this._chunkHandler.bind(this));\\n  this.xo.once('finish', function(status, text) {\\n    debug('finish', status, text);\\n    self._chunkHandler(status, text);\\n    self.xo = null;\\n    var reason = status === 200 ? 'network' : 'permanent';\\n    debug('close', reason);\\n    self.emit('close', null, reason);\\n    self._cleanup();\\n  });\\n}\\n\\ninherits(XhrReceiver, EventEmitter);\\n\\nXhrReceiver.prototype._chunkHandler = function(status, text) {\\n  debug('_chunkHandler', status);\\n  if (status !== 200 || !text) {\\n    return;\\n  }\\n\\n  for (var idx = -1; ; this.bufferPosition += idx + 1) {\\n    var buf = text.slice(this.bufferPosition);\\n    idx = buf.indexOf('\\\\n');\\n    if (idx === -1) {\\n      break;\\n    }\\n    var msg = buf.slice(0, idx);\\n    if (msg) {\\n      debug('message', msg);\\n      this.emit('message', msg);\\n    }\\n  }\\n};\\n\\nXhrReceiver.prototype._cleanup = function() {\\n  debug('_cleanup');\\n  this.removeAllListeners();\\n};\\n\\nXhrReceiver.prototype.abort = function() {\\n  debug('abort');\\n  if (this.xo) {\\n    this.xo.close();\\n    debug('close');\\n    this.emit('close', null, 'user');\\n    this.xo = null;\\n  }\\n  this._cleanup();\\n};\\n\\nmodule.exports = XhrReceiver;\\n\\n}).call(this,{ env: {} })\\n\\n},{\\\"debug\\\":55,\\\"events\\\":3,\\\"inherits\\\":57}],33:[function(require,module,exports){\\n(function (process,global){\\n'use strict';\\n\\nvar random = require('../../utils/random')\\n  , urlUtils = require('../../utils/url')\\n  ;\\n\\nvar debug = function() {};\\nif (process.env.NODE_ENV !== 'production') {\\n  debug = require('debug')('sockjs-client:sender:jsonp');\\n}\\n\\nvar form, area;\\n\\nfunction createIframe(id) {\\n  debug('createIframe', id);\\n  try {\\n    // ie6 dynamic iframes with target=\\\"\\\" support (thanks Chris Lambacher)\\n    return global.document.createElement('<iframe name=\\\"' + id + '\\\">');\\n  } catch (x) {\\n    var iframe = global.document.createElement('iframe');\\n    iframe.name = id;\\n    return iframe;\\n  }\\n}\\n\\nfunction createForm() {\\n  debug('createForm');\\n  form = global.document.createElement('form');\\n  form.style.display = 'none';\\n  form.style.position = 'absolute';\\n  form.method = 'POST';\\n  form.enctype = 'application/x-www-form-urlencoded';\\n  form.acceptCharset = 'UTF-8';\\n\\n  area = global.document.createElement('textarea');\\n  area.name = 'd';\\n  form.appendChild(area);\\n\\n  global.document.body.appendChild(form);\\n}\\n\\nmodule.exports = function(url, payload, callback) {\\n  debug(url, payload);\\n  if (!form) {\\n    createForm();\\n  }\\n  var id = 'a' + random.string(8);\\n  form.target = id;\\n  form.action = urlUtils.addQuery(urlUtils.addPath(url, '/jsonp_send'), 'i=' + id);\\n\\n  var iframe = createIframe(id);\\n  iframe.id = id;\\n  iframe.style.display = 'none';\\n  form.appendChild(iframe);\\n\\n  try {\\n    area.value = payload;\\n  } catch (e) {\\n    // seriously broken browsers get here\\n  }\\n  form.submit();\\n\\n  var completed = function(err) {\\n    debug('completed', id, err);\\n    if (!iframe.onerror) {\\n      return;\\n    }\\n    iframe.onreadystatechange = iframe.onerror = iframe.onload = null;\\n    // Opera mini doesn't like if we GC iframe\\n    // immediately, thus this timeout.\\n    setTimeout(function() {\\n      debug('cleaning up', id);\\n      iframe.parentNode.removeChild(iframe);\\n      iframe = null;\\n    }, 500);\\n    area.value = '';\\n    // It is not possible to detect if the iframe succeeded or\\n    // failed to submit our form.\\n    callback(err);\\n  };\\n  iframe.onerror = function() {\\n    debug('onerror', id);\\n    completed();\\n  };\\n  iframe.onload = function() {\\n    debug('onload', id);\\n    completed();\\n  };\\n  iframe.onreadystatechange = function(e) {\\n    debug('onreadystatechange', id, iframe.readyState, e);\\n    if (iframe.readyState === 'complete') {\\n      completed();\\n    }\\n  };\\n  return function() {\\n    debug('aborted', id);\\n    completed(new Error('Aborted'));\\n  };\\n};\\n\\n}).call(this,{ env: {} },typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n\\n},{\\\"../../utils/random\\\":50,\\\"../../utils/url\\\":52,\\\"debug\\\":55}],34:[function(require,module,exports){\\n(function (process,global){\\n'use strict';\\n\\nvar EventEmitter = require('events').EventEmitter\\n  , inherits = require('inherits')\\n  , eventUtils = require('../../utils/event')\\n  , browser = require('../../utils/browser')\\n  , urlUtils = require('../../utils/url')\\n  ;\\n\\nvar debug = function() {};\\nif (process.env.NODE_ENV !== 'production') {\\n  debug = require('debug')('sockjs-client:sender:xdr');\\n}\\n\\n// References:\\n//   http://ajaxian.com/archives/100-line-ajax-wrapper\\n//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx\\n\\nfunction XDRObject(method, url, payload) {\\n  debug(method, url);\\n  var self = this;\\n  EventEmitter.call(this);\\n\\n  setTimeout(function() {\\n    self._start(method, url, payload);\\n  }, 0);\\n}\\n\\ninherits(XDRObject, EventEmitter);\\n\\nXDRObject.prototype._start = function(method, url, payload) {\\n  debug('_start');\\n  var self = this;\\n  var xdr = new global.XDomainRequest();\\n  // IE caches even POSTs\\n  url = urlUtils.addQuery(url, 't=' + (+new Date()));\\n\\n  xdr.onerror = function() {\\n    debug('onerror');\\n    self._error();\\n  };\\n  xdr.ontimeout = function() {\\n    debug('ontimeout');\\n    self._error();\\n  };\\n  xdr.onprogress = function() {\\n    debug('progress', xdr.responseText);\\n    self.emit('chunk', 200, xdr.responseText);\\n  };\\n  xdr.onload = function() {\\n    debug('load');\\n    self.emit('finish', 200, xdr.responseText);\\n    self._cleanup(false);\\n  };\\n  this.xdr = xdr;\\n  this.unloadRef = eventUtils.unloadAdd(function() {\\n    self._cleanup(true);\\n  });\\n  try {\\n    // Fails with AccessDenied if port number is bogus\\n    this.xdr.open(method, url);\\n    if (this.timeout) {\\n      this.xdr.timeout = this.timeout;\\n    }\\n    this.xdr.send(payload);\\n  } catch (x) {\\n    this._error();\\n  }\\n};\\n\\nXDRObject.prototype._error = function() {\\n  this.emit('finish', 0, '');\\n  this._cleanup(false);\\n};\\n\\nXDRObject.prototype._cleanup = function(abort) {\\n  debug('cleanup', abort);\\n  if (!this.xdr) {\\n    return;\\n  }\\n  this.removeAllListeners();\\n  eventUtils.unloadDel(this.unloadRef);\\n\\n  this.xdr.ontimeout = this.xdr.onerror = this.xdr.onprogress = this.xdr.onload = null;\\n  if (abort) {\\n    try {\\n      this.xdr.abort();\\n    } catch (x) {\\n      // intentionally empty\\n    }\\n  }\\n  this.unloadRef = this.xdr = null;\\n};\\n\\nXDRObject.prototype.close = function() {\\n  debug('close');\\n  this._cleanup(true);\\n};\\n\\n// IE 8/9 if the request target uses the same scheme - #79\\nXDRObject.enabled = !!(global.XDomainRequest && browser.hasDomain());\\n\\nmodule.exports = XDRObject;\\n\\n}).call(this,{ env: {} },typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n\\n},{\\\"../../utils/browser\\\":44,\\\"../../utils/event\\\":46,\\\"../../utils/url\\\":52,\\\"debug\\\":55,\\\"events\\\":3,\\\"inherits\\\":57}],35:[function(require,module,exports){\\n'use strict';\\n\\nvar inherits = require('inherits')\\n  , XhrDriver = require('../driver/xhr')\\n  ;\\n\\nfunction XHRCorsObject(method, url, payload, opts) {\\n  XhrDriver.call(this, method, url, payload, opts);\\n}\\n\\ninherits(XHRCorsObject, XhrDriver);\\n\\nXHRCorsObject.enabled = XhrDriver.enabled && XhrDriver.supportsCORS;\\n\\nmodule.exports = XHRCorsObject;\\n\\n},{\\\"../driver/xhr\\\":17,\\\"inherits\\\":57}],36:[function(require,module,exports){\\n'use strict';\\n\\nvar EventEmitter = require('events').EventEmitter\\n  , inherits = require('inherits')\\n  ;\\n\\nfunction XHRFake(/* method, url, payload, opts */) {\\n  var self = this;\\n  EventEmitter.call(this);\\n\\n  this.to = setTimeout(function() {\\n    self.emit('finish', 200, '{}');\\n  }, XHRFake.timeout);\\n}\\n\\ninherits(XHRFake, EventEmitter);\\n\\nXHRFake.prototype.close = function() {\\n  clearTimeout(this.to);\\n};\\n\\nXHRFake.timeout = 2000;\\n\\nmodule.exports = XHRFake;\\n\\n},{\\\"events\\\":3,\\\"inherits\\\":57}],37:[function(require,module,exports){\\n'use strict';\\n\\nvar inherits = require('inherits')\\n  , XhrDriver = require('../driver/xhr')\\n  ;\\n\\nfunction XHRLocalObject(method, url, payload /*, opts */) {\\n  XhrDriver.call(this, method, url, payload, {\\n    noCredentials: true\\n  });\\n}\\n\\ninherits(XHRLocalObject, XhrDriver);\\n\\nXHRLocalObject.enabled = XhrDriver.enabled;\\n\\nmodule.exports = XHRLocalObject;\\n\\n},{\\\"../driver/xhr\\\":17,\\\"inherits\\\":57}],38:[function(require,module,exports){\\n(function (process){\\n'use strict';\\n\\nvar utils = require('../utils/event')\\n  , urlUtils = require('../utils/url')\\n  , inherits = require('inherits')\\n  , EventEmitter = require('events').EventEmitter\\n  , WebsocketDriver = require('./driver/websocket')\\n  ;\\n\\nvar debug = function() {};\\nif (process.env.NODE_ENV !== 'production') {\\n  debug = require('debug')('sockjs-client:websocket');\\n}\\n\\nfunction WebSocketTransport(transUrl, ignore, options) {\\n  if (!WebSocketTransport.enabled()) {\\n    throw new Error('Transport created when disabled');\\n  }\\n\\n  EventEmitter.call(this);\\n  debug('constructor', transUrl);\\n\\n  var self = this;\\n  var url = urlUtils.addPath(transUrl, '/websocket');\\n  if (url.slice(0, 5) === 'https') {\\n    url = 'wss' + url.slice(5);\\n  } else {\\n    url = 'ws' + url.slice(4);\\n  }\\n  this.url = url;\\n\\n  this.ws = new WebsocketDriver(this.url, [], options);\\n  this.ws.onmessage = function(e) {\\n    debug('message event', e.data);\\n    self.emit('message', e.data);\\n  };\\n  // Firefox has an interesting bug. If a websocket connection is\\n  // created after onunload, it stays alive even when user\\n  // navigates away from the page. In such situation let's lie -\\n  // let's not open the ws connection at all. See:\\n  // https://github.com/sockjs/sockjs-client/issues/28\\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=696085\\n  this.unloadRef = utils.unloadAdd(function() {\\n    debug('unload');\\n    self.ws.close();\\n  });\\n  this.ws.onclose = function(e) {\\n    debug('close event', e.code, e.reason);\\n    self.emit('close', e.code, e.reason);\\n    self._cleanup();\\n  };\\n  this.ws.onerror = function(e) {\\n    debug('error event', e);\\n    self.emit('close', 1006, 'WebSocket connection broken');\\n    self._cleanup();\\n  };\\n}\\n\\ninherits(WebSocketTransport, EventEmitter);\\n\\nWebSocketTransport.prototype.send = function(data) {\\n  var msg = '[' + data + ']';\\n  debug('send', msg);\\n  this.ws.send(msg);\\n};\\n\\nWebSocketTransport.prototype.close = function() {\\n  debug('close');\\n  var ws = this.ws;\\n  this._cleanup();\\n  if (ws) {\\n    ws.close();\\n  }\\n};\\n\\nWebSocketTransport.prototype._cleanup = function() {\\n  debug('_cleanup');\\n  var ws = this.ws;\\n  if (ws) {\\n    ws.onmessage = ws.onclose = ws.onerror = null;\\n  }\\n  utils.unloadDel(this.unloadRef);\\n  this.unloadRef = this.ws = null;\\n  this.removeAllListeners();\\n};\\n\\nWebSocketTransport.enabled = function() {\\n  debug('enabled');\\n  return !!WebsocketDriver;\\n};\\nWebSocketTransport.transportName = 'websocket';\\n\\n// In theory, ws should require 1 round trip. But in chrome, this is\\n// not very stable over SSL. Most likely a ws connection requires a\\n// separate SSL connection, in which case 2 round trips are an\\n// absolute minumum.\\nWebSocketTransport.roundTrips = 2;\\n\\nmodule.exports = WebSocketTransport;\\n\\n}).call(this,{ env: {} })\\n\\n},{\\\"../utils/event\\\":46,\\\"../utils/url\\\":52,\\\"./driver/websocket\\\":19,\\\"debug\\\":55,\\\"events\\\":3,\\\"inherits\\\":57}],39:[function(require,module,exports){\\n'use strict';\\n\\nvar inherits = require('inherits')\\n  , AjaxBasedTransport = require('./lib/ajax-based')\\n  , XdrStreamingTransport = require('./xdr-streaming')\\n  , XhrReceiver = require('./receiver/xhr')\\n  , XDRObject = require('./sender/xdr')\\n  ;\\n\\nfunction XdrPollingTransport(transUrl) {\\n  if (!XDRObject.enabled) {\\n    throw new Error('Transport created when disabled');\\n  }\\n  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XDRObject);\\n}\\n\\ninherits(XdrPollingTransport, AjaxBasedTransport);\\n\\nXdrPollingTransport.enabled = XdrStreamingTransport.enabled;\\nXdrPollingTransport.transportName = 'xdr-polling';\\nXdrPollingTransport.roundTrips = 2; // preflight, ajax\\n\\nmodule.exports = XdrPollingTransport;\\n\\n},{\\\"./lib/ajax-based\\\":24,\\\"./receiver/xhr\\\":32,\\\"./sender/xdr\\\":34,\\\"./xdr-streaming\\\":40,\\\"inherits\\\":57}],40:[function(require,module,exports){\\n'use strict';\\n\\nvar inherits = require('inherits')\\n  , AjaxBasedTransport = require('./lib/ajax-based')\\n  , XhrReceiver = require('./receiver/xhr')\\n  , XDRObject = require('./sender/xdr')\\n  ;\\n\\n// According to:\\n//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests\\n//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/\\n\\nfunction XdrStreamingTransport(transUrl) {\\n  if (!XDRObject.enabled) {\\n    throw new Error('Transport created when disabled');\\n  }\\n  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XDRObject);\\n}\\n\\ninherits(XdrStreamingTransport, AjaxBasedTransport);\\n\\nXdrStreamingTransport.enabled = function(info) {\\n  if (info.cookie_needed || info.nullOrigin) {\\n    return false;\\n  }\\n  return XDRObject.enabled && info.sameScheme;\\n};\\n\\nXdrStreamingTransport.transportName = 'xdr-streaming';\\nXdrStreamingTransport.roundTrips = 2; // preflight, ajax\\n\\nmodule.exports = XdrStreamingTransport;\\n\\n},{\\\"./lib/ajax-based\\\":24,\\\"./receiver/xhr\\\":32,\\\"./sender/xdr\\\":34,\\\"inherits\\\":57}],41:[function(require,module,exports){\\n'use strict';\\n\\nvar inherits = require('inherits')\\n  , AjaxBasedTransport = require('./lib/ajax-based')\\n  , XhrReceiver = require('./receiver/xhr')\\n  , XHRCorsObject = require('./sender/xhr-cors')\\n  , XHRLocalObject = require('./sender/xhr-local')\\n  ;\\n\\nfunction XhrPollingTransport(transUrl) {\\n  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {\\n    throw new Error('Transport created when disabled');\\n  }\\n  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XHRCorsObject);\\n}\\n\\ninherits(XhrPollingTransport, AjaxBasedTransport);\\n\\nXhrPollingTransport.enabled = function(info) {\\n  if (info.nullOrigin) {\\n    return false;\\n  }\\n\\n  if (XHRLocalObject.enabled && info.sameOrigin) {\\n    return true;\\n  }\\n  return XHRCorsObject.enabled;\\n};\\n\\nXhrPollingTransport.transportName = 'xhr-polling';\\nXhrPollingTransport.roundTrips = 2; // preflight, ajax\\n\\nmodule.exports = XhrPollingTransport;\\n\\n},{\\\"./lib/ajax-based\\\":24,\\\"./receiver/xhr\\\":32,\\\"./sender/xhr-cors\\\":35,\\\"./sender/xhr-local\\\":37,\\\"inherits\\\":57}],42:[function(require,module,exports){\\n(function (global){\\n'use strict';\\n\\nvar inherits = require('inherits')\\n  , AjaxBasedTransport = require('./lib/ajax-based')\\n  , XhrReceiver = require('./receiver/xhr')\\n  , XHRCorsObject = require('./sender/xhr-cors')\\n  , XHRLocalObject = require('./sender/xhr-local')\\n  , browser = require('../utils/browser')\\n  ;\\n\\nfunction XhrStreamingTransport(transUrl) {\\n  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {\\n    throw new Error('Transport created when disabled');\\n  }\\n  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XHRCorsObject);\\n}\\n\\ninherits(XhrStreamingTransport, AjaxBasedTransport);\\n\\nXhrStreamingTransport.enabled = function(info) {\\n  if (info.nullOrigin) {\\n    return false;\\n  }\\n  // Opera doesn't support xhr-streaming #60\\n  // But it might be able to #92\\n  if (browser.isOpera()) {\\n    return false;\\n  }\\n\\n  return XHRCorsObject.enabled;\\n};\\n\\nXhrStreamingTransport.transportName = 'xhr-streaming';\\nXhrStreamingTransport.roundTrips = 2; // preflight, ajax\\n\\n// Safari gets confused when a streaming ajax request is started\\n// before onload. This causes the load indicator to spin indefinetely.\\n// Only require body when used in a browser\\nXhrStreamingTransport.needBody = !!global.document;\\n\\nmodule.exports = XhrStreamingTransport;\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n\\n},{\\\"../utils/browser\\\":44,\\\"./lib/ajax-based\\\":24,\\\"./receiver/xhr\\\":32,\\\"./sender/xhr-cors\\\":35,\\\"./sender/xhr-local\\\":37,\\\"inherits\\\":57}],43:[function(require,module,exports){\\n(function (global){\\n'use strict';\\n\\nif (global.crypto && global.crypto.getRandomValues) {\\n  module.exports.randomBytes = function(length) {\\n    var bytes = new Uint8Array(length);\\n    global.crypto.getRandomValues(bytes);\\n    return bytes;\\n  };\\n} else {\\n  module.exports.randomBytes = function(length) {\\n    var bytes = new Array(length);\\n    for (var i = 0; i < length; i++) {\\n      bytes[i] = Math.floor(Math.random() * 256);\\n    }\\n    return bytes;\\n  };\\n}\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n\\n},{}],44:[function(require,module,exports){\\n(function (global){\\n'use strict';\\n\\nmodule.exports = {\\n  isOpera: function() {\\n    return global.navigator &&\\n      /opera/i.test(global.navigator.userAgent);\\n  }\\n\\n, isKonqueror: function() {\\n    return global.navigator &&\\n      /konqueror/i.test(global.navigator.userAgent);\\n  }\\n\\n  // #187 wrap document.domain in try/catch because of WP8 from file:///\\n, hasDomain: function () {\\n    // non-browser client always has a domain\\n    if (!global.document) {\\n      return true;\\n    }\\n\\n    try {\\n      return !!global.document.domain;\\n    } catch (e) {\\n      return false;\\n    }\\n  }\\n};\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n\\n},{}],45:[function(require,module,exports){\\n'use strict';\\n\\nvar JSON3 = require('json3');\\n\\n// Some extra characters that Chrome gets wrong, and substitutes with\\n// something else on the wire.\\n// eslint-disable-next-line no-control-regex\\nvar extraEscapable = /[\\\\x00-\\\\x1f\\\\ud800-\\\\udfff\\\\ufffe\\\\uffff\\\\u0300-\\\\u0333\\\\u033d-\\\\u0346\\\\u034a-\\\\u034c\\\\u0350-\\\\u0352\\\\u0357-\\\\u0358\\\\u035c-\\\\u0362\\\\u0374\\\\u037e\\\\u0387\\\\u0591-\\\\u05af\\\\u05c4\\\\u0610-\\\\u0617\\\\u0653-\\\\u0654\\\\u0657-\\\\u065b\\\\u065d-\\\\u065e\\\\u06df-\\\\u06e2\\\\u06eb-\\\\u06ec\\\\u0730\\\\u0732-\\\\u0733\\\\u0735-\\\\u0736\\\\u073a\\\\u073d\\\\u073f-\\\\u0741\\\\u0743\\\\u0745\\\\u0747\\\\u07eb-\\\\u07f1\\\\u0951\\\\u0958-\\\\u095f\\\\u09dc-\\\\u09dd\\\\u09df\\\\u0a33\\\\u0a36\\\\u0a59-\\\\u0a5b\\\\u0a5e\\\\u0b5c-\\\\u0b5d\\\\u0e38-\\\\u0e39\\\\u0f43\\\\u0f4d\\\\u0f52\\\\u0f57\\\\u0f5c\\\\u0f69\\\\u0f72-\\\\u0f76\\\\u0f78\\\\u0f80-\\\\u0f83\\\\u0f93\\\\u0f9d\\\\u0fa2\\\\u0fa7\\\\u0fac\\\\u0fb9\\\\u1939-\\\\u193a\\\\u1a17\\\\u1b6b\\\\u1cda-\\\\u1cdb\\\\u1dc0-\\\\u1dcf\\\\u1dfc\\\\u1dfe\\\\u1f71\\\\u1f73\\\\u1f75\\\\u1f77\\\\u1f79\\\\u1f7b\\\\u1f7d\\\\u1fbb\\\\u1fbe\\\\u1fc9\\\\u1fcb\\\\u1fd3\\\\u1fdb\\\\u1fe3\\\\u1feb\\\\u1fee-\\\\u1fef\\\\u1ff9\\\\u1ffb\\\\u1ffd\\\\u2000-\\\\u2001\\\\u20d0-\\\\u20d1\\\\u20d4-\\\\u20d7\\\\u20e7-\\\\u20e9\\\\u2126\\\\u212a-\\\\u212b\\\\u2329-\\\\u232a\\\\u2adc\\\\u302b-\\\\u302c\\\\uaab2-\\\\uaab3\\\\uf900-\\\\ufa0d\\\\ufa10\\\\ufa12\\\\ufa15-\\\\ufa1e\\\\ufa20\\\\ufa22\\\\ufa25-\\\\ufa26\\\\ufa2a-\\\\ufa2d\\\\ufa30-\\\\ufa6d\\\\ufa70-\\\\ufad9\\\\ufb1d\\\\ufb1f\\\\ufb2a-\\\\ufb36\\\\ufb38-\\\\ufb3c\\\\ufb3e\\\\ufb40-\\\\ufb41\\\\ufb43-\\\\ufb44\\\\ufb46-\\\\ufb4e\\\\ufff0-\\\\uffff]/g\\n  , extraLookup;\\n\\n// This may be quite slow, so let's delay until user actually uses bad\\n// characters.\\nvar unrollLookup = function(escapable) {\\n  var i;\\n  var unrolled = {};\\n  var c = [];\\n  for (i = 0; i < 65536; i++) {\\n    c.push( String.fromCharCode(i) );\\n  }\\n  escapable.lastIndex = 0;\\n  c.join('').replace(escapable, function(a) {\\n    unrolled[ a ] = '\\\\\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\\n    return '';\\n  });\\n  escapable.lastIndex = 0;\\n  return unrolled;\\n};\\n\\n// Quote string, also taking care of unicode characters that browsers\\n// often break. Especially, take care of unicode surrogates:\\n// http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates\\nmodule.exports = {\\n  quote: function(string) {\\n    var quoted = JSON3.stringify(string);\\n\\n    // In most cases this should be very fast and good enough.\\n    extraEscapable.lastIndex = 0;\\n    if (!extraEscapable.test(quoted)) {\\n      return quoted;\\n    }\\n\\n    if (!extraLookup) {\\n      extraLookup = unrollLookup(extraEscapable);\\n    }\\n\\n    return quoted.replace(extraEscapable, function(a) {\\n      return extraLookup[a];\\n    });\\n  }\\n};\\n\\n},{\\\"json3\\\":58}],46:[function(require,module,exports){\\n(function (global){\\n'use strict';\\n\\nvar random = require('./random');\\n\\nvar onUnload = {}\\n  , afterUnload = false\\n    // detect google chrome packaged apps because they don't allow the 'unload' event\\n  , isChromePackagedApp = global.chrome && global.chrome.app && global.chrome.app.runtime\\n  ;\\n\\nmodule.exports = {\\n  attachEvent: function(event, listener) {\\n    if (typeof global.addEventListener !== 'undefined') {\\n      global.addEventListener(event, listener, false);\\n    } else if (global.document && global.attachEvent) {\\n      // IE quirks.\\n      // According to: http://stevesouders.com/misc/test-postmessage.php\\n      // the message gets delivered only to 'document', not 'window'.\\n      global.document.attachEvent('on' + event, listener);\\n      // I get 'window' for ie8.\\n      global.attachEvent('on' + event, listener);\\n    }\\n  }\\n\\n, detachEvent: function(event, listener) {\\n    if (typeof global.addEventListener !== 'undefined') {\\n      global.removeEventListener(event, listener, false);\\n    } else if (global.document && global.detachEvent) {\\n      global.document.detachEvent('on' + event, listener);\\n      global.detachEvent('on' + event, listener);\\n    }\\n  }\\n\\n, unloadAdd: function(listener) {\\n    if (isChromePackagedApp) {\\n      return null;\\n    }\\n\\n    var ref = random.string(8);\\n    onUnload[ref] = listener;\\n    if (afterUnload) {\\n      setTimeout(this.triggerUnloadCallbacks, 0);\\n    }\\n    return ref;\\n  }\\n\\n, unloadDel: function(ref) {\\n    if (ref in onUnload) {\\n      delete onUnload[ref];\\n    }\\n  }\\n\\n, triggerUnloadCallbacks: function() {\\n    for (var ref in onUnload) {\\n      onUnload[ref]();\\n      delete onUnload[ref];\\n    }\\n  }\\n};\\n\\nvar unloadTriggered = function() {\\n  if (afterUnload) {\\n    return;\\n  }\\n  afterUnload = true;\\n  module.exports.triggerUnloadCallbacks();\\n};\\n\\n// 'unload' alone is not reliable in opera within an iframe, but we\\n// can't use `beforeunload` as IE fires it on javascript: links.\\nif (!isChromePackagedApp) {\\n  module.exports.attachEvent('unload', unloadTriggered);\\n}\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n\\n},{\\\"./random\\\":50}],47:[function(require,module,exports){\\n(function (process,global){\\n'use strict';\\n\\nvar eventUtils = require('./event')\\n  , JSON3 = require('json3')\\n  , browser = require('./browser')\\n  ;\\n\\nvar debug = function() {};\\nif (process.env.NODE_ENV !== 'production') {\\n  debug = require('debug')('sockjs-client:utils:iframe');\\n}\\n\\nmodule.exports = {\\n  WPrefix: '_jp'\\n, currentWindowId: null\\n\\n, polluteGlobalNamespace: function() {\\n    if (!(module.exports.WPrefix in global)) {\\n      global[module.exports.WPrefix] = {};\\n    }\\n  }\\n\\n, postMessage: function(type, data) {\\n    if (global.parent !== global) {\\n      global.parent.postMessage(JSON3.stringify({\\n        windowId: module.exports.currentWindowId\\n      , type: type\\n      , data: data || ''\\n      }), '*');\\n    } else {\\n      debug('Cannot postMessage, no parent window.', type, data);\\n    }\\n  }\\n\\n, createIframe: function(iframeUrl, errorCallback) {\\n    var iframe = global.document.createElement('iframe');\\n    var tref, unloadRef;\\n    var unattach = function() {\\n      debug('unattach');\\n      clearTimeout(tref);\\n      // Explorer had problems with that.\\n      try {\\n        iframe.onload = null;\\n      } catch (x) {\\n        // intentionally empty\\n      }\\n      iframe.onerror = null;\\n    };\\n    var cleanup = function() {\\n      debug('cleanup');\\n      if (iframe) {\\n        unattach();\\n        // This timeout makes chrome fire onbeforeunload event\\n        // within iframe. Without the timeout it goes straight to\\n        // onunload.\\n        setTimeout(function() {\\n          if (iframe) {\\n            iframe.parentNode.removeChild(iframe);\\n          }\\n          iframe = null;\\n        }, 0);\\n        eventUtils.unloadDel(unloadRef);\\n      }\\n    };\\n    var onerror = function(err) {\\n      debug('onerror', err);\\n      if (iframe) {\\n        cleanup();\\n        errorCallback(err);\\n      }\\n    };\\n    var post = function(msg, origin) {\\n      debug('post', msg, origin);\\n      try {\\n        // When the iframe is not loaded, IE raises an exception\\n        // on 'contentWindow'.\\n        setTimeout(function() {\\n          if (iframe && iframe.contentWindow) {\\n            iframe.contentWindow.postMessage(msg, origin);\\n          }\\n        }, 0);\\n      } catch (x) {\\n        // intentionally empty\\n      }\\n    };\\n\\n    iframe.src = iframeUrl;\\n    iframe.style.display = 'none';\\n    iframe.style.position = 'absolute';\\n    iframe.onerror = function() {\\n      onerror('onerror');\\n    };\\n    iframe.onload = function() {\\n      debug('onload');\\n      // `onload` is triggered before scripts on the iframe are\\n      // executed. Give it few seconds to actually load stuff.\\n      clearTimeout(tref);\\n      tref = setTimeout(function() {\\n        onerror('onload timeout');\\n      }, 2000);\\n    };\\n    global.document.body.appendChild(iframe);\\n    tref = setTimeout(function() {\\n      onerror('timeout');\\n    }, 15000);\\n    unloadRef = eventUtils.unloadAdd(cleanup);\\n    return {\\n      post: post\\n    , cleanup: cleanup\\n    , loaded: unattach\\n    };\\n  }\\n\\n/* eslint no-undef: \\\"off\\\", new-cap: \\\"off\\\" */\\n, createHtmlfile: function(iframeUrl, errorCallback) {\\n    var axo = ['Active'].concat('Object').join('X');\\n    var doc = new global[axo]('htmlfile');\\n    var tref, unloadRef;\\n    var iframe;\\n    var unattach = function() {\\n      clearTimeout(tref);\\n      iframe.onerror = null;\\n    };\\n    var cleanup = function() {\\n      if (doc) {\\n        unattach();\\n        eventUtils.unloadDel(unloadRef);\\n        iframe.parentNode.removeChild(iframe);\\n        iframe = doc = null;\\n        CollectGarbage();\\n      }\\n    };\\n    var onerror = function(r) {\\n      debug('onerror', r);\\n      if (doc) {\\n        cleanup();\\n        errorCallback(r);\\n      }\\n    };\\n    var post = function(msg, origin) {\\n      try {\\n        // When the iframe is not loaded, IE raises an exception\\n        // on 'contentWindow'.\\n        setTimeout(function() {\\n          if (iframe && iframe.contentWindow) {\\n              iframe.contentWindow.postMessage(msg, origin);\\n          }\\n        }, 0);\\n      } catch (x) {\\n        // intentionally empty\\n      }\\n    };\\n\\n    doc.open();\\n    doc.write('<html><s' + 'cript>' +\\n              'document.domain=\\\"' + global.document.domain + '\\\";' +\\n              '</s' + 'cript></html>');\\n    doc.close();\\n    doc.parentWindow[module.exports.WPrefix] = global[module.exports.WPrefix];\\n    var c = doc.createElement('div');\\n    doc.body.appendChild(c);\\n    iframe = doc.createElement('iframe');\\n    c.appendChild(iframe);\\n    iframe.src = iframeUrl;\\n    iframe.onerror = function() {\\n      onerror('onerror');\\n    };\\n    tref = setTimeout(function() {\\n      onerror('timeout');\\n    }, 15000);\\n    unloadRef = eventUtils.unloadAdd(cleanup);\\n    return {\\n      post: post\\n    , cleanup: cleanup\\n    , loaded: unattach\\n    };\\n  }\\n};\\n\\nmodule.exports.iframeEnabled = false;\\nif (global.document) {\\n  // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with\\n  // huge delay, or not at all.\\n  module.exports.iframeEnabled = (typeof global.postMessage === 'function' ||\\n    typeof global.postMessage === 'object') && (!browser.isKonqueror());\\n}\\n\\n}).call(this,{ env: {} },typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n\\n},{\\\"./browser\\\":44,\\\"./event\\\":46,\\\"debug\\\":55,\\\"json3\\\":58}],48:[function(require,module,exports){\\n(function (global){\\n'use strict';\\n\\nvar logObject = {};\\n['log', 'debug', 'warn'].forEach(function (level) {\\n  var levelExists;\\n\\n  try {\\n    levelExists = global.console && global.console[level] && global.console[level].apply;\\n  } catch(e) {\\n    // do nothing\\n  }\\n\\n  logObject[level] = levelExists ? function () {\\n    return global.console[level].apply(global.console, arguments);\\n  } : (level === 'log' ? function () {} : logObject.log);\\n});\\n\\nmodule.exports = logObject;\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n\\n},{}],49:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = {\\n  isObject: function(obj) {\\n    var type = typeof obj;\\n    return type === 'function' || type === 'object' && !!obj;\\n  }\\n\\n, extend: function(obj) {\\n    if (!this.isObject(obj)) {\\n      return obj;\\n    }\\n    var source, prop;\\n    for (var i = 1, length = arguments.length; i < length; i++) {\\n      source = arguments[i];\\n      for (prop in source) {\\n        if (Object.prototype.hasOwnProperty.call(source, prop)) {\\n          obj[prop] = source[prop];\\n        }\\n      }\\n    }\\n    return obj;\\n  }\\n};\\n\\n},{}],50:[function(require,module,exports){\\n'use strict';\\n\\n/* global crypto:true */\\nvar crypto = require('crypto');\\n\\n// This string has length 32, a power of 2, so the modulus doesn't introduce a\\n// bias.\\nvar _randomStringChars = 'abcdefghijklmnopqrstuvwxyz012345';\\nmodule.exports = {\\n  string: function(length) {\\n    var max = _randomStringChars.length;\\n    var bytes = crypto.randomBytes(length);\\n    var ret = [];\\n    for (var i = 0; i < length; i++) {\\n      ret.push(_randomStringChars.substr(bytes[i] % max, 1));\\n    }\\n    return ret.join('');\\n  }\\n\\n, number: function(max) {\\n    return Math.floor(Math.random() * max);\\n  }\\n\\n, numberString: function(max) {\\n    var t = ('' + (max - 1)).length;\\n    var p = new Array(t + 1).join('0');\\n    return (p + this.number(max)).slice(-t);\\n  }\\n};\\n\\n},{\\\"crypto\\\":43}],51:[function(require,module,exports){\\n(function (process){\\n'use strict';\\n\\nvar debug = function() {};\\nif (process.env.NODE_ENV !== 'production') {\\n  debug = require('debug')('sockjs-client:utils:transport');\\n}\\n\\nmodule.exports = function(availableTransports) {\\n  return {\\n    filterToEnabled: function(transportsWhitelist, info) {\\n      var transports = {\\n        main: []\\n      , facade: []\\n      };\\n      if (!transportsWhitelist) {\\n        transportsWhitelist = [];\\n      } else if (typeof transportsWhitelist === 'string') {\\n        transportsWhitelist = [transportsWhitelist];\\n      }\\n\\n      availableTransports.forEach(function(trans) {\\n        if (!trans) {\\n          return;\\n        }\\n\\n        if (trans.transportName === 'websocket' && info.websocket === false) {\\n          debug('disabled from server', 'websocket');\\n          return;\\n        }\\n\\n        if (transportsWhitelist.length &&\\n            transportsWhitelist.indexOf(trans.transportName) === -1) {\\n          debug('not in whitelist', trans.transportName);\\n          return;\\n        }\\n\\n        if (trans.enabled(info)) {\\n          debug('enabled', trans.transportName);\\n          transports.main.push(trans);\\n          if (trans.facadeTransport) {\\n            transports.facade.push(trans.facadeTransport);\\n          }\\n        } else {\\n          debug('disabled', trans.transportName);\\n        }\\n      });\\n      return transports;\\n    }\\n  };\\n};\\n\\n}).call(this,{ env: {} })\\n\\n},{\\\"debug\\\":55}],52:[function(require,module,exports){\\n(function (process){\\n'use strict';\\n\\nvar URL = require('url-parse');\\n\\nvar debug = function() {};\\nif (process.env.NODE_ENV !== 'production') {\\n  debug = require('debug')('sockjs-client:utils:url');\\n}\\n\\nmodule.exports = {\\n  getOrigin: function(url) {\\n    if (!url) {\\n      return null;\\n    }\\n\\n    var p = new URL(url);\\n    if (p.protocol === 'file:') {\\n      return null;\\n    }\\n\\n    var port = p.port;\\n    if (!port) {\\n      port = (p.protocol === 'https:') ? '443' : '80';\\n    }\\n\\n    return p.protocol + '//' + p.hostname + ':' + port;\\n  }\\n\\n, isOriginEqual: function(a, b) {\\n    var res = this.getOrigin(a) === this.getOrigin(b);\\n    debug('same', a, b, res);\\n    return res;\\n  }\\n\\n, isSchemeEqual: function(a, b) {\\n    return (a.split(':')[0] === b.split(':')[0]);\\n  }\\n\\n, addPath: function (url, path) {\\n    var qs = url.split('?');\\n    return qs[0] + path + (qs[1] ? '?' + qs[1] : '');\\n  }\\n\\n, addQuery: function (url, q) {\\n    return url + (url.indexOf('?') === -1 ? ('?' + q) : ('&' + q));\\n  }\\n};\\n\\n}).call(this,{ env: {} })\\n\\n},{\\\"debug\\\":55,\\\"url-parse\\\":61}],53:[function(require,module,exports){\\nmodule.exports = '1.1.4';\\n\\n},{}],54:[function(require,module,exports){\\n/**\\n * Helpers.\\n */\\n\\nvar s = 1000\\nvar m = s * 60\\nvar h = m * 60\\nvar d = h * 24\\nvar y = d * 365.25\\n\\n/**\\n * Parse or format the given `val`.\\n *\\n * Options:\\n *\\n *  - `long` verbose formatting [false]\\n *\\n * @param {String|Number} val\\n * @param {Object} [options]\\n * @throws {Error} throw an error if val is not a non-empty string or a number\\n * @return {String|Number}\\n * @api public\\n */\\n\\nmodule.exports = function (val, options) {\\n  options = options || {}\\n  var type = typeof val\\n  if (type === 'string' && val.length > 0) {\\n    return parse(val)\\n  } else if (type === 'number' && isNaN(val) === false) {\\n    return options.long ?\\n\\t\\t\\tfmtLong(val) :\\n\\t\\t\\tfmtShort(val)\\n  }\\n  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val))\\n}\\n\\n/**\\n * Parse the given `str` and return milliseconds.\\n *\\n * @param {String} str\\n * @return {Number}\\n * @api private\\n */\\n\\nfunction parse(str) {\\n  str = String(str)\\n  if (str.length > 10000) {\\n    return\\n  }\\n  var match = /^((?:\\\\d+)?\\\\.?\\\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str)\\n  if (!match) {\\n    return\\n  }\\n  var n = parseFloat(match[1])\\n  var type = (match[2] || 'ms').toLowerCase()\\n  switch (type) {\\n    case 'years':\\n    case 'year':\\n    case 'yrs':\\n    case 'yr':\\n    case 'y':\\n      return n * y\\n    case 'days':\\n    case 'day':\\n    case 'd':\\n      return n * d\\n    case 'hours':\\n    case 'hour':\\n    case 'hrs':\\n    case 'hr':\\n    case 'h':\\n      return n * h\\n    case 'minutes':\\n    case 'minute':\\n    case 'mins':\\n    case 'min':\\n    case 'm':\\n      return n * m\\n    case 'seconds':\\n    case 'second':\\n    case 'secs':\\n    case 'sec':\\n    case 's':\\n      return n * s\\n    case 'milliseconds':\\n    case 'millisecond':\\n    case 'msecs':\\n    case 'msec':\\n    case 'ms':\\n      return n\\n    default:\\n      return undefined\\n  }\\n}\\n\\n/**\\n * Short format for `ms`.\\n *\\n * @param {Number} ms\\n * @return {String}\\n * @api private\\n */\\n\\nfunction fmtShort(ms) {\\n  if (ms >= d) {\\n    return Math.round(ms / d) + 'd'\\n  }\\n  if (ms >= h) {\\n    return Math.round(ms / h) + 'h'\\n  }\\n  if (ms >= m) {\\n    return Math.round(ms / m) + 'm'\\n  }\\n  if (ms >= s) {\\n    return Math.round(ms / s) + 's'\\n  }\\n  return ms + 'ms'\\n}\\n\\n/**\\n * Long format for `ms`.\\n *\\n * @param {Number} ms\\n * @return {String}\\n * @api private\\n */\\n\\nfunction fmtLong(ms) {\\n  return plural(ms, d, 'day') ||\\n    plural(ms, h, 'hour') ||\\n    plural(ms, m, 'minute') ||\\n    plural(ms, s, 'second') ||\\n    ms + ' ms'\\n}\\n\\n/**\\n * Pluralization helper.\\n */\\n\\nfunction plural(ms, n, name) {\\n  if (ms < n) {\\n    return\\n  }\\n  if (ms < n * 1.5) {\\n    return Math.floor(ms / n) + ' ' + name\\n  }\\n  return Math.ceil(ms / n) + ' ' + name + 's'\\n}\\n\\n},{}],55:[function(require,module,exports){\\n(function (process){\\n/**\\n * This is the web browser implementation of `debug()`.\\n *\\n * Expose `debug()` as the module.\\n */\\n\\nexports = module.exports = require('./debug');\\nexports.log = log;\\nexports.formatArgs = formatArgs;\\nexports.save = save;\\nexports.load = load;\\nexports.useColors = useColors;\\nexports.storage = 'undefined' != typeof chrome\\n               && 'undefined' != typeof chrome.storage\\n                  ? chrome.storage.local\\n                  : localstorage();\\n\\n/**\\n * Colors.\\n */\\n\\nexports.colors = [\\n  'lightseagreen',\\n  'forestgreen',\\n  'goldenrod',\\n  'dodgerblue',\\n  'darkorchid',\\n  'crimson'\\n];\\n\\n/**\\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\\n * and the Firebug extension (any Firefox version) are known\\n * to support \\\"%c\\\" CSS customizations.\\n *\\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\\n */\\n\\nfunction useColors() {\\n  // NB: In an Electron preload script, document will be defined but not fully\\n  // initialized. Since we know we're in Chrome, we'll just detect this case\\n  // explicitly\\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\\n    return true;\\n  }\\n\\n  // is webkit? http://stackoverflow.com/a/16459606/376773\\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\\n  return (typeof document !== 'undefined' && document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\\n    // is firebug? http://stackoverflow.com/a/398120/376773\\n    (typeof window !== 'undefined' && window && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\\n    // is firefox >= v31?\\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\\n    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\\\/(\\\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\\n    // double check webkit in userAgent just in case we are in a worker\\n    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\\\/(\\\\d+)/));\\n}\\n\\n/**\\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\\n */\\n\\nexports.formatters.j = function(v) {\\n  try {\\n    return JSON.stringify(v);\\n  } catch (err) {\\n    return '[UnexpectedJSONParseError]: ' + err.message;\\n  }\\n};\\n\\n\\n/**\\n * Colorize log arguments if enabled.\\n *\\n * @api public\\n */\\n\\nfunction formatArgs(args) {\\n  var useColors = this.useColors;\\n\\n  args[0] = (useColors ? '%c' : '')\\n    + this.namespace\\n    + (useColors ? ' %c' : ' ')\\n    + args[0]\\n    + (useColors ? '%c ' : ' ')\\n    + '+' + exports.humanize(this.diff);\\n\\n  if (!useColors) return;\\n\\n  var c = 'color: ' + this.color;\\n  args.splice(1, 0, c, 'color: inherit')\\n\\n  // the final \\\"%c\\\" is somewhat tricky, because there could be other\\n  // arguments passed either before or after the %c, so we need to\\n  // figure out the correct index to insert the CSS into\\n  var index = 0;\\n  var lastC = 0;\\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\\n    if ('%%' === match) return;\\n    index++;\\n    if ('%c' === match) {\\n      // we only are interested in the *last* %c\\n      // (the user may have provided their own)\\n      lastC = index;\\n    }\\n  });\\n\\n  args.splice(lastC, 0, c);\\n}\\n\\n/**\\n * Invokes `console.log()` when available.\\n * No-op when `console.log` is not a \\\"function\\\".\\n *\\n * @api public\\n */\\n\\nfunction log() {\\n  // this hackery is required for IE8/9, where\\n  // the `console.log` function doesn't have 'apply'\\n  return 'object' === typeof console\\n    && console.log\\n    && Function.prototype.apply.call(console.log, console, arguments);\\n}\\n\\n/**\\n * Save `namespaces`.\\n *\\n * @param {String} namespaces\\n * @api private\\n */\\n\\nfunction save(namespaces) {\\n  try {\\n    if (null == namespaces) {\\n      exports.storage.removeItem('debug');\\n    } else {\\n      exports.storage.debug = namespaces;\\n    }\\n  } catch(e) {}\\n}\\n\\n/**\\n * Load `namespaces`.\\n *\\n * @return {String} returns the previously persisted debug modes\\n * @api private\\n */\\n\\nfunction load() {\\n  var r;\\n  try {\\n    r = exports.storage.debug;\\n  } catch(e) {}\\n\\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\\n    r = process.env.DEBUG;\\n  }\\n\\n  return r;\\n}\\n\\n/**\\n * Enable namespaces listed in `localStorage.debug` initially.\\n */\\n\\nexports.enable(load());\\n\\n/**\\n * Localstorage attempts to return the localstorage.\\n *\\n * This is necessary because safari throws\\n * when a user disables cookies/localstorage\\n * and you attempt to access it.\\n *\\n * @return {LocalStorage}\\n * @api private\\n */\\n\\nfunction localstorage() {\\n  try {\\n    return window.localStorage;\\n  } catch (e) {}\\n}\\n\\n}).call(this,{ env: {} })\\n\\n},{\\\"./debug\\\":56}],56:[function(require,module,exports){\\n\\n/**\\n * This is the common logic for both the Node.js and web browser\\n * implementations of `debug()`.\\n *\\n * Expose `debug()` as the module.\\n */\\n\\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\\nexports.coerce = coerce;\\nexports.disable = disable;\\nexports.enable = enable;\\nexports.enabled = enabled;\\nexports.humanize = require('ms');\\n\\n/**\\n * The currently active debug mode names, and names to skip.\\n */\\n\\nexports.names = [];\\nexports.skips = [];\\n\\n/**\\n * Map of special \\\"%n\\\" handling functions, for the debug \\\"format\\\" argument.\\n *\\n * Valid key names are a single, lower or upper-case letter, i.e. \\\"n\\\" and \\\"N\\\".\\n */\\n\\nexports.formatters = {};\\n\\n/**\\n * Previous log timestamp.\\n */\\n\\nvar prevTime;\\n\\n/**\\n * Select a color.\\n * @param {String} namespace\\n * @return {Number}\\n * @api private\\n */\\n\\nfunction selectColor(namespace) {\\n  var hash = 0, i;\\n\\n  for (i in namespace) {\\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\\n    hash |= 0; // Convert to 32bit integer\\n  }\\n\\n  return exports.colors[Math.abs(hash) % exports.colors.length];\\n}\\n\\n/**\\n * Create a debugger with the given `namespace`.\\n *\\n * @param {String} namespace\\n * @return {Function}\\n * @api public\\n */\\n\\nfunction createDebug(namespace) {\\n\\n  function debug() {\\n    // disabled?\\n    if (!debug.enabled) return;\\n\\n    var self = debug;\\n\\n    // set `diff` timestamp\\n    var curr = +new Date();\\n    var ms = curr - (prevTime || curr);\\n    self.diff = ms;\\n    self.prev = prevTime;\\n    self.curr = curr;\\n    prevTime = curr;\\n\\n    // turn the `arguments` into a proper Array\\n    var args = new Array(arguments.length);\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i];\\n    }\\n\\n    args[0] = exports.coerce(args[0]);\\n\\n    if ('string' !== typeof args[0]) {\\n      // anything else let's inspect with %O\\n      args.unshift('%O');\\n    }\\n\\n    // apply any `formatters` transformations\\n    var index = 0;\\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\\n      // if we encounter an escaped % then don't increase the array index\\n      if (match === '%%') return match;\\n      index++;\\n      var formatter = exports.formatters[format];\\n      if ('function' === typeof formatter) {\\n        var val = args[index];\\n        match = formatter.call(self, val);\\n\\n        // now we need to remove `args[index]` since it's inlined in the `format`\\n        args.splice(index, 1);\\n        index--;\\n      }\\n      return match;\\n    });\\n\\n    // apply env-specific formatting (colors, etc.)\\n    exports.formatArgs.call(self, args);\\n\\n    var logFn = debug.log || exports.log || console.log.bind(console);\\n    logFn.apply(self, args);\\n  }\\n\\n  debug.namespace = namespace;\\n  debug.enabled = exports.enabled(namespace);\\n  debug.useColors = exports.useColors();\\n  debug.color = selectColor(namespace);\\n\\n  // env-specific initialization logic for debug instances\\n  if ('function' === typeof exports.init) {\\n    exports.init(debug);\\n  }\\n\\n  return debug;\\n}\\n\\n/**\\n * Enables a debug mode by namespaces. This can include modes\\n * separated by a colon and wildcards.\\n *\\n * @param {String} namespaces\\n * @api public\\n */\\n\\nfunction enable(namespaces) {\\n  exports.save(namespaces);\\n\\n  exports.names = [];\\n  exports.skips = [];\\n\\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\\\s,]+/);\\n  var len = split.length;\\n\\n  for (var i = 0; i < len; i++) {\\n    if (!split[i]) continue; // ignore empty strings\\n    namespaces = split[i].replace(/\\\\*/g, '.*?');\\n    if (namespaces[0] === '-') {\\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\\n    } else {\\n      exports.names.push(new RegExp('^' + namespaces + '$'));\\n    }\\n  }\\n}\\n\\n/**\\n * Disable debug output.\\n *\\n * @api public\\n */\\n\\nfunction disable() {\\n  exports.enable('');\\n}\\n\\n/**\\n * Returns true if the given mode name is enabled, false otherwise.\\n *\\n * @param {String} name\\n * @return {Boolean}\\n * @api public\\n */\\n\\nfunction enabled(name) {\\n  var i, len;\\n  for (i = 0, len = exports.skips.length; i < len; i++) {\\n    if (exports.skips[i].test(name)) {\\n      return false;\\n    }\\n  }\\n  for (i = 0, len = exports.names.length; i < len; i++) {\\n    if (exports.names[i].test(name)) {\\n      return true;\\n    }\\n  }\\n  return false;\\n}\\n\\n/**\\n * Coerce `val`.\\n *\\n * @param {Mixed} val\\n * @return {Mixed}\\n * @api private\\n */\\n\\nfunction coerce(val) {\\n  if (val instanceof Error) return val.stack || val.message;\\n  return val;\\n}\\n\\n},{\\\"ms\\\":54}],57:[function(require,module,exports){\\nif (typeof Object.create === 'function') {\\n  // implementation from standard node.js 'util' module\\n  module.exports = function inherits(ctor, superCtor) {\\n    ctor.super_ = superCtor\\n    ctor.prototype = Object.create(superCtor.prototype, {\\n      constructor: {\\n        value: ctor,\\n        enumerable: false,\\n        writable: true,\\n        configurable: true\\n      }\\n    });\\n  };\\n} else {\\n  // old school shim for old browsers\\n  module.exports = function inherits(ctor, superCtor) {\\n    ctor.super_ = superCtor\\n    var TempCtor = function () {}\\n    TempCtor.prototype = superCtor.prototype\\n    ctor.prototype = new TempCtor()\\n    ctor.prototype.constructor = ctor\\n  }\\n}\\n\\n},{}],58:[function(require,module,exports){\\n(function (global){\\n/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */\\n;(function () {\\n  // Detect the `define` function exposed by asynchronous module loaders. The\\n  // strict `define` check is necessary for compatibility with `r.js`.\\n  var isLoader = typeof define === \\\"function\\\" && define.amd;\\n\\n  // A set of types used to distinguish objects from primitives.\\n  var objectTypes = {\\n    \\\"function\\\": true,\\n    \\\"object\\\": true\\n  };\\n\\n  // Detect the `exports` object exposed by CommonJS implementations.\\n  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\\n\\n  // Use the `global` object exposed by Node (including Browserify via\\n  // `insert-module-globals`), Narwhal, and Ringo as the default context,\\n  // and the `window` object in browsers. Rhino exports a `global` function\\n  // instead.\\n  var root = objectTypes[typeof window] && window || this,\\n      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == \\\"object\\\" && global;\\n\\n  if (freeGlobal && (freeGlobal[\\\"global\\\"] === freeGlobal || freeGlobal[\\\"window\\\"] === freeGlobal || freeGlobal[\\\"self\\\"] === freeGlobal)) {\\n    root = freeGlobal;\\n  }\\n\\n  // Public: Initializes JSON 3 using the given `context` object, attaching the\\n  // `stringify` and `parse` functions to the specified `exports` object.\\n  function runInContext(context, exports) {\\n    context || (context = root[\\\"Object\\\"]());\\n    exports || (exports = root[\\\"Object\\\"]());\\n\\n    // Native constructor aliases.\\n    var Number = context[\\\"Number\\\"] || root[\\\"Number\\\"],\\n        String = context[\\\"String\\\"] || root[\\\"String\\\"],\\n        Object = context[\\\"Object\\\"] || root[\\\"Object\\\"],\\n        Date = context[\\\"Date\\\"] || root[\\\"Date\\\"],\\n        SyntaxError = context[\\\"SyntaxError\\\"] || root[\\\"SyntaxError\\\"],\\n        TypeError = context[\\\"TypeError\\\"] || root[\\\"TypeError\\\"],\\n        Math = context[\\\"Math\\\"] || root[\\\"Math\\\"],\\n        nativeJSON = context[\\\"JSON\\\"] || root[\\\"JSON\\\"];\\n\\n    // Delegate to the native `stringify` and `parse` implementations.\\n    if (typeof nativeJSON == \\\"object\\\" && nativeJSON) {\\n      exports.stringify = nativeJSON.stringify;\\n      exports.parse = nativeJSON.parse;\\n    }\\n\\n    // Convenience aliases.\\n    var objectProto = Object.prototype,\\n        getClass = objectProto.toString,\\n        isProperty, forEach, undef;\\n\\n    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.\\n    var isExtended = new Date(-3509827334573292);\\n    try {\\n      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical\\n      // results for certain dates in Opera >= 10.53.\\n      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&\\n        // Safari < 2.0.2 stores the internal millisecond time value correctly,\\n        // but clips the values returned by the date methods to the range of\\n        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).\\n        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;\\n    } catch (exception) {}\\n\\n    // Internal: Determines whether the native `JSON.stringify` and `parse`\\n    // implementations are spec-compliant. Based on work by Ken Snyder.\\n    function has(name) {\\n      if (has[name] !== undef) {\\n        // Return cached feature test result.\\n        return has[name];\\n      }\\n      var isSupported;\\n      if (name == \\\"bug-string-char-index\\\") {\\n        // IE <= 7 doesn't support accessing string characters using square\\n        // bracket notation. IE 8 only supports this for primitives.\\n        isSupported = \\\"a\\\"[0] != \\\"a\\\";\\n      } else if (name == \\\"json\\\") {\\n        // Indicates whether both `JSON.stringify` and `JSON.parse` are\\n        // supported.\\n        isSupported = has(\\\"json-stringify\\\") && has(\\\"json-parse\\\");\\n      } else {\\n        var value, serialized = '{\\\"a\\\":[1,true,false,null,\\\"\\\\\\\\u0000\\\\\\\\b\\\\\\\\n\\\\\\\\f\\\\\\\\r\\\\\\\\t\\\"]}';\\n        // Test `JSON.stringify`.\\n        if (name == \\\"json-stringify\\\") {\\n          var stringify = exports.stringify, stringifySupported = typeof stringify == \\\"function\\\" && isExtended;\\n          if (stringifySupported) {\\n            // A test function object with a custom `toJSON` method.\\n            (value = function () {\\n              return 1;\\n            }).toJSON = value;\\n            try {\\n              stringifySupported =\\n                // Firefox 3.1b1 and b2 serialize string, number, and boolean\\n                // primitives as object literals.\\n                stringify(0) === \\\"0\\\" &&\\n                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object\\n                // literals.\\n                stringify(new Number()) === \\\"0\\\" &&\\n                stringify(new String()) == '\\\"\\\"' &&\\n                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or\\n                // does not define a canonical JSON representation (this applies to\\n                // objects with `toJSON` properties as well, *unless* they are nested\\n                // within an object or array).\\n                stringify(getClass) === undef &&\\n                // IE 8 serializes `undefined` as `\\\"undefined\\\"`. Safari <= 5.1.7 and\\n                // FF 3.1b3 pass this test.\\n                stringify(undef) === undef &&\\n                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,\\n                // respectively, if the value is omitted entirely.\\n                stringify() === undef &&\\n                // FF 3.1b1, 2 throw an error if the given value is not a number,\\n                // string, array, object, Boolean, or `null` literal. This applies to\\n                // objects with custom `toJSON` methods as well, unless they are nested\\n                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`\\n                // methods entirely.\\n                stringify(value) === \\\"1\\\" &&\\n                stringify([value]) == \\\"[1]\\\" &&\\n                // Prototype <= 1.6.1 serializes `[undefined]` as `\\\"[]\\\"` instead of\\n                // `\\\"[null]\\\"`.\\n                stringify([undef]) == \\\"[null]\\\" &&\\n                // YUI 3.0.0b1 fails to serialize `null` literals.\\n                stringify(null) == \\\"null\\\" &&\\n                // FF 3.1b1, 2 halts serialization if an array contains a function:\\n                // `[1, true, getClass, 1]` serializes as \\\"[1,true,],\\\". FF 3.1b3\\n                // elides non-JSON values from objects and arrays, unless they\\n                // define custom `toJSON` methods.\\n                stringify([undef, getClass, null]) == \\\"[null,null,null]\\\" &&\\n                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences\\n                // where character escape codes are expected (e.g., `\\\\b` => `\\\\u0008`).\\n                stringify({ \\\"a\\\": [value, true, false, null, \\\"\\\\x00\\\\b\\\\n\\\\f\\\\r\\\\t\\\"] }) == serialized &&\\n                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.\\n                stringify(null, value) === \\\"1\\\" &&\\n                stringify([1, 2], null, 1) == \\\"[\\\\n 1,\\\\n 2\\\\n]\\\" &&\\n                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly\\n                // serialize extended years.\\n                stringify(new Date(-8.64e15)) == '\\\"-271821-04-20T00:00:00.000Z\\\"' &&\\n                // The milliseconds are optional in ES 5, but required in 5.1.\\n                stringify(new Date(8.64e15)) == '\\\"+275760-09-13T00:00:00.000Z\\\"' &&\\n                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative\\n                // four-digit years instead of six-digit years. Credits: @Yaffle.\\n                stringify(new Date(-621987552e5)) == '\\\"-000001-01-01T00:00:00.000Z\\\"' &&\\n                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond\\n                // values less than 1000. Credits: @Yaffle.\\n                stringify(new Date(-1)) == '\\\"1969-12-31T23:59:59.999Z\\\"';\\n            } catch (exception) {\\n              stringifySupported = false;\\n            }\\n          }\\n          isSupported = stringifySupported;\\n        }\\n        // Test `JSON.parse`.\\n        if (name == \\\"json-parse\\\") {\\n          var parse = exports.parse;\\n          if (typeof parse == \\\"function\\\") {\\n            try {\\n              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.\\n              // Conforming implementations should also coerce the initial argument to\\n              // a string prior to parsing.\\n              if (parse(\\\"0\\\") === 0 && !parse(false)) {\\n                // Simple parsing test.\\n                value = parse(serialized);\\n                var parseSupported = value[\\\"a\\\"].length == 5 && value[\\\"a\\\"][0] === 1;\\n                if (parseSupported) {\\n                  try {\\n                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.\\n                    parseSupported = !parse('\\\"\\\\t\\\"');\\n                  } catch (exception) {}\\n                  if (parseSupported) {\\n                    try {\\n                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading\\n                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow\\n                      // certain octal literals.\\n                      parseSupported = parse(\\\"01\\\") !== 1;\\n                    } catch (exception) {}\\n                  }\\n                  if (parseSupported) {\\n                    try {\\n                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal\\n                      // points. These environments, along with FF 3.1b1 and 2,\\n                      // also allow trailing commas in JSON objects and arrays.\\n                      parseSupported = parse(\\\"1.\\\") !== 1;\\n                    } catch (exception) {}\\n                  }\\n                }\\n              }\\n            } catch (exception) {\\n              parseSupported = false;\\n            }\\n          }\\n          isSupported = parseSupported;\\n        }\\n      }\\n      return has[name] = !!isSupported;\\n    }\\n\\n    if (!has(\\\"json\\\")) {\\n      // Common `[[Class]]` name aliases.\\n      var functionClass = \\\"[object Function]\\\",\\n          dateClass = \\\"[object Date]\\\",\\n          numberClass = \\\"[object Number]\\\",\\n          stringClass = \\\"[object String]\\\",\\n          arrayClass = \\\"[object Array]\\\",\\n          booleanClass = \\\"[object Boolean]\\\";\\n\\n      // Detect incomplete support for accessing string characters by index.\\n      var charIndexBuggy = has(\\\"bug-string-char-index\\\");\\n\\n      // Define additional utility methods if the `Date` methods are buggy.\\n      if (!isExtended) {\\n        var floor = Math.floor;\\n        // A mapping between the months of the year and the number of days between\\n        // January 1st and the first of the respective month.\\n        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\\n        // Internal: Calculates the number of days between the Unix epoch and the\\n        // first day of the given month.\\n        var getDay = function (year, month) {\\n          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);\\n        };\\n      }\\n\\n      // Internal: Determines if a property is a direct property of the given\\n      // object. Delegates to the native `Object#hasOwnProperty` method.\\n      if (!(isProperty = objectProto.hasOwnProperty)) {\\n        isProperty = function (property) {\\n          var members = {}, constructor;\\n          if ((members.__proto__ = null, members.__proto__ = {\\n            // The *proto* property cannot be set multiple times in recent\\n            // versions of Firefox and SeaMonkey.\\n            \\\"toString\\\": 1\\n          }, members).toString != getClass) {\\n            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but\\n            // supports the mutable *proto* property.\\n            isProperty = function (property) {\\n              // Capture and break the object's prototype chain (see section 8.6.2\\n              // of the ES 5.1 spec). The parenthesized expression prevents an\\n              // unsafe transformation by the Closure Compiler.\\n              var original = this.__proto__, result = property in (this.__proto__ = null, this);\\n              // Restore the original prototype chain.\\n              this.__proto__ = original;\\n              return result;\\n            };\\n          } else {\\n            // Capture a reference to the top-level `Object` constructor.\\n            constructor = members.constructor;\\n            // Use the `constructor` property to simulate `Object#hasOwnProperty` in\\n            // other environments.\\n            isProperty = function (property) {\\n              var parent = (this.constructor || constructor).prototype;\\n              return property in this && !(property in parent && this[property] === parent[property]);\\n            };\\n          }\\n          members = null;\\n          return isProperty.call(this, property);\\n        };\\n      }\\n\\n      // Internal: Normalizes the `for...in` iteration algorithm across\\n      // environments. Each enumerated key is yielded to a `callback` function.\\n      forEach = function (object, callback) {\\n        var size = 0, Properties, members, property;\\n\\n        // Tests for bugs in the current environment's `for...in` algorithm. The\\n        // `valueOf` property inherits the non-enumerable flag from\\n        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.\\n        (Properties = function () {\\n          this.valueOf = 0;\\n        }).prototype.valueOf = 0;\\n\\n        // Iterate over a new instance of the `Properties` class.\\n        members = new Properties();\\n        for (property in members) {\\n          // Ignore all properties inherited from `Object.prototype`.\\n          if (isProperty.call(members, property)) {\\n            size++;\\n          }\\n        }\\n        Properties = members = null;\\n\\n        // Normalize the iteration algorithm.\\n        if (!size) {\\n          // A list of non-enumerable properties inherited from `Object.prototype`.\\n          members = [\\\"valueOf\\\", \\\"toString\\\", \\\"toLocaleString\\\", \\\"propertyIsEnumerable\\\", \\\"isPrototypeOf\\\", \\\"hasOwnProperty\\\", \\\"constructor\\\"];\\n          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable\\n          // properties.\\n          forEach = function (object, callback) {\\n            var isFunction = getClass.call(object) == functionClass, property, length;\\n            var hasProperty = !isFunction && typeof object.constructor != \\\"function\\\" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;\\n            for (property in object) {\\n              // Gecko <= 1.0 enumerates the `prototype` property of functions under\\n              // certain conditions; IE does not.\\n              if (!(isFunction && property == \\\"prototype\\\") && hasProperty.call(object, property)) {\\n                callback(property);\\n              }\\n            }\\n            // Manually invoke the callback for each non-enumerable property.\\n            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));\\n          };\\n        } else if (size == 2) {\\n          // Safari <= 2.0.4 enumerates shadowed properties twice.\\n          forEach = function (object, callback) {\\n            // Create a set of iterated properties.\\n            var members = {}, isFunction = getClass.call(object) == functionClass, property;\\n            for (property in object) {\\n              // Store each property name to prevent double enumeration. The\\n              // `prototype` property of functions is not enumerated due to cross-\\n              // environment inconsistencies.\\n              if (!(isFunction && property == \\\"prototype\\\") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {\\n                callback(property);\\n              }\\n            }\\n          };\\n        } else {\\n          // No bugs detected; use the standard `for...in` algorithm.\\n          forEach = function (object, callback) {\\n            var isFunction = getClass.call(object) == functionClass, property, isConstructor;\\n            for (property in object) {\\n              if (!(isFunction && property == \\\"prototype\\\") && isProperty.call(object, property) && !(isConstructor = property === \\\"constructor\\\")) {\\n                callback(property);\\n              }\\n            }\\n            // Manually invoke the callback for the `constructor` property due to\\n            // cross-environment inconsistencies.\\n            if (isConstructor || isProperty.call(object, (property = \\\"constructor\\\"))) {\\n              callback(property);\\n            }\\n          };\\n        }\\n        return forEach(object, callback);\\n      };\\n\\n      // Public: Serializes a JavaScript `value` as a JSON string. The optional\\n      // `filter` argument may specify either a function that alters how object and\\n      // array members are serialized, or an array of strings and numbers that\\n      // indicates which properties should be serialized. The optional `width`\\n      // argument may be either a string or number that specifies the indentation\\n      // level of the output.\\n      if (!has(\\\"json-stringify\\\")) {\\n        // Internal: A map of control characters and their escaped equivalents.\\n        var Escapes = {\\n          92: \\\"\\\\\\\\\\\\\\\\\\\",\\n          34: '\\\\\\\\\\\"',\\n          8: \\\"\\\\\\\\b\\\",\\n          12: \\\"\\\\\\\\f\\\",\\n          10: \\\"\\\\\\\\n\\\",\\n          13: \\\"\\\\\\\\r\\\",\\n          9: \\\"\\\\\\\\t\\\"\\n        };\\n\\n        // Internal: Converts `value` into a zero-padded string such that its\\n        // length is at least equal to `width`. The `width` must be <= 6.\\n        var leadingZeroes = \\\"000000\\\";\\n        var toPaddedString = function (width, value) {\\n          // The `|| 0` expression is necessary to work around a bug in\\n          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== \\\"0\\\"`.\\n          return (leadingZeroes + (value || 0)).slice(-width);\\n        };\\n\\n        // Internal: Double-quotes a string `value`, replacing all ASCII control\\n        // characters (characters with code unit values between 0 and 31) with\\n        // their escaped equivalents. This is an implementation of the\\n        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.\\n        var unicodePrefix = \\\"\\\\\\\\u00\\\";\\n        var quote = function (value) {\\n          var result = '\\\"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;\\n          var symbols = useCharIndex && (charIndexBuggy ? value.split(\\\"\\\") : value);\\n          for (; index < length; index++) {\\n            var charCode = value.charCodeAt(index);\\n            // If the character is a control character, append its Unicode or\\n            // shorthand escape sequence; otherwise, append the character as-is.\\n            switch (charCode) {\\n              case 8: case 9: case 10: case 12: case 13: case 34: case 92:\\n                result += Escapes[charCode];\\n                break;\\n              default:\\n                if (charCode < 32) {\\n                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));\\n                  break;\\n                }\\n                result += useCharIndex ? symbols[index] : value.charAt(index);\\n            }\\n          }\\n          return result + '\\\"';\\n        };\\n\\n        // Internal: Recursively serializes an object. Implements the\\n        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.\\n        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {\\n          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;\\n          try {\\n            // Necessary for host object support.\\n            value = object[property];\\n          } catch (exception) {}\\n          if (typeof value == \\\"object\\\" && value) {\\n            className = getClass.call(value);\\n            if (className == dateClass && !isProperty.call(value, \\\"toJSON\\\")) {\\n              if (value > -1 / 0 && value < 1 / 0) {\\n                // Dates are serialized according to the `Date#toJSON` method\\n                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15\\n                // for the ISO 8601 date time string format.\\n                if (getDay) {\\n                  // Manually compute the year, month, date, hours, minutes,\\n                  // seconds, and milliseconds if the `getUTC*` methods are\\n                  // buggy. Adapted from @Yaffle's `date-shim` project.\\n                  date = floor(value / 864e5);\\n                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);\\n                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);\\n                  date = 1 + date - getDay(year, month);\\n                  // The `time` value specifies the time within the day (see ES\\n                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used\\n                  // to compute `A modulo B`, as the `%` operator does not\\n                  // correspond to the `modulo` operation for negative numbers.\\n                  time = (value % 864e5 + 864e5) % 864e5;\\n                  // The hours, minutes, seconds, and milliseconds are obtained by\\n                  // decomposing the time within the day. See section 15.9.1.10.\\n                  hours = floor(time / 36e5) % 24;\\n                  minutes = floor(time / 6e4) % 60;\\n                  seconds = floor(time / 1e3) % 60;\\n                  milliseconds = time % 1e3;\\n                } else {\\n                  year = value.getUTCFullYear();\\n                  month = value.getUTCMonth();\\n                  date = value.getUTCDate();\\n                  hours = value.getUTCHours();\\n                  minutes = value.getUTCMinutes();\\n                  seconds = value.getUTCSeconds();\\n                  milliseconds = value.getUTCMilliseconds();\\n                }\\n                // Serialize extended years correctly.\\n                value = (year <= 0 || year >= 1e4 ? (year < 0 ? \\\"-\\\" : \\\"+\\\") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +\\n                  \\\"-\\\" + toPaddedString(2, month + 1) + \\\"-\\\" + toPaddedString(2, date) +\\n                  // Months, dates, hours, minutes, and seconds should have two\\n                  // digits; milliseconds should have three.\\n                  \\\"T\\\" + toPaddedString(2, hours) + \\\":\\\" + toPaddedString(2, minutes) + \\\":\\\" + toPaddedString(2, seconds) +\\n                  // Milliseconds are optional in ES 5.0, but required in 5.1.\\n                  \\\".\\\" + toPaddedString(3, milliseconds) + \\\"Z\\\";\\n              } else {\\n                value = null;\\n              }\\n            } else if (typeof value.toJSON == \\\"function\\\" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, \\\"toJSON\\\"))) {\\n              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the\\n              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3\\n              // ignores all `toJSON` methods on these objects unless they are\\n              // defined directly on an instance.\\n              value = value.toJSON(property);\\n            }\\n          }\\n          if (callback) {\\n            // If a replacement function was provided, call it to obtain the value\\n            // for serialization.\\n            value = callback.call(object, property, value);\\n          }\\n          if (value === null) {\\n            return \\\"null\\\";\\n          }\\n          className = getClass.call(value);\\n          if (className == booleanClass) {\\n            // Booleans are represented literally.\\n            return \\\"\\\" + value;\\n          } else if (className == numberClass) {\\n            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as\\n            // `\\\"null\\\"`.\\n            return value > -1 / 0 && value < 1 / 0 ? \\\"\\\" + value : \\\"null\\\";\\n          } else if (className == stringClass) {\\n            // Strings are double-quoted and escaped.\\n            return quote(\\\"\\\" + value);\\n          }\\n          // Recursively serialize objects and arrays.\\n          if (typeof value == \\\"object\\\") {\\n            // Check for cyclic structures. This is a linear search; performance\\n            // is inversely proportional to the number of unique nested objects.\\n            for (length = stack.length; length--;) {\\n              if (stack[length] === value) {\\n                // Cyclic structures cannot be serialized by `JSON.stringify`.\\n                throw TypeError();\\n              }\\n            }\\n            // Add the object to the stack of traversed objects.\\n            stack.push(value);\\n            results = [];\\n            // Save the current indentation level and indent one additional level.\\n            prefix = indentation;\\n            indentation += whitespace;\\n            if (className == arrayClass) {\\n              // Recursively serialize array elements.\\n              for (index = 0, length = value.length; index < length; index++) {\\n                element = serialize(index, value, callback, properties, whitespace, indentation, stack);\\n                results.push(element === undef ? \\\"null\\\" : element);\\n              }\\n              result = results.length ? (whitespace ? \\\"[\\\\n\\\" + indentation + results.join(\\\",\\\\n\\\" + indentation) + \\\"\\\\n\\\" + prefix + \\\"]\\\" : (\\\"[\\\" + results.join(\\\",\\\") + \\\"]\\\")) : \\\"[]\\\";\\n            } else {\\n              // Recursively serialize object members. Members are selected from\\n              // either a user-specified list of property names, or the object\\n              // itself.\\n              forEach(properties || value, function (property) {\\n                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);\\n                if (element !== undef) {\\n                  // According to ES 5.1 section 15.12.3: \\\"If `gap` {whitespace}\\n                  // is not the empty string, let `member` {quote(property) + \\\":\\\"}\\n                  // be the concatenation of `member` and the `space` character.\\\"\\n                  // The \\\"`space` character\\\" refers to the literal space\\n                  // character, not the `space` {width} argument provided to\\n                  // `JSON.stringify`.\\n                  results.push(quote(property) + \\\":\\\" + (whitespace ? \\\" \\\" : \\\"\\\") + element);\\n                }\\n              });\\n              result = results.length ? (whitespace ? \\\"{\\\\n\\\" + indentation + results.join(\\\",\\\\n\\\" + indentation) + \\\"\\\\n\\\" + prefix + \\\"}\\\" : (\\\"{\\\" + results.join(\\\",\\\") + \\\"}\\\")) : \\\"{}\\\";\\n            }\\n            // Remove the object from the traversed object stack.\\n            stack.pop();\\n            return result;\\n          }\\n        };\\n\\n        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.\\n        exports.stringify = function (source, filter, width) {\\n          var whitespace, callback, properties, className;\\n          if (objectTypes[typeof filter] && filter) {\\n            if ((className = getClass.call(filter)) == functionClass) {\\n              callback = filter;\\n            } else if (className == arrayClass) {\\n              // Convert the property names array into a makeshift set.\\n              properties = {};\\n              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));\\n            }\\n          }\\n          if (width) {\\n            if ((className = getClass.call(width)) == numberClass) {\\n              // Convert the `width` to an integer and create a string containing\\n              // `width` number of space characters.\\n              if ((width -= width % 1) > 0) {\\n                for (whitespace = \\\"\\\", width > 10 && (width = 10); whitespace.length < width; whitespace += \\\" \\\");\\n              }\\n            } else if (className == stringClass) {\\n              whitespace = width.length <= 10 ? width : width.slice(0, 10);\\n            }\\n          }\\n          // Opera <= 7.54u2 discards the values associated with empty string keys\\n          // (`\\\"\\\"`) only if they are used directly within an object member list\\n          // (e.g., `!(\\\"\\\" in { \\\"\\\": 1})`).\\n          return serialize(\\\"\\\", (value = {}, value[\\\"\\\"] = source, value), callback, properties, whitespace, \\\"\\\", []);\\n        };\\n      }\\n\\n      // Public: Parses a JSON source string.\\n      if (!has(\\\"json-parse\\\")) {\\n        var fromCharCode = String.fromCharCode;\\n\\n        // Internal: A map of escaped control characters and their unescaped\\n        // equivalents.\\n        var Unescapes = {\\n          92: \\\"\\\\\\\\\\\",\\n          34: '\\\"',\\n          47: \\\"/\\\",\\n          98: \\\"\\\\b\\\",\\n          116: \\\"\\\\t\\\",\\n          110: \\\"\\\\n\\\",\\n          102: \\\"\\\\f\\\",\\n          114: \\\"\\\\r\\\"\\n        };\\n\\n        // Internal: Stores the parser state.\\n        var Index, Source;\\n\\n        // Internal: Resets the parser state and throws a `SyntaxError`.\\n        var abort = function () {\\n          Index = Source = null;\\n          throw SyntaxError();\\n        };\\n\\n        // Internal: Returns the next token, or `\\\"$\\\"` if the parser has reached\\n        // the end of the source string. A token may be a string, number, `null`\\n        // literal, or Boolean literal.\\n        var lex = function () {\\n          var source = Source, length = source.length, value, begin, position, isSigned, charCode;\\n          while (Index < length) {\\n            charCode = source.charCodeAt(Index);\\n            switch (charCode) {\\n              case 9: case 10: case 13: case 32:\\n                // Skip whitespace tokens, including tabs, carriage returns, line\\n                // feeds, and space characters.\\n                Index++;\\n                break;\\n              case 123: case 125: case 91: case 93: case 58: case 44:\\n                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at\\n                // the current position.\\n                value = charIndexBuggy ? source.charAt(Index) : source[Index];\\n                Index++;\\n                return value;\\n              case 34:\\n                // `\\\"` delimits a JSON string; advance to the next character and\\n                // begin parsing the string. String tokens are prefixed with the\\n                // sentinel `@` character to distinguish them from punctuators and\\n                // end-of-string tokens.\\n                for (value = \\\"@\\\", Index++; Index < length;) {\\n                  charCode = source.charCodeAt(Index);\\n                  if (charCode < 32) {\\n                    // Unescaped ASCII control characters (those with a code unit\\n                    // less than the space character) are not permitted.\\n                    abort();\\n                  } else if (charCode == 92) {\\n                    // A reverse solidus (`\\\\`) marks the beginning of an escaped\\n                    // control character (including `\\\"`, `\\\\`, and `/`) or Unicode\\n                    // escape sequence.\\n                    charCode = source.charCodeAt(++Index);\\n                    switch (charCode) {\\n                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:\\n                        // Revive escaped control characters.\\n                        value += Unescapes[charCode];\\n                        Index++;\\n                        break;\\n                      case 117:\\n                        // `\\\\u` marks the beginning of a Unicode escape sequence.\\n                        // Advance to the first character and validate the\\n                        // four-digit code point.\\n                        begin = ++Index;\\n                        for (position = Index + 4; Index < position; Index++) {\\n                          charCode = source.charCodeAt(Index);\\n                          // A valid sequence comprises four hexdigits (case-\\n                          // insensitive) that form a single hexadecimal value.\\n                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {\\n                            // Invalid Unicode escape sequence.\\n                            abort();\\n                          }\\n                        }\\n                        // Revive the escaped character.\\n                        value += fromCharCode(\\\"0x\\\" + source.slice(begin, Index));\\n                        break;\\n                      default:\\n                        // Invalid escape sequence.\\n                        abort();\\n                    }\\n                  } else {\\n                    if (charCode == 34) {\\n                      // An unescaped double-quote character marks the end of the\\n                      // string.\\n                      break;\\n                    }\\n                    charCode = source.charCodeAt(Index);\\n                    begin = Index;\\n                    // Optimize for the common case where a string is valid.\\n                    while (charCode >= 32 && charCode != 92 && charCode != 34) {\\n                      charCode = source.charCodeAt(++Index);\\n                    }\\n                    // Append the string as-is.\\n                    value += source.slice(begin, Index);\\n                  }\\n                }\\n                if (source.charCodeAt(Index) == 34) {\\n                  // Advance to the next character and return the revived string.\\n                  Index++;\\n                  return value;\\n                }\\n                // Unterminated string.\\n                abort();\\n              default:\\n                // Parse numbers and literals.\\n                begin = Index;\\n                // Advance past the negative sign, if one is specified.\\n                if (charCode == 45) {\\n                  isSigned = true;\\n                  charCode = source.charCodeAt(++Index);\\n                }\\n                // Parse an integer or floating-point value.\\n                if (charCode >= 48 && charCode <= 57) {\\n                  // Leading zeroes are interpreted as octal literals.\\n                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {\\n                    // Illegal octal literal.\\n                    abort();\\n                  }\\n                  isSigned = false;\\n                  // Parse the integer component.\\n                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);\\n                  // Floats cannot contain a leading decimal point; however, this\\n                  // case is already accounted for by the parser.\\n                  if (source.charCodeAt(Index) == 46) {\\n                    position = ++Index;\\n                    // Parse the decimal component.\\n                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\\n                    if (position == Index) {\\n                      // Illegal trailing decimal.\\n                      abort();\\n                    }\\n                    Index = position;\\n                  }\\n                  // Parse exponents. The `e` denoting the exponent is\\n                  // case-insensitive.\\n                  charCode = source.charCodeAt(Index);\\n                  if (charCode == 101 || charCode == 69) {\\n                    charCode = source.charCodeAt(++Index);\\n                    // Skip past the sign following the exponent, if one is\\n                    // specified.\\n                    if (charCode == 43 || charCode == 45) {\\n                      Index++;\\n                    }\\n                    // Parse the exponential component.\\n                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\\n                    if (position == Index) {\\n                      // Illegal empty exponent.\\n                      abort();\\n                    }\\n                    Index = position;\\n                  }\\n                  // Coerce the parsed value to a JavaScript number.\\n                  return +source.slice(begin, Index);\\n                }\\n                // A negative sign may only precede numbers.\\n                if (isSigned) {\\n                  abort();\\n                }\\n                // `true`, `false`, and `null` literals.\\n                if (source.slice(Index, Index + 4) == \\\"true\\\") {\\n                  Index += 4;\\n                  return true;\\n                } else if (source.slice(Index, Index + 5) == \\\"false\\\") {\\n                  Index += 5;\\n                  return false;\\n                } else if (source.slice(Index, Index + 4) == \\\"null\\\") {\\n                  Index += 4;\\n                  return null;\\n                }\\n                // Unrecognized token.\\n                abort();\\n            }\\n          }\\n          // Return the sentinel `$` character if the parser has reached the end\\n          // of the source string.\\n          return \\\"$\\\";\\n        };\\n\\n        // Internal: Parses a JSON `value` token.\\n        var get = function (value) {\\n          var results, hasMembers;\\n          if (value == \\\"$\\\") {\\n            // Unexpected end of input.\\n            abort();\\n          }\\n          if (typeof value == \\\"string\\\") {\\n            if ((charIndexBuggy ? value.charAt(0) : value[0]) == \\\"@\\\") {\\n              // Remove the sentinel `@` character.\\n              return value.slice(1);\\n            }\\n            // Parse object and array literals.\\n            if (value == \\\"[\\\") {\\n              // Parses a JSON array, returning a new JavaScript array.\\n              results = [];\\n              for (;; hasMembers || (hasMembers = true)) {\\n                value = lex();\\n                // A closing square bracket marks the end of the array literal.\\n                if (value == \\\"]\\\") {\\n                  break;\\n                }\\n                // If the array literal contains elements, the current token\\n                // should be a comma separating the previous element from the\\n                // next.\\n                if (hasMembers) {\\n                  if (value == \\\",\\\") {\\n                    value = lex();\\n                    if (value == \\\"]\\\") {\\n                      // Unexpected trailing `,` in array literal.\\n                      abort();\\n                    }\\n                  } else {\\n                    // A `,` must separate each array element.\\n                    abort();\\n                  }\\n                }\\n                // Elisions and leading commas are not permitted.\\n                if (value == \\\",\\\") {\\n                  abort();\\n                }\\n                results.push(get(value));\\n              }\\n              return results;\\n            } else if (value == \\\"{\\\") {\\n              // Parses a JSON object, returning a new JavaScript object.\\n              results = {};\\n              for (;; hasMembers || (hasMembers = true)) {\\n                value = lex();\\n                // A closing curly brace marks the end of the object literal.\\n                if (value == \\\"}\\\") {\\n                  break;\\n                }\\n                // If the object literal contains members, the current token\\n                // should be a comma separator.\\n                if (hasMembers) {\\n                  if (value == \\\",\\\") {\\n                    value = lex();\\n                    if (value == \\\"}\\\") {\\n                      // Unexpected trailing `,` in object literal.\\n                      abort();\\n                    }\\n                  } else {\\n                    // A `,` must separate each object member.\\n                    abort();\\n                  }\\n                }\\n                // Leading commas are not permitted, object property names must be\\n                // double-quoted strings, and a `:` must separate each property\\n                // name and value.\\n                if (value == \\\",\\\" || typeof value != \\\"string\\\" || (charIndexBuggy ? value.charAt(0) : value[0]) != \\\"@\\\" || lex() != \\\":\\\") {\\n                  abort();\\n                }\\n                results[value.slice(1)] = get(lex());\\n              }\\n              return results;\\n            }\\n            // Unexpected token encountered.\\n            abort();\\n          }\\n          return value;\\n        };\\n\\n        // Internal: Updates a traversed object member.\\n        var update = function (source, property, callback) {\\n          var element = walk(source, property, callback);\\n          if (element === undef) {\\n            delete source[property];\\n          } else {\\n            source[property] = element;\\n          }\\n        };\\n\\n        // Internal: Recursively traverses a parsed JSON object, invoking the\\n        // `callback` function for each value. This is an implementation of the\\n        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.\\n        var walk = function (source, property, callback) {\\n          var value = source[property], length;\\n          if (typeof value == \\\"object\\\" && value) {\\n            // `forEach` can't be used to traverse an array in Opera <= 8.54\\n            // because its `Object#hasOwnProperty` implementation returns `false`\\n            // for array indices (e.g., `![1, 2, 3].hasOwnProperty(\\\"0\\\")`).\\n            if (getClass.call(value) == arrayClass) {\\n              for (length = value.length; length--;) {\\n                update(value, length, callback);\\n              }\\n            } else {\\n              forEach(value, function (property) {\\n                update(value, property, callback);\\n              });\\n            }\\n          }\\n          return callback.call(source, property, value);\\n        };\\n\\n        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.\\n        exports.parse = function (source, callback) {\\n          var result, value;\\n          Index = 0;\\n          Source = \\\"\\\" + source;\\n          result = get(lex());\\n          // If a JSON string contains multiple tokens, it is invalid.\\n          if (lex() != \\\"$\\\") {\\n            abort();\\n          }\\n          // Reset the parser state.\\n          Index = Source = null;\\n          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[\\\"\\\"] = result, value), \\\"\\\", callback) : result;\\n        };\\n      }\\n    }\\n\\n    exports[\\\"runInContext\\\"] = runInContext;\\n    return exports;\\n  }\\n\\n  if (freeExports && !isLoader) {\\n    // Export for CommonJS environments.\\n    runInContext(root, freeExports);\\n  } else {\\n    // Export for web browsers and JavaScript engines.\\n    var nativeJSON = root.JSON,\\n        previousJSON = root[\\\"JSON3\\\"],\\n        isRestored = false;\\n\\n    var JSON3 = runInContext(root, (root[\\\"JSON3\\\"] = {\\n      // Public: Restores the original value of the global `JSON` object and\\n      // returns a reference to the `JSON3` object.\\n      \\\"noConflict\\\": function () {\\n        if (!isRestored) {\\n          isRestored = true;\\n          root.JSON = nativeJSON;\\n          root[\\\"JSON3\\\"] = previousJSON;\\n          nativeJSON = previousJSON = null;\\n        }\\n        return JSON3;\\n      }\\n    }));\\n\\n    root.JSON = {\\n      \\\"parse\\\": JSON3.parse,\\n      \\\"stringify\\\": JSON3.stringify\\n    };\\n  }\\n\\n  // Export for asynchronous module loaders.\\n  if (isLoader) {\\n    define(function () {\\n      return JSON3;\\n    });\\n  }\\n}).call(this);\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n\\n},{}],59:[function(require,module,exports){\\n'use strict';\\n\\nvar has = Object.prototype.hasOwnProperty;\\n\\n/**\\n * Simple query string parser.\\n *\\n * @param {String} query The query string that needs to be parsed.\\n * @returns {Object}\\n * @api public\\n */\\nfunction querystring(query) {\\n  var parser = /([^=?&]+)=?([^&]*)/g\\n    , result = {}\\n    , part;\\n\\n  //\\n  // Little nifty parsing hack, leverage the fact that RegExp.exec increments\\n  // the lastIndex property so we can continue executing this loop until we've\\n  // parsed all results.\\n  //\\n  for (;\\n    part = parser.exec(query);\\n    result[decodeURIComponent(part[1])] = decodeURIComponent(part[2])\\n  );\\n\\n  return result;\\n}\\n\\n/**\\n * Transform a query string to an object.\\n *\\n * @param {Object} obj Object that should be transformed.\\n * @param {String} prefix Optional prefix.\\n * @returns {String}\\n * @api public\\n */\\nfunction querystringify(obj, prefix) {\\n  prefix = prefix || '';\\n\\n  var pairs = [];\\n\\n  //\\n  // Optionally prefix with a '?' if needed\\n  //\\n  if ('string' !== typeof prefix) prefix = '?';\\n\\n  for (var key in obj) {\\n    if (has.call(obj, key)) {\\n      pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));\\n    }\\n  }\\n\\n  return pairs.length ? prefix + pairs.join('&') : '';\\n}\\n\\n//\\n// Expose the module.\\n//\\nexports.stringify = querystringify;\\nexports.parse = querystring;\\n\\n},{}],60:[function(require,module,exports){\\n'use strict';\\n\\n/**\\n * Check if we're required to add a port number.\\n *\\n * @see https://url.spec.whatwg.org/#default-port\\n * @param {Number|String} port Port number we need to check\\n * @param {String} protocol Protocol we need to check against.\\n * @returns {Boolean} Is it a default port for the given protocol\\n * @api private\\n */\\nmodule.exports = function required(port, protocol) {\\n  protocol = protocol.split(':')[0];\\n  port = +port;\\n\\n  if (!port) return false;\\n\\n  switch (protocol) {\\n    case 'http':\\n    case 'ws':\\n    return port !== 80;\\n\\n    case 'https':\\n    case 'wss':\\n    return port !== 443;\\n\\n    case 'ftp':\\n    return port !== 21;\\n\\n    case 'gopher':\\n    return port !== 70;\\n\\n    case 'file':\\n    return false;\\n  }\\n\\n  return port !== 0;\\n};\\n\\n},{}],61:[function(require,module,exports){\\n'use strict';\\n\\nvar required = require('requires-port')\\n  , lolcation = require('./lolcation')\\n  , qs = require('querystringify')\\n  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\\\\/\\\\/)?([\\\\S\\\\s]*)/i;\\n\\n/**\\n * These are the parse rules for the URL parser, it informs the parser\\n * about:\\n *\\n * 0. The char it Needs to parse, if it's a string it should be done using\\n *    indexOf, RegExp using exec and NaN means set as current value.\\n * 1. The property we should set when parsing this value.\\n * 2. Indication if it's backwards or forward parsing, when set as number it's\\n *    the value of extra chars that should be split off.\\n * 3. Inherit from location if non existing in the parser.\\n * 4. `toLowerCase` the resulting value.\\n */\\nvar rules = [\\n  ['#', 'hash'],                        // Extract from the back.\\n  ['?', 'query'],                       // Extract from the back.\\n  ['/', 'pathname'],                    // Extract from the back.\\n  ['@', 'auth', 1],                     // Extract from the front.\\n  [NaN, 'host', undefined, 1, 1],       // Set left over value.\\n  [/:(\\\\d+)$/, 'port', undefined, 1],    // RegExp the back.\\n  [NaN, 'hostname', undefined, 1, 1]    // Set left over.\\n];\\n\\n/**\\n * @typedef ProtocolExtract\\n * @type Object\\n * @property {String} protocol Protocol matched in the URL, in lowercase.\\n * @property {Boolean} slashes `true` if protocol is followed by \\\"//\\\", else `false`.\\n * @property {String} rest Rest of the URL that is not part of the protocol.\\n */\\n\\n/**\\n * Extract protocol information from a URL with/without double slash (\\\"//\\\").\\n *\\n * @param {String} address URL we want to extract from.\\n * @return {ProtocolExtract} Extracted information.\\n * @api private\\n */\\nfunction extractProtocol(address) {\\n  var match = protocolre.exec(address);\\n\\n  return {\\n    protocol: match[1] ? match[1].toLowerCase() : '',\\n    slashes: !!match[2],\\n    rest: match[3]\\n  };\\n}\\n\\n/**\\n * Resolve a relative URL pathname against a base URL pathname.\\n *\\n * @param {String} relative Pathname of the relative URL.\\n * @param {String} base Pathname of the base URL.\\n * @return {String} Resolved pathname.\\n * @api private\\n */\\nfunction resolve(relative, base) {\\n  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))\\n    , i = path.length\\n    , last = path[i - 1]\\n    , unshift = false\\n    , up = 0;\\n\\n  while (i--) {\\n    if (path[i] === '.') {\\n      path.splice(i, 1);\\n    } else if (path[i] === '..') {\\n      path.splice(i, 1);\\n      up++;\\n    } else if (up) {\\n      if (i === 0) unshift = true;\\n      path.splice(i, 1);\\n      up--;\\n    }\\n  }\\n\\n  if (unshift) path.unshift('');\\n  if (last === '.' || last === '..') path.push('');\\n\\n  return path.join('/');\\n}\\n\\n/**\\n * The actual URL instance. Instead of returning an object we've opted-in to\\n * create an actual constructor as it's much more memory efficient and\\n * faster and it pleases my OCD.\\n *\\n * @constructor\\n * @param {String} address URL we want to parse.\\n * @param {Object|String} location Location defaults for relative paths.\\n * @param {Boolean|Function} parser Parser for the query string.\\n * @api public\\n */\\nfunction URL(address, location, parser) {\\n  if (!(this instanceof URL)) {\\n    return new URL(address, location, parser);\\n  }\\n\\n  var relative, extracted, parse, instruction, index, key\\n    , instructions = rules.slice()\\n    , type = typeof location\\n    , url = this\\n    , i = 0;\\n\\n  //\\n  // The following if statements allows this module two have compatibility with\\n  // 2 different API:\\n  //\\n  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments\\n  //    where the boolean indicates that the query string should also be parsed.\\n  //\\n  // 2. The `URL` interface of the browser which accepts a URL, object as\\n  //    arguments. The supplied object will be used as default values / fall-back\\n  //    for relative paths.\\n  //\\n  if ('object' !== type && 'string' !== type) {\\n    parser = location;\\n    location = null;\\n  }\\n\\n  if (parser && 'function' !== typeof parser) parser = qs.parse;\\n\\n  location = lolcation(location);\\n\\n  //\\n  // Extract protocol information before running the instructions.\\n  //\\n  extracted = extractProtocol(address || '');\\n  relative = !extracted.protocol && !extracted.slashes;\\n  url.slashes = extracted.slashes || relative && location.slashes;\\n  url.protocol = extracted.protocol || location.protocol || '';\\n  address = extracted.rest;\\n\\n  //\\n  // When the authority component is absent the URL starts with a path\\n  // component.\\n  //\\n  if (!extracted.slashes) instructions[2] = [/(.*)/, 'pathname'];\\n\\n  for (; i < instructions.length; i++) {\\n    instruction = instructions[i];\\n    parse = instruction[0];\\n    key = instruction[1];\\n\\n    if (parse !== parse) {\\n      url[key] = address;\\n    } else if ('string' === typeof parse) {\\n      if (~(index = address.indexOf(parse))) {\\n        if ('number' === typeof instruction[2]) {\\n          url[key] = address.slice(0, index);\\n          address = address.slice(index + instruction[2]);\\n        } else {\\n          url[key] = address.slice(index);\\n          address = address.slice(0, index);\\n        }\\n      }\\n    } else if ((index = parse.exec(address))) {\\n      url[key] = index[1];\\n      address = address.slice(0, index.index);\\n    }\\n\\n    url[key] = url[key] || (\\n      relative && instruction[3] ? location[key] || '' : ''\\n    );\\n\\n    //\\n    // Hostname, host and protocol should be lowercased so they can be used to\\n    // create a proper `origin`.\\n    //\\n    if (instruction[4]) url[key] = url[key].toLowerCase();\\n  }\\n\\n  //\\n  // Also parse the supplied query string in to an object. If we're supplied\\n  // with a custom parser as function use that instead of the default build-in\\n  // parser.\\n  //\\n  if (parser) url.query = parser(url.query);\\n\\n  //\\n  // If the URL is relative, resolve the pathname against the base URL.\\n  //\\n  if (\\n      relative\\n    && location.slashes\\n    && url.pathname.charAt(0) !== '/'\\n    && (url.pathname !== '' || location.pathname !== '')\\n  ) {\\n    url.pathname = resolve(url.pathname, location.pathname);\\n  }\\n\\n  //\\n  // We should not add port numbers if they are already the default port number\\n  // for a given protocol. As the host also contains the port number we're going\\n  // override it with the hostname which contains no port number.\\n  //\\n  if (!required(url.port, url.protocol)) {\\n    url.host = url.hostname;\\n    url.port = '';\\n  }\\n\\n  //\\n  // Parse down the `auth` for the username and password.\\n  //\\n  url.username = url.password = '';\\n  if (url.auth) {\\n    instruction = url.auth.split(':');\\n    url.username = instruction[0] || '';\\n    url.password = instruction[1] || '';\\n  }\\n\\n  url.origin = url.protocol && url.host && url.protocol !== 'file:'\\n    ? url.protocol +'//'+ url.host\\n    : 'null';\\n\\n  //\\n  // The href is just the compiled result.\\n  //\\n  url.href = url.toString();\\n}\\n\\n/**\\n * This is convenience method for changing properties in the URL instance to\\n * insure that they all propagate correctly.\\n *\\n * @param {String} part          Property we need to adjust.\\n * @param {Mixed} value          The newly assigned value.\\n * @param {Boolean|Function} fn  When setting the query, it will be the function\\n *                               used to parse the query.\\n *                               When setting the protocol, double slash will be\\n *                               removed from the final url if it is true.\\n * @returns {URL}\\n * @api public\\n */\\nfunction set(part, value, fn) {\\n  var url = this;\\n\\n  switch (part) {\\n    case 'query':\\n      if ('string' === typeof value && value.length) {\\n        value = (fn || qs.parse)(value);\\n      }\\n\\n      url[part] = value;\\n      break;\\n\\n    case 'port':\\n      url[part] = value;\\n\\n      if (!required(value, url.protocol)) {\\n        url.host = url.hostname;\\n        url[part] = '';\\n      } else if (value) {\\n        url.host = url.hostname +':'+ value;\\n      }\\n\\n      break;\\n\\n    case 'hostname':\\n      url[part] = value;\\n\\n      if (url.port) value += ':'+ url.port;\\n      url.host = value;\\n      break;\\n\\n    case 'host':\\n      url[part] = value;\\n\\n      if (/:\\\\d+$/.test(value)) {\\n        value = value.split(':');\\n        url.port = value.pop();\\n        url.hostname = value.join(':');\\n      } else {\\n        url.hostname = value;\\n        url.port = '';\\n      }\\n\\n      break;\\n\\n    case 'protocol':\\n      url.protocol = value.toLowerCase();\\n      url.slashes = !fn;\\n      break;\\n\\n    case 'pathname':\\n      url.pathname = value.length && value.charAt(0) !== '/' ? '/' + value : value;\\n\\n      break;\\n\\n    default:\\n      url[part] = value;\\n  }\\n\\n  for (var i = 0; i < rules.length; i++) {\\n    var ins = rules[i];\\n\\n    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();\\n  }\\n\\n  url.origin = url.protocol && url.host && url.protocol !== 'file:'\\n    ? url.protocol +'//'+ url.host\\n    : 'null';\\n\\n  url.href = url.toString();\\n\\n  return url;\\n};\\n\\n/**\\n * Transform the properties back in to a valid and full URL string.\\n *\\n * @param {Function} stringify Optional query stringify function.\\n * @returns {String}\\n * @api public\\n */\\nfunction toString(stringify) {\\n  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;\\n\\n  var query\\n    , url = this\\n    , protocol = url.protocol;\\n\\n  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';\\n\\n  var result = protocol + (url.slashes ? '//' : '');\\n\\n  if (url.username) {\\n    result += url.username;\\n    if (url.password) result += ':'+ url.password;\\n    result += '@';\\n  }\\n\\n  result += url.host + url.pathname;\\n\\n  query = 'object' === typeof url.query ? stringify(url.query) : url.query;\\n  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;\\n\\n  if (url.hash) result += url.hash;\\n\\n  return result;\\n}\\n\\nURL.prototype = { set: set, toString: toString };\\n\\n//\\n// Expose the URL parser and some additional properties that might be useful for\\n// others or testing.\\n//\\nURL.extractProtocol = extractProtocol;\\nURL.location = lolcation;\\nURL.qs = qs;\\n\\nmodule.exports = URL;\\n\\n},{\\\"./lolcation\\\":62,\\\"querystringify\\\":59,\\\"requires-port\\\":60}],62:[function(require,module,exports){\\n(function (global){\\n'use strict';\\n\\nvar slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\\\\/\\\\//;\\n\\n/**\\n * These properties should not be copied or inherited from. This is only needed\\n * for all non blob URL's as a blob URL does not include a hash, only the\\n * origin.\\n *\\n * @type {Object}\\n * @private\\n */\\nvar ignore = { hash: 1, query: 1 }\\n  , URL;\\n\\n/**\\n * The location object differs when your code is loaded through a normal page,\\n * Worker or through a worker using a blob. And with the blobble begins the\\n * trouble as the location object will contain the URL of the blob, not the\\n * location of the page where our code is loaded in. The actual origin is\\n * encoded in the `pathname` so we can thankfully generate a good \\\"default\\\"\\n * location from it so we can generate proper relative URL's again.\\n *\\n * @param {Object|String} loc Optional default location object.\\n * @returns {Object} lolcation object.\\n * @api public\\n */\\nmodule.exports = function lolcation(loc) {\\n  loc = loc || global.location || {};\\n  URL = URL || require('./');\\n\\n  var finaldestination = {}\\n    , type = typeof loc\\n    , key;\\n\\n  if ('blob:' === loc.protocol) {\\n    finaldestination = new URL(unescape(loc.pathname), {});\\n  } else if ('string' === type) {\\n    finaldestination = new URL(loc, {});\\n    for (key in ignore) delete finaldestination[key];\\n  } else if ('object' === type) {\\n    for (key in loc) {\\n      if (key in ignore) continue;\\n      finaldestination[key] = loc[key];\\n    }\\n\\n    if (finaldestination.slashes === undefined) {\\n      finaldestination.slashes = slashes.test(loc.href);\\n    }\\n  }\\n\\n  return finaldestination;\\n};\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n\\n},{\\\"./\\\":61}]},{},[1])(1)\\n});\\n\\n\\n//# sourceMappingURL=sockjs.js.map\\n\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(0)))//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvZGlzdC9zb2NranMuanM/NTNkMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiMERBQUE7QUFDQSxhQUFhLFNBQTJELG1CQUFtQixlQUFxTixDQUFnQixhQUFhLDBCQUEwQiwwQkFBMEIsZ0JBQWdCLFVBQVUsVUFBVSwwQ0FBMEMsOEJBQXdCLG9CQUFvQiw4Q0FBOEMsa0NBQWtDLFlBQVksWUFBWSxtQ0FBbUMsaUJBQWlCLGdCQUFnQixzQkFBc0Isb0JBQW9CLDBDQUEwQyxZQUFZLFdBQVcsWUFBWSxTQUFTLEdBQUc7QUFDMXlCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsRUFBRSxrQ0FBa0M7QUFDckM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUMsRUFBRSwwQkFBMEI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsZ0NBQWdDO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEdBQUc7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEdBQUc7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsMEJBQTBCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsRUFBRSwrQkFBK0I7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUsdUlBQXVJO0FBQzFJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSxtRUFBbUU7QUFDdEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsc0ZBQXNGO0FBQ3pGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRSwwSEFBMEg7O0FBRWxKLENBQUMsRUFBRSxzSEFBc0g7QUFDekg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSx3TkFBd047QUFDM047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMscUlBQXFJOztBQUV0SSxDQUFDLEdBQUc7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdELFdBQVc7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywwQkFBMEI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGtEQUFrRCxXQUFXO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELENBQUMsR0FBRztBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxFQUFFLDBRQUEwUTtBQUM3UTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUUsMEhBQTBIOztBQUVsSixDQUFDLEVBQUUsZ0ZBQWdGO0FBQ25GO0FBQ0E7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsR0FBRztBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBLENBQUMscUlBQXFJOztBQUV0SSxDQUFDLEdBQUc7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsd0dBQXdHO0FBQzNHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLENBQUMsRUFBRSxxRkFBcUY7QUFDeEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRTs7QUFFeEIsQ0FBQyxFQUFFLCtJQUErSTtBQUNsSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSxxREFBcUQ7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFLDBIQUEwSDs7QUFFbEosQ0FBQyxFQUFFLHlHQUF5RztBQUM1RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMEJBQTBCLHFEQUFxRCxtQkFBbUIsV0FBVztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUUsMEhBQTBIOztBQUVsSixDQUFDLEVBQUUsa0lBQWtJO0FBQ3JJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLEVBQUU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSxvQ0FBb0M7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUUsMEhBQTBIOztBQUVsSixDQUFDLEVBQUUsd0RBQXdEO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsR0FBRztBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLHFJQUFxSTs7QUFFdEksQ0FBQyxHQUFHO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLENBQUMsRUFBRSxXQUFXO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLHFJQUFxSTs7QUFFdEksQ0FBQyxFQUFFLGNBQWM7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEdBQUc7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0RBQW9EO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7O0FBRUE7QUFDQSx5REFBeUQ7QUFDekQsR0FBRztBQUNILHNDQUFzQztBQUN0QztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUMscUlBQXFJOztBQUV0SSxDQUFDLEVBQUUsUUFBUSxFQUFFLEdBQUc7QUFDaEIsQ0FBQzs7O0FBR0QiLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBzb2NranMtY2xpZW50IHYxLjEuNCB8IGh0dHA6Ly9zb2NranMub3JnIHwgTUlUIGxpY2Vuc2UgKi9cbihmdW5jdGlvbihmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCImJnR5cGVvZiBtb2R1bGUhPT1cInVuZGVmaW5lZFwiKXttb2R1bGUuZXhwb3J0cz1mKCl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW10sZil9ZWxzZXt2YXIgZztpZih0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIil7Zz13aW5kb3d9ZWxzZSBpZih0eXBlb2YgZ2xvYmFsIT09XCJ1bmRlZmluZWRcIil7Zz1nbG9iYWx9ZWxzZSBpZih0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCIpe2c9c2VsZn1lbHNle2c9dGhpc31nLlNvY2tKUyA9IGYoKX19KShmdW5jdGlvbigpe3ZhciBkZWZpbmUsbW9kdWxlLGV4cG9ydHM7cmV0dXJuIChmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pKHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHRyYW5zcG9ydExpc3QgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC1saXN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tYWluJykodHJhbnNwb3J0TGlzdCk7XG5cbi8vIFRPRE8gY2FuJ3QgZ2V0IHJpZCBvZiB0aGlzIHVudGlsIGFsbCBzZXJ2ZXJzIGRvXG5pZiAoJ19zb2NranNfb25sb2FkJyBpbiBnbG9iYWwpIHtcbiAgc2V0VGltZW91dChnbG9iYWwuX3NvY2tqc19vbmxvYWQsIDEpO1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL21haW5cIjoxNCxcIi4vdHJhbnNwb3J0LWxpc3RcIjoxNn1dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50JylcbiAgO1xuXG5mdW5jdGlvbiBDbG9zZUV2ZW50KCkge1xuICBFdmVudC5jYWxsKHRoaXMpO1xuICB0aGlzLmluaXRFdmVudCgnY2xvc2UnLCBmYWxzZSwgZmFsc2UpO1xuICB0aGlzLndhc0NsZWFuID0gZmFsc2U7XG4gIHRoaXMuY29kZSA9IDA7XG4gIHRoaXMucmVhc29uID0gJyc7XG59XG5cbmluaGVyaXRzKENsb3NlRXZlbnQsIEV2ZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbG9zZUV2ZW50O1xuXG59LHtcIi4vZXZlbnRcIjo0LFwiaW5oZXJpdHNcIjo1N31dLDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL2V2ZW50dGFyZ2V0JylcbiAgO1xuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XG59XG5cbmluaGVyaXRzKEV2ZW50RW1pdHRlciwgRXZlbnRUYXJnZXQpO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHR5cGUpIHtcbiAgICBkZWxldGUgdGhpcy5fbGlzdGVuZXJzW3R5cGVdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgICAsIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLm9uKHR5cGUsIGcpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0eXBlID0gYXJndW1lbnRzWzBdO1xuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdO1xuICBpZiAoIWxpc3RlbmVycykge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBlcXVpdmFsZW50IG9mIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobCAtIDEpO1xuICBmb3IgKHZhciBhaSA9IDE7IGFpIDwgbDsgYWkrKykge1xuICAgIGFyZ3NbYWkgLSAxXSA9IGFyZ3VtZW50c1thaV07XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gRXZlbnRUYXJnZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXI7XG5cbm1vZHVsZS5leHBvcnRzLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxufSx7XCIuL2V2ZW50dGFyZ2V0XCI6NSxcImluaGVyaXRzXCI6NTd9XSw0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gRXZlbnQoZXZlbnRUeXBlKSB7XG4gIHRoaXMudHlwZSA9IGV2ZW50VHlwZTtcbn1cblxuRXZlbnQucHJvdG90eXBlLmluaXRFdmVudCA9IGZ1bmN0aW9uKGV2ZW50VHlwZSwgY2FuQnViYmxlLCBjYW5jZWxhYmxlKSB7XG4gIHRoaXMudHlwZSA9IGV2ZW50VHlwZTtcbiAgdGhpcy5idWJibGVzID0gY2FuQnViYmxlO1xuICB0aGlzLmNhbmNlbGFibGUgPSBjYW5jZWxhYmxlO1xuICB0aGlzLnRpbWVTdGFtcCA9ICtuZXcgRGF0ZSgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50LnByb3RvdHlwZS5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpIHt9O1xuRXZlbnQucHJvdG90eXBlLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7fTtcblxuRXZlbnQuQ0FQVFVSSU5HX1BIQVNFID0gMTtcbkV2ZW50LkFUX1RBUkdFVCA9IDI7XG5FdmVudC5CVUJCTElOR19QSEFTRSA9IDM7XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnQ7XG5cbn0se31dLDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vKiBTaW1wbGlmaWVkIGltcGxlbWVudGF0aW9uIG9mIERPTTIgRXZlbnRUYXJnZXQuXG4gKiAgIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUV2ZW50cy9ldmVudHMuaHRtbCNFdmVudHMtRXZlbnRUYXJnZXRcbiAqL1xuXG5mdW5jdGlvbiBFdmVudFRhcmdldCgpIHtcbiAgdGhpcy5fbGlzdGVuZXJzID0ge307XG59XG5cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIShldmVudFR5cGUgaW4gdGhpcy5fbGlzdGVuZXJzKSkge1xuICAgIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdID0gW107XG4gIH1cbiAgdmFyIGFyciA9IHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdO1xuICAvLyAjNFxuICBpZiAoYXJyLmluZGV4T2YobGlzdGVuZXIpID09PSAtMSkge1xuICAgIC8vIE1ha2UgYSBjb3B5IHNvIGFzIG5vdCB0byBpbnRlcmZlcmUgd2l0aCBhIGN1cnJlbnQgZGlzcGF0Y2hFdmVudC5cbiAgICBhcnIgPSBhcnIuY29uY2F0KFtsaXN0ZW5lcl0pO1xuICB9XG4gIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdID0gYXJyO1xufTtcblxuRXZlbnRUYXJnZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBhcnIgPSB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXTtcbiAgaWYgKCFhcnIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGlkeCA9IGFyci5pbmRleE9mKGxpc3RlbmVyKTtcbiAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICBpZiAoYXJyLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIE1ha2UgYSBjb3B5IHNvIGFzIG5vdCB0byBpbnRlcmZlcmUgd2l0aCBhIGN1cnJlbnQgZGlzcGF0Y2hFdmVudC5cbiAgICAgIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdID0gYXJyLnNsaWNlKDAsIGlkeCkuY29uY2F0KGFyci5zbGljZShpZHggKyAxKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG59O1xuXG5FdmVudFRhcmdldC5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZXZlbnQgPSBhcmd1bWVudHNbMF07XG4gIHZhciB0ID0gZXZlbnQudHlwZTtcbiAgLy8gZXF1aXZhbGVudCBvZiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBbZXZlbnRdIDogQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgLy8gVE9ETzogVGhpcyBkb2Vzbid0IG1hdGNoIHRoZSByZWFsIGJlaGF2aW9yOyBwZXIgc3BlYywgb25mb28gZ2V0XG4gIC8vIHRoZWlyIHBsYWNlIGluIGxpbmUgZnJvbSB0aGUgL2ZpcnN0LyB0aW1lIHRoZXkncmUgc2V0IGZyb21cbiAgLy8gbm9uLW51bGwuIEFsdGhvdWdoIFdlYktpdCBidW1wcyBpdCB0byB0aGUgZW5kIGV2ZXJ5IHRpbWUgaXQnc1xuICAvLyBzZXQuXG4gIGlmICh0aGlzWydvbicgKyB0XSkge1xuICAgIHRoaXNbJ29uJyArIHRdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG4gIGlmICh0IGluIHRoaXMuX2xpc3RlbmVycykge1xuICAgIC8vIEdyYWIgYSByZWZlcmVuY2UgdG8gdGhlIGxpc3RlbmVycyBsaXN0LiByZW1vdmVFdmVudExpc3RlbmVyIG1heSBhbHRlciB0aGUgbGlzdC5cbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW3RdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50VGFyZ2V0O1xuXG59LHt9XSw2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudCcpXG4gIDtcblxuZnVuY3Rpb24gVHJhbnNwb3J0TWVzc2FnZUV2ZW50KGRhdGEpIHtcbiAgRXZlbnQuY2FsbCh0aGlzKTtcbiAgdGhpcy5pbml0RXZlbnQoJ21lc3NhZ2UnLCBmYWxzZSwgZmFsc2UpO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xufVxuXG5pbmhlcml0cyhUcmFuc3BvcnRNZXNzYWdlRXZlbnQsIEV2ZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc3BvcnRNZXNzYWdlRXZlbnQ7XG5cbn0se1wiLi9ldmVudFwiOjQsXCJpbmhlcml0c1wiOjU3fV0sNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBpZnJhbWVVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvaWZyYW1lJylcbiAgO1xuXG5mdW5jdGlvbiBGYWNhZGVKUyh0cmFuc3BvcnQpIHtcbiAgdGhpcy5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICB0cmFuc3BvcnQub24oJ21lc3NhZ2UnLCB0aGlzLl90cmFuc3BvcnRNZXNzYWdlLmJpbmQodGhpcykpO1xuICB0cmFuc3BvcnQub24oJ2Nsb3NlJywgdGhpcy5fdHJhbnNwb3J0Q2xvc2UuYmluZCh0aGlzKSk7XG59XG5cbkZhY2FkZUpTLnByb3RvdHlwZS5fdHJhbnNwb3J0Q2xvc2UgPSBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgaWZyYW1lVXRpbHMucG9zdE1lc3NhZ2UoJ2MnLCBKU09OMy5zdHJpbmdpZnkoW2NvZGUsIHJlYXNvbl0pKTtcbn07XG5GYWNhZGVKUy5wcm90b3R5cGUuX3RyYW5zcG9ydE1lc3NhZ2UgPSBmdW5jdGlvbihmcmFtZSkge1xuICBpZnJhbWVVdGlscy5wb3N0TWVzc2FnZSgndCcsIGZyYW1lKTtcbn07XG5GYWNhZGVKUy5wcm90b3R5cGUuX3NlbmQgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHRoaXMuX3RyYW5zcG9ydC5zZW5kKGRhdGEpO1xufTtcbkZhY2FkZUpTLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fdHJhbnNwb3J0LmNsb3NlKCk7XG4gIHRoaXMuX3RyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRmFjYWRlSlM7XG5cbn0se1wiLi91dGlscy9pZnJhbWVcIjo0NyxcImpzb24zXCI6NTh9XSw4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB1cmxVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvdXJsJylcbiAgLCBldmVudFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9ldmVudCcpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgRmFjYWRlSlMgPSByZXF1aXJlKCcuL2ZhY2FkZScpXG4gICwgSW5mb0lmcmFtZVJlY2VpdmVyID0gcmVxdWlyZSgnLi9pbmZvLWlmcmFtZS1yZWNlaXZlcicpXG4gICwgaWZyYW1lVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL2lmcmFtZScpXG4gICwgbG9jID0gcmVxdWlyZSgnLi9sb2NhdGlvbicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDppZnJhbWUtYm9vdHN0cmFwJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oU29ja0pTLCBhdmFpbGFibGVUcmFuc3BvcnRzKSB7XG4gIHZhciB0cmFuc3BvcnRNYXAgPSB7fTtcbiAgYXZhaWxhYmxlVHJhbnNwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uKGF0KSB7XG4gICAgaWYgKGF0LmZhY2FkZVRyYW5zcG9ydCkge1xuICAgICAgdHJhbnNwb3J0TWFwW2F0LmZhY2FkZVRyYW5zcG9ydC50cmFuc3BvcnROYW1lXSA9IGF0LmZhY2FkZVRyYW5zcG9ydDtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGhhcmQtY29kZWQgZm9yIHRoZSBpbmZvIGlmcmFtZVxuICAvLyBUT0RPIHNlZSBpZiB3ZSBjYW4gbWFrZSB0aGlzIG1vcmUgZHluYW1pY1xuICB0cmFuc3BvcnRNYXBbSW5mb0lmcmFtZVJlY2VpdmVyLnRyYW5zcG9ydE5hbWVdID0gSW5mb0lmcmFtZVJlY2VpdmVyO1xuICB2YXIgcGFyZW50T3JpZ2luO1xuXG4gIC8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuICBTb2NrSlMuYm9vdHN0cmFwX2lmcmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8qIGVzbGludC1lbmFibGUgY2FtZWxjYXNlICovXG4gICAgdmFyIGZhY2FkZTtcbiAgICBpZnJhbWVVdGlscy5jdXJyZW50V2luZG93SWQgPSBsb2MuaGFzaC5zbGljZSgxKTtcbiAgICB2YXIgb25NZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGUuc291cmNlICE9PSBwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwYXJlbnRPcmlnaW4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHBhcmVudE9yaWdpbiA9IGUub3JpZ2luO1xuICAgICAgfVxuICAgICAgaWYgKGUub3JpZ2luICE9PSBwYXJlbnRPcmlnaW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWZyYW1lTWVzc2FnZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmcmFtZU1lc3NhZ2UgPSBKU09OMy5wYXJzZShlLmRhdGEpO1xuICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICBkZWJ1ZygnYmFkIGpzb24nLCBlLmRhdGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChpZnJhbWVNZXNzYWdlLndpbmRvd0lkICE9PSBpZnJhbWVVdGlscy5jdXJyZW50V2luZG93SWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChpZnJhbWVNZXNzYWdlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3MnOlxuICAgICAgICB2YXIgcDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwID0gSlNPTjMucGFyc2UoaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICAgIGRlYnVnKCdiYWQganNvbicsIGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZlcnNpb24gPSBwWzBdO1xuICAgICAgICB2YXIgdHJhbnNwb3J0ID0gcFsxXTtcbiAgICAgICAgdmFyIHRyYW5zVXJsID0gcFsyXTtcbiAgICAgICAgdmFyIGJhc2VVcmwgPSBwWzNdO1xuICAgICAgICBkZWJ1Zyh2ZXJzaW9uLCB0cmFuc3BvcnQsIHRyYW5zVXJsLCBiYXNlVXJsKTtcbiAgICAgICAgLy8gY2hhbmdlIHRoaXMgdG8gc2VtdmVyIGxvZ2ljXG4gICAgICAgIGlmICh2ZXJzaW9uICE9PSBTb2NrSlMudmVyc2lvbikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb21wYXRpYmxlIFNvY2tKUyEgTWFpbiBzaXRlIHVzZXM6JyArXG4gICAgICAgICAgICAgICAgICAgICcgXCInICsgdmVyc2lvbiArICdcIiwgdGhlIGlmcmFtZTonICtcbiAgICAgICAgICAgICAgICAgICAgJyBcIicgKyBTb2NrSlMudmVyc2lvbiArICdcIi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdXJsVXRpbHMuaXNPcmlnaW5FcXVhbCh0cmFuc1VybCwgbG9jLmhyZWYpIHx8XG4gICAgICAgICAgICAhdXJsVXRpbHMuaXNPcmlnaW5FcXVhbChiYXNlVXJsLCBsb2MuaHJlZikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgY29ubmVjdCB0byBkaWZmZXJlbnQgZG9tYWluIGZyb20gd2l0aGluIGFuICcgK1xuICAgICAgICAgICAgICAgICAgICAnaWZyYW1lLiAoJyArIGxvYy5ocmVmICsgJywgJyArIHRyYW5zVXJsICsgJywgJyArIGJhc2VVcmwgKyAnKScpO1xuICAgICAgICB9XG4gICAgICAgIGZhY2FkZSA9IG5ldyBGYWNhZGVKUyhuZXcgdHJhbnNwb3J0TWFwW3RyYW5zcG9ydF0odHJhbnNVcmwsIGJhc2VVcmwpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtJzpcbiAgICAgICAgZmFjYWRlLl9zZW5kKGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYyc6XG4gICAgICAgIGlmIChmYWNhZGUpIHtcbiAgICAgICAgICBmYWNhZGUuX2Nsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZmFjYWRlID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGV2ZW50VXRpbHMuYXR0YWNoRXZlbnQoJ21lc3NhZ2UnLCBvbk1lc3NhZ2UpO1xuXG4gICAgLy8gU3RhcnRcbiAgICBpZnJhbWVVdGlscy5wb3N0TWVzc2FnZSgncycpO1xuICB9O1xufTtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4vZmFjYWRlXCI6NyxcIi4vaW5mby1pZnJhbWUtcmVjZWl2ZXJcIjoxMCxcIi4vbG9jYXRpb25cIjoxMyxcIi4vdXRpbHMvZXZlbnRcIjo0NixcIi4vdXRpbHMvaWZyYW1lXCI6NDcsXCIuL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NSxcImpzb24zXCI6NTh9XSw5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBvYmplY3RVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvb2JqZWN0JylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmluZm8tYWpheCcpO1xufVxuXG5mdW5jdGlvbiBJbmZvQWpheCh1cmwsIEFqYXhPYmplY3QpIHtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdDAgPSArbmV3IERhdGUoKTtcbiAgdGhpcy54byA9IG5ldyBBamF4T2JqZWN0KCdHRVQnLCB1cmwpO1xuXG4gIHRoaXMueG8ub25jZSgnZmluaXNoJywgZnVuY3Rpb24oc3RhdHVzLCB0ZXh0KSB7XG4gICAgdmFyIGluZm8sIHJ0dDtcbiAgICBpZiAoc3RhdHVzID09PSAyMDApIHtcbiAgICAgIHJ0dCA9ICgrbmV3IERhdGUoKSkgLSB0MDtcbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaW5mbyA9IEpTT04zLnBhcnNlKHRleHQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGVidWcoJ2JhZCBqc29uJywgdGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFvYmplY3RVdGlscy5pc09iamVjdChpbmZvKSkge1xuICAgICAgICBpbmZvID0ge307XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGYuZW1pdCgnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgICBzZWxmLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9KTtcbn1cblxuaW5oZXJpdHMoSW5mb0FqYXgsIEV2ZW50RW1pdHRlcik7XG5cbkluZm9BamF4LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB0aGlzLnhvLmNsb3NlKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluZm9BamF4O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi91dGlscy9vYmplY3RcIjo0OSxcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1NyxcImpzb24zXCI6NTh9XSwxMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBYSFJMb2NhbE9iamVjdCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItbG9jYWwnKVxuICAsIEluZm9BamF4ID0gcmVxdWlyZSgnLi9pbmZvLWFqYXgnKVxuICA7XG5cbmZ1bmN0aW9uIEluZm9SZWNlaXZlcklmcmFtZSh0cmFuc1VybCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHRoaXMuaXIgPSBuZXcgSW5mb0FqYXgodHJhbnNVcmwsIFhIUkxvY2FsT2JqZWN0KTtcbiAgdGhpcy5pci5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihpbmZvLCBydHQpIHtcbiAgICBzZWxmLmlyID0gbnVsbDtcbiAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBKU09OMy5zdHJpbmdpZnkoW2luZm8sIHJ0dF0pKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKEluZm9SZWNlaXZlcklmcmFtZSwgRXZlbnRFbWl0dGVyKTtcblxuSW5mb1JlY2VpdmVySWZyYW1lLnRyYW5zcG9ydE5hbWUgPSAnaWZyYW1lLWluZm8tcmVjZWl2ZXInO1xuXG5JbmZvUmVjZWl2ZXJJZnJhbWUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmlyKSB7XG4gICAgdGhpcy5pci5jbG9zZSgpO1xuICAgIHRoaXMuaXIgPSBudWxsO1xuICB9XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluZm9SZWNlaXZlcklmcmFtZTtcblxufSx7XCIuL2luZm8tYWpheFwiOjksXCIuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWxvY2FsXCI6MzcsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1NyxcImpzb24zXCI6NTh9XSwxMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9ldmVudCcpXG4gICwgSWZyYW1lVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvaWZyYW1lJylcbiAgLCBJbmZvUmVjZWl2ZXJJZnJhbWUgPSByZXF1aXJlKCcuL2luZm8taWZyYW1lLXJlY2VpdmVyJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmluZm8taWZyYW1lJyk7XG59XG5cbmZ1bmN0aW9uIEluZm9JZnJhbWUoYmFzZVVybCwgdXJsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdmFyIGdvID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlmciA9IHNlbGYuaWZyID0gbmV3IElmcmFtZVRyYW5zcG9ydChJbmZvUmVjZWl2ZXJJZnJhbWUudHJhbnNwb3J0TmFtZSwgdXJsLCBiYXNlVXJsKTtcblxuICAgIGlmci5vbmNlKCdtZXNzYWdlJywgZnVuY3Rpb24obXNnKSB7XG4gICAgICBpZiAobXNnKSB7XG4gICAgICAgIHZhciBkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGQgPSBKU09OMy5wYXJzZShtc2cpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGVidWcoJ2JhZCBqc29uJywgbXNnKTtcbiAgICAgICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcpO1xuICAgICAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5mbyA9IGRbMF0sIHJ0dCA9IGRbMV07XG4gICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgICAgIH1cbiAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICB9KTtcblxuICAgIGlmci5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnKTtcbiAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBUT0RPIHRoaXMgc2VlbXMgdGhlIHNhbWUgYXMgdGhlICduZWVkQm9keScgZnJvbSB0cmFuc3BvcnRzXG4gIGlmICghZ2xvYmFsLmRvY3VtZW50LmJvZHkpIHtcbiAgICB1dGlscy5hdHRhY2hFdmVudCgnbG9hZCcsIGdvKTtcbiAgfSBlbHNlIHtcbiAgICBnbygpO1xuICB9XG59XG5cbmluaGVyaXRzKEluZm9JZnJhbWUsIEV2ZW50RW1pdHRlcik7XG5cbkluZm9JZnJhbWUuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQoKTtcbn07XG5cbkluZm9JZnJhbWUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmlmcikge1xuICAgIHRoaXMuaWZyLmNsb3NlKCk7XG4gIH1cbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdGhpcy5pZnIgPSBudWxsO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmZvSWZyYW1lO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL2luZm8taWZyYW1lLXJlY2VpdmVyXCI6MTAsXCIuL3RyYW5zcG9ydC9pZnJhbWVcIjoyMixcIi4vdXRpbHMvZXZlbnRcIjo0NixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1NyxcImpzb24zXCI6NTh9XSwxMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL3VybCcpXG4gICwgWERSID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvc2VuZGVyL3hkcicpXG4gICwgWEhSQ29ycyA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItY29ycycpXG4gICwgWEhSTG9jYWwgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWxvY2FsJylcbiAgLCBYSFJGYWtlID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvc2VuZGVyL3hoci1mYWtlJylcbiAgLCBJbmZvSWZyYW1lID0gcmVxdWlyZSgnLi9pbmZvLWlmcmFtZScpXG4gICwgSW5mb0FqYXggPSByZXF1aXJlKCcuL2luZm8tYWpheCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDppbmZvLXJlY2VpdmVyJyk7XG59XG5cbmZ1bmN0aW9uIEluZm9SZWNlaXZlcihiYXNlVXJsLCB1cmxJbmZvKSB7XG4gIGRlYnVnKGJhc2VVcmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5kb1hocihiYXNlVXJsLCB1cmxJbmZvKTtcbiAgfSwgMCk7XG59XG5cbmluaGVyaXRzKEluZm9SZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcblxuLy8gVE9ETyB0aGlzIGlzIGN1cnJlbnRseSBpZ25vcmluZyB0aGUgbGlzdCBvZiBhdmFpbGFibGUgdHJhbnNwb3J0cyBhbmQgdGhlIHdoaXRlbGlzdFxuXG5JbmZvUmVjZWl2ZXIuX2dldFJlY2VpdmVyID0gZnVuY3Rpb24oYmFzZVVybCwgdXJsLCB1cmxJbmZvKSB7XG4gIC8vIGRldGVybWluZSBtZXRob2Qgb2YgQ09SUyBzdXBwb3J0IChpZiBuZWVkZWQpXG4gIGlmICh1cmxJbmZvLnNhbWVPcmlnaW4pIHtcbiAgICByZXR1cm4gbmV3IEluZm9BamF4KHVybCwgWEhSTG9jYWwpO1xuICB9XG4gIGlmIChYSFJDb3JzLmVuYWJsZWQpIHtcbiAgICByZXR1cm4gbmV3IEluZm9BamF4KHVybCwgWEhSQ29ycyk7XG4gIH1cbiAgaWYgKFhEUi5lbmFibGVkICYmIHVybEluZm8uc2FtZVNjaGVtZSkge1xuICAgIHJldHVybiBuZXcgSW5mb0FqYXgodXJsLCBYRFIpO1xuICB9XG4gIGlmIChJbmZvSWZyYW1lLmVuYWJsZWQoKSkge1xuICAgIHJldHVybiBuZXcgSW5mb0lmcmFtZShiYXNlVXJsLCB1cmwpO1xuICB9XG4gIHJldHVybiBuZXcgSW5mb0FqYXgodXJsLCBYSFJGYWtlKTtcbn07XG5cbkluZm9SZWNlaXZlci5wcm90b3R5cGUuZG9YaHIgPSBmdW5jdGlvbihiYXNlVXJsLCB1cmxJbmZvKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICAgICwgdXJsID0gdXJsVXRpbHMuYWRkUGF0aChiYXNlVXJsLCAnL2luZm8nKVxuICAgIDtcbiAgZGVidWcoJ2RvWGhyJywgdXJsKTtcblxuICB0aGlzLnhvID0gSW5mb1JlY2VpdmVyLl9nZXRSZWNlaXZlcihiYXNlVXJsLCB1cmwsIHVybEluZm8pO1xuXG4gIHRoaXMudGltZW91dFJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3RpbWVvdXQnKTtcbiAgICBzZWxmLl9jbGVhbnVwKGZhbHNlKTtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcpO1xuICB9LCBJbmZvUmVjZWl2ZXIudGltZW91dCk7XG5cbiAgdGhpcy54by5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihpbmZvLCBydHQpIHtcbiAgICBkZWJ1ZygnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgICBzZWxmLl9jbGVhbnVwKHRydWUpO1xuICAgIHNlbGYuZW1pdCgnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgfSk7XG59O1xuXG5JbmZvUmVjZWl2ZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24od2FzQ2xlYW4pIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRSZWYpO1xuICB0aGlzLnRpbWVvdXRSZWYgPSBudWxsO1xuICBpZiAoIXdhc0NsZWFuICYmIHRoaXMueG8pIHtcbiAgICB0aGlzLnhvLmNsb3NlKCk7XG4gIH1cbiAgdGhpcy54byA9IG51bGw7XG59O1xuXG5JbmZvUmVjZWl2ZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB0aGlzLl9jbGVhbnVwKGZhbHNlKTtcbn07XG5cbkluZm9SZWNlaXZlci50aW1lb3V0ID0gODAwMDtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmZvUmVjZWl2ZXI7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuL2luZm8tYWpheFwiOjksXCIuL2luZm8taWZyYW1lXCI6MTEsXCIuL3RyYW5zcG9ydC9zZW5kZXIveGRyXCI6MzQsXCIuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWNvcnNcIjozNSxcIi4vdHJhbnNwb3J0L3NlbmRlci94aHItZmFrZVwiOjM2LFwiLi90cmFuc3BvcnQvc2VuZGVyL3hoci1sb2NhbFwiOjM3LFwiLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDEzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwubG9jYXRpb24gfHwge1xuICBvcmlnaW46ICdodHRwOi8vbG9jYWxob3N0OjgwJ1xuLCBwcm90b2NvbDogJ2h0dHAnXG4sIGhvc3Q6ICdsb2NhbGhvc3QnXG4sIHBvcnQ6IDgwXG4sIGhyZWY6ICdodHRwOi8vbG9jYWxob3N0LydcbiwgaGFzaDogJydcbn07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSwxNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi9zaGltcycpO1xuXG52YXIgVVJMID0gcmVxdWlyZSgndXJsLXBhcnNlJylcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCByYW5kb20gPSByZXF1aXJlKCcuL3V0aWxzL3JhbmRvbScpXG4gICwgZXNjYXBlID0gcmVxdWlyZSgnLi91dGlscy9lc2NhcGUnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy91cmwnKVxuICAsIGV2ZW50VXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL2V2ZW50JylcbiAgLCB0cmFuc3BvcnQgPSByZXF1aXJlKCcuL3V0aWxzL3RyYW5zcG9ydCcpXG4gICwgb2JqZWN0VXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL29iamVjdCcpXG4gICwgYnJvd3NlciA9IHJlcXVpcmUoJy4vdXRpbHMvYnJvd3NlcicpXG4gICwgbG9nID0gcmVxdWlyZSgnLi91dGlscy9sb2cnKVxuICAsIEV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudC9ldmVudCcpXG4gICwgRXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL2V2ZW50L2V2ZW50dGFyZ2V0JylcbiAgLCBsb2MgPSByZXF1aXJlKCcuL2xvY2F0aW9uJylcbiAgLCBDbG9zZUV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudC9jbG9zZScpXG4gICwgVHJhbnNwb3J0TWVzc2FnZUV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudC90cmFucy1tZXNzYWdlJylcbiAgLCBJbmZvUmVjZWl2ZXIgPSByZXF1aXJlKCcuL2luZm8tcmVjZWl2ZXInKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6bWFpbicpO1xufVxuXG52YXIgdHJhbnNwb3J0cztcblxuLy8gZm9sbG93IGNvbnN0cnVjdG9yIHN0ZXBzIGRlZmluZWQgYXQgaHR0cDovL2Rldi53My5vcmcvaHRtbDUvd2Vic29ja2V0cy8jdGhlLXdlYnNvY2tldC1pbnRlcmZhY2VcbmZ1bmN0aW9uIFNvY2tKUyh1cmwsIHByb3RvY29scywgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU29ja0pTKSkge1xuICAgIHJldHVybiBuZXcgU29ja0pTKHVybCwgcHJvdG9jb2xzLCBvcHRpb25zKTtcbiAgfVxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnU29ja0pTOiAxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnRcIik7XG4gIH1cbiAgRXZlbnRUYXJnZXQuY2FsbCh0aGlzKTtcblxuICB0aGlzLnJlYWR5U3RhdGUgPSBTb2NrSlMuQ09OTkVDVElORztcbiAgdGhpcy5leHRlbnNpb25zID0gJyc7XG4gIHRoaXMucHJvdG9jb2wgPSAnJztcblxuICAvLyBub24tc3RhbmRhcmQgZXh0ZW5zaW9uXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAob3B0aW9ucy5wcm90b2NvbHNfd2hpdGVsaXN0KSB7XG4gICAgbG9nLndhcm4oXCIncHJvdG9jb2xzX3doaXRlbGlzdCcgaXMgREVQUkVDQVRFRC4gVXNlICd0cmFuc3BvcnRzJyBpbnN0ZWFkLlwiKTtcbiAgfVxuICB0aGlzLl90cmFuc3BvcnRzV2hpdGVsaXN0ID0gb3B0aW9ucy50cmFuc3BvcnRzO1xuICB0aGlzLl90cmFuc3BvcnRPcHRpb25zID0gb3B0aW9ucy50cmFuc3BvcnRPcHRpb25zIHx8IHt9O1xuXG4gIHZhciBzZXNzaW9uSWQgPSBvcHRpb25zLnNlc3Npb25JZCB8fCA4O1xuICBpZiAodHlwZW9mIHNlc3Npb25JZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuX2dlbmVyYXRlU2Vzc2lvbklkID0gc2Vzc2lvbklkO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzZXNzaW9uSWQgPT09ICdudW1iZXInKSB7XG4gICAgdGhpcy5fZ2VuZXJhdGVTZXNzaW9uSWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByYW5kb20uc3RyaW5nKHNlc3Npb25JZCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJZiBzZXNzaW9uSWQgaXMgdXNlZCBpbiB0aGUgb3B0aW9ucywgaXQgbmVlZHMgdG8gYmUgYSBudW1iZXIgb3IgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHRoaXMuX3NlcnZlciA9IG9wdGlvbnMuc2VydmVyIHx8IHJhbmRvbS5udW1iZXJTdHJpbmcoMTAwMCk7XG5cbiAgLy8gU3RlcCAxIG9mIFdTIHNwZWMgLSBwYXJzZSBhbmQgdmFsaWRhdGUgdGhlIHVybC4gSXNzdWUgIzhcbiAgdmFyIHBhcnNlZFVybCA9IG5ldyBVUkwodXJsKTtcbiAgaWYgKCFwYXJzZWRVcmwuaG9zdCB8fCAhcGFyc2VkVXJsLnByb3RvY29sKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVGhlIFVSTCAnXCIgKyB1cmwgKyBcIicgaXMgaW52YWxpZFwiKTtcbiAgfSBlbHNlIGlmIChwYXJzZWRVcmwuaGFzaCkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVGhlIFVSTCBtdXN0IG5vdCBjb250YWluIGEgZnJhZ21lbnQnKTtcbiAgfSBlbHNlIGlmIChwYXJzZWRVcmwucHJvdG9jb2wgIT09ICdodHRwOicgJiYgcGFyc2VkVXJsLnByb3RvY29sICE9PSAnaHR0cHM6Jykge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlRoZSBVUkwncyBzY2hlbWUgbXVzdCBiZSBlaXRoZXIgJ2h0dHA6JyBvciAnaHR0cHM6Jy4gJ1wiICsgcGFyc2VkVXJsLnByb3RvY29sICsgXCInIGlzIG5vdCBhbGxvd2VkLlwiKTtcbiAgfVxuXG4gIHZhciBzZWN1cmUgPSBwYXJzZWRVcmwucHJvdG9jb2wgPT09ICdodHRwczonO1xuICAvLyBTdGVwIDIgLSBkb24ndCBhbGxvdyBzZWN1cmUgb3JpZ2luIHdpdGggYW4gaW5zZWN1cmUgcHJvdG9jb2xcbiAgaWYgKGxvYy5wcm90b2NvbCA9PT0gJ2h0dHBzJyAmJiAhc2VjdXJlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTZWN1cml0eUVycm9yOiBBbiBpbnNlY3VyZSBTb2NrSlMgY29ubmVjdGlvbiBtYXkgbm90IGJlIGluaXRpYXRlZCBmcm9tIGEgcGFnZSBsb2FkZWQgb3ZlciBIVFRQUycpO1xuICB9XG5cbiAgLy8gU3RlcCAzIC0gY2hlY2sgcG9ydCBhY2Nlc3MgLSBubyBuZWVkIGhlcmVcbiAgLy8gU3RlcCA0IC0gcGFyc2UgcHJvdG9jb2xzIGFyZ3VtZW50XG4gIGlmICghcHJvdG9jb2xzKSB7XG4gICAgcHJvdG9jb2xzID0gW107XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkocHJvdG9jb2xzKSkge1xuICAgIHByb3RvY29scyA9IFtwcm90b2NvbHNdO1xuICB9XG5cbiAgLy8gU3RlcCA1IC0gY2hlY2sgcHJvdG9jb2xzIGFyZ3VtZW50XG4gIHZhciBzb3J0ZWRQcm90b2NvbHMgPSBwcm90b2NvbHMuc29ydCgpO1xuICBzb3J0ZWRQcm90b2NvbHMuZm9yRWFjaChmdW5jdGlvbihwcm90bywgaSkge1xuICAgIGlmICghcHJvdG8pIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlRoZSBwcm90b2NvbHMgZW50cnkgJ1wiICsgcHJvdG8gKyBcIicgaXMgaW52YWxpZC5cIik7XG4gICAgfVxuICAgIGlmIChpIDwgKHNvcnRlZFByb3RvY29scy5sZW5ndGggLSAxKSAmJiBwcm90byA9PT0gc29ydGVkUHJvdG9jb2xzW2kgKyAxXSkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVGhlIHByb3RvY29scyBlbnRyeSAnXCIgKyBwcm90byArIFwiJyBpcyBkdXBsaWNhdGVkLlwiKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFN0ZXAgNiAtIGNvbnZlcnQgb3JpZ2luXG4gIHZhciBvID0gdXJsVXRpbHMuZ2V0T3JpZ2luKGxvYy5ocmVmKTtcbiAgdGhpcy5fb3JpZ2luID0gbyA/IG8udG9Mb3dlckNhc2UoKSA6IG51bGw7XG5cbiAgLy8gcmVtb3ZlIHRoZSB0cmFpbGluZyBzbGFzaFxuICBwYXJzZWRVcmwuc2V0KCdwYXRobmFtZScsIHBhcnNlZFVybC5wYXRobmFtZS5yZXBsYWNlKC9cXC8rJC8sICcnKSk7XG5cbiAgLy8gc3RvcmUgdGhlIHNhbml0aXplZCB1cmxcbiAgdGhpcy51cmwgPSBwYXJzZWRVcmwuaHJlZjtcbiAgZGVidWcoJ3VzaW5nIHVybCcsIHRoaXMudXJsKTtcblxuICAvLyBTdGVwIDcgLSBzdGFydCBjb25uZWN0aW9uIGluIGJhY2tncm91bmRcbiAgLy8gb2J0YWluIHNlcnZlciBpbmZvXG4gIC8vIGh0dHA6Ly9zb2NranMuZ2l0aHViLmlvL3NvY2tqcy1wcm90b2NvbC9zb2NranMtcHJvdG9jb2wtMC4zLjMuaHRtbCNzZWN0aW9uLTI2XG4gIHRoaXMuX3VybEluZm8gPSB7XG4gICAgbnVsbE9yaWdpbjogIWJyb3dzZXIuaGFzRG9tYWluKClcbiAgLCBzYW1lT3JpZ2luOiB1cmxVdGlscy5pc09yaWdpbkVxdWFsKHRoaXMudXJsLCBsb2MuaHJlZilcbiAgLCBzYW1lU2NoZW1lOiB1cmxVdGlscy5pc1NjaGVtZUVxdWFsKHRoaXMudXJsLCBsb2MuaHJlZilcbiAgfTtcblxuICB0aGlzLl9pciA9IG5ldyBJbmZvUmVjZWl2ZXIodGhpcy51cmwsIHRoaXMuX3VybEluZm8pO1xuICB0aGlzLl9pci5vbmNlKCdmaW5pc2gnLCB0aGlzLl9yZWNlaXZlSW5mby5iaW5kKHRoaXMpKTtcbn1cblxuaW5oZXJpdHMoU29ja0pTLCBFdmVudFRhcmdldCk7XG5cbmZ1bmN0aW9uIHVzZXJTZXRDb2RlKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPT09IDEwMDAgfHwgKGNvZGUgPj0gMzAwMCAmJiBjb2RlIDw9IDQ5OTkpO1xufVxuXG5Tb2NrSlMucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gIC8vIFN0ZXAgMVxuICBpZiAoY29kZSAmJiAhdXNlclNldENvZGUoY29kZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWRBY2Nlc3NFcnJvcjogSW52YWxpZCBjb2RlJyk7XG4gIH1cbiAgLy8gU3RlcCAyLjQgc3RhdGVzIHRoZSBtYXggaXMgMTIzIGJ5dGVzLCBidXQgd2UgYXJlIGp1c3QgY2hlY2tpbmcgbGVuZ3RoXG4gIGlmIChyZWFzb24gJiYgcmVhc29uLmxlbmd0aCA+IDEyMykge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcigncmVhc29uIGFyZ3VtZW50IGhhcyBhbiBpbnZhbGlkIGxlbmd0aCcpO1xuICB9XG5cbiAgLy8gU3RlcCAzLjFcbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNMT1NJTkcgfHwgdGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ0xPU0VEKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVE9ETyBsb29rIGF0IGRvY3MgdG8gZGV0ZXJtaW5lIGhvdyB0byBzZXQgdGhpc1xuICB2YXIgd2FzQ2xlYW4gPSB0cnVlO1xuICB0aGlzLl9jbG9zZShjb2RlIHx8IDEwMDAsIHJlYXNvbiB8fCAnTm9ybWFsIGNsb3N1cmUnLCB3YXNDbGVhbik7XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihkYXRhKSB7XG4gIC8vICMxMyAtIGNvbnZlcnQgYW55dGhpbmcgbm9uLXN0cmluZyB0byBzdHJpbmdcbiAgLy8gVE9ETyB0aGlzIGN1cnJlbnRseSB0dXJucyBvYmplY3RzIGludG8gW29iamVjdCBPYmplY3RdXG4gIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICBkYXRhID0gJycgKyBkYXRhO1xuICB9XG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DT05ORUNUSU5HKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkU3RhdGVFcnJvcjogVGhlIGNvbm5lY3Rpb24gaGFzIG5vdCBiZWVuIGVzdGFibGlzaGVkIHlldCcpO1xuICB9XG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFNvY2tKUy5PUEVOKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuX3RyYW5zcG9ydC5zZW5kKGVzY2FwZS5xdW90ZShkYXRhKSk7XG59O1xuXG5Tb2NrSlMudmVyc2lvbiA9IHJlcXVpcmUoJy4vdmVyc2lvbicpO1xuXG5Tb2NrSlMuQ09OTkVDVElORyA9IDA7XG5Tb2NrSlMuT1BFTiA9IDE7XG5Tb2NrSlMuQ0xPU0lORyA9IDI7XG5Tb2NrSlMuQ0xPU0VEID0gMztcblxuU29ja0pTLnByb3RvdHlwZS5fcmVjZWl2ZUluZm8gPSBmdW5jdGlvbihpbmZvLCBydHQpIHtcbiAgZGVidWcoJ19yZWNlaXZlSW5mbycsIHJ0dCk7XG4gIHRoaXMuX2lyID0gbnVsbDtcbiAgaWYgKCFpbmZvKSB7XG4gICAgdGhpcy5fY2xvc2UoMTAwMiwgJ0Nhbm5vdCBjb25uZWN0IHRvIHNlcnZlcicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGVzdGFibGlzaCBhIHJvdW5kLXRyaXAgdGltZW91dCAoUlRPKSBiYXNlZCBvbiB0aGVcbiAgLy8gcm91bmQtdHJpcCB0aW1lIChSVFQpXG4gIHRoaXMuX3J0byA9IHRoaXMuY291bnRSVE8ocnR0KTtcbiAgLy8gYWxsb3cgc2VydmVyIHRvIG92ZXJyaWRlIHVybCB1c2VkIGZvciB0aGUgYWN0dWFsIHRyYW5zcG9ydFxuICB0aGlzLl90cmFuc1VybCA9IGluZm8uYmFzZV91cmwgPyBpbmZvLmJhc2VfdXJsIDogdGhpcy51cmw7XG4gIGluZm8gPSBvYmplY3RVdGlscy5leHRlbmQoaW5mbywgdGhpcy5fdXJsSW5mbyk7XG4gIGRlYnVnKCdpbmZvJywgaW5mbyk7XG4gIC8vIGRldGVybWluZSBsaXN0IG9mIGRlc2lyZWQgYW5kIHN1cHBvcnRlZCB0cmFuc3BvcnRzXG4gIHZhciBlbmFibGVkVHJhbnNwb3J0cyA9IHRyYW5zcG9ydHMuZmlsdGVyVG9FbmFibGVkKHRoaXMuX3RyYW5zcG9ydHNXaGl0ZWxpc3QsIGluZm8pO1xuICB0aGlzLl90cmFuc3BvcnRzID0gZW5hYmxlZFRyYW5zcG9ydHMubWFpbjtcbiAgZGVidWcodGhpcy5fdHJhbnNwb3J0cy5sZW5ndGggKyAnIGVuYWJsZWQgdHJhbnNwb3J0cycpO1xuXG4gIHRoaXMuX2Nvbm5lY3QoKTtcbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgVHJhbnNwb3J0ID0gdGhpcy5fdHJhbnNwb3J0cy5zaGlmdCgpOyBUcmFuc3BvcnQ7IFRyYW5zcG9ydCA9IHRoaXMuX3RyYW5zcG9ydHMuc2hpZnQoKSkge1xuICAgIGRlYnVnKCdhdHRlbXB0JywgVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUpO1xuICAgIGlmIChUcmFuc3BvcnQubmVlZEJvZHkpIHtcbiAgICAgIGlmICghZ2xvYmFsLmRvY3VtZW50LmJvZHkgfHxcbiAgICAgICAgICAodHlwZW9mIGdsb2JhbC5kb2N1bWVudC5yZWFkeVN0YXRlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgZ2xvYmFsLmRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICdjb21wbGV0ZScgJiZcbiAgICAgICAgICAgIGdsb2JhbC5kb2N1bWVudC5yZWFkeVN0YXRlICE9PSAnaW50ZXJhY3RpdmUnKSkge1xuICAgICAgICBkZWJ1Zygnd2FpdGluZyBmb3IgYm9keScpO1xuICAgICAgICB0aGlzLl90cmFuc3BvcnRzLnVuc2hpZnQoVHJhbnNwb3J0KTtcbiAgICAgICAgZXZlbnRVdGlscy5hdHRhY2hFdmVudCgnbG9hZCcsIHRoaXMuX2Nvbm5lY3QuYmluZCh0aGlzKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjYWxjdWxhdGUgdGltZW91dCBiYXNlZCBvbiBSVE8gYW5kIHJvdW5kIHRyaXBzLiBEZWZhdWx0IHRvIDVzXG4gICAgdmFyIHRpbWVvdXRNcyA9ICh0aGlzLl9ydG8gKiBUcmFuc3BvcnQucm91bmRUcmlwcykgfHwgNTAwMDtcbiAgICB0aGlzLl90cmFuc3BvcnRUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KHRoaXMuX3RyYW5zcG9ydFRpbWVvdXQuYmluZCh0aGlzKSwgdGltZW91dE1zKTtcbiAgICBkZWJ1ZygndXNpbmcgdGltZW91dCcsIHRpbWVvdXRNcyk7XG5cbiAgICB2YXIgdHJhbnNwb3J0VXJsID0gdXJsVXRpbHMuYWRkUGF0aCh0aGlzLl90cmFuc1VybCwgJy8nICsgdGhpcy5fc2VydmVyICsgJy8nICsgdGhpcy5fZ2VuZXJhdGVTZXNzaW9uSWQoKSk7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLl90cmFuc3BvcnRPcHRpb25zW1RyYW5zcG9ydC50cmFuc3BvcnROYW1lXTtcbiAgICBkZWJ1ZygndHJhbnNwb3J0IHVybCcsIHRyYW5zcG9ydFVybCk7XG4gICAgdmFyIHRyYW5zcG9ydE9iaiA9IG5ldyBUcmFuc3BvcnQodHJhbnNwb3J0VXJsLCB0aGlzLl90cmFuc1VybCwgb3B0aW9ucyk7XG4gICAgdHJhbnNwb3J0T2JqLm9uKCdtZXNzYWdlJywgdGhpcy5fdHJhbnNwb3J0TWVzc2FnZS5iaW5kKHRoaXMpKTtcbiAgICB0cmFuc3BvcnRPYmoub25jZSgnY2xvc2UnLCB0aGlzLl90cmFuc3BvcnRDbG9zZS5iaW5kKHRoaXMpKTtcbiAgICB0cmFuc3BvcnRPYmoudHJhbnNwb3J0TmFtZSA9IFRyYW5zcG9ydC50cmFuc3BvcnROYW1lO1xuICAgIHRoaXMuX3RyYW5zcG9ydCA9IHRyYW5zcG9ydE9iajtcblxuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLl9jbG9zZSgyMDAwLCAnQWxsIHRyYW5zcG9ydHMgZmFpbGVkJywgZmFsc2UpO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5fdHJhbnNwb3J0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX3RyYW5zcG9ydFRpbWVvdXQnKTtcbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNPTk5FQ1RJTkcpIHtcbiAgICB0aGlzLl90cmFuc3BvcnRDbG9zZSgyMDA3LCAnVHJhbnNwb3J0IHRpbWVkIG91dCcpO1xuICB9XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl90cmFuc3BvcnRNZXNzYWdlID0gZnVuY3Rpb24obXNnKSB7XG4gIGRlYnVnKCdfdHJhbnNwb3J0TWVzc2FnZScsIG1zZyk7XG4gIHZhciBzZWxmID0gdGhpc1xuICAgICwgdHlwZSA9IG1zZy5zbGljZSgwLCAxKVxuICAgICwgY29udGVudCA9IG1zZy5zbGljZSgxKVxuICAgICwgcGF5bG9hZFxuICAgIDtcblxuICAvLyBmaXJzdCBjaGVjayBmb3IgbWVzc2FnZXMgdGhhdCBkb24ndCBuZWVkIGEgcGF5bG9hZFxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdvJzpcbiAgICAgIHRoaXMuX29wZW4oKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlICdoJzpcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2hlYXJ0YmVhdCcpKTtcbiAgICAgIGRlYnVnKCdoZWFydGJlYXQnLCB0aGlzLnRyYW5zcG9ydCk7XG4gICAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY29udGVudCkge1xuICAgIHRyeSB7XG4gICAgICBwYXlsb2FkID0gSlNPTjMucGFyc2UoY29udGVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGVidWcoJ2JhZCBqc29uJywgY29udGVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAndW5kZWZpbmVkJykge1xuICAgIGRlYnVnKCdlbXB0eSBwYXlsb2FkJywgY29udGVudCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYSc6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSkge1xuICAgICAgICBwYXlsb2FkLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICAgIGRlYnVnKCdtZXNzYWdlJywgc2VsZi50cmFuc3BvcnQsIHApO1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChuZXcgVHJhbnNwb3J0TWVzc2FnZUV2ZW50KHApKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdtJzpcbiAgICAgIGRlYnVnKCdtZXNzYWdlJywgdGhpcy50cmFuc3BvcnQsIHBheWxvYWQpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBUcmFuc3BvcnRNZXNzYWdlRXZlbnQocGF5bG9hZCkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYyc6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSAmJiBwYXlsb2FkLmxlbmd0aCA9PT0gMikge1xuICAgICAgICB0aGlzLl9jbG9zZShwYXlsb2FkWzBdLCBwYXlsb2FkWzFdLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl90cmFuc3BvcnRDbG9zZSA9IGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICBkZWJ1ZygnX3RyYW5zcG9ydENsb3NlJywgdGhpcy50cmFuc3BvcnQsIGNvZGUsIHJlYXNvbik7XG4gIGlmICh0aGlzLl90cmFuc3BvcnQpIHtcbiAgICB0aGlzLl90cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7XG4gIH1cblxuICBpZiAoIXVzZXJTZXRDb2RlKGNvZGUpICYmIGNvZGUgIT09IDIwMDAgJiYgdGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xuICAgIHRoaXMuX2Nvbm5lY3QoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9jbG9zZShjb2RlLCByZWFzb24pO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5fb3BlbiA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX29wZW4nLCB0aGlzLl90cmFuc3BvcnQudHJhbnNwb3J0TmFtZSwgdGhpcy5yZWFkeVN0YXRlKTtcbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNPTk5FQ1RJTkcpIHtcbiAgICBpZiAodGhpcy5fdHJhbnNwb3J0VGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdHJhbnNwb3J0VGltZW91dElkKTtcbiAgICAgIHRoaXMuX3RyYW5zcG9ydFRpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNvY2tKUy5PUEVOO1xuICAgIHRoaXMudHJhbnNwb3J0ID0gdGhpcy5fdHJhbnNwb3J0LnRyYW5zcG9ydE5hbWU7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnb3BlbicpKTtcbiAgICBkZWJ1ZygnY29ubmVjdGVkJywgdGhpcy50cmFuc3BvcnQpO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoZSBzZXJ2ZXIgbWlnaHQgaGF2ZSBiZWVuIHJlc3RhcnRlZCwgYW5kIGxvc3QgdHJhY2sgb2Ygb3VyXG4gICAgLy8gY29ubmVjdGlvbi5cbiAgICB0aGlzLl9jbG9zZSgxMDA2LCAnU2VydmVyIGxvc3Qgc2Vzc2lvbicpO1xuICB9XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uKGNvZGUsIHJlYXNvbiwgd2FzQ2xlYW4pIHtcbiAgZGVidWcoJ19jbG9zZScsIHRoaXMudHJhbnNwb3J0LCBjb2RlLCByZWFzb24sIHdhc0NsZWFuLCB0aGlzLnJlYWR5U3RhdGUpO1xuICB2YXIgZm9yY2VGYWlsID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMuX2lyKSB7XG4gICAgZm9yY2VGYWlsID0gdHJ1ZTtcbiAgICB0aGlzLl9pci5jbG9zZSgpO1xuICAgIHRoaXMuX2lyID0gbnVsbDtcbiAgfVxuICBpZiAodGhpcy5fdHJhbnNwb3J0KSB7XG4gICAgdGhpcy5fdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7XG4gIH1cblxuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ0xPU0VEKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkU3RhdGVFcnJvcjogU29ja0pTIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkJyk7XG4gIH1cblxuICB0aGlzLnJlYWR5U3RhdGUgPSBTb2NrSlMuQ0xPU0lORztcbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBTb2NrSlMuQ0xPU0VEO1xuXG4gICAgaWYgKGZvcmNlRmFpbCkge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnZXJyb3InKSk7XG4gICAgfVxuXG4gICAgdmFyIGUgPSBuZXcgQ2xvc2VFdmVudCgnY2xvc2UnKTtcbiAgICBlLndhc0NsZWFuID0gd2FzQ2xlYW4gfHwgZmFsc2U7XG4gICAgZS5jb2RlID0gY29kZSB8fCAxMDAwO1xuICAgIGUucmVhc29uID0gcmVhc29uO1xuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUpO1xuICAgIHRoaXMub25tZXNzYWdlID0gdGhpcy5vbmNsb3NlID0gdGhpcy5vbmVycm9yID0gbnVsbDtcbiAgICBkZWJ1ZygnZGlzY29ubmVjdGVkJyk7XG4gIH0uYmluZCh0aGlzKSwgMCk7XG59O1xuXG4vLyBTZWU6IGh0dHA6Ly93d3cuZXJnLmFiZG4uYWMudWsvfmdlcnJpdC9kY2NwL25vdGVzL2NjaWQyL3J0b19lc3RpbWF0b3IvXG4vLyBhbmQgUkZDIDI5ODguXG5Tb2NrSlMucHJvdG90eXBlLmNvdW50UlRPID0gZnVuY3Rpb24ocnR0KSB7XG4gIC8vIEluIGEgbG9jYWwgZW52aXJvbm1lbnQsIHdoZW4gdXNpbmcgSUU4LzkgYW5kIHRoZSBganNvbnAtcG9sbGluZ2BcbiAgLy8gdHJhbnNwb3J0IHRoZSB0aW1lIG5lZWRlZCB0byBlc3RhYmxpc2ggYSBjb25uZWN0aW9uICh0aGUgdGltZSB0aGF0IHBhc3NcbiAgLy8gZnJvbSB0aGUgb3BlbmluZyBvZiB0aGUgdHJhbnNwb3J0IHRvIHRoZSBjYWxsIG9mIGBfZGlzcGF0Y2hPcGVuYCkgaXNcbiAgLy8gYXJvdW5kIDIwMG1zZWMgKHRoZSBsb3dlciBib3VuZCB1c2VkIGluIHRoZSBhcnRpY2xlIGFib3ZlKSBhbmQgdGhpc1xuICAvLyBjYXVzZXMgc3B1cmlvdXMgdGltZW91dHMuIEZvciB0aGlzIHJlYXNvbiB3ZSBjYWxjdWxhdGUgYSB2YWx1ZSBzbGlnaHRseVxuICAvLyBsYXJnZXIgdGhhbiB0aGF0IHVzZWQgaW4gdGhlIGFydGljbGUuXG4gIGlmIChydHQgPiAxMDApIHtcbiAgICByZXR1cm4gNCAqIHJ0dDsgLy8gcnRvID4gNDAwbXNlY1xuICB9XG4gIHJldHVybiAzMDAgKyBydHQ7IC8vIDMwMG1zZWMgPCBydG8gPD0gNDAwbXNlY1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhdmFpbGFibGVUcmFuc3BvcnRzKSB7XG4gIHRyYW5zcG9ydHMgPSB0cmFuc3BvcnQoYXZhaWxhYmxlVHJhbnNwb3J0cyk7XG4gIHJlcXVpcmUoJy4vaWZyYW1lLWJvb3RzdHJhcCcpKFNvY2tKUywgYXZhaWxhYmxlVHJhbnNwb3J0cyk7XG4gIHJldHVybiBTb2NrSlM7XG59O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL2V2ZW50L2Nsb3NlXCI6MixcIi4vZXZlbnQvZXZlbnRcIjo0LFwiLi9ldmVudC9ldmVudHRhcmdldFwiOjUsXCIuL2V2ZW50L3RyYW5zLW1lc3NhZ2VcIjo2LFwiLi9pZnJhbWUtYm9vdHN0cmFwXCI6OCxcIi4vaW5mby1yZWNlaXZlclwiOjEyLFwiLi9sb2NhdGlvblwiOjEzLFwiLi9zaGltc1wiOjE1LFwiLi91dGlscy9icm93c2VyXCI6NDQsXCIuL3V0aWxzL2VzY2FwZVwiOjQ1LFwiLi91dGlscy9ldmVudFwiOjQ2LFwiLi91dGlscy9sb2dcIjo0OCxcIi4vdXRpbHMvb2JqZWN0XCI6NDksXCIuL3V0aWxzL3JhbmRvbVwiOjUwLFwiLi91dGlscy90cmFuc3BvcnRcIjo1MSxcIi4vdXRpbHMvdXJsXCI6NTIsXCIuL3ZlcnNpb25cIjo1MyxcImRlYnVnXCI6NTUsXCJpbmhlcml0c1wiOjU3LFwianNvbjNcIjo1OCxcInVybC1wYXJzZVwiOjYxfV0sMTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qIGpzY3M6IGRpc2FibGUgKi9cbid1c2Ugc3RyaWN0JztcblxuLy8gcHVsbGVkIHNwZWNpZmljIHNoaW1zIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltXG5cbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xudmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIFN0cmluZ1Byb3RvdHlwZSA9IFN0cmluZy5wcm90b3R5cGU7XG52YXIgYXJyYXlfc2xpY2UgPSBBcnJheVByb3RvdHlwZS5zbGljZTtcblxudmFyIF90b1N0cmluZyA9IE9iamVjdFByb3RvdHlwZS50b1N0cmluZztcbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiBPYmplY3RQcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcbnZhciBpc0FycmF5ID0gZnVuY3Rpb24gaXNBcnJheShvYmopIHtcbiAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG52YXIgaXNTdHJpbmcgPSBmdW5jdGlvbiBpc1N0cmluZyhvYmopIHtcbiAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG59O1xuXG52YXIgc3VwcG9ydHNEZXNjcmlwdG9ycyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiAoZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3gnLCB7fSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHsgLyogdGhpcyBpcyBFUzMgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn0oKSk7XG5cbi8vIERlZmluZSBjb25maWd1cmFibGUsIHdyaXRhYmxlIGFuZCBub24tZW51bWVyYWJsZSBwcm9wc1xuLy8gaWYgdGhleSBkb24ndCBleGlzdC5cbnZhciBkZWZpbmVQcm9wZXJ0eTtcbmlmIChzdXBwb3J0c0Rlc2NyaXB0b3JzKSB7XG4gICAgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBtZXRob2QsIGZvcmNlQXNzaWduKSB7XG4gICAgICAgIGlmICghZm9yY2VBc3NpZ24gJiYgKG5hbWUgaW4gb2JqZWN0KSkgeyByZXR1cm47IH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBtZXRob2RcbiAgICAgICAgfSk7XG4gICAgfTtcbn0gZWxzZSB7XG4gICAgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBtZXRob2QsIGZvcmNlQXNzaWduKSB7XG4gICAgICAgIGlmICghZm9yY2VBc3NpZ24gJiYgKG5hbWUgaW4gb2JqZWN0KSkgeyByZXR1cm47IH1cbiAgICAgICAgb2JqZWN0W25hbWVdID0gbWV0aG9kO1xuICAgIH07XG59XG52YXIgZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmplY3QsIG1hcCwgZm9yY2VBc3NpZ24pIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIG1hcCkge1xuICAgICAgICBpZiAoT2JqZWN0UHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwLCBuYW1lKSkge1xuICAgICAgICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwgbWFwW25hbWVdLCBmb3JjZUFzc2lnbik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgdG9PYmplY3QgPSBmdW5jdGlvbiAobykge1xuICAgIGlmIChvID09IG51bGwpIHsgLy8gdGhpcyBtYXRjaGVzIGJvdGggbnVsbCBhbmQgdW5kZWZpbmVkXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW4ndCBjb252ZXJ0IFwiICsgbyArICcgdG8gb2JqZWN0Jyk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qobyk7XG59O1xuXG4vL1xuLy8gVXRpbFxuLy8gPT09PT09XG4vL1xuXG4vLyBFUzUgOS40XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3g5LjRcbi8vIGh0dHA6Ly9qc3BlcmYuY29tL3RvLWludGVnZXJcblxuZnVuY3Rpb24gdG9JbnRlZ2VyKG51bSkge1xuICAgIHZhciBuID0gK251bTtcbiAgICBpZiAobiAhPT0gbikgeyAvLyBpc05hTlxuICAgICAgICBuID0gMDtcbiAgICB9IGVsc2UgaWYgKG4gIT09IDAgJiYgbiAhPT0gKDEgLyAwKSAmJiBuICE9PSAtKDEgLyAwKSkge1xuICAgICAgICBuID0gKG4gPiAwIHx8IC0xKSAqIE1hdGguZmxvb3IoTWF0aC5hYnMobikpO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gVG9VaW50MzIoeCkge1xuICAgIHJldHVybiB4ID4+PiAwO1xufVxuXG4vL1xuLy8gRnVuY3Rpb25cbi8vID09PT09PT09XG4vL1xuXG4vLyBFUy01IDE1LjMuNC41XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4zLjQuNVxuXG5mdW5jdGlvbiBFbXB0eSgpIHt9XG5cbmRlZmluZVByb3BlcnRpZXMoRnVuY3Rpb25Qcm90b3R5cGUsIHtcbiAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKHRoYXQpIHsgLy8gLmxlbmd0aCBpcyAxXG4gICAgICAgIC8vIDEuIExldCBUYXJnZXQgYmUgdGhlIHRoaXMgdmFsdWUuXG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzO1xuICAgICAgICAvLyAyLiBJZiBJc0NhbGxhYmxlKFRhcmdldCkgaXMgZmFsc2UsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgJyArIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMy4gTGV0IEEgYmUgYSBuZXcgKHBvc3NpYmx5IGVtcHR5KSBpbnRlcm5hbCBsaXN0IG9mIGFsbCBvZiB0aGVcbiAgICAgICAgLy8gICBhcmd1bWVudCB2YWx1ZXMgcHJvdmlkZWQgYWZ0ZXIgdGhpc0FyZyAoYXJnMSwgYXJnMiBldGMpLCBpbiBvcmRlci5cbiAgICAgICAgLy8gWFhYIHNsaWNlZEFyZ3Mgd2lsbCBzdGFuZCBpbiBmb3IgXCJBXCIgaWYgdXNlZFxuICAgICAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsgLy8gZm9yIG5vcm1hbCBjYWxsXG4gICAgICAgIC8vIDQuIExldCBGIGJlIGEgbmV3IG5hdGl2ZSBFQ01BU2NyaXB0IG9iamVjdC5cbiAgICAgICAgLy8gMTEuIFNldCB0aGUgW1tQcm90b3R5cGVdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIHRvIHRoZSBzdGFuZGFyZFxuICAgICAgICAvLyAgIGJ1aWx0LWluIEZ1bmN0aW9uIHByb3RvdHlwZSBvYmplY3QgYXMgc3BlY2lmaWVkIGluIDE1LjMuMy4xLlxuICAgICAgICAvLyAxMi4gU2V0IHRoZSBbW0NhbGxdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIGFzIGRlc2NyaWJlZCBpblxuICAgICAgICAvLyAgIDE1LjMuNC41LjEuXG4gICAgICAgIC8vIDEzLiBTZXQgdGhlIFtbQ29uc3RydWN0XV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiBhcyBkZXNjcmliZWQgaW5cbiAgICAgICAgLy8gICAxNS4zLjQuNS4yLlxuICAgICAgICAvLyAxNC4gU2V0IHRoZSBbW0hhc0luc3RhbmNlXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiBhcyBkZXNjcmliZWQgaW5cbiAgICAgICAgLy8gICAxNS4zLjQuNS4zLlxuICAgICAgICB2YXIgYmluZGVyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gMTUuMy40LjUuMiBbW0NvbnN0cnVjdF1dXG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBtZXRob2Qgb2YgYSBmdW5jdGlvbiBvYmplY3QsXG4gICAgICAgICAgICAgICAgLy8gRiB0aGF0IHdhcyBjcmVhdGVkIHVzaW5nIHRoZSBiaW5kIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGFcbiAgICAgICAgICAgICAgICAvLyBsaXN0IG9mIGFyZ3VtZW50cyBFeHRyYUFyZ3MsIHRoZSBmb2xsb3dpbmcgc3RlcHMgYXJlIHRha2VuOlxuICAgICAgICAgICAgICAgIC8vIDEuIExldCB0YXJnZXQgYmUgdGhlIHZhbHVlIG9mIEYncyBbW1RhcmdldEZ1bmN0aW9uXV1cbiAgICAgICAgICAgICAgICAvLyAgIGludGVybmFsIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDIuIElmIHRhcmdldCBoYXMgbm8gW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBtZXRob2QsIGFcbiAgICAgICAgICAgICAgICAvLyAgIFR5cGVFcnJvciBleGNlcHRpb24gaXMgdGhyb3duLlxuICAgICAgICAgICAgICAgIC8vIDMuIExldCBib3VuZEFyZ3MgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kQXJnc11dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyA0LiBMZXQgYXJncyBiZSBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhlIHNhbWUgdmFsdWVzIGFzIHRoZVxuICAgICAgICAgICAgICAgIC8vICAgbGlzdCBib3VuZEFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIgZm9sbG93ZWQgYnkgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAvLyAgIHZhbHVlcyBhcyB0aGUgbGlzdCBFeHRyYUFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAgICAgICAgICAgICAgLy8gNS4gUmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgbWV0aG9kIG9mIHRhcmdldCBwcm92aWRpbmcgYXJncyBhcyB0aGUgYXJndW1lbnRzLlxuXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgYXJncy5jb25jYXQoYXJyYXlfc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gMTUuMy40LjUuMSBbW0NhbGxdXVxuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIFtbQ2FsbF1dIGludGVybmFsIG1ldGhvZCBvZiBhIGZ1bmN0aW9uIG9iamVjdCwgRixcbiAgICAgICAgICAgICAgICAvLyB3aGljaCB3YXMgY3JlYXRlZCB1c2luZyB0aGUgYmluZCBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhXG4gICAgICAgICAgICAgICAgLy8gdGhpcyB2YWx1ZSBhbmQgYSBsaXN0IG9mIGFyZ3VtZW50cyBFeHRyYUFyZ3MsIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICAgICAgICAvLyBzdGVwcyBhcmUgdGFrZW46XG4gICAgICAgICAgICAgICAgLy8gMS4gTGV0IGJvdW5kQXJncyBiZSB0aGUgdmFsdWUgb2YgRidzIFtbQm91bmRBcmdzXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDIuIExldCBib3VuZFRoaXMgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kVGhpc11dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyAzLiBMZXQgdGFyZ2V0IGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tUYXJnZXRGdW5jdGlvbl1dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyA0LiBMZXQgYXJncyBiZSBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhlIHNhbWUgdmFsdWVzIGFzIHRoZVxuICAgICAgICAgICAgICAgIC8vICAgbGlzdCBib3VuZEFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIgZm9sbG93ZWQgYnkgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAvLyAgIHZhbHVlcyBhcyB0aGUgbGlzdCBFeHRyYUFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAgICAgICAgICAgICAgLy8gNS4gUmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tDYWxsXV0gaW50ZXJuYWwgbWV0aG9kXG4gICAgICAgICAgICAgICAgLy8gICBvZiB0YXJnZXQgcHJvdmlkaW5nIGJvdW5kVGhpcyBhcyB0aGUgdGhpcyB2YWx1ZSBhbmRcbiAgICAgICAgICAgICAgICAvLyAgIHByb3ZpZGluZyBhcmdzIGFzIHRoZSBhcmd1bWVudHMuXG5cbiAgICAgICAgICAgICAgICAvLyBlcXVpdjogdGFyZ2V0LmNhbGwodGhpcywgLi4uYm91bmRBcmdzLCAuLi5hcmdzKVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgIHRoYXQsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KGFycmF5X3NsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfTtcblxuICAgICAgICAvLyAxNS4gSWYgdGhlIFtbQ2xhc3NdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBUYXJnZXQgaXMgXCJGdW5jdGlvblwiLCB0aGVuXG4gICAgICAgIC8vICAgICBhLiBMZXQgTCBiZSB0aGUgbGVuZ3RoIHByb3BlcnR5IG9mIFRhcmdldCBtaW51cyB0aGUgbGVuZ3RoIG9mIEEuXG4gICAgICAgIC8vICAgICBiLiBTZXQgdGhlIGxlbmd0aCBvd24gcHJvcGVydHkgb2YgRiB0byBlaXRoZXIgMCBvciBMLCB3aGljaGV2ZXIgaXNcbiAgICAgICAgLy8gICAgICAgbGFyZ2VyLlxuICAgICAgICAvLyAxNi4gRWxzZSBzZXQgdGhlIGxlbmd0aCBvd24gcHJvcGVydHkgb2YgRiB0byAwLlxuXG4gICAgICAgIHZhciBib3VuZExlbmd0aCA9IE1hdGgubWF4KDAsIHRhcmdldC5sZW5ndGggLSBhcmdzLmxlbmd0aCk7XG5cbiAgICAgICAgLy8gMTcuIFNldCB0aGUgYXR0cmlidXRlcyBvZiB0aGUgbGVuZ3RoIG93biBwcm9wZXJ0eSBvZiBGIHRvIHRoZSB2YWx1ZXNcbiAgICAgICAgLy8gICBzcGVjaWZpZWQgaW4gMTUuMy41LjEuXG4gICAgICAgIHZhciBib3VuZEFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZExlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBib3VuZEFyZ3MucHVzaCgnJCcgKyBpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFhYWCBCdWlsZCBhIGR5bmFtaWMgZnVuY3Rpb24gd2l0aCBkZXNpcmVkIGFtb3VudCBvZiBhcmd1bWVudHMgaXMgdGhlIG9ubHlcbiAgICAgICAgLy8gd2F5IHRvIHNldCB0aGUgbGVuZ3RoIHByb3BlcnR5IG9mIGEgZnVuY3Rpb24uXG4gICAgICAgIC8vIEluIGVudmlyb25tZW50cyB3aGVyZSBDb250ZW50IFNlY3VyaXR5IFBvbGljaWVzIGVuYWJsZWQgKENocm9tZSBleHRlbnNpb25zLFxuICAgICAgICAvLyBmb3IgZXguKSBhbGwgdXNlIG9mIGV2YWwgb3IgRnVuY3Rpb24gY29zdHJ1Y3RvciB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICAgICAgICAvLyBIb3dldmVyIGluIGFsbCBvZiB0aGVzZSBlbnZpcm9ubWVudHMgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgZXhpc3RzXG4gICAgICAgIC8vIGFuZCBzbyB0aGlzIGNvZGUgd2lsbCBuZXZlciBiZSBleGVjdXRlZC5cbiAgICAgICAgdmFyIGJvdW5kID0gRnVuY3Rpb24oJ2JpbmRlcicsICdyZXR1cm4gZnVuY3Rpb24gKCcgKyBib3VuZEFyZ3Muam9pbignLCcpICsgJyl7IHJldHVybiBiaW5kZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfScpKGJpbmRlcik7XG5cbiAgICAgICAgaWYgKHRhcmdldC5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgICAgICBib3VuZC5wcm90b3R5cGUgPSBuZXcgRW1wdHkoKTtcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIGRhbmdsaW5nIHJlZmVyZW5jZXMuXG4gICAgICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyAxOC4gU2V0IHRoZSBbW0V4dGVuc2libGVdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIHRvIHRydWUuXG5cbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyAxOS4gTGV0IHRocm93ZXIgYmUgdGhlIFtbVGhyb3dUeXBlRXJyb3JdXSBmdW5jdGlvbiBPYmplY3QgKDEzLjIuMykuXG4gICAgICAgIC8vIDIwLiBDYWxsIHRoZSBbW0RlZmluZU93blByb3BlcnR5XV0gaW50ZXJuYWwgbWV0aG9kIG9mIEYgd2l0aFxuICAgICAgICAvLyAgIGFyZ3VtZW50cyBcImNhbGxlclwiLCBQcm9wZXJ0eURlc2NyaXB0b3Ige1tbR2V0XV06IHRocm93ZXIsIFtbU2V0XV06XG4gICAgICAgIC8vICAgdGhyb3dlciwgW1tFbnVtZXJhYmxlXV06IGZhbHNlLCBbW0NvbmZpZ3VyYWJsZV1dOiBmYWxzZX0sIGFuZFxuICAgICAgICAvLyAgIGZhbHNlLlxuICAgICAgICAvLyAyMS4gQ2FsbCB0aGUgW1tEZWZpbmVPd25Qcm9wZXJ0eV1dIGludGVybmFsIG1ldGhvZCBvZiBGIHdpdGhcbiAgICAgICAgLy8gICBhcmd1bWVudHMgXCJhcmd1bWVudHNcIiwgUHJvcGVydHlEZXNjcmlwdG9yIHtbW0dldF1dOiB0aHJvd2VyLFxuICAgICAgICAvLyAgIFtbU2V0XV06IHRocm93ZXIsIFtbRW51bWVyYWJsZV1dOiBmYWxzZSwgW1tDb25maWd1cmFibGVdXTogZmFsc2V9LFxuICAgICAgICAvLyAgIGFuZCBmYWxzZS5cblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIE5PVEUgRnVuY3Rpb24gb2JqZWN0cyBjcmVhdGVkIHVzaW5nIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGRvIG5vdFxuICAgICAgICAvLyBoYXZlIGEgcHJvdG90eXBlIHByb3BlcnR5IG9yIHRoZSBbW0NvZGVdXSwgW1tGb3JtYWxQYXJhbWV0ZXJzXV0sIGFuZFxuICAgICAgICAvLyBbW1Njb3BlXV0gaW50ZXJuYWwgcHJvcGVydGllcy5cbiAgICAgICAgLy8gWFhYIGNhbid0IGRlbGV0ZSBwcm90b3R5cGUgaW4gcHVyZS1qcy5cblxuICAgICAgICAvLyAyMi4gUmV0dXJuIEYuXG4gICAgICAgIHJldHVybiBib3VuZDtcbiAgICB9XG59KTtcblxuLy9cbi8vIEFycmF5XG4vLyA9PT09PVxuLy9cblxuLy8gRVM1IDE1LjQuMy4yXG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjMuMlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaXNBcnJheVxuZGVmaW5lUHJvcGVydGllcyhBcnJheSwgeyBpc0FycmF5OiBpc0FycmF5IH0pO1xuXG5cbnZhciBib3hlZFN0cmluZyA9IE9iamVjdCgnYScpO1xudmFyIHNwbGl0U3RyaW5nID0gYm94ZWRTdHJpbmdbMF0gIT09ICdhJyB8fCAhKDAgaW4gYm94ZWRTdHJpbmcpO1xuXG52YXIgcHJvcGVybHlCb3hlc0NvbnRleHQgPSBmdW5jdGlvbiBwcm9wZXJseUJveGVkKG1ldGhvZCkge1xuICAgIC8vIENoZWNrIG5vZGUgMC42LjIxIGJ1ZyB3aGVyZSB0aGlyZCBwYXJhbWV0ZXIgaXMgbm90IGJveGVkXG4gICAgdmFyIHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgPSB0cnVlO1xuICAgIHZhciBwcm9wZXJseUJveGVzU3RyaWN0ID0gdHJ1ZTtcbiAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgIG1ldGhvZC5jYWxsKCdmb28nLCBmdW5jdGlvbiAoXywgX18sIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGV4dCAhPT0gJ29iamVjdCcpIHsgcHJvcGVybHlCb3hlc05vblN0cmljdCA9IGZhbHNlOyB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1ldGhvZC5jYWxsKFsxXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuICAgICAgICAgICAgcHJvcGVybHlCb3hlc1N0cmljdCA9IHR5cGVvZiB0aGlzID09PSAnc3RyaW5nJztcbiAgICAgICAgfSwgJ3gnKTtcbiAgICB9XG4gICAgcmV0dXJuICEhbWV0aG9kICYmIHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgJiYgcHJvcGVybHlCb3hlc1N0cmljdDtcbn07XG5cbmRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGZ1biAvKiwgdGhpc3AqLykge1xuICAgICAgICB2YXIgb2JqZWN0ID0gdG9PYmplY3QodGhpcyksXG4gICAgICAgICAgICBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyB0aGlzLnNwbGl0KCcnKSA6IG9iamVjdCxcbiAgICAgICAgICAgIHRoaXNwID0gYXJndW1lbnRzWzFdLFxuICAgICAgICAgICAgaSA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggPj4+IDA7XG5cbiAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgZnVuY3Rpb24gb3IgaWYgY2FsbGJhY2sgaXMgbm90IGEgY2FsbGFibGUgZnVuY3Rpb25cbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTsgLy8gVE9ETyBtZXNzYWdlXG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoKytpIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBzZWxmKSB7XG4gICAgICAgICAgICAgICAgLy8gSW52b2tlIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIGNhbGwsIHBhc3NpbmcgYXJndW1lbnRzOlxuICAgICAgICAgICAgICAgIC8vIGNvbnRleHQsIHByb3BlcnR5IHZhbHVlLCBwcm9wZXJ0eSBrZXksIHRoaXNBcmcgb2JqZWN0XG4gICAgICAgICAgICAgICAgLy8gY29udGV4dFxuICAgICAgICAgICAgICAgIGZ1bi5jYWxsKHRoaXNwLCBzZWxmW2ldLCBpLCBvYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSwgIXByb3Blcmx5Qm94ZXNDb250ZXh0KEFycmF5UHJvdG90eXBlLmZvckVhY2gpKTtcblxuLy8gRVM1IDE1LjQuNC4xNFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjE0XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pbmRleE9mXG52YXIgaGFzRmlyZWZveDJJbmRleE9mQnVnID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YgJiYgWzAsIDFdLmluZGV4T2YoMSwgMikgIT09IC0xO1xuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc291Z2h0IC8qLCBmcm9tSW5kZXggKi8gKSB7XG4gICAgICAgIHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyB0aGlzLnNwbGl0KCcnKSA6IHRvT2JqZWN0KHRoaXMpLFxuICAgICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggPj4+IDA7XG5cbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBpID0gdG9JbnRlZ2VyKGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYW5kbGUgbmVnYXRpdmUgaW5kaWNlc1xuICAgICAgICBpID0gaSA+PSAwID8gaSA6IE1hdGgubWF4KDAsIGxlbmd0aCArIGkpO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBzZWxmICYmIHNlbGZbaV0gPT09IHNvdWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG59LCBoYXNGaXJlZm94MkluZGV4T2ZCdWcpO1xuXG4vL1xuLy8gU3RyaW5nXG4vLyA9PT09PT1cbi8vXG5cbi8vIEVTNSAxNS41LjQuMTRcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjUuNC4xNFxuXG4vLyBbYnVnZml4LCBJRSBsdCA5LCBmaXJlZm94IDQsIEtvbnF1ZXJvciwgT3BlcmEsIG9ic2N1cmUgYnJvd3NlcnNdXG4vLyBNYW55IGJyb3dzZXJzIGRvIG5vdCBzcGxpdCBwcm9wZXJseSB3aXRoIHJlZ3VsYXIgZXhwcmVzc2lvbnMgb3IgdGhleVxuLy8gZG8gbm90IHBlcmZvcm0gdGhlIHNwbGl0IGNvcnJlY3RseSB1bmRlciBvYnNjdXJlIGNvbmRpdGlvbnMuXG4vLyBTZWUgaHR0cDovL2Jsb2cuc3RldmVubGV2aXRoYW4uY29tL2FyY2hpdmVzL2Nyb3NzLWJyb3dzZXItc3BsaXRcbi8vIEkndmUgdGVzdGVkIGluIG1hbnkgYnJvd3NlcnMgYW5kIHRoaXMgc2VlbXMgdG8gY292ZXIgdGhlIGRldmlhbnQgb25lczpcbi8vICAgICdhYicuc3BsaXQoLyg/OmFiKSovKSBzaG91bGQgYmUgW1wiXCIsIFwiXCJdLCBub3QgW1wiXCJdXG4vLyAgICAnLicuc3BsaXQoLyguPykoLj8pLykgc2hvdWxkIGJlIFtcIlwiLCBcIi5cIiwgXCJcIiwgXCJcIl0sIG5vdCBbXCJcIiwgXCJcIl1cbi8vICAgICd0ZXNzdCcuc3BsaXQoLyhzKSovKSBzaG91bGQgYmUgW1widFwiLCB1bmRlZmluZWQsIFwiZVwiLCBcInNcIiwgXCJ0XCJdLCBub3Rcbi8vICAgICAgIFt1bmRlZmluZWQsIFwidFwiLCB1bmRlZmluZWQsIFwiZVwiLCAuLi5dXG4vLyAgICAnJy5zcGxpdCgvLj8vKSBzaG91bGQgYmUgW10sIG5vdCBbXCJcIl1cbi8vICAgICcuJy5zcGxpdCgvKCkoKS8pIHNob3VsZCBiZSBbXCIuXCJdLCBub3QgW1wiXCIsIFwiXCIsIFwiLlwiXVxuXG52YXIgc3RyaW5nX3NwbGl0ID0gU3RyaW5nUHJvdG90eXBlLnNwbGl0O1xuaWYgKFxuICAgICdhYicuc3BsaXQoLyg/OmFiKSovKS5sZW5ndGggIT09IDIgfHxcbiAgICAnLicuc3BsaXQoLyguPykoLj8pLykubGVuZ3RoICE9PSA0IHx8XG4gICAgJ3Rlc3N0Jy5zcGxpdCgvKHMpKi8pWzFdID09PSAndCcgfHxcbiAgICAndGVzdCcuc3BsaXQoLyg/OikvLCAtMSkubGVuZ3RoICE9PSA0IHx8XG4gICAgJycuc3BsaXQoLy4/LykubGVuZ3RoIHx8XG4gICAgJy4nLnNwbGl0KC8oKSgpLykubGVuZ3RoID4gMVxuKSB7XG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbXBsaWFudEV4ZWNOcGNnID0gLygpPz8vLmV4ZWMoJycpWzFdID09PSB2b2lkIDA7IC8vIE5QQ0c6IG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwXG5cbiAgICAgICAgU3RyaW5nUHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgICAgICAgIHZhciBzdHJpbmcgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHNlcGFyYXRvciA9PT0gdm9pZCAwICYmIGxpbWl0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBgc2VwYXJhdG9yYCBpcyBub3QgYSByZWdleCwgdXNlIG5hdGl2ZSBzcGxpdFxuICAgICAgICAgICAgaWYgKF90b1N0cmluZy5jYWxsKHNlcGFyYXRvcikgIT09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ19zcGxpdC5jYWxsKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gW10sXG4gICAgICAgICAgICAgICAgZmxhZ3MgPSAoc2VwYXJhdG9yLmlnbm9yZUNhc2UgPyAnaScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5tdWx0aWxpbmUgID8gJ20nIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IuZXh0ZW5kZWQgICA/ICd4JyA6ICcnKSArIC8vIFByb3Bvc2VkIGZvciBFUzZcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3Iuc3RpY2t5ICAgICA/ICd5JyA6ICcnKSwgLy8gRmlyZWZveCAzK1xuICAgICAgICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSAwLFxuICAgICAgICAgICAgICAgIC8vIE1ha2UgYGdsb2JhbGAgYW5kIGF2b2lkIGBsYXN0SW5kZXhgIGlzc3VlcyBieSB3b3JraW5nIHdpdGggYSBjb3B5XG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yMiwgbWF0Y2gsIGxhc3RJbmRleCwgbGFzdExlbmd0aDtcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IG5ldyBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgZmxhZ3MgKyAnZycpO1xuICAgICAgICAgICAgc3RyaW5nICs9ICcnOyAvLyBUeXBlLWNvbnZlcnRcbiAgICAgICAgICAgIGlmICghY29tcGxpYW50RXhlY05wY2cpIHtcbiAgICAgICAgICAgICAgICAvLyBEb2Vzbid0IG5lZWQgZmxhZ3MgZ3ksIGJ1dCB0aGV5IGRvbid0IGh1cnRcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3IyID0gbmV3IFJlZ0V4cCgnXicgKyBzZXBhcmF0b3Iuc291cmNlICsgJyQoPyFcXFxccyknLCBmbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBWYWx1ZXMgZm9yIGBsaW1pdGAsIHBlciB0aGUgc3BlYzpcbiAgICAgICAgICAgICAqIElmIHVuZGVmaW5lZDogNDI5NDk2NzI5NSAvLyBNYXRoLnBvdygyLCAzMikgLSAxXG4gICAgICAgICAgICAgKiBJZiAwLCBJbmZpbml0eSwgb3IgTmFOOiAwXG4gICAgICAgICAgICAgKiBJZiBwb3NpdGl2ZSBudW1iZXI6IGxpbWl0ID0gTWF0aC5mbG9vcihsaW1pdCk7IGlmIChsaW1pdCA+IDQyOTQ5NjcyOTUpIGxpbWl0IC09IDQyOTQ5NjcyOTY7XG4gICAgICAgICAgICAgKiBJZiBuZWdhdGl2ZSBudW1iZXI6IDQyOTQ5NjcyOTYgLSBNYXRoLmZsb29yKE1hdGguYWJzKGxpbWl0KSlcbiAgICAgICAgICAgICAqIElmIG90aGVyOiBUeXBlLWNvbnZlcnQsIHRoZW4gdXNlIHRoZSBhYm92ZSBydWxlc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsaW1pdCA9IGxpbWl0ID09PSB2b2lkIDAgP1xuICAgICAgICAgICAgICAgIC0xID4+PiAwIDogLy8gTWF0aC5wb3coMiwgMzIpIC0gMVxuICAgICAgICAgICAgICAgIFRvVWludDMyKGxpbWl0KTtcbiAgICAgICAgICAgIHdoaWxlIChtYXRjaCA9IHNlcGFyYXRvci5leGVjKHN0cmluZykpIHtcbiAgICAgICAgICAgICAgICAvLyBgc2VwYXJhdG9yLmxhc3RJbmRleGAgaXMgbm90IHJlbGlhYmxlIGNyb3NzLWJyb3dzZXJcbiAgICAgICAgICAgICAgICBsYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGAgZm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3Vwc1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbXBsaWFudEV4ZWNOcGNnICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzBdLnJlcGxhY2Uoc2VwYXJhdG9yMiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoW2ldID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoLmxlbmd0aCA+IDEgJiYgbWF0Y2guaW5kZXggPCBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBBcnJheVByb3RvdHlwZS5wdXNoLmFwcGx5KG91dHB1dCwgbWF0Y2guc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxhc3RMZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXQubGVuZ3RoID49IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VwYXJhdG9yLmxhc3RJbmRleCA9PT0gbWF0Y2guaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VwYXJhdG9yLmxhc3RJbmRleCsrOyAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhc3RMYXN0SW5kZXggPT09IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdExlbmd0aCB8fCAhc2VwYXJhdG9yLnRlc3QoJycpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0Lmxlbmd0aCA+IGxpbWl0ID8gb3V0cHV0LnNsaWNlKDAsIGxpbWl0KSA6IG91dHB1dDtcbiAgICAgICAgfTtcbiAgICB9KCkpO1xuXG4vLyBbYnVnZml4LCBjaHJvbWVdXG4vLyBJZiBzZXBhcmF0b3IgaXMgdW5kZWZpbmVkLCB0aGVuIHRoZSByZXN1bHQgYXJyYXkgY29udGFpbnMganVzdCBvbmUgU3RyaW5nLFxuLy8gd2hpY2ggaXMgdGhlIHRoaXMgdmFsdWUgKGNvbnZlcnRlZCB0byBhIFN0cmluZykuIElmIGxpbWl0IGlzIG5vdCB1bmRlZmluZWQsXG4vLyB0aGVuIHRoZSBvdXRwdXQgYXJyYXkgaXMgdHJ1bmNhdGVkIHNvIHRoYXQgaXQgY29udGFpbnMgbm8gbW9yZSB0aGFuIGxpbWl0XG4vLyBlbGVtZW50cy5cbi8vIFwiMFwiLnNwbGl0KHVuZGVmaW5lZCwgMCkgLT4gW11cbn0gZWxzZSBpZiAoJzAnLnNwbGl0KHZvaWQgMCwgMCkubGVuZ3RoKSB7XG4gICAgU3RyaW5nUHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgICBpZiAoc2VwYXJhdG9yID09PSB2b2lkIDAgJiYgbGltaXQgPT09IDApIHsgcmV0dXJuIFtdOyB9XG4gICAgICAgIHJldHVybiBzdHJpbmdfc3BsaXQuY2FsbCh0aGlzLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9O1xufVxuXG4vLyBFQ01BLTI2MiwgM3JkIEIuMi4zXG4vLyBOb3QgYW4gRUNNQVNjcmlwdCBzdGFuZGFyZCwgYWx0aG91Z2ggRUNNQVNjcmlwdCAzcmQgRWRpdGlvbiBoYXMgYVxuLy8gbm9uLW5vcm1hdGl2ZSBzZWN0aW9uIHN1Z2dlc3RpbmcgdW5pZm9ybSBzZW1hbnRpY3MgYW5kIGl0IHNob3VsZCBiZVxuLy8gbm9ybWFsaXplZCBhY3Jvc3MgYWxsIGJyb3dzZXJzXG4vLyBbYnVnZml4LCBJRSBsdCA5XSBJRSA8IDkgc3Vic3RyKCkgd2l0aCBuZWdhdGl2ZSB2YWx1ZSBub3Qgd29ya2luZyBpbiBJRVxudmFyIHN0cmluZ19zdWJzdHIgPSBTdHJpbmdQcm90b3R5cGUuc3Vic3RyO1xudmFyIGhhc05lZ2F0aXZlU3Vic3RyQnVnID0gJycuc3Vic3RyICYmICcwYicuc3Vic3RyKC0xKSAhPT0gJ2InO1xuZGVmaW5lUHJvcGVydGllcyhTdHJpbmdQcm90b3R5cGUsIHtcbiAgICBzdWJzdHI6IGZ1bmN0aW9uIHN1YnN0cihzdGFydCwgbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdfc3Vic3RyLmNhbGwoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgc3RhcnQgPCAwID8gKChzdGFydCA9IHRoaXMubGVuZ3RoICsgc3RhcnQpIDwgMCA/IDAgOiBzdGFydCkgOiBzdGFydCxcbiAgICAgICAgICAgIGxlbmd0aFxuICAgICAgICApO1xuICAgIH1cbn0sIGhhc05lZ2F0aXZlU3Vic3RyQnVnKTtcblxufSx7fV0sMTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgLy8gc3RyZWFtaW5nIHRyYW5zcG9ydHNcbiAgcmVxdWlyZSgnLi90cmFuc3BvcnQvd2Vic29ja2V0JylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQveGhyLXN0cmVhbWluZycpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L3hkci1zdHJlYW1pbmcnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9ldmVudHNvdXJjZScpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2xpYi9pZnJhbWUtd3JhcCcpKHJlcXVpcmUoJy4vdHJhbnNwb3J0L2V2ZW50c291cmNlJykpXG5cbiAgLy8gcG9sbGluZyB0cmFuc3BvcnRzXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2h0bWxmaWxlJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvbGliL2lmcmFtZS13cmFwJykocmVxdWlyZSgnLi90cmFuc3BvcnQvaHRtbGZpbGUnKSlcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQveGhyLXBvbGxpbmcnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC94ZHItcG9sbGluZycpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2xpYi9pZnJhbWUtd3JhcCcpKHJlcXVpcmUoJy4vdHJhbnNwb3J0L3hoci1wb2xsaW5nJykpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2pzb25wLXBvbGxpbmcnKVxuXTtcblxufSx7XCIuL3RyYW5zcG9ydC9ldmVudHNvdXJjZVwiOjIwLFwiLi90cmFuc3BvcnQvaHRtbGZpbGVcIjoyMSxcIi4vdHJhbnNwb3J0L2pzb25wLXBvbGxpbmdcIjoyMyxcIi4vdHJhbnNwb3J0L2xpYi9pZnJhbWUtd3JhcFwiOjI2LFwiLi90cmFuc3BvcnQvd2Vic29ja2V0XCI6MzgsXCIuL3RyYW5zcG9ydC94ZHItcG9sbGluZ1wiOjM5LFwiLi90cmFuc3BvcnQveGRyLXN0cmVhbWluZ1wiOjQwLFwiLi90cmFuc3BvcnQveGhyLXBvbGxpbmdcIjo0MSxcIi4vdHJhbnNwb3J0L3hoci1zdHJlYW1pbmdcIjo0Mn1dLDE3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9ldmVudCcpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICAsIFhIUiA9IGdsb2JhbC5YTUxIdHRwUmVxdWVzdFxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6YnJvd3Nlcjp4aHInKTtcbn1cblxuZnVuY3Rpb24gQWJzdHJhY3RYSFJPYmplY3QobWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpIHtcbiAgZGVidWcobWV0aG9kLCB1cmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX3N0YXJ0KG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKTtcbiAgfSwgMCk7XG59XG5cbmluaGVyaXRzKEFic3RyYWN0WEhST2JqZWN0LCBFdmVudEVtaXR0ZXIpO1xuXG5BYnN0cmFjdFhIUk9iamVjdC5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24obWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRyeSB7XG4gICAgdGhpcy54aHIgPSBuZXcgWEhSKCk7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gIH1cblxuICBpZiAoIXRoaXMueGhyKSB7XG4gICAgZGVidWcoJ25vIHhocicpO1xuICAgIHRoaXMuZW1pdCgnZmluaXNoJywgMCwgJ25vIHhociBzdXBwb3J0Jyk7XG4gICAgdGhpcy5fY2xlYW51cCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHNldmVyYWwgYnJvd3NlcnMgY2FjaGUgUE9TVHNcbiAgdXJsID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsLCAndD0nICsgKCtuZXcgRGF0ZSgpKSk7XG5cbiAgLy8gRXhwbG9yZXIgdGVuZHMgdG8ga2VlcCBjb25uZWN0aW9uIG9wZW4sIGV2ZW4gYWZ0ZXIgdGhlXG4gIC8vIHRhYiBnZXRzIGNsb3NlZDogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvNTI4MFxuICB0aGlzLnVubG9hZFJlZiA9IHV0aWxzLnVubG9hZEFkZChmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygndW5sb2FkIGNsZWFudXAnKTtcbiAgICBzZWxmLl9jbGVhbnVwKHRydWUpO1xuICB9KTtcbiAgdHJ5IHtcbiAgICB0aGlzLnhoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcbiAgICBpZiAodGhpcy50aW1lb3V0ICYmICd0aW1lb3V0JyBpbiB0aGlzLnhocikge1xuICAgICAgdGhpcy54aHIudGltZW91dCA9IHRoaXMudGltZW91dDtcbiAgICAgIHRoaXMueGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBkZWJ1ZygneGhyIHRpbWVvdXQnKTtcbiAgICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XG4gICAgICAgIHNlbGYuX2NsZWFudXAoZmFsc2UpO1xuICAgICAgfTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkZWJ1ZygnZXhjZXB0aW9uJywgZSk7XG4gICAgLy8gSUUgcmFpc2VzIGFuIGV4Y2VwdGlvbiBvbiB3cm9uZyBwb3J0LlxuICAgIHRoaXMuZW1pdCgnZmluaXNoJywgMCwgJycpO1xuICAgIHRoaXMuX2NsZWFudXAoZmFsc2UpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICgoIW9wdHMgfHwgIW9wdHMubm9DcmVkZW50aWFscykgJiYgQWJzdHJhY3RYSFJPYmplY3Quc3VwcG9ydHNDT1JTKSB7XG4gICAgZGVidWcoJ3dpdGhDcmVkZW50aWFscycpO1xuICAgIC8vIE1vemlsbGEgZG9jcyBzYXlzIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL1hNTEh0dHBSZXF1ZXN0IDpcbiAgICAvLyBcIlRoaXMgbmV2ZXIgYWZmZWN0cyBzYW1lLXNpdGUgcmVxdWVzdHMuXCJcblxuICAgIHRoaXMueGhyLndpdGhDcmVkZW50aWFscyA9ICd0cnVlJztcbiAgfVxuICBpZiAob3B0cyAmJiBvcHRzLmhlYWRlcnMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb3B0cy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLnhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgb3B0cy5oZWFkZXJzW2tleV0pO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMueGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChzZWxmLnhocikge1xuICAgICAgdmFyIHggPSBzZWxmLnhocjtcbiAgICAgIHZhciB0ZXh0LCBzdGF0dXM7XG4gICAgICBkZWJ1ZygncmVhZHlTdGF0ZScsIHgucmVhZHlTdGF0ZSk7XG4gICAgICBzd2l0Y2ggKHgucmVhZHlTdGF0ZSkge1xuICAgICAgY2FzZSAzOlxuICAgICAgICAvLyBJRSBkb2Vzbid0IGxpa2UgcGVla2luZyBpbnRvIHJlc3BvbnNlVGV4dCBvciBzdGF0dXNcbiAgICAgICAgLy8gb24gTWljcm9zb2Z0LlhNTEhUVFAgYW5kIHJlYWR5c3RhdGU9M1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHN0YXR1cyA9IHguc3RhdHVzO1xuICAgICAgICAgIHRleHQgPSB4LnJlc3BvbnNlVGV4dDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgICAgfVxuICAgICAgICBkZWJ1Zygnc3RhdHVzJywgc3RhdHVzKTtcbiAgICAgICAgLy8gSUUgcmV0dXJucyAxMjIzIGZvciAyMDQ6IGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzE0NTBcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMTIyMykge1xuICAgICAgICAgIHN0YXR1cyA9IDIwNDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElFIGRvZXMgcmV0dXJuIHJlYWR5c3RhdGUgPT0gMyBmb3IgNDA0IGFuc3dlcnMuXG4gICAgICAgIGlmIChzdGF0dXMgPT09IDIwMCAmJiB0ZXh0ICYmIHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGRlYnVnKCdjaHVuaycpO1xuICAgICAgICAgIHNlbGYuZW1pdCgnY2h1bmsnLCBzdGF0dXMsIHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA0OlxuICAgICAgICBzdGF0dXMgPSB4LnN0YXR1cztcbiAgICAgICAgZGVidWcoJ3N0YXR1cycsIHN0YXR1cyk7XG4gICAgICAgIC8vIElFIHJldHVybnMgMTIyMyBmb3IgMjA0OiBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xNDUwXG4gICAgICAgIGlmIChzdGF0dXMgPT09IDEyMjMpIHtcbiAgICAgICAgICBzdGF0dXMgPSAyMDQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSUUgcmV0dXJucyB0aGlzIGZvciBhIGJhZCBwb3J0XG4gICAgICAgIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS93aW5kb3dzL2Rlc2t0b3AvYWEzODM3NzAodj12cy44NSkuYXNweFxuICAgICAgICBpZiAoc3RhdHVzID09PSAxMjAwNSB8fCBzdGF0dXMgPT09IDEyMDI5KSB7XG4gICAgICAgICAgc3RhdHVzID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlYnVnKCdmaW5pc2gnLCBzdGF0dXMsIHgucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnLCBzdGF0dXMsIHgucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB0cnkge1xuICAgIHNlbGYueGhyLnNlbmQocGF5bG9hZCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIDAsICcnKTtcbiAgICBzZWxmLl9jbGVhbnVwKGZhbHNlKTtcbiAgfVxufTtcblxuQWJzdHJhY3RYSFJPYmplY3QucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oYWJvcnQpIHtcbiAgZGVidWcoJ2NsZWFudXAnKTtcbiAgaWYgKCF0aGlzLnhocikge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB1dGlscy51bmxvYWREZWwodGhpcy51bmxvYWRSZWYpO1xuXG4gIC8vIElFIG5lZWRzIHRoaXMgZmllbGQgdG8gYmUgYSBmdW5jdGlvblxuICB0aGlzLnhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHt9O1xuICBpZiAodGhpcy54aHIub250aW1lb3V0KSB7XG4gICAgdGhpcy54aHIub250aW1lb3V0ID0gbnVsbDtcbiAgfVxuXG4gIGlmIChhYm9ydCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnhoci5hYm9ydCgpO1xuICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICB9XG4gIH1cbiAgdGhpcy51bmxvYWRSZWYgPSB0aGlzLnhociA9IG51bGw7XG59O1xuXG5BYnN0cmFjdFhIUk9iamVjdC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMuX2NsZWFudXAodHJ1ZSk7XG59O1xuXG5BYnN0cmFjdFhIUk9iamVjdC5lbmFibGVkID0gISFYSFI7XG4vLyBvdmVycmlkZSBYTUxIdHRwUmVxdWVzdCBmb3IgSUU2Lzdcbi8vIG9iZnVzY2F0ZSB0byBhdm9pZCBmaXJld2FsbHNcbnZhciBheG8gPSBbJ0FjdGl2ZSddLmNvbmNhdCgnT2JqZWN0Jykuam9pbignWCcpO1xuaWYgKCFBYnN0cmFjdFhIUk9iamVjdC5lbmFibGVkICYmIChheG8gaW4gZ2xvYmFsKSkge1xuICBkZWJ1Zygnb3ZlcnJpZGluZyB4bWxodHRwcmVxdWVzdCcpO1xuICBYSFIgPSBmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBnbG9iYWxbYXhvXSgnTWljcm9zb2Z0LlhNTEhUVFAnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG4gIEFic3RyYWN0WEhST2JqZWN0LmVuYWJsZWQgPSAhIW5ldyBYSFIoKTtcbn1cblxudmFyIGNvcnMgPSBmYWxzZTtcbnRyeSB7XG4gIGNvcnMgPSAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWEhSKCk7XG59IGNhdGNoIChpZ25vcmVkKSB7XG4gIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbn1cblxuQWJzdHJhY3RYSFJPYmplY3Quc3VwcG9ydHNDT1JTID0gY29ycztcblxubW9kdWxlLmV4cG9ydHMgPSBBYnN0cmFjdFhIUk9iamVjdDtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi4vLi4vdXRpbHMvZXZlbnRcIjo0NixcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuRXZlbnRTb3VyY2U7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSwxOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBEcml2ZXIgPSBnbG9iYWwuV2ViU29ja2V0IHx8IGdsb2JhbC5Nb3pXZWJTb2NrZXQ7XG5pZiAoRHJpdmVyKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gV2ViU29ja2V0QnJvd3NlckRyaXZlcih1cmwpIHtcblx0XHRyZXR1cm4gbmV3IERyaXZlcih1cmwpO1xuXHR9O1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMgPSB1bmRlZmluZWQ7XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSwyMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgLCBFdmVudFNvdXJjZVJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci9ldmVudHNvdXJjZScpXG4gICwgWEhSQ29yc09iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1jb3JzJylcbiAgLCBFdmVudFNvdXJjZURyaXZlciA9IHJlcXVpcmUoJ2V2ZW50c291cmNlJylcbiAgO1xuXG5mdW5jdGlvbiBFdmVudFNvdXJjZVRyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIUV2ZW50U291cmNlVHJhbnNwb3J0LmVuYWJsZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG5cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcvZXZlbnRzb3VyY2UnLCBFdmVudFNvdXJjZVJlY2VpdmVyLCBYSFJDb3JzT2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoRXZlbnRTb3VyY2VUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cbkV2ZW50U291cmNlVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICEhRXZlbnRTb3VyY2VEcml2ZXI7XG59O1xuXG5FdmVudFNvdXJjZVRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ2V2ZW50c291cmNlJztcbkV2ZW50U291cmNlVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50U291cmNlVHJhbnNwb3J0O1xuXG59LHtcIi4vbGliL2FqYXgtYmFzZWRcIjoyNCxcIi4vcmVjZWl2ZXIvZXZlbnRzb3VyY2VcIjoyOSxcIi4vc2VuZGVyL3hoci1jb3JzXCI6MzUsXCJldmVudHNvdXJjZVwiOjE4LFwiaW5oZXJpdHNcIjo1N31dLDIxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEh0bWxmaWxlUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL2h0bWxmaWxlJylcbiAgLCBYSFJMb2NhbE9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1sb2NhbCcpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gIDtcblxuZnVuY3Rpb24gSHRtbEZpbGVUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFIdG1sZmlsZVJlY2VpdmVyLmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy9odG1sZmlsZScsIEh0bWxmaWxlUmVjZWl2ZXIsIFhIUkxvY2FsT2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoSHRtbEZpbGVUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cbkh0bWxGaWxlVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbihpbmZvKSB7XG4gIHJldHVybiBIdG1sZmlsZVJlY2VpdmVyLmVuYWJsZWQgJiYgaW5mby5zYW1lT3JpZ2luO1xufTtcblxuSHRtbEZpbGVUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdodG1sZmlsZSc7XG5IdG1sRmlsZVRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjtcblxubW9kdWxlLmV4cG9ydHMgPSBIdG1sRmlsZVRyYW5zcG9ydDtcblxufSx7XCIuL2xpYi9hamF4LWJhc2VkXCI6MjQsXCIuL3JlY2VpdmVyL2h0bWxmaWxlXCI6MzAsXCIuL3NlbmRlci94aHItbG9jYWxcIjozNyxcImluaGVyaXRzXCI6NTd9XSwyMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBGZXcgY29vbCB0cmFuc3BvcnRzIGRvIHdvcmsgb25seSBmb3Igc2FtZS1vcmlnaW4uIEluIG9yZGVyIHRvIG1ha2Vcbi8vIHRoZW0gd29yayBjcm9zcy1kb21haW4gd2Ugc2hhbGwgdXNlIGlmcmFtZSwgc2VydmVkIGZyb20gdGhlXG4vLyByZW1vdGUgZG9tYWluLiBOZXcgYnJvd3NlcnMgaGF2ZSBjYXBhYmlsaXRpZXMgdG8gY29tbXVuaWNhdGUgd2l0aFxuLy8gY3Jvc3MgZG9tYWluIGlmcmFtZSB1c2luZyBwb3N0TWVzc2FnZSgpLiBJbiBJRSBpdCB3YXMgaW1wbGVtZW50ZWRcbi8vIGZyb20gSUUgOCssIGJ1dCBvZiBjb3Vyc2UsIElFIGdvdCBzb21lIGRldGFpbHMgd3Jvbmc6XG4vLyAgICBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvY2MxOTcwMTUodj1WUy44NSkuYXNweFxuLy8gICAgaHR0cDovL3N0ZXZlc291ZGVycy5jb20vbWlzYy90ZXN0LXBvc3RtZXNzYWdlLnBocFxuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgdmVyc2lvbiA9IHJlcXVpcmUoJy4uL3ZlcnNpb24nKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXJsJylcbiAgLCBpZnJhbWVVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2lmcmFtZScpXG4gICwgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2V2ZW50JylcbiAgLCByYW5kb20gPSByZXF1aXJlKCcuLi91dGlscy9yYW5kb20nKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6dHJhbnNwb3J0OmlmcmFtZScpO1xufVxuXG5mdW5jdGlvbiBJZnJhbWVUcmFuc3BvcnQodHJhbnNwb3J0LCB0cmFuc1VybCwgYmFzZVVybCkge1xuICBpZiAoIUlmcmFtZVRyYW5zcG9ydC5lbmFibGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMub3JpZ2luID0gdXJsVXRpbHMuZ2V0T3JpZ2luKGJhc2VVcmwpO1xuICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsO1xuICB0aGlzLnRyYW5zVXJsID0gdHJhbnNVcmw7XG4gIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICB0aGlzLndpbmRvd0lkID0gcmFuZG9tLnN0cmluZyg4KTtcblxuICB2YXIgaWZyYW1lVXJsID0gdXJsVXRpbHMuYWRkUGF0aChiYXNlVXJsLCAnL2lmcmFtZS5odG1sJykgKyAnIycgKyB0aGlzLndpbmRvd0lkO1xuICBkZWJ1Zyh0cmFuc3BvcnQsIHRyYW5zVXJsLCBpZnJhbWVVcmwpO1xuXG4gIHRoaXMuaWZyYW1lT2JqID0gaWZyYW1lVXRpbHMuY3JlYXRlSWZyYW1lKGlmcmFtZVVybCwgZnVuY3Rpb24ocikge1xuICAgIGRlYnVnKCdlcnIgY2FsbGJhY2snKTtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgMTAwNiwgJ1VuYWJsZSB0byBsb2FkIGFuIGlmcmFtZSAoJyArIHIgKyAnKScpO1xuICAgIHNlbGYuY2xvc2UoKTtcbiAgfSk7XG5cbiAgdGhpcy5vbm1lc3NhZ2VDYWxsYmFjayA9IHRoaXMuX21lc3NhZ2UuYmluZCh0aGlzKTtcbiAgZXZlbnRVdGlscy5hdHRhY2hFdmVudCgnbWVzc2FnZScsIHRoaXMub25tZXNzYWdlQ2FsbGJhY2spO1xufVxuXG5pbmhlcml0cyhJZnJhbWVUcmFuc3BvcnQsIEV2ZW50RW1pdHRlcik7XG5cbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIGlmICh0aGlzLmlmcmFtZU9iaikge1xuICAgIGV2ZW50VXRpbHMuZGV0YWNoRXZlbnQoJ21lc3NhZ2UnLCB0aGlzLm9ubWVzc2FnZUNhbGxiYWNrKTtcbiAgICB0cnkge1xuICAgICAgLy8gV2hlbiB0aGUgaWZyYW1lIGlzIG5vdCBsb2FkZWQsIElFIHJhaXNlcyBhbiBleGNlcHRpb25cbiAgICAgIC8vIG9uICdjb250ZW50V2luZG93Jy5cbiAgICAgIHRoaXMucG9zdE1lc3NhZ2UoJ2MnKTtcbiAgICB9IGNhdGNoICh4KSB7XG4gICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgfVxuICAgIHRoaXMuaWZyYW1lT2JqLmNsZWFudXAoKTtcbiAgICB0aGlzLmlmcmFtZU9iaiA9IG51bGw7XG4gICAgdGhpcy5vbm1lc3NhZ2VDYWxsYmFjayA9IHRoaXMuaWZyYW1lT2JqID0gbnVsbDtcbiAgfVxufTtcblxuSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZS5fbWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgZGVidWcoJ21lc3NhZ2UnLCBlLmRhdGEpO1xuICBpZiAoIXVybFV0aWxzLmlzT3JpZ2luRXF1YWwoZS5vcmlnaW4sIHRoaXMub3JpZ2luKSkge1xuICAgIGRlYnVnKCdub3Qgc2FtZSBvcmlnaW4nLCBlLm9yaWdpbiwgdGhpcy5vcmlnaW4pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBpZnJhbWVNZXNzYWdlO1xuICB0cnkge1xuICAgIGlmcmFtZU1lc3NhZ2UgPSBKU09OMy5wYXJzZShlLmRhdGEpO1xuICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgZGVidWcoJ2JhZCBqc29uJywgZS5kYXRhKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaWZyYW1lTWVzc2FnZS53aW5kb3dJZCAhPT0gdGhpcy53aW5kb3dJZCkge1xuICAgIGRlYnVnKCdtaXNtYXRjaGVkIHdpbmRvdyBpZCcsIGlmcmFtZU1lc3NhZ2Uud2luZG93SWQsIHRoaXMud2luZG93SWQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAoaWZyYW1lTWVzc2FnZS50eXBlKSB7XG4gIGNhc2UgJ3MnOlxuICAgIHRoaXMuaWZyYW1lT2JqLmxvYWRlZCgpO1xuICAgIC8vIHdpbmRvdyBnbG9iYWwgZGVwZW5kZW5jeVxuICAgIHRoaXMucG9zdE1lc3NhZ2UoJ3MnLCBKU09OMy5zdHJpbmdpZnkoW1xuICAgICAgdmVyc2lvblxuICAgICwgdGhpcy50cmFuc3BvcnRcbiAgICAsIHRoaXMudHJhbnNVcmxcbiAgICAsIHRoaXMuYmFzZVVybFxuICAgIF0pKTtcbiAgICBicmVhaztcbiAgY2FzZSAndCc6XG4gICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICBicmVhaztcbiAgY2FzZSAnYyc6XG4gICAgdmFyIGNkYXRhO1xuICAgIHRyeSB7XG4gICAgICBjZGF0YSA9IEpTT04zLnBhcnNlKGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgZGVidWcoJ2JhZCBqc29uJywgaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIGNkYXRhWzBdLCBjZGF0YVsxXSk7XG4gICAgdGhpcy5jbG9zZSgpO1xuICAgIGJyZWFrO1xuICB9XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlLnBvc3RNZXNzYWdlID0gZnVuY3Rpb24odHlwZSwgZGF0YSkge1xuICBkZWJ1ZygncG9zdE1lc3NhZ2UnLCB0eXBlLCBkYXRhKTtcbiAgdGhpcy5pZnJhbWVPYmoucG9zdChKU09OMy5zdHJpbmdpZnkoe1xuICAgIHdpbmRvd0lkOiB0aGlzLndpbmRvd0lkXG4gICwgdHlwZTogdHlwZVxuICAsIGRhdGE6IGRhdGEgfHwgJydcbiAgfSksIHRoaXMub3JpZ2luKTtcbn07XG5cbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgZGVidWcoJ3NlbmQnLCBtZXNzYWdlKTtcbiAgdGhpcy5wb3N0TWVzc2FnZSgnbScsIG1lc3NhZ2UpO1xufTtcblxuSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGlmcmFtZVV0aWxzLmlmcmFtZUVuYWJsZWQ7XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdpZnJhbWUnO1xuSWZyYW1lVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IElmcmFtZVRyYW5zcG9ydDtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4uL3V0aWxzL2V2ZW50XCI6NDYsXCIuLi91dGlscy9pZnJhbWVcIjo0NyxcIi4uL3V0aWxzL3JhbmRvbVwiOjUwLFwiLi4vdXRpbHMvdXJsXCI6NTIsXCIuLi92ZXJzaW9uXCI6NTMsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTcsXCJqc29uM1wiOjU4fV0sMjM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGUgc2ltcGxlc3QgYW5kIG1vc3Qgcm9idXN0IHRyYW5zcG9ydCwgdXNpbmcgdGhlIHdlbGwta25vdyBjcm9zc1xuLy8gZG9tYWluIGhhY2sgLSBKU09OUC4gVGhpcyB0cmFuc3BvcnQgaXMgcXVpdGUgaW5lZmZpY2llbnQgLSBvbmVcbi8vIG1lc3NhZ2UgY291bGQgdXNlIHVwIHRvIG9uZSBodHRwIHJlcXVlc3QuIEJ1dCBhdCBsZWFzdCBpdCB3b3JrcyBhbG1vc3Rcbi8vIGV2ZXJ5d2hlcmUuXG4vLyBLbm93biBsaW1pdGF0aW9uczpcbi8vICAgbyB5b3Ugd2lsbCBnZXQgYSBzcGlubmluZyBjdXJzb3Jcbi8vICAgbyBmb3IgS29ucXVlcm9yIGEgZHVtYiB0aW1lciBpcyBuZWVkZWQgdG8gZGV0ZWN0IGVycm9yc1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgU2VuZGVyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL2xpYi9zZW5kZXItcmVjZWl2ZXInKVxuICAsIEpzb25wUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL2pzb25wJylcbiAgLCBqc29ucFNlbmRlciA9IHJlcXVpcmUoJy4vc2VuZGVyL2pzb25wJylcbiAgO1xuXG5mdW5jdGlvbiBKc29uUFRyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIUpzb25QVHJhbnNwb3J0LmVuYWJsZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIFNlbmRlclJlY2VpdmVyLmNhbGwodGhpcywgdHJhbnNVcmwsICcvanNvbnAnLCBqc29ucFNlbmRlciwgSnNvbnBSZWNlaXZlcik7XG59XG5cbmluaGVyaXRzKEpzb25QVHJhbnNwb3J0LCBTZW5kZXJSZWNlaXZlcik7XG5cbkpzb25QVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICEhZ2xvYmFsLmRvY3VtZW50O1xufTtcblxuSnNvblBUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdqc29ucC1wb2xsaW5nJztcbkpzb25QVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAxO1xuSnNvblBUcmFuc3BvcnQubmVlZEJvZHkgPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpzb25QVHJhbnNwb3J0O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL2xpYi9zZW5kZXItcmVjZWl2ZXJcIjoyOCxcIi4vcmVjZWl2ZXIvanNvbnBcIjozMSxcIi4vc2VuZGVyL2pzb25wXCI6MzMsXCJpbmhlcml0c1wiOjU3fV0sMjQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBTZW5kZXJSZWNlaXZlciA9IHJlcXVpcmUoJy4vc2VuZGVyLXJlY2VpdmVyJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmFqYXgtYmFzZWQnKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQWpheFNlbmRlcihBamF4T2JqZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbih1cmwsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgZGVidWcoJ2NyZWF0ZSBhamF4IHNlbmRlcicsIHVybCwgcGF5bG9hZCk7XG4gICAgdmFyIG9wdCA9IHt9O1xuICAgIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG9wdC5oZWFkZXJzID0geydDb250ZW50LXR5cGUnOiAndGV4dC9wbGFpbid9O1xuICAgIH1cbiAgICB2YXIgYWpheFVybCA9IHVybFV0aWxzLmFkZFBhdGgodXJsLCAnL3hocl9zZW5kJyk7XG4gICAgdmFyIHhvID0gbmV3IEFqYXhPYmplY3QoJ1BPU1QnLCBhamF4VXJsLCBwYXlsb2FkLCBvcHQpO1xuICAgIHhvLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uKHN0YXR1cykge1xuICAgICAgZGVidWcoJ2ZpbmlzaCcsIHN0YXR1cyk7XG4gICAgICB4byA9IG51bGw7XG5cbiAgICAgIGlmIChzdGF0dXMgIT09IDIwMCAmJiBzdGF0dXMgIT09IDIwNCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdodHRwIHN0YXR1cyAnICsgc3RhdHVzKSk7XG4gICAgICB9XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdhYm9ydCcpO1xuICAgICAgeG8uY2xvc2UoKTtcbiAgICAgIHhvID0gbnVsbDtcblxuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignQWJvcnRlZCcpO1xuICAgICAgZXJyLmNvZGUgPSAxMDAwO1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9O1xuICB9O1xufVxuXG5mdW5jdGlvbiBBamF4QmFzZWRUcmFuc3BvcnQodHJhbnNVcmwsIHVybFN1ZmZpeCwgUmVjZWl2ZXIsIEFqYXhPYmplY3QpIHtcbiAgU2VuZGVyUmVjZWl2ZXIuY2FsbCh0aGlzLCB0cmFuc1VybCwgdXJsU3VmZml4LCBjcmVhdGVBamF4U2VuZGVyKEFqYXhPYmplY3QpLCBSZWNlaXZlciwgQWpheE9iamVjdCk7XG59XG5cbmluaGVyaXRzKEFqYXhCYXNlZFRyYW5zcG9ydCwgU2VuZGVyUmVjZWl2ZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFqYXhCYXNlZFRyYW5zcG9ydDtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiLi9zZW5kZXItcmVjZWl2ZXJcIjoyOCxcImRlYnVnXCI6NTUsXCJpbmhlcml0c1wiOjU3fV0sMjU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6YnVmZmVyZWQtc2VuZGVyJyk7XG59XG5cbmZ1bmN0aW9uIEJ1ZmZlcmVkU2VuZGVyKHVybCwgc2VuZGVyKSB7XG4gIGRlYnVnKHVybCk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgdGhpcy5zZW5kZXIgPSBzZW5kZXI7XG4gIHRoaXMudXJsID0gdXJsO1xufVxuXG5pbmhlcml0cyhCdWZmZXJlZFNlbmRlciwgRXZlbnRFbWl0dGVyKTtcblxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gIGRlYnVnKCdzZW5kJywgbWVzc2FnZSk7XG4gIHRoaXMuc2VuZEJ1ZmZlci5wdXNoKG1lc3NhZ2UpO1xuICBpZiAoIXRoaXMuc2VuZFN0b3ApIHtcbiAgICB0aGlzLnNlbmRTY2hlZHVsZSgpO1xuICB9XG59O1xuXG4vLyBGb3IgcG9sbGluZyB0cmFuc3BvcnRzIGluIGEgc2l0dWF0aW9uIHdoZW4gaW4gdGhlIG1lc3NhZ2UgY2FsbGJhY2ssXG4vLyBuZXcgbWVzc2FnZSBpcyBiZWluZyBzZW5kLiBJZiB0aGUgc2VuZGluZyBjb25uZWN0aW9uIHdhcyBzdGFydGVkXG4vLyBiZWZvcmUgcmVjZWl2aW5nIG9uZSwgaXQgaXMgcG9zc2libGUgdG8gc2F0dXJhdGUgdGhlIG5ldHdvcmsgYW5kXG4vLyB0aW1lb3V0IGR1ZSB0byB0aGUgbGFjayBvZiByZWNlaXZpbmcgc29ja2V0LiBUbyBhdm9pZCB0aGF0IHdlIGRlbGF5XG4vLyBzZW5kaW5nIG1lc3NhZ2VzIGJ5IHNvbWUgc21hbGwgdGltZSwgaW4gb3JkZXIgdG8gbGV0IHJlY2VpdmluZ1xuLy8gY29ubmVjdGlvbiBiZSBzdGFydGVkIGJlZm9yZWhhbmQuIFRoaXMgaXMgb25seSBhIGhhbGZtZWFzdXJlIGFuZFxuLy8gZG9lcyBub3QgZml4IHRoZSBiaWcgcHJvYmxlbSwgYnV0IGl0IGRvZXMgbWFrZSB0aGUgdGVzdHMgZ28gbW9yZVxuLy8gc3RhYmxlIG9uIHNsb3cgbmV0d29ya3MuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuc2VuZFNjaGVkdWxlV2FpdCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1Zygnc2VuZFNjaGVkdWxlV2FpdCcpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB0cmVmO1xuICB0aGlzLnNlbmRTdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3NlbmRTdG9wJyk7XG4gICAgc2VsZi5zZW5kU3RvcCA9IG51bGw7XG4gICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xuICB9O1xuICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygndGltZW91dCcpO1xuICAgIHNlbGYuc2VuZFN0b3AgPSBudWxsO1xuICAgIHNlbGYuc2VuZFNjaGVkdWxlKCk7XG4gIH0sIDI1KTtcbn07XG5cbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5zZW5kU2NoZWR1bGUgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ3NlbmRTY2hlZHVsZScsIHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGgpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICh0aGlzLnNlbmRCdWZmZXIubGVuZ3RoID4gMCkge1xuICAgIHZhciBwYXlsb2FkID0gJ1snICsgdGhpcy5zZW5kQnVmZmVyLmpvaW4oJywnKSArICddJztcbiAgICB0aGlzLnNlbmRTdG9wID0gdGhpcy5zZW5kZXIodGhpcy51cmwsIHBheWxvYWQsIGZ1bmN0aW9uKGVycikge1xuICAgICAgc2VsZi5zZW5kU3RvcCA9IG51bGw7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGRlYnVnKCdlcnJvcicsIGVycik7XG4gICAgICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBlcnIuY29kZSB8fCAxMDA2LCAnU2VuZGluZyBlcnJvcjogJyArIGVycik7XG4gICAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuc2VuZFNjaGVkdWxlV2FpdCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICB9XG59O1xuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMuX2NsZWFudXAoKTtcbiAgaWYgKHRoaXMuc2VuZFN0b3ApIHtcbiAgICB0aGlzLnNlbmRTdG9wKCk7XG4gICAgdGhpcy5zZW5kU3RvcCA9IG51bGw7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyZWRTZW5kZXI7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwyNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBJZnJhbWVUcmFuc3BvcnQgPSByZXF1aXJlKCcuLi9pZnJhbWUnKVxuICAsIG9iamVjdFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0JylcbiAgO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRyYW5zcG9ydCkge1xuXG4gIGZ1bmN0aW9uIElmcmFtZVdyYXBUcmFuc3BvcnQodHJhbnNVcmwsIGJhc2VVcmwpIHtcbiAgICBJZnJhbWVUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc3BvcnQudHJhbnNwb3J0TmFtZSwgdHJhbnNVcmwsIGJhc2VVcmwpO1xuICB9XG5cbiAgaW5oZXJpdHMoSWZyYW1lV3JhcFRyYW5zcG9ydCwgSWZyYW1lVHJhbnNwb3J0KTtcblxuICBJZnJhbWVXcmFwVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbih1cmwsIGluZm8pIHtcbiAgICBpZiAoIWdsb2JhbC5kb2N1bWVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBpZnJhbWVJbmZvID0gb2JqZWN0VXRpbHMuZXh0ZW5kKHt9LCBpbmZvKTtcbiAgICBpZnJhbWVJbmZvLnNhbWVPcmlnaW4gPSB0cnVlO1xuICAgIHJldHVybiB0cmFuc3BvcnQuZW5hYmxlZChpZnJhbWVJbmZvKSAmJiBJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCgpO1xuICB9O1xuXG4gIElmcmFtZVdyYXBUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdpZnJhbWUtJyArIHRyYW5zcG9ydC50cmFuc3BvcnROYW1lO1xuICBJZnJhbWVXcmFwVHJhbnNwb3J0Lm5lZWRCb2R5ID0gdHJ1ZTtcbiAgSWZyYW1lV3JhcFRyYW5zcG9ydC5yb3VuZFRyaXBzID0gSWZyYW1lVHJhbnNwb3J0LnJvdW5kVHJpcHMgKyB0cmFuc3BvcnQucm91bmRUcmlwcyAtIDE7IC8vIGh0bWwsIGphdmFzY3JpcHQgKDIpICsgdHJhbnNwb3J0IC0gbm8gQ09SUyAoMSlcblxuICBJZnJhbWVXcmFwVHJhbnNwb3J0LmZhY2FkZVRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcblxuICByZXR1cm4gSWZyYW1lV3JhcFRyYW5zcG9ydDtcbn07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uLy4uL3V0aWxzL29iamVjdFwiOjQ5LFwiLi4vaWZyYW1lXCI6MjIsXCJpbmhlcml0c1wiOjU3fV0sMjc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cG9sbGluZycpO1xufVxuXG5mdW5jdGlvbiBQb2xsaW5nKFJlY2VpdmVyLCByZWNlaXZlVXJsLCBBamF4T2JqZWN0KSB7XG4gIGRlYnVnKHJlY2VpdmVVcmwpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgdGhpcy5SZWNlaXZlciA9IFJlY2VpdmVyO1xuICB0aGlzLnJlY2VpdmVVcmwgPSByZWNlaXZlVXJsO1xuICB0aGlzLkFqYXhPYmplY3QgPSBBamF4T2JqZWN0O1xuICB0aGlzLl9zY2hlZHVsZVJlY2VpdmVyKCk7XG59XG5cbmluaGVyaXRzKFBvbGxpbmcsIEV2ZW50RW1pdHRlcik7XG5cblBvbGxpbmcucHJvdG90eXBlLl9zY2hlZHVsZVJlY2VpdmVyID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfc2NoZWR1bGVSZWNlaXZlcicpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBwb2xsID0gdGhpcy5wb2xsID0gbmV3IHRoaXMuUmVjZWl2ZXIodGhpcy5yZWNlaXZlVXJsLCB0aGlzLkFqYXhPYmplY3QpO1xuXG4gIHBvbGwub24oJ21lc3NhZ2UnLCBmdW5jdGlvbihtc2cpIHtcbiAgICBkZWJ1ZygnbWVzc2FnZScsIG1zZyk7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgbXNnKTtcbiAgfSk7XG5cbiAgcG9sbC5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICAgIGRlYnVnKCdjbG9zZScsIGNvZGUsIHJlYXNvbiwgc2VsZi5wb2xsSXNDbG9zaW5nKTtcbiAgICBzZWxmLnBvbGwgPSBwb2xsID0gbnVsbDtcblxuICAgIGlmICghc2VsZi5wb2xsSXNDbG9zaW5nKSB7XG4gICAgICBpZiAocmVhc29uID09PSAnbmV0d29yaycpIHtcbiAgICAgICAgc2VsZi5fc2NoZWR1bGVSZWNlaXZlcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5lbWl0KCdjbG9zZScsIGNvZGUgfHwgMTAwNiwgcmVhc29uKTtcbiAgICAgICAgc2VsZi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuUG9sbGluZy5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Fib3J0Jyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIHRoaXMucG9sbElzQ2xvc2luZyA9IHRydWU7XG4gIGlmICh0aGlzLnBvbGwpIHtcbiAgICB0aGlzLnBvbGwuYWJvcnQoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb2xsaW5nO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMjg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBCdWZmZXJlZFNlbmRlciA9IHJlcXVpcmUoJy4vYnVmZmVyZWQtc2VuZGVyJylcbiAgLCBQb2xsaW5nID0gcmVxdWlyZSgnLi9wb2xsaW5nJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnNlbmRlci1yZWNlaXZlcicpO1xufVxuXG5mdW5jdGlvbiBTZW5kZXJSZWNlaXZlcih0cmFuc1VybCwgdXJsU3VmZml4LCBzZW5kZXJGdW5jLCBSZWNlaXZlciwgQWpheE9iamVjdCkge1xuICB2YXIgcG9sbFVybCA9IHVybFV0aWxzLmFkZFBhdGgodHJhbnNVcmwsIHVybFN1ZmZpeCk7XG4gIGRlYnVnKHBvbGxVcmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEJ1ZmZlcmVkU2VuZGVyLmNhbGwodGhpcywgdHJhbnNVcmwsIHNlbmRlckZ1bmMpO1xuXG4gIHRoaXMucG9sbCA9IG5ldyBQb2xsaW5nKFJlY2VpdmVyLCBwb2xsVXJsLCBBamF4T2JqZWN0KTtcbiAgdGhpcy5wb2xsLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24obXNnKSB7XG4gICAgZGVidWcoJ3BvbGwgbWVzc2FnZScsIG1zZyk7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgbXNnKTtcbiAgfSk7XG4gIHRoaXMucG9sbC5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICAgIGRlYnVnKCdwb2xsIGNsb3NlJywgY29kZSwgcmVhc29uKTtcbiAgICBzZWxmLnBvbGwgPSBudWxsO1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBjb2RlLCByZWFzb24pO1xuICAgIHNlbGYuY2xvc2UoKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKFNlbmRlclJlY2VpdmVyLCBCdWZmZXJlZFNlbmRlcik7XG5cblNlbmRlclJlY2VpdmVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBCdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuY2xvc2UuY2FsbCh0aGlzKTtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIGlmICh0aGlzLnBvbGwpIHtcbiAgICB0aGlzLnBvbGwuYWJvcnQoKTtcbiAgICB0aGlzLnBvbGwgPSBudWxsO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbmRlclJlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCIuL2J1ZmZlcmVkLXNlbmRlclwiOjI1LFwiLi9wb2xsaW5nXCI6MjcsXCJkZWJ1Z1wiOjU1LFwiaW5oZXJpdHNcIjo1N31dLDI5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBFdmVudFNvdXJjZURyaXZlciA9IHJlcXVpcmUoJ2V2ZW50c291cmNlJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnJlY2VpdmVyOmV2ZW50c291cmNlJyk7XG59XG5cbmZ1bmN0aW9uIEV2ZW50U291cmNlUmVjZWl2ZXIodXJsKSB7XG4gIGRlYnVnKHVybCk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGVzID0gdGhpcy5lcyA9IG5ldyBFdmVudFNvdXJjZURyaXZlcih1cmwpO1xuICBlcy5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ21lc3NhZ2UnLCBlLmRhdGEpO1xuICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIGRlY29kZVVSSShlLmRhdGEpKTtcbiAgfTtcbiAgZXMub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1ZygnZXJyb3InLCBlcy5yZWFkeVN0YXRlLCBlKTtcbiAgICAvLyBFUyBvbiByZWNvbm5lY3Rpb24gaGFzIHJlYWR5U3RhdGUgPSAwIG9yIDEuXG4gICAgLy8gb24gbmV0d29yayBlcnJvciBpdCdzIENMT1NFRCA9IDJcbiAgICB2YXIgcmVhc29uID0gKGVzLnJlYWR5U3RhdGUgIT09IDIgPyAnbmV0d29yaycgOiAncGVybWFuZW50Jyk7XG4gICAgc2VsZi5fY2xlYW51cCgpO1xuICAgIHNlbGYuX2Nsb3NlKHJlYXNvbik7XG4gIH07XG59XG5cbmluaGVyaXRzKEV2ZW50U291cmNlUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cbkV2ZW50U291cmNlUmVjZWl2ZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdhYm9ydCcpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG4gIHRoaXMuX2Nsb3NlKCd1c2VyJyk7XG59O1xuXG5FdmVudFNvdXJjZVJlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xlYW51cCcpO1xuICB2YXIgZXMgPSB0aGlzLmVzO1xuICBpZiAoZXMpIHtcbiAgICBlcy5vbm1lc3NhZ2UgPSBlcy5vbmVycm9yID0gbnVsbDtcbiAgICBlcy5jbG9zZSgpO1xuICAgIHRoaXMuZXMgPSBudWxsO1xuICB9XG59O1xuXG5FdmVudFNvdXJjZVJlY2VpdmVyLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbihyZWFzb24pIHtcbiAgZGVidWcoJ2Nsb3NlJywgcmVhc29uKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICAvLyBTYWZhcmkgYW5kIGNocm9tZSA8IDE1IGNyYXNoIGlmIHdlIGNsb3NlIHdpbmRvdyBiZWZvcmVcbiAgLy8gd2FpdGluZyBmb3IgRVMgY2xlYW51cC4gU2VlOlxuICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODkxNTVcbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgbnVsbCwgcmVhc29uKTtcbiAgICBzZWxmLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9LCAyMDApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFNvdXJjZVJlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJldmVudHNvdXJjZVwiOjE4LFwiaW5oZXJpdHNcIjo1N31dLDMwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgaWZyYW1lVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9pZnJhbWUnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCByYW5kb20gPSByZXF1aXJlKCcuLi8uLi91dGlscy9yYW5kb20nKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cmVjZWl2ZXI6aHRtbGZpbGUnKTtcbn1cblxuZnVuY3Rpb24gSHRtbGZpbGVSZWNlaXZlcih1cmwpIHtcbiAgZGVidWcodXJsKTtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWZyYW1lVXRpbHMucG9sbHV0ZUdsb2JhbE5hbWVzcGFjZSgpO1xuXG4gIHRoaXMuaWQgPSAnYScgKyByYW5kb20uc3RyaW5nKDYpO1xuICB1cmwgPSB1cmxVdGlscy5hZGRRdWVyeSh1cmwsICdjPScgKyBkZWNvZGVVUklDb21wb25lbnQoaWZyYW1lVXRpbHMuV1ByZWZpeCArICcuJyArIHRoaXMuaWQpKTtcblxuICBkZWJ1ZygndXNpbmcgaHRtbGZpbGUnLCBIdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCk7XG4gIHZhciBjb25zdHJ1Y3RGdW5jID0gSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQgP1xuICAgICAgaWZyYW1lVXRpbHMuY3JlYXRlSHRtbGZpbGUgOiBpZnJhbWVVdGlscy5jcmVhdGVJZnJhbWU7XG5cbiAgZ2xvYmFsW2lmcmFtZVV0aWxzLldQcmVmaXhdW3RoaXMuaWRdID0ge1xuICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdzdGFydCcpO1xuICAgICAgc2VsZi5pZnJhbWVPYmoubG9hZGVkKCk7XG4gICAgfVxuICAsIG1lc3NhZ2U6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIGRlYnVnKCdtZXNzYWdlJywgZGF0YSk7XG4gICAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBkYXRhKTtcbiAgICB9XG4gICwgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1Zygnc3RvcCcpO1xuICAgICAgc2VsZi5fY2xlYW51cCgpO1xuICAgICAgc2VsZi5fY2xvc2UoJ25ldHdvcmsnKTtcbiAgICB9XG4gIH07XG4gIHRoaXMuaWZyYW1lT2JqID0gY29uc3RydWN0RnVuYyh1cmwsIGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdjYWxsYmFjaycpO1xuICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgICBzZWxmLl9jbG9zZSgncGVybWFuZW50Jyk7XG4gIH0pO1xufVxuXG5pbmhlcml0cyhIdG1sZmlsZVJlY2VpdmVyLCBFdmVudEVtaXR0ZXIpO1xuXG5IdG1sZmlsZVJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnYWJvcnQnKTtcbiAgdGhpcy5fY2xlYW51cCgpO1xuICB0aGlzLl9jbG9zZSgndXNlcicpO1xufTtcblxuSHRtbGZpbGVSZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIGlmICh0aGlzLmlmcmFtZU9iaikge1xuICAgIHRoaXMuaWZyYW1lT2JqLmNsZWFudXAoKTtcbiAgICB0aGlzLmlmcmFtZU9iaiA9IG51bGw7XG4gIH1cbiAgZGVsZXRlIGdsb2JhbFtpZnJhbWVVdGlscy5XUHJlZml4XVt0aGlzLmlkXTtcbn07XG5cbkh0bWxmaWxlUmVjZWl2ZXIucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uKHJlYXNvbikge1xuICBkZWJ1ZygnX2Nsb3NlJywgcmVhc29uKTtcbiAgdGhpcy5lbWl0KCdjbG9zZScsIG51bGwsIHJlYXNvbik7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5IdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCA9IGZhbHNlO1xuXG4vLyBvYmZ1c2NhdGUgdG8gYXZvaWQgZmlyZXdhbGxzXG52YXIgYXhvID0gWydBY3RpdmUnXS5jb25jYXQoJ09iamVjdCcpLmpvaW4oJ1gnKTtcbmlmIChheG8gaW4gZ2xvYmFsKSB7XG4gIHRyeSB7XG4gICAgSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQgPSAhIW5ldyBnbG9iYWxbYXhvXSgnaHRtbGZpbGUnKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgfVxufVxuXG5IdG1sZmlsZVJlY2VpdmVyLmVuYWJsZWQgPSBIdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCB8fCBpZnJhbWVVdGlscy5pZnJhbWVFbmFibGVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEh0bWxmaWxlUmVjZWl2ZXI7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uLy4uL3V0aWxzL2lmcmFtZVwiOjQ3LFwiLi4vLi4vdXRpbHMvcmFuZG9tXCI6NTAsXCIuLi8uLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDMxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9pZnJhbWUnKVxuICAsIHJhbmRvbSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3JhbmRvbScpXG4gICwgYnJvd3NlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2Jyb3dzZXInKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnJlY2VpdmVyOmpzb25wJyk7XG59XG5cbmZ1bmN0aW9uIEpzb25wUmVjZWl2ZXIodXJsKSB7XG4gIGRlYnVnKHVybCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdXRpbHMucG9sbHV0ZUdsb2JhbE5hbWVzcGFjZSgpO1xuXG4gIHRoaXMuaWQgPSAnYScgKyByYW5kb20uc3RyaW5nKDYpO1xuICB2YXIgdXJsV2l0aElkID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsLCAnYz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHV0aWxzLldQcmVmaXggKyAnLicgKyB0aGlzLmlkKSk7XG5cbiAgZ2xvYmFsW3V0aWxzLldQcmVmaXhdW3RoaXMuaWRdID0gdGhpcy5fY2FsbGJhY2suYmluZCh0aGlzKTtcbiAgdGhpcy5fY3JlYXRlU2NyaXB0KHVybFdpdGhJZCk7XG5cbiAgLy8gRmFsbGJhY2sgbW9zdGx5IGZvciBLb25xdWVyb3IgLSBzdHVwaWQgdGltZXIsIDM1IHNlY29uZHMgc2hhbGwgYmUgcGxlbnR5LlxuICB0aGlzLnRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3RpbWVvdXQnKTtcbiAgICBzZWxmLl9hYm9ydChuZXcgRXJyb3IoJ0pTT05QIHNjcmlwdCBsb2FkZWQgYWJub3JtYWxseSAodGltZW91dCknKSk7XG4gIH0sIEpzb25wUmVjZWl2ZXIudGltZW91dCk7XG59XG5cbmluaGVyaXRzKEpzb25wUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdhYm9ydCcpO1xuICBpZiAoZ2xvYmFsW3V0aWxzLldQcmVmaXhdW3RoaXMuaWRdKSB7XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignSlNPTlAgdXNlciBhYm9ydGVkIHJlYWQnKTtcbiAgICBlcnIuY29kZSA9IDEwMDA7XG4gICAgdGhpcy5fYWJvcnQoZXJyKTtcbiAgfVxufTtcblxuSnNvbnBSZWNlaXZlci50aW1lb3V0ID0gMzUwMDA7XG5Kc29ucFJlY2VpdmVyLnNjcmlwdEVycm9yVGltZW91dCA9IDEwMDA7XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9jYWxsYmFjayA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgZGVidWcoJ19jYWxsYmFjaycsIGRhdGEpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG5cbiAgaWYgKHRoaXMuYWJvcnRpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZGF0YSkge1xuICAgIGRlYnVnKCdtZXNzYWdlJywgZGF0YSk7XG4gICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgZGF0YSk7XG4gIH1cbiAgdGhpcy5lbWl0KCdjbG9zZScsIG51bGwsICduZXR3b3JrJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5fYWJvcnQgPSBmdW5jdGlvbihlcnIpIHtcbiAgZGVidWcoJ19hYm9ydCcsIGVycik7XG4gIHRoaXMuX2NsZWFudXAoKTtcbiAgdGhpcy5hYm9ydGluZyA9IHRydWU7XG4gIHRoaXMuZW1pdCgnY2xvc2UnLCBlcnIuY29kZSwgZXJyLm1lc3NhZ2UpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZCk7XG4gIGlmICh0aGlzLnNjcmlwdDIpIHtcbiAgICB0aGlzLnNjcmlwdDIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdDIpO1xuICAgIHRoaXMuc2NyaXB0MiA9IG51bGw7XG4gIH1cbiAgaWYgKHRoaXMuc2NyaXB0KSB7XG4gICAgdmFyIHNjcmlwdCA9IHRoaXMuc2NyaXB0O1xuICAgIC8vIFVuZm9ydHVuYXRlbHksIHlvdSBjYW4ndCByZWFsbHkgYWJvcnQgc2NyaXB0IGxvYWRpbmcgb2ZcbiAgICAvLyB0aGUgc2NyaXB0LlxuICAgIHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHNjcmlwdC5vbmVycm9yID1cbiAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbmNsaWNrID0gbnVsbDtcbiAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG4gIH1cbiAgZGVsZXRlIGdsb2JhbFt1dGlscy5XUHJlZml4XVt0aGlzLmlkXTtcbn07XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9zY3JpcHRFcnJvciA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX3NjcmlwdEVycm9yJyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHRoaXMuZXJyb3JUaW1lcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuZXJyb3JUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFzZWxmLmxvYWRlZE9rYXkpIHtcbiAgICAgIHNlbGYuX2Fib3J0KG5ldyBFcnJvcignSlNPTlAgc2NyaXB0IGxvYWRlZCBhYm5vcm1hbGx5IChvbmVycm9yKScpKTtcbiAgICB9XG4gIH0sIEpzb25wUmVjZWl2ZXIuc2NyaXB0RXJyb3JUaW1lb3V0KTtcbn07XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9jcmVhdGVTY3JpcHQgPSBmdW5jdGlvbih1cmwpIHtcbiAgZGVidWcoJ19jcmVhdGVTY3JpcHQnLCB1cmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzY3JpcHQgPSB0aGlzLnNjcmlwdCA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgdmFyIHNjcmlwdDI7ICAvLyBPcGVyYSBzeW5jaHJvbm91cyBsb2FkIHRyaWNrLlxuXG4gIHNjcmlwdC5pZCA9ICdhJyArIHJhbmRvbS5zdHJpbmcoOCk7XG4gIHNjcmlwdC5zcmMgPSB1cmw7XG4gIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gIHNjcmlwdC5jaGFyc2V0ID0gJ1VURi04JztcbiAgc2NyaXB0Lm9uZXJyb3IgPSB0aGlzLl9zY3JpcHRFcnJvci5iaW5kKHRoaXMpO1xuICBzY3JpcHQub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29ubG9hZCcpO1xuICAgIHNlbGYuX2Fib3J0KG5ldyBFcnJvcignSlNPTlAgc2NyaXB0IGxvYWRlZCBhYm5vcm1hbGx5IChvbmxvYWQpJykpO1xuICB9O1xuXG4gIC8vIElFOSBmaXJlcyAnZXJyb3InIGV2ZW50IGFmdGVyIG9ucmVhZHlzdGF0ZWNoYW5nZSBvciBiZWZvcmUsIGluIHJhbmRvbSBvcmRlci5cbiAgLy8gVXNlIGxvYWRlZE9rYXkgdG8gZGV0ZXJtaW5lIGlmIGFjdHVhbGx5IGVycm9yZWRcbiAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbnJlYWR5c3RhdGVjaGFuZ2UnLCBzY3JpcHQucmVhZHlTdGF0ZSk7XG4gICAgaWYgKC9sb2FkZWR8Y2xvc2VkLy50ZXN0KHNjcmlwdC5yZWFkeVN0YXRlKSkge1xuICAgICAgaWYgKHNjcmlwdCAmJiBzY3JpcHQuaHRtbEZvciAmJiBzY3JpcHQub25jbGljaykge1xuICAgICAgICBzZWxmLmxvYWRlZE9rYXkgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIEluIElFLCBhY3R1YWxseSBleGVjdXRlIHRoZSBzY3JpcHQuXG4gICAgICAgICAgc2NyaXB0Lm9uY2xpY2soKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNjcmlwdCkge1xuICAgICAgICBzZWxmLl9hYm9ydChuZXcgRXJyb3IoJ0pTT05QIHNjcmlwdCBsb2FkZWQgYWJub3JtYWxseSAob25yZWFkeXN0YXRlY2hhbmdlKScpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8vIElFOiBldmVudC9odG1sRm9yL29uY2xpY2sgdHJpY2suXG4gIC8vIE9uZSBjYW4ndCByZWx5IG9uIHByb3BlciBvcmRlciBmb3Igb25yZWFkeXN0YXRlY2hhbmdlLiBJbiBvcmRlciB0b1xuICAvLyBtYWtlIHN1cmUsIHNldCBhICdodG1sRm9yJyBhbmQgJ2V2ZW50JyBwcm9wZXJ0aWVzLCBzbyB0aGF0XG4gIC8vIHNjcmlwdCBjb2RlIHdpbGwgYmUgaW5zdGFsbGVkIGFzICdvbmNsaWNrJyBoYW5kbGVyIGZvciB0aGVcbiAgLy8gc2NyaXB0IG9iamVjdC4gTGF0ZXIsIG9ucmVhZHlzdGF0ZWNoYW5nZSwgbWFudWFsbHkgZXhlY3V0ZSB0aGlzXG4gIC8vIGNvZGUuIEZGIGFuZCBDaHJvbWUgZG9lc24ndCB3b3JrIHdpdGggJ2V2ZW50JyBhbmQgJ2h0bWxGb3InXG4gIC8vIHNldC4gRm9yIHJlZmVyZW5jZSBzZWU6XG4gIC8vICAgaHR0cDovL2phdWJvdXJnLm5ldC8yMDEwLzA3L2xvYWRpbmctc2NyaXB0LWFzLW9uY2xpY2staGFuZGxlci1vZi5odG1sXG4gIC8vIEFsc28sIHJlYWQgb24gdGhhdCBhYm91dCBzY3JpcHQgb3JkZXJpbmc6XG4gIC8vICAgaHR0cDovL3dpa2kud2hhdHdnLm9yZy93aWtpL0R5bmFtaWNfU2NyaXB0X0V4ZWN1dGlvbl9PcmRlclxuICBpZiAodHlwZW9mIHNjcmlwdC5hc3luYyA9PT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsLmRvY3VtZW50LmF0dGFjaEV2ZW50KSB7XG4gICAgLy8gQWNjb3JkaW5nIHRvIG1vemlsbGEgZG9jcywgaW4gcmVjZW50IGJyb3dzZXJzIHNjcmlwdC5hc3luYyBkZWZhdWx0c1xuICAgIC8vIHRvICd0cnVlJywgc28gd2UgbWF5IHVzZSBpdCB0byBkZXRlY3QgYSBnb29kIGJyb3dzZXI6XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSFRNTC9FbGVtZW50L3NjcmlwdFxuICAgIGlmICghYnJvd3Nlci5pc09wZXJhKCkpIHtcbiAgICAgIC8vIE5haXZlbHkgYXNzdW1lIHdlJ3JlIGluIElFXG4gICAgICB0cnkge1xuICAgICAgICBzY3JpcHQuaHRtbEZvciA9IHNjcmlwdC5pZDtcbiAgICAgICAgc2NyaXB0LmV2ZW50ID0gJ29uY2xpY2snO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICB9XG4gICAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPcGVyYSwgc2Vjb25kIHN5bmMgc2NyaXB0IGhhY2tcbiAgICAgIHNjcmlwdDIgPSB0aGlzLnNjcmlwdDIgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICBzY3JpcHQyLnRleHQgPSBcInRyeXt2YXIgYSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdcIiArIHNjcmlwdC5pZCArIFwiJyk7IGlmKGEpYS5vbmVycm9yKCk7fWNhdGNoKHgpe307XCI7XG4gICAgICBzY3JpcHQuYXN5bmMgPSBzY3JpcHQyLmFzeW5jID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2Ygc2NyaXB0LmFzeW5jICE9PSAndW5kZWZpbmVkJykge1xuICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gIH1cblxuICB2YXIgaGVhZCA9IGdsb2JhbC5kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICBoZWFkLmluc2VydEJlZm9yZShzY3JpcHQsIGhlYWQuZmlyc3RDaGlsZCk7XG4gIGlmIChzY3JpcHQyKSB7XG4gICAgaGVhZC5pbnNlcnRCZWZvcmUoc2NyaXB0MiwgaGVhZC5maXJzdENoaWxkKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBKc29ucFJlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuLi8uLi91dGlscy9icm93c2VyXCI6NDQsXCIuLi8uLi91dGlscy9pZnJhbWVcIjo0NyxcIi4uLy4uL3V0aWxzL3JhbmRvbVwiOjUwLFwiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwzMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpyZWNlaXZlcjp4aHInKTtcbn1cblxuZnVuY3Rpb24gWGhyUmVjZWl2ZXIodXJsLCBBamF4T2JqZWN0KSB7XG4gIGRlYnVnKHVybCk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5idWZmZXJQb3NpdGlvbiA9IDA7XG5cbiAgdGhpcy54byA9IG5ldyBBamF4T2JqZWN0KCdQT1NUJywgdXJsLCBudWxsKTtcbiAgdGhpcy54by5vbignY2h1bmsnLCB0aGlzLl9jaHVua0hhbmRsZXIuYmluZCh0aGlzKSk7XG4gIHRoaXMueG8ub25jZSgnZmluaXNoJywgZnVuY3Rpb24oc3RhdHVzLCB0ZXh0KSB7XG4gICAgZGVidWcoJ2ZpbmlzaCcsIHN0YXR1cywgdGV4dCk7XG4gICAgc2VsZi5fY2h1bmtIYW5kbGVyKHN0YXR1cywgdGV4dCk7XG4gICAgc2VsZi54byA9IG51bGw7XG4gICAgdmFyIHJlYXNvbiA9IHN0YXR1cyA9PT0gMjAwID8gJ25ldHdvcmsnIDogJ3Blcm1hbmVudCc7XG4gICAgZGVidWcoJ2Nsb3NlJywgcmVhc29uKTtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgbnVsbCwgcmVhc29uKTtcbiAgICBzZWxmLl9jbGVhbnVwKCk7XG4gIH0pO1xufVxuXG5pbmhlcml0cyhYaHJSZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcblxuWGhyUmVjZWl2ZXIucHJvdG90eXBlLl9jaHVua0hhbmRsZXIgPSBmdW5jdGlvbihzdGF0dXMsIHRleHQpIHtcbiAgZGVidWcoJ19jaHVua0hhbmRsZXInLCBzdGF0dXMpO1xuICBpZiAoc3RhdHVzICE9PSAyMDAgfHwgIXRleHQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKHZhciBpZHggPSAtMTsgOyB0aGlzLmJ1ZmZlclBvc2l0aW9uICs9IGlkeCArIDEpIHtcbiAgICB2YXIgYnVmID0gdGV4dC5zbGljZSh0aGlzLmJ1ZmZlclBvc2l0aW9uKTtcbiAgICBpZHggPSBidWYuaW5kZXhPZignXFxuJyk7XG4gICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgbXNnID0gYnVmLnNsaWNlKDAsIGlkeCk7XG4gICAgaWYgKG1zZykge1xuICAgICAgZGVidWcoJ21lc3NhZ2UnLCBtc2cpO1xuICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgbXNnKTtcbiAgICB9XG4gIH1cbn07XG5cblhoclJlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cblhoclJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnYWJvcnQnKTtcbiAgaWYgKHRoaXMueG8pIHtcbiAgICB0aGlzLnhvLmNsb3NlKCk7XG4gICAgZGVidWcoJ2Nsb3NlJyk7XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIG51bGwsICd1c2VyJyk7XG4gICAgdGhpcy54byA9IG51bGw7XG4gIH1cbiAgdGhpcy5fY2xlYW51cCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBYaHJSZWNlaXZlcjtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDMzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmFuZG9tID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvcmFuZG9tJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpzZW5kZXI6anNvbnAnKTtcbn1cblxudmFyIGZvcm0sIGFyZWE7XG5cbmZ1bmN0aW9uIGNyZWF0ZUlmcmFtZShpZCkge1xuICBkZWJ1ZygnY3JlYXRlSWZyYW1lJywgaWQpO1xuICB0cnkge1xuICAgIC8vIGllNiBkeW5hbWljIGlmcmFtZXMgd2l0aCB0YXJnZXQ9XCJcIiBzdXBwb3J0ICh0aGFua3MgQ2hyaXMgTGFtYmFjaGVyKVxuICAgIHJldHVybiBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPGlmcmFtZSBuYW1lPVwiJyArIGlkICsgJ1wiPicpO1xuICB9IGNhdGNoICh4KSB7XG4gICAgdmFyIGlmcmFtZSA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICBpZnJhbWUubmFtZSA9IGlkO1xuICAgIHJldHVybiBpZnJhbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRm9ybSgpIHtcbiAgZGVidWcoJ2NyZWF0ZUZvcm0nKTtcbiAgZm9ybSA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG4gIGZvcm0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgZm9ybS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIGZvcm0ubWV0aG9kID0gJ1BPU1QnO1xuICBmb3JtLmVuY3R5cGUgPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJztcbiAgZm9ybS5hY2NlcHRDaGFyc2V0ID0gJ1VURi04JztcblxuICBhcmVhID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gIGFyZWEubmFtZSA9ICdkJztcbiAgZm9ybS5hcHBlbmRDaGlsZChhcmVhKTtcblxuICBnbG9iYWwuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1cmwsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gIGRlYnVnKHVybCwgcGF5bG9hZCk7XG4gIGlmICghZm9ybSkge1xuICAgIGNyZWF0ZUZvcm0oKTtcbiAgfVxuICB2YXIgaWQgPSAnYScgKyByYW5kb20uc3RyaW5nKDgpO1xuICBmb3JtLnRhcmdldCA9IGlkO1xuICBmb3JtLmFjdGlvbiA9IHVybFV0aWxzLmFkZFF1ZXJ5KHVybFV0aWxzLmFkZFBhdGgodXJsLCAnL2pzb25wX3NlbmQnKSwgJ2k9JyArIGlkKTtcblxuICB2YXIgaWZyYW1lID0gY3JlYXRlSWZyYW1lKGlkKTtcbiAgaWZyYW1lLmlkID0gaWQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBmb3JtLmFwcGVuZENoaWxkKGlmcmFtZSk7XG5cbiAgdHJ5IHtcbiAgICBhcmVhLnZhbHVlID0gcGF5bG9hZDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIHNlcmlvdXNseSBicm9rZW4gYnJvd3NlcnMgZ2V0IGhlcmVcbiAgfVxuICBmb3JtLnN1Ym1pdCgpO1xuXG4gIHZhciBjb21wbGV0ZWQgPSBmdW5jdGlvbihlcnIpIHtcbiAgICBkZWJ1ZygnY29tcGxldGVkJywgaWQsIGVycik7XG4gICAgaWYgKCFpZnJhbWUub25lcnJvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZnJhbWUub25yZWFkeXN0YXRlY2hhbmdlID0gaWZyYW1lLm9uZXJyb3IgPSBpZnJhbWUub25sb2FkID0gbnVsbDtcbiAgICAvLyBPcGVyYSBtaW5pIGRvZXNuJ3QgbGlrZSBpZiB3ZSBHQyBpZnJhbWVcbiAgICAvLyBpbW1lZGlhdGVseSwgdGh1cyB0aGlzIHRpbWVvdXQuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdjbGVhbmluZyB1cCcsIGlkKTtcbiAgICAgIGlmcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgICBpZnJhbWUgPSBudWxsO1xuICAgIH0sIDUwMCk7XG4gICAgYXJlYS52YWx1ZSA9ICcnO1xuICAgIC8vIEl0IGlzIG5vdCBwb3NzaWJsZSB0byBkZXRlY3QgaWYgdGhlIGlmcmFtZSBzdWNjZWVkZWQgb3JcbiAgICAvLyBmYWlsZWQgdG8gc3VibWl0IG91ciBmb3JtLlxuICAgIGNhbGxiYWNrKGVycik7XG4gIH07XG4gIGlmcmFtZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBpZCk7XG4gICAgY29tcGxldGVkKCk7XG4gIH07XG4gIGlmcmFtZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb25sb2FkJywgaWQpO1xuICAgIGNvbXBsZXRlZCgpO1xuICB9O1xuICBpZnJhbWUub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdvbnJlYWR5c3RhdGVjaGFuZ2UnLCBpZCwgaWZyYW1lLnJlYWR5U3RhdGUsIGUpO1xuICAgIGlmIChpZnJhbWUucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgY29tcGxldGVkKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ2Fib3J0ZWQnLCBpZCk7XG4gICAgY29tcGxldGVkKG5ldyBFcnJvcignQWJvcnRlZCcpKTtcbiAgfTtcbn07XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uLy4uL3V0aWxzL3JhbmRvbVwiOjUwLFwiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU1fV0sMzQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBldmVudFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvZXZlbnQnKVxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9icm93c2VyJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpzZW5kZXI6eGRyJyk7XG59XG5cbi8vIFJlZmVyZW5jZXM6XG4vLyAgIGh0dHA6Ly9hamF4aWFuLmNvbS9hcmNoaXZlcy8xMDAtbGluZS1hamF4LXdyYXBwZXJcbi8vICAgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2NjMjg4MDYwKHY9VlMuODUpLmFzcHhcblxuZnVuY3Rpb24gWERST2JqZWN0KG1ldGhvZCwgdXJsLCBwYXlsb2FkKSB7XG4gIGRlYnVnKG1ldGhvZCwgdXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuX3N0YXJ0KG1ldGhvZCwgdXJsLCBwYXlsb2FkKTtcbiAgfSwgMCk7XG59XG5cbmluaGVyaXRzKFhEUk9iamVjdCwgRXZlbnRFbWl0dGVyKTtcblxuWERST2JqZWN0LnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbihtZXRob2QsIHVybCwgcGF5bG9hZCkge1xuICBkZWJ1ZygnX3N0YXJ0Jyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHhkciA9IG5ldyBnbG9iYWwuWERvbWFpblJlcXVlc3QoKTtcbiAgLy8gSUUgY2FjaGVzIGV2ZW4gUE9TVHNcbiAgdXJsID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsLCAndD0nICsgKCtuZXcgRGF0ZSgpKSk7XG5cbiAgeGRyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicpO1xuICAgIHNlbGYuX2Vycm9yKCk7XG4gIH07XG4gIHhkci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb250aW1lb3V0Jyk7XG4gICAgc2VsZi5fZXJyb3IoKTtcbiAgfTtcbiAgeGRyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygncHJvZ3Jlc3MnLCB4ZHIucmVzcG9uc2VUZXh0KTtcbiAgICBzZWxmLmVtaXQoJ2NodW5rJywgMjAwLCB4ZHIucmVzcG9uc2VUZXh0KTtcbiAgfTtcbiAgeGRyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdsb2FkJyk7XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnLCAyMDAsIHhkci5yZXNwb25zZVRleHQpO1xuICAgIHNlbGYuX2NsZWFudXAoZmFsc2UpO1xuICB9O1xuICB0aGlzLnhkciA9IHhkcjtcbiAgdGhpcy51bmxvYWRSZWYgPSBldmVudFV0aWxzLnVubG9hZEFkZChmdW5jdGlvbigpIHtcbiAgICBzZWxmLl9jbGVhbnVwKHRydWUpO1xuICB9KTtcbiAgdHJ5IHtcbiAgICAvLyBGYWlscyB3aXRoIEFjY2Vzc0RlbmllZCBpZiBwb3J0IG51bWJlciBpcyBib2d1c1xuICAgIHRoaXMueGRyLm9wZW4obWV0aG9kLCB1cmwpO1xuICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgIHRoaXMueGRyLnRpbWVvdXQgPSB0aGlzLnRpbWVvdXQ7XG4gICAgfVxuICAgIHRoaXMueGRyLnNlbmQocGF5bG9hZCk7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICB0aGlzLl9lcnJvcigpO1xuICB9XG59O1xuXG5YRFJPYmplY3QucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVtaXQoJ2ZpbmlzaCcsIDAsICcnKTtcbiAgdGhpcy5fY2xlYW51cChmYWxzZSk7XG59O1xuXG5YRFJPYmplY3QucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oYWJvcnQpIHtcbiAgZGVidWcoJ2NsZWFudXAnLCBhYm9ydCk7XG4gIGlmICghdGhpcy54ZHIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgZXZlbnRVdGlscy51bmxvYWREZWwodGhpcy51bmxvYWRSZWYpO1xuXG4gIHRoaXMueGRyLm9udGltZW91dCA9IHRoaXMueGRyLm9uZXJyb3IgPSB0aGlzLnhkci5vbnByb2dyZXNzID0gdGhpcy54ZHIub25sb2FkID0gbnVsbDtcbiAgaWYgKGFib3J0KSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMueGRyLmFib3J0KCk7XG4gICAgfSBjYXRjaCAoeCkge1xuICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgIH1cbiAgfVxuICB0aGlzLnVubG9hZFJlZiA9IHRoaXMueGRyID0gbnVsbDtcbn07XG5cblhEUk9iamVjdC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMuX2NsZWFudXAodHJ1ZSk7XG59O1xuXG4vLyBJRSA4LzkgaWYgdGhlIHJlcXVlc3QgdGFyZ2V0IHVzZXMgdGhlIHNhbWUgc2NoZW1lIC0gIzc5XG5YRFJPYmplY3QuZW5hYmxlZCA9ICEhKGdsb2JhbC5YRG9tYWluUmVxdWVzdCAmJiBicm93c2VyLmhhc0RvbWFpbigpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBYRFJPYmplY3Q7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uLy4uL3V0aWxzL2Jyb3dzZXJcIjo0NCxcIi4uLy4uL3V0aWxzL2V2ZW50XCI6NDYsXCIuLi8uLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDM1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIFhockRyaXZlciA9IHJlcXVpcmUoJy4uL2RyaXZlci94aHInKVxuICA7XG5cbmZ1bmN0aW9uIFhIUkNvcnNPYmplY3QobWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpIHtcbiAgWGhyRHJpdmVyLmNhbGwodGhpcywgbWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpO1xufVxuXG5pbmhlcml0cyhYSFJDb3JzT2JqZWN0LCBYaHJEcml2ZXIpO1xuXG5YSFJDb3JzT2JqZWN0LmVuYWJsZWQgPSBYaHJEcml2ZXIuZW5hYmxlZCAmJiBYaHJEcml2ZXIuc3VwcG9ydHNDT1JTO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhIUkNvcnNPYmplY3Q7XG5cbn0se1wiLi4vZHJpdmVyL3hoclwiOjE3LFwiaW5oZXJpdHNcIjo1N31dLDM2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICA7XG5cbmZ1bmN0aW9uIFhIUkZha2UoLyogbWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMgKi8pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB0aGlzLnRvID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIDIwMCwgJ3t9Jyk7XG4gIH0sIFhIUkZha2UudGltZW91dCk7XG59XG5cbmluaGVyaXRzKFhIUkZha2UsIEV2ZW50RW1pdHRlcik7XG5cblhIUkZha2UucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGNsZWFyVGltZW91dCh0aGlzLnRvKTtcbn07XG5cblhIUkZha2UudGltZW91dCA9IDIwMDA7XG5cbm1vZHVsZS5leHBvcnRzID0gWEhSRmFrZTtcblxufSx7XCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDM3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIFhockRyaXZlciA9IHJlcXVpcmUoJy4uL2RyaXZlci94aHInKVxuICA7XG5cbmZ1bmN0aW9uIFhIUkxvY2FsT2JqZWN0KG1ldGhvZCwgdXJsLCBwYXlsb2FkIC8qLCBvcHRzICovKSB7XG4gIFhockRyaXZlci5jYWxsKHRoaXMsIG1ldGhvZCwgdXJsLCBwYXlsb2FkLCB7XG4gICAgbm9DcmVkZW50aWFsczogdHJ1ZVxuICB9KTtcbn1cblxuaW5oZXJpdHMoWEhSTG9jYWxPYmplY3QsIFhockRyaXZlcik7XG5cblhIUkxvY2FsT2JqZWN0LmVuYWJsZWQgPSBYaHJEcml2ZXIuZW5hYmxlZDtcblxubW9kdWxlLmV4cG9ydHMgPSBYSFJMb2NhbE9iamVjdDtcblxufSx7XCIuLi9kcml2ZXIveGhyXCI6MTcsXCJpbmhlcml0c1wiOjU3fV0sMzg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvZXZlbnQnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXJsJylcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBXZWJzb2NrZXREcml2ZXIgPSByZXF1aXJlKCcuL2RyaXZlci93ZWJzb2NrZXQnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6d2Vic29ja2V0Jyk7XG59XG5cbmZ1bmN0aW9uIFdlYlNvY2tldFRyYW5zcG9ydCh0cmFuc1VybCwgaWdub3JlLCBvcHRpb25zKSB7XG4gIGlmICghV2ViU29ja2V0VHJhbnNwb3J0LmVuYWJsZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG5cbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIGRlYnVnKCdjb25zdHJ1Y3RvcicsIHRyYW5zVXJsKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB1cmwgPSB1cmxVdGlscy5hZGRQYXRoKHRyYW5zVXJsLCAnL3dlYnNvY2tldCcpO1xuICBpZiAodXJsLnNsaWNlKDAsIDUpID09PSAnaHR0cHMnKSB7XG4gICAgdXJsID0gJ3dzcycgKyB1cmwuc2xpY2UoNSk7XG4gIH0gZWxzZSB7XG4gICAgdXJsID0gJ3dzJyArIHVybC5zbGljZSg0KTtcbiAgfVxuICB0aGlzLnVybCA9IHVybDtcblxuICB0aGlzLndzID0gbmV3IFdlYnNvY2tldERyaXZlcih0aGlzLnVybCwgW10sIG9wdGlvbnMpO1xuICB0aGlzLndzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1ZygnbWVzc2FnZSBldmVudCcsIGUuZGF0YSk7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgZS5kYXRhKTtcbiAgfTtcbiAgLy8gRmlyZWZveCBoYXMgYW4gaW50ZXJlc3RpbmcgYnVnLiBJZiBhIHdlYnNvY2tldCBjb25uZWN0aW9uIGlzXG4gIC8vIGNyZWF0ZWQgYWZ0ZXIgb251bmxvYWQsIGl0IHN0YXlzIGFsaXZlIGV2ZW4gd2hlbiB1c2VyXG4gIC8vIG5hdmlnYXRlcyBhd2F5IGZyb20gdGhlIHBhZ2UuIEluIHN1Y2ggc2l0dWF0aW9uIGxldCdzIGxpZSAtXG4gIC8vIGxldCdzIG5vdCBvcGVuIHRoZSB3cyBjb25uZWN0aW9uIGF0IGFsbC4gU2VlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vc29ja2pzL3NvY2tqcy1jbGllbnQvaXNzdWVzLzI4XG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NjA4NVxuICB0aGlzLnVubG9hZFJlZiA9IHV0aWxzLnVubG9hZEFkZChmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygndW5sb2FkJyk7XG4gICAgc2VsZi53cy5jbG9zZSgpO1xuICB9KTtcbiAgdGhpcy53cy5vbmNsb3NlID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdjbG9zZSBldmVudCcsIGUuY29kZSwgZS5yZWFzb24pO1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBlLmNvZGUsIGUucmVhc29uKTtcbiAgICBzZWxmLl9jbGVhbnVwKCk7XG4gIH07XG4gIHRoaXMud3Mub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1ZygnZXJyb3IgZXZlbnQnLCBlKTtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgMTAwNiwgJ1dlYlNvY2tldCBjb25uZWN0aW9uIGJyb2tlbicpO1xuICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgfTtcbn1cblxuaW5oZXJpdHMoV2ViU29ja2V0VHJhbnNwb3J0LCBFdmVudEVtaXR0ZXIpO1xuXG5XZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHZhciBtc2cgPSAnWycgKyBkYXRhICsgJ10nO1xuICBkZWJ1Zygnc2VuZCcsIG1zZyk7XG4gIHRoaXMud3Muc2VuZChtc2cpO1xufTtcblxuV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdmFyIHdzID0gdGhpcy53cztcbiAgdGhpcy5fY2xlYW51cCgpO1xuICBpZiAod3MpIHtcbiAgICB3cy5jbG9zZSgpO1xuICB9XG59O1xuXG5XZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICB2YXIgd3MgPSB0aGlzLndzO1xuICBpZiAod3MpIHtcbiAgICB3cy5vbm1lc3NhZ2UgPSB3cy5vbmNsb3NlID0gd3Mub25lcnJvciA9IG51bGw7XG4gIH1cbiAgdXRpbHMudW5sb2FkRGVsKHRoaXMudW5sb2FkUmVmKTtcbiAgdGhpcy51bmxvYWRSZWYgPSB0aGlzLndzID0gbnVsbDtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbldlYlNvY2tldFRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdlbmFibGVkJyk7XG4gIHJldHVybiAhIVdlYnNvY2tldERyaXZlcjtcbn07XG5XZWJTb2NrZXRUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd3ZWJzb2NrZXQnO1xuXG4vLyBJbiB0aGVvcnksIHdzIHNob3VsZCByZXF1aXJlIDEgcm91bmQgdHJpcC4gQnV0IGluIGNocm9tZSwgdGhpcyBpc1xuLy8gbm90IHZlcnkgc3RhYmxlIG92ZXIgU1NMLiBNb3N0IGxpa2VseSBhIHdzIGNvbm5lY3Rpb24gcmVxdWlyZXMgYVxuLy8gc2VwYXJhdGUgU1NMIGNvbm5lY3Rpb24sIGluIHdoaWNoIGNhc2UgMiByb3VuZCB0cmlwcyBhcmUgYW5cbi8vIGFic29sdXRlIG1pbnVtdW0uXG5XZWJTb2NrZXRUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0VHJhbnNwb3J0O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi4vdXRpbHMvZXZlbnRcIjo0NixcIi4uL3V0aWxzL3VybFwiOjUyLFwiLi9kcml2ZXIvd2Vic29ja2V0XCI6MTksXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwzOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgLCBYZHJTdHJlYW1pbmdUcmFuc3BvcnQgPSByZXF1aXJlKCcuL3hkci1zdHJlYW1pbmcnKVxuICAsIFhoclJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci94aHInKVxuICAsIFhEUk9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hkcicpXG4gIDtcblxuZnVuY3Rpb24gWGRyUG9sbGluZ1RyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIVhEUk9iamVjdC5lbmFibGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcveGhyJywgWGhyUmVjZWl2ZXIsIFhEUk9iamVjdCk7XG59XG5cbmluaGVyaXRzKFhkclBvbGxpbmdUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cblhkclBvbGxpbmdUcmFuc3BvcnQuZW5hYmxlZCA9IFhkclN0cmVhbWluZ1RyYW5zcG9ydC5lbmFibGVkO1xuWGRyUG9sbGluZ1RyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ3hkci1wb2xsaW5nJztcblhkclBvbGxpbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxuXG5tb2R1bGUuZXhwb3J0cyA9IFhkclBvbGxpbmdUcmFuc3BvcnQ7XG5cbn0se1wiLi9saWIvYWpheC1iYXNlZFwiOjI0LFwiLi9yZWNlaXZlci94aHJcIjozMixcIi4vc2VuZGVyL3hkclwiOjM0LFwiLi94ZHItc3RyZWFtaW5nXCI6NDAsXCJpbmhlcml0c1wiOjU3fV0sNDA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gICwgWGhyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL3hocicpXG4gICwgWERST2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGRyJylcbiAgO1xuXG4vLyBBY2NvcmRpbmcgdG86XG4vLyAgIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTY0MTUwNy9kZXRlY3QtYnJvd3Nlci1zdXBwb3J0LWZvci1jcm9zcy1kb21haW4teG1saHR0cHJlcXVlc3RzXG4vLyAgIGh0dHA6Ly9oYWNrcy5tb3ppbGxhLm9yZy8yMDA5LzA3L2Nyb3NzLXNpdGUteG1saHR0cHJlcXVlc3Qtd2l0aC1jb3JzL1xuXG5mdW5jdGlvbiBYZHJTdHJlYW1pbmdUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFYRFJPYmplY3QuZW5hYmxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL3hocl9zdHJlYW1pbmcnLCBYaHJSZWNlaXZlciwgWERST2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoWGRyU3RyZWFtaW5nVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuXG5YZHJTdHJlYW1pbmdUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgaWYgKGluZm8uY29va2llX25lZWRlZCB8fCBpbmZvLm51bGxPcmlnaW4pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIFhEUk9iamVjdC5lbmFibGVkICYmIGluZm8uc2FtZVNjaGVtZTtcbn07XG5cblhkclN0cmVhbWluZ1RyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ3hkci1zdHJlYW1pbmcnO1xuWGRyU3RyZWFtaW5nVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyOyAvLyBwcmVmbGlnaHQsIGFqYXhcblxubW9kdWxlLmV4cG9ydHMgPSBYZHJTdHJlYW1pbmdUcmFuc3BvcnQ7XG5cbn0se1wiLi9saWIvYWpheC1iYXNlZFwiOjI0LFwiLi9yZWNlaXZlci94aHJcIjozMixcIi4vc2VuZGVyL3hkclwiOjM0LFwiaW5oZXJpdHNcIjo1N31dLDQxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICAsIFhoclJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci94aHInKVxuICAsIFhIUkNvcnNPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItY29ycycpXG4gICwgWEhSTG9jYWxPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItbG9jYWwnKVxuICA7XG5cbmZ1bmN0aW9uIFhoclBvbGxpbmdUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFYSFJMb2NhbE9iamVjdC5lbmFibGVkICYmICFYSFJDb3JzT2JqZWN0LmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy94aHInLCBYaHJSZWNlaXZlciwgWEhSQ29yc09iamVjdCk7XG59XG5cbmluaGVyaXRzKFhoclBvbGxpbmdUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cblhoclBvbGxpbmdUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgaWYgKGluZm8ubnVsbE9yaWdpbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChYSFJMb2NhbE9iamVjdC5lbmFibGVkICYmIGluZm8uc2FtZU9yaWdpbikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBYSFJDb3JzT2JqZWN0LmVuYWJsZWQ7XG59O1xuXG5YaHJQb2xsaW5nVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAneGhyLXBvbGxpbmcnO1xuWGhyUG9sbGluZ1RyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjsgLy8gcHJlZmxpZ2h0LCBhamF4XG5cbm1vZHVsZS5leHBvcnRzID0gWGhyUG9sbGluZ1RyYW5zcG9ydDtcblxufSx7XCIuL2xpYi9hamF4LWJhc2VkXCI6MjQsXCIuL3JlY2VpdmVyL3hoclwiOjMyLFwiLi9zZW5kZXIveGhyLWNvcnNcIjozNSxcIi4vc2VuZGVyL3hoci1sb2NhbFwiOjM3LFwiaW5oZXJpdHNcIjo1N31dLDQyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICAsIFhoclJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci94aHInKVxuICAsIFhIUkNvcnNPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItY29ycycpXG4gICwgWEhSTG9jYWxPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItbG9jYWwnKVxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuLi91dGlscy9icm93c2VyJylcbiAgO1xuXG5mdW5jdGlvbiBYaHJTdHJlYW1pbmdUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFYSFJMb2NhbE9iamVjdC5lbmFibGVkICYmICFYSFJDb3JzT2JqZWN0LmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy94aHJfc3RyZWFtaW5nJywgWGhyUmVjZWl2ZXIsIFhIUkNvcnNPYmplY3QpO1xufVxuXG5pbmhlcml0cyhYaHJTdHJlYW1pbmdUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cblhoclN0cmVhbWluZ1RyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oaW5mbykge1xuICBpZiAoaW5mby5udWxsT3JpZ2luKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIE9wZXJhIGRvZXNuJ3Qgc3VwcG9ydCB4aHItc3RyZWFtaW5nICM2MFxuICAvLyBCdXQgaXQgbWlnaHQgYmUgYWJsZSB0byAjOTJcbiAgaWYgKGJyb3dzZXIuaXNPcGVyYSgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIFhIUkNvcnNPYmplY3QuZW5hYmxlZDtcbn07XG5cblhoclN0cmVhbWluZ1RyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ3hoci1zdHJlYW1pbmcnO1xuWGhyU3RyZWFtaW5nVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyOyAvLyBwcmVmbGlnaHQsIGFqYXhcblxuLy8gU2FmYXJpIGdldHMgY29uZnVzZWQgd2hlbiBhIHN0cmVhbWluZyBhamF4IHJlcXVlc3QgaXMgc3RhcnRlZFxuLy8gYmVmb3JlIG9ubG9hZC4gVGhpcyBjYXVzZXMgdGhlIGxvYWQgaW5kaWNhdG9yIHRvIHNwaW4gaW5kZWZpbmV0ZWx5LlxuLy8gT25seSByZXF1aXJlIGJvZHkgd2hlbiB1c2VkIGluIGEgYnJvd3NlclxuWGhyU3RyZWFtaW5nVHJhbnNwb3J0Lm5lZWRCb2R5ID0gISFnbG9iYWwuZG9jdW1lbnQ7XG5cbm1vZHVsZS5leHBvcnRzID0gWGhyU3RyZWFtaW5nVHJhbnNwb3J0O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuLi91dGlscy9icm93c2VyXCI6NDQsXCIuL2xpYi9hamF4LWJhc2VkXCI6MjQsXCIuL3JlY2VpdmVyL3hoclwiOjMyLFwiLi9zZW5kZXIveGhyLWNvcnNcIjozNSxcIi4vc2VuZGVyL3hoci1sb2NhbFwiOjM3LFwiaW5oZXJpdHNcIjo1N31dLDQzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxuaWYgKGdsb2JhbC5jcnlwdG8gJiYgZ2xvYmFsLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgbW9kdWxlLmV4cG9ydHMucmFuZG9tQnl0ZXMgPSBmdW5jdGlvbihsZW5ndGgpIHtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIGdsb2JhbC5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGJ5dGVzKTtcbiAgICByZXR1cm4gYnl0ZXM7XG4gIH07XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cy5yYW5kb21CeXRlcyA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgIHZhciBieXRlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ5dGVzW2ldID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9O1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sNDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNPcGVyYTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5uYXZpZ2F0b3IgJiZcbiAgICAgIC9vcGVyYS9pLnRlc3QoZ2xvYmFsLm5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiwgaXNLb25xdWVyb3I6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBnbG9iYWwubmF2aWdhdG9yICYmXG4gICAgICAva29ucXVlcm9yL2kudGVzdChnbG9iYWwubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH1cblxuICAvLyAjMTg3IHdyYXAgZG9jdW1lbnQuZG9tYWluIGluIHRyeS9jYXRjaCBiZWNhdXNlIG9mIFdQOCBmcm9tIGZpbGU6Ly8vXG4sIGhhc0RvbWFpbjogZnVuY3Rpb24gKCkge1xuICAgIC8vIG5vbi1icm93c2VyIGNsaWVudCBhbHdheXMgaGFzIGEgZG9tYWluXG4gICAgaWYgKCFnbG9iYWwuZG9jdW1lbnQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gISFnbG9iYWwuZG9jdW1lbnQuZG9tYWluO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSw0NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJyk7XG5cbi8vIFNvbWUgZXh0cmEgY2hhcmFjdGVycyB0aGF0IENocm9tZSBnZXRzIHdyb25nLCBhbmQgc3Vic3RpdHV0ZXMgd2l0aFxuLy8gc29tZXRoaW5nIGVsc2Ugb24gdGhlIHdpcmUuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxudmFyIGV4dHJhRXNjYXBhYmxlID0gL1tcXHgwMC1cXHgxZlxcdWQ4MDAtXFx1ZGZmZlxcdWZmZmVcXHVmZmZmXFx1MDMwMC1cXHUwMzMzXFx1MDMzZC1cXHUwMzQ2XFx1MDM0YS1cXHUwMzRjXFx1MDM1MC1cXHUwMzUyXFx1MDM1Ny1cXHUwMzU4XFx1MDM1Yy1cXHUwMzYyXFx1MDM3NFxcdTAzN2VcXHUwMzg3XFx1MDU5MS1cXHUwNWFmXFx1MDVjNFxcdTA2MTAtXFx1MDYxN1xcdTA2NTMtXFx1MDY1NFxcdTA2NTctXFx1MDY1YlxcdTA2NWQtXFx1MDY1ZVxcdTA2ZGYtXFx1MDZlMlxcdTA2ZWItXFx1MDZlY1xcdTA3MzBcXHUwNzMyLVxcdTA3MzNcXHUwNzM1LVxcdTA3MzZcXHUwNzNhXFx1MDczZFxcdTA3M2YtXFx1MDc0MVxcdTA3NDNcXHUwNzQ1XFx1MDc0N1xcdTA3ZWItXFx1MDdmMVxcdTA5NTFcXHUwOTU4LVxcdTA5NWZcXHUwOWRjLVxcdTA5ZGRcXHUwOWRmXFx1MGEzM1xcdTBhMzZcXHUwYTU5LVxcdTBhNWJcXHUwYTVlXFx1MGI1Yy1cXHUwYjVkXFx1MGUzOC1cXHUwZTM5XFx1MGY0M1xcdTBmNGRcXHUwZjUyXFx1MGY1N1xcdTBmNWNcXHUwZjY5XFx1MGY3Mi1cXHUwZjc2XFx1MGY3OFxcdTBmODAtXFx1MGY4M1xcdTBmOTNcXHUwZjlkXFx1MGZhMlxcdTBmYTdcXHUwZmFjXFx1MGZiOVxcdTE5MzktXFx1MTkzYVxcdTFhMTdcXHUxYjZiXFx1MWNkYS1cXHUxY2RiXFx1MWRjMC1cXHUxZGNmXFx1MWRmY1xcdTFkZmVcXHUxZjcxXFx1MWY3M1xcdTFmNzVcXHUxZjc3XFx1MWY3OVxcdTFmN2JcXHUxZjdkXFx1MWZiYlxcdTFmYmVcXHUxZmM5XFx1MWZjYlxcdTFmZDNcXHUxZmRiXFx1MWZlM1xcdTFmZWJcXHUxZmVlLVxcdTFmZWZcXHUxZmY5XFx1MWZmYlxcdTFmZmRcXHUyMDAwLVxcdTIwMDFcXHUyMGQwLVxcdTIwZDFcXHUyMGQ0LVxcdTIwZDdcXHUyMGU3LVxcdTIwZTlcXHUyMTI2XFx1MjEyYS1cXHUyMTJiXFx1MjMyOS1cXHUyMzJhXFx1MmFkY1xcdTMwMmItXFx1MzAyY1xcdWFhYjItXFx1YWFiM1xcdWY5MDAtXFx1ZmEwZFxcdWZhMTBcXHVmYTEyXFx1ZmExNS1cXHVmYTFlXFx1ZmEyMFxcdWZhMjJcXHVmYTI1LVxcdWZhMjZcXHVmYTJhLVxcdWZhMmRcXHVmYTMwLVxcdWZhNmRcXHVmYTcwLVxcdWZhZDlcXHVmYjFkXFx1ZmIxZlxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwLVxcdWZiNDFcXHVmYjQzLVxcdWZiNDRcXHVmYjQ2LVxcdWZiNGVcXHVmZmYwLVxcdWZmZmZdL2dcbiAgLCBleHRyYUxvb2t1cDtcblxuLy8gVGhpcyBtYXkgYmUgcXVpdGUgc2xvdywgc28gbGV0J3MgZGVsYXkgdW50aWwgdXNlciBhY3R1YWxseSB1c2VzIGJhZFxuLy8gY2hhcmFjdGVycy5cbnZhciB1bnJvbGxMb29rdXAgPSBmdW5jdGlvbihlc2NhcGFibGUpIHtcbiAgdmFyIGk7XG4gIHZhciB1bnJvbGxlZCA9IHt9O1xuICB2YXIgYyA9IFtdO1xuICBmb3IgKGkgPSAwOyBpIDwgNjU1MzY7IGkrKykge1xuICAgIGMucHVzaCggU3RyaW5nLmZyb21DaGFyQ29kZShpKSApO1xuICB9XG4gIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICBjLmpvaW4oJycpLnJlcGxhY2UoZXNjYXBhYmxlLCBmdW5jdGlvbihhKSB7XG4gICAgdW5yb2xsZWRbIGEgXSA9ICdcXFxcdScgKyAoJzAwMDAnICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgIHJldHVybiAnJztcbiAgfSk7XG4gIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICByZXR1cm4gdW5yb2xsZWQ7XG59O1xuXG4vLyBRdW90ZSBzdHJpbmcsIGFsc28gdGFraW5nIGNhcmUgb2YgdW5pY29kZSBjaGFyYWN0ZXJzIHRoYXQgYnJvd3NlcnNcbi8vIG9mdGVuIGJyZWFrLiBFc3BlY2lhbGx5LCB0YWtlIGNhcmUgb2YgdW5pY29kZSBzdXJyb2dhdGVzOlxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYXBwaW5nX29mX1VuaWNvZGVfY2hhcmFjdGVycyNTdXJyb2dhdGVzXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcXVvdGU6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciBxdW90ZWQgPSBKU09OMy5zdHJpbmdpZnkoc3RyaW5nKTtcblxuICAgIC8vIEluIG1vc3QgY2FzZXMgdGhpcyBzaG91bGQgYmUgdmVyeSBmYXN0IGFuZCBnb29kIGVub3VnaC5cbiAgICBleHRyYUVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgIGlmICghZXh0cmFFc2NhcGFibGUudGVzdChxdW90ZWQpKSB7XG4gICAgICByZXR1cm4gcXVvdGVkO1xuICAgIH1cblxuICAgIGlmICghZXh0cmFMb29rdXApIHtcbiAgICAgIGV4dHJhTG9va3VwID0gdW5yb2xsTG9va3VwKGV4dHJhRXNjYXBhYmxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcXVvdGVkLnJlcGxhY2UoZXh0cmFFc2NhcGFibGUsIGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiBleHRyYUxvb2t1cFthXTtcbiAgICB9KTtcbiAgfVxufTtcblxufSx7XCJqc29uM1wiOjU4fV0sNDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmFuZG9tID0gcmVxdWlyZSgnLi9yYW5kb20nKTtcblxudmFyIG9uVW5sb2FkID0ge31cbiAgLCBhZnRlclVubG9hZCA9IGZhbHNlXG4gICAgLy8gZGV0ZWN0IGdvb2dsZSBjaHJvbWUgcGFja2FnZWQgYXBwcyBiZWNhdXNlIHRoZXkgZG9uJ3QgYWxsb3cgdGhlICd1bmxvYWQnIGV2ZW50XG4gICwgaXNDaHJvbWVQYWNrYWdlZEFwcCA9IGdsb2JhbC5jaHJvbWUgJiYgZ2xvYmFsLmNocm9tZS5hcHAgJiYgZ2xvYmFsLmNocm9tZS5hcHAucnVudGltZVxuICA7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhdHRhY2hFdmVudDogZnVuY3Rpb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLmRvY3VtZW50ICYmIGdsb2JhbC5hdHRhY2hFdmVudCkge1xuICAgICAgLy8gSUUgcXVpcmtzLlxuICAgICAgLy8gQWNjb3JkaW5nIHRvOiBodHRwOi8vc3RldmVzb3VkZXJzLmNvbS9taXNjL3Rlc3QtcG9zdG1lc3NhZ2UucGhwXG4gICAgICAvLyB0aGUgbWVzc2FnZSBnZXRzIGRlbGl2ZXJlZCBvbmx5IHRvICdkb2N1bWVudCcsIG5vdCAnd2luZG93Jy5cbiAgICAgIGdsb2JhbC5kb2N1bWVudC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgIC8vIEkgZ2V0ICd3aW5kb3cnIGZvciBpZTguXG4gICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICB9XG5cbiwgZGV0YWNoRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBnbG9iYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5kb2N1bWVudCAmJiBnbG9iYWwuZGV0YWNoRXZlbnQpIHtcbiAgICAgIGdsb2JhbC5kb2N1bWVudC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgIGdsb2JhbC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH1cblxuLCB1bmxvYWRBZGQ6IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgaWYgKGlzQ2hyb21lUGFja2FnZWRBcHApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciByZWYgPSByYW5kb20uc3RyaW5nKDgpO1xuICAgIG9uVW5sb2FkW3JlZl0gPSBsaXN0ZW5lcjtcbiAgICBpZiAoYWZ0ZXJVbmxvYWQpIHtcbiAgICAgIHNldFRpbWVvdXQodGhpcy50cmlnZ2VyVW5sb2FkQ2FsbGJhY2tzLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZjtcbiAgfVxuXG4sIHVubG9hZERlbDogZnVuY3Rpb24ocmVmKSB7XG4gICAgaWYgKHJlZiBpbiBvblVubG9hZCkge1xuICAgICAgZGVsZXRlIG9uVW5sb2FkW3JlZl07XG4gICAgfVxuICB9XG5cbiwgdHJpZ2dlclVubG9hZENhbGxiYWNrczogZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgcmVmIGluIG9uVW5sb2FkKSB7XG4gICAgICBvblVubG9hZFtyZWZdKCk7XG4gICAgICBkZWxldGUgb25VbmxvYWRbcmVmXTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB1bmxvYWRUcmlnZ2VyZWQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKGFmdGVyVW5sb2FkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFmdGVyVW5sb2FkID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMudHJpZ2dlclVubG9hZENhbGxiYWNrcygpO1xufTtcblxuLy8gJ3VubG9hZCcgYWxvbmUgaXMgbm90IHJlbGlhYmxlIGluIG9wZXJhIHdpdGhpbiBhbiBpZnJhbWUsIGJ1dCB3ZVxuLy8gY2FuJ3QgdXNlIGBiZWZvcmV1bmxvYWRgIGFzIElFIGZpcmVzIGl0IG9uIGphdmFzY3JpcHQ6IGxpbmtzLlxuaWYgKCFpc0Nocm9tZVBhY2thZ2VkQXBwKSB7XG4gIG1vZHVsZS5leHBvcnRzLmF0dGFjaEV2ZW50KCd1bmxvYWQnLCB1bmxvYWRUcmlnZ2VyZWQpO1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL3JhbmRvbVwiOjUwfV0sNDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBldmVudFV0aWxzID0gcmVxdWlyZSgnLi9ldmVudCcpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgYnJvd3NlciA9IHJlcXVpcmUoJy4vYnJvd3NlcicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp1dGlsczppZnJhbWUnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdQcmVmaXg6ICdfanAnXG4sIGN1cnJlbnRXaW5kb3dJZDogbnVsbFxuXG4sIHBvbGx1dGVHbG9iYWxOYW1lc3BhY2U6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghKG1vZHVsZS5leHBvcnRzLldQcmVmaXggaW4gZ2xvYmFsKSkge1xuICAgICAgZ2xvYmFsW21vZHVsZS5leHBvcnRzLldQcmVmaXhdID0ge307XG4gICAgfVxuICB9XG5cbiwgcG9zdE1lc3NhZ2U6IGZ1bmN0aW9uKHR5cGUsIGRhdGEpIHtcbiAgICBpZiAoZ2xvYmFsLnBhcmVudCAhPT0gZ2xvYmFsKSB7XG4gICAgICBnbG9iYWwucGFyZW50LnBvc3RNZXNzYWdlKEpTT04zLnN0cmluZ2lmeSh7XG4gICAgICAgIHdpbmRvd0lkOiBtb2R1bGUuZXhwb3J0cy5jdXJyZW50V2luZG93SWRcbiAgICAgICwgdHlwZTogdHlwZVxuICAgICAgLCBkYXRhOiBkYXRhIHx8ICcnXG4gICAgICB9KSwgJyonKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ0Nhbm5vdCBwb3N0TWVzc2FnZSwgbm8gcGFyZW50IHdpbmRvdy4nLCB0eXBlLCBkYXRhKTtcbiAgICB9XG4gIH1cblxuLCBjcmVhdGVJZnJhbWU6IGZ1bmN0aW9uKGlmcmFtZVVybCwgZXJyb3JDYWxsYmFjaykge1xuICAgIHZhciBpZnJhbWUgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgdmFyIHRyZWYsIHVubG9hZFJlZjtcbiAgICB2YXIgdW5hdHRhY2ggPSBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCd1bmF0dGFjaCcpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xuICAgICAgLy8gRXhwbG9yZXIgaGFkIHByb2JsZW1zIHdpdGggdGhhdC5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmcmFtZS5vbmxvYWQgPSBudWxsO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICB9XG4gICAgICBpZnJhbWUub25lcnJvciA9IG51bGw7XG4gICAgfTtcbiAgICB2YXIgY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAgIGlmIChpZnJhbWUpIHtcbiAgICAgICAgdW5hdHRhY2goKTtcbiAgICAgICAgLy8gVGhpcyB0aW1lb3V0IG1ha2VzIGNocm9tZSBmaXJlIG9uYmVmb3JldW5sb2FkIGV2ZW50XG4gICAgICAgIC8vIHdpdGhpbiBpZnJhbWUuIFdpdGhvdXQgdGhlIHRpbWVvdXQgaXQgZ29lcyBzdHJhaWdodCB0b1xuICAgICAgICAvLyBvbnVubG9hZC5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoaWZyYW1lKSB7XG4gICAgICAgICAgICBpZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZnJhbWUgPSBudWxsO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgZXZlbnRVdGlscy51bmxvYWREZWwodW5sb2FkUmVmKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBvbmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICBkZWJ1Zygnb25lcnJvcicsIGVycik7XG4gICAgICBpZiAoaWZyYW1lKSB7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgZXJyb3JDYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHBvc3QgPSBmdW5jdGlvbihtc2csIG9yaWdpbikge1xuICAgICAgZGVidWcoJ3Bvc3QnLCBtc2csIG9yaWdpbik7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBXaGVuIHRoZSBpZnJhbWUgaXMgbm90IGxvYWRlZCwgSUUgcmFpc2VzIGFuIGV4Y2VwdGlvblxuICAgICAgICAvLyBvbiAnY29udGVudFdpbmRvdycuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGlmcmFtZSAmJiBpZnJhbWUuY29udGVudFdpbmRvdykge1xuICAgICAgICAgICAgaWZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UobXNnLCBvcmlnaW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWZyYW1lLnNyYyA9IGlmcmFtZVVybDtcbiAgICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBpZnJhbWUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGlmcmFtZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICBvbmVycm9yKCdvbmVycm9yJyk7XG4gICAgfTtcbiAgICBpZnJhbWUub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1Zygnb25sb2FkJyk7XG4gICAgICAvLyBgb25sb2FkYCBpcyB0cmlnZ2VyZWQgYmVmb3JlIHNjcmlwdHMgb24gdGhlIGlmcmFtZSBhcmVcbiAgICAgIC8vIGV4ZWN1dGVkLiBHaXZlIGl0IGZldyBzZWNvbmRzIHRvIGFjdHVhbGx5IGxvYWQgc3R1ZmYuXG4gICAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gICAgICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgb25lcnJvcignb25sb2FkIHRpbWVvdXQnKTtcbiAgICAgIH0sIDIwMDApO1xuICAgIH07XG4gICAgZ2xvYmFsLmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIG9uZXJyb3IoJ3RpbWVvdXQnKTtcbiAgICB9LCAxNTAwMCk7XG4gICAgdW5sb2FkUmVmID0gZXZlbnRVdGlscy51bmxvYWRBZGQoY2xlYW51cCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc3Q6IHBvc3RcbiAgICAsIGNsZWFudXA6IGNsZWFudXBcbiAgICAsIGxvYWRlZDogdW5hdHRhY2hcbiAgICB9O1xuICB9XG5cbi8qIGVzbGludCBuby11bmRlZjogXCJvZmZcIiwgbmV3LWNhcDogXCJvZmZcIiAqL1xuLCBjcmVhdGVIdG1sZmlsZTogZnVuY3Rpb24oaWZyYW1lVXJsLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgdmFyIGF4byA9IFsnQWN0aXZlJ10uY29uY2F0KCdPYmplY3QnKS5qb2luKCdYJyk7XG4gICAgdmFyIGRvYyA9IG5ldyBnbG9iYWxbYXhvXSgnaHRtbGZpbGUnKTtcbiAgICB2YXIgdHJlZiwgdW5sb2FkUmVmO1xuICAgIHZhciBpZnJhbWU7XG4gICAgdmFyIHVuYXR0YWNoID0gZnVuY3Rpb24oKSB7XG4gICAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gICAgICBpZnJhbWUub25lcnJvciA9IG51bGw7XG4gICAgfTtcbiAgICB2YXIgY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGRvYykge1xuICAgICAgICB1bmF0dGFjaCgpO1xuICAgICAgICBldmVudFV0aWxzLnVubG9hZERlbCh1bmxvYWRSZWYpO1xuICAgICAgICBpZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgICAgICBpZnJhbWUgPSBkb2MgPSBudWxsO1xuICAgICAgICBDb2xsZWN0R2FyYmFnZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIG9uZXJyb3IgPSBmdW5jdGlvbihyKSB7XG4gICAgICBkZWJ1Zygnb25lcnJvcicsIHIpO1xuICAgICAgaWYgKGRvYykge1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIGVycm9yQ2FsbGJhY2socik7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcG9zdCA9IGZ1bmN0aW9uKG1zZywgb3JpZ2luKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBXaGVuIHRoZSBpZnJhbWUgaXMgbm90IGxvYWRlZCwgSUUgcmFpc2VzIGFuIGV4Y2VwdGlvblxuICAgICAgICAvLyBvbiAnY29udGVudFdpbmRvdycuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGlmcmFtZSAmJiBpZnJhbWUuY29udGVudFdpbmRvdykge1xuICAgICAgICAgICAgICBpZnJhbWUuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShtc2csIG9yaWdpbik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgfVxuICAgIH07XG5cbiAgICBkb2Mub3BlbigpO1xuICAgIGRvYy53cml0ZSgnPGh0bWw+PHMnICsgJ2NyaXB0PicgK1xuICAgICAgICAgICAgICAnZG9jdW1lbnQuZG9tYWluPVwiJyArIGdsb2JhbC5kb2N1bWVudC5kb21haW4gKyAnXCI7JyArXG4gICAgICAgICAgICAgICc8L3MnICsgJ2NyaXB0PjwvaHRtbD4nKTtcbiAgICBkb2MuY2xvc2UoKTtcbiAgICBkb2MucGFyZW50V2luZG93W21vZHVsZS5leHBvcnRzLldQcmVmaXhdID0gZ2xvYmFsW21vZHVsZS5leHBvcnRzLldQcmVmaXhdO1xuICAgIHZhciBjID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRvYy5ib2R5LmFwcGVuZENoaWxkKGMpO1xuICAgIGlmcmFtZSA9IGRvYy5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICBjLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgaWZyYW1lLnNyYyA9IGlmcmFtZVVybDtcbiAgICBpZnJhbWUub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgb25lcnJvcignb25lcnJvcicpO1xuICAgIH07XG4gICAgdHJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBvbmVycm9yKCd0aW1lb3V0Jyk7XG4gICAgfSwgMTUwMDApO1xuICAgIHVubG9hZFJlZiA9IGV2ZW50VXRpbHMudW5sb2FkQWRkKGNsZWFudXApO1xuICAgIHJldHVybiB7XG4gICAgICBwb3N0OiBwb3N0XG4gICAgLCBjbGVhbnVwOiBjbGVhbnVwXG4gICAgLCBsb2FkZWQ6IHVuYXR0YWNoXG4gICAgfTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuaWZyYW1lRW5hYmxlZCA9IGZhbHNlO1xuaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICAvLyBwb3N0TWVzc2FnZSBtaXNiZWhhdmVzIGluIGtvbnF1ZXJvciA0LjYuNSAtIHRoZSBtZXNzYWdlcyBhcmUgZGVsaXZlcmVkIHdpdGhcbiAgLy8gaHVnZSBkZWxheSwgb3Igbm90IGF0IGFsbC5cbiAgbW9kdWxlLmV4cG9ydHMuaWZyYW1lRW5hYmxlZCA9ICh0eXBlb2YgZ2xvYmFsLnBvc3RNZXNzYWdlID09PSAnZnVuY3Rpb24nIHx8XG4gICAgdHlwZW9mIGdsb2JhbC5wb3N0TWVzc2FnZSA9PT0gJ29iamVjdCcpICYmICghYnJvd3Nlci5pc0tvbnF1ZXJvcigpKTtcbn1cblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi9icm93c2VyXCI6NDQsXCIuL2V2ZW50XCI6NDYsXCJkZWJ1Z1wiOjU1LFwianNvbjNcIjo1OH1dLDQ4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGxvZ09iamVjdCA9IHt9O1xuWydsb2cnLCAnZGVidWcnLCAnd2FybiddLmZvckVhY2goZnVuY3Rpb24gKGxldmVsKSB7XG4gIHZhciBsZXZlbEV4aXN0cztcblxuICB0cnkge1xuICAgIGxldmVsRXhpc3RzID0gZ2xvYmFsLmNvbnNvbGUgJiYgZ2xvYmFsLmNvbnNvbGVbbGV2ZWxdICYmIGdsb2JhbC5jb25zb2xlW2xldmVsXS5hcHBseTtcbiAgfSBjYXRjaChlKSB7XG4gICAgLy8gZG8gbm90aGluZ1xuICB9XG5cbiAgbG9nT2JqZWN0W2xldmVsXSA9IGxldmVsRXhpc3RzID8gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnbG9iYWwuY29uc29sZVtsZXZlbF0uYXBwbHkoZ2xvYmFsLmNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gIH0gOiAobGV2ZWwgPT09ICdsb2cnID8gZnVuY3Rpb24gKCkge30gOiBsb2dPYmplY3QubG9nKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxvZ09iamVjdDtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se31dLDQ5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzT2JqZWN0OiBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmo7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZSA9PT0gJ29iamVjdCcgJiYgISFvYmo7XG4gIH1cblxuLCBleHRlbmQ6IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghdGhpcy5pc09iamVjdChvYmopKSB7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICB2YXIgc291cmNlLCBwcm9wO1xuICAgIGZvciAodmFyIGkgPSAxLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAocHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIHByb3ApKSB7XG4gICAgICAgICAgb2JqW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cbn07XG5cbn0se31dLDUwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLyogZ2xvYmFsIGNyeXB0bzp0cnVlICovXG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbi8vIFRoaXMgc3RyaW5nIGhhcyBsZW5ndGggMzIsIGEgcG93ZXIgb2YgMiwgc28gdGhlIG1vZHVsdXMgZG9lc24ndCBpbnRyb2R1Y2UgYVxuLy8gYmlhcy5cbnZhciBfcmFuZG9tU3RyaW5nQ2hhcnMgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDUnO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN0cmluZzogZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgdmFyIG1heCA9IF9yYW5kb21TdHJpbmdDaGFycy5sZW5ndGg7XG4gICAgdmFyIGJ5dGVzID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGxlbmd0aCk7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJldC5wdXNoKF9yYW5kb21TdHJpbmdDaGFycy5zdWJzdHIoYnl0ZXNbaV0gJSBtYXgsIDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldC5qb2luKCcnKTtcbiAgfVxuXG4sIG51bWJlcjogZnVuY3Rpb24obWF4KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG1heCk7XG4gIH1cblxuLCBudW1iZXJTdHJpbmc6IGZ1bmN0aW9uKG1heCkge1xuICAgIHZhciB0ID0gKCcnICsgKG1heCAtIDEpKS5sZW5ndGg7XG4gICAgdmFyIHAgPSBuZXcgQXJyYXkodCArIDEpLmpvaW4oJzAnKTtcbiAgICByZXR1cm4gKHAgKyB0aGlzLm51bWJlcihtYXgpKS5zbGljZSgtdCk7XG4gIH1cbn07XG5cbn0se1wiY3J5cHRvXCI6NDN9XSw1MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnV0aWxzOnRyYW5zcG9ydCcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGF2YWlsYWJsZVRyYW5zcG9ydHMpIHtcbiAgcmV0dXJuIHtcbiAgICBmaWx0ZXJUb0VuYWJsZWQ6IGZ1bmN0aW9uKHRyYW5zcG9ydHNXaGl0ZWxpc3QsIGluZm8pIHtcbiAgICAgIHZhciB0cmFuc3BvcnRzID0ge1xuICAgICAgICBtYWluOiBbXVxuICAgICAgLCBmYWNhZGU6IFtdXG4gICAgICB9O1xuICAgICAgaWYgKCF0cmFuc3BvcnRzV2hpdGVsaXN0KSB7XG4gICAgICAgIHRyYW5zcG9ydHNXaGl0ZWxpc3QgPSBbXTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRyYW5zcG9ydHNXaGl0ZWxpc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyYW5zcG9ydHNXaGl0ZWxpc3QgPSBbdHJhbnNwb3J0c1doaXRlbGlzdF07XG4gICAgICB9XG5cbiAgICAgIGF2YWlsYWJsZVRyYW5zcG9ydHMuZm9yRWFjaChmdW5jdGlvbih0cmFucykge1xuICAgICAgICBpZiAoIXRyYW5zKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYW5zLnRyYW5zcG9ydE5hbWUgPT09ICd3ZWJzb2NrZXQnICYmIGluZm8ud2Vic29ja2V0ID09PSBmYWxzZSkge1xuICAgICAgICAgIGRlYnVnKCdkaXNhYmxlZCBmcm9tIHNlcnZlcicsICd3ZWJzb2NrZXQnKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHJhbnNwb3J0c1doaXRlbGlzdC5sZW5ndGggJiZcbiAgICAgICAgICAgIHRyYW5zcG9ydHNXaGl0ZWxpc3QuaW5kZXhPZih0cmFucy50cmFuc3BvcnROYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICBkZWJ1Zygnbm90IGluIHdoaXRlbGlzdCcsIHRyYW5zLnRyYW5zcG9ydE5hbWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFucy5lbmFibGVkKGluZm8pKSB7XG4gICAgICAgICAgZGVidWcoJ2VuYWJsZWQnLCB0cmFucy50cmFuc3BvcnROYW1lKTtcbiAgICAgICAgICB0cmFuc3BvcnRzLm1haW4ucHVzaCh0cmFucyk7XG4gICAgICAgICAgaWYgKHRyYW5zLmZhY2FkZVRyYW5zcG9ydCkge1xuICAgICAgICAgICAgdHJhbnNwb3J0cy5mYWNhZGUucHVzaCh0cmFucy5mYWNhZGVUcmFuc3BvcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWJ1ZygnZGlzYWJsZWQnLCB0cmFucy50cmFuc3BvcnROYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJhbnNwb3J0cztcbiAgICB9XG4gIH07XG59O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiZGVidWdcIjo1NX1dLDUyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBVUkwgPSByZXF1aXJlKCd1cmwtcGFyc2UnKTtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp1dGlsczp1cmwnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldE9yaWdpbjogZnVuY3Rpb24odXJsKSB7XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBwID0gbmV3IFVSTCh1cmwpO1xuICAgIGlmIChwLnByb3RvY29sID09PSAnZmlsZTonKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcG9ydCA9IHAucG9ydDtcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgIHBvcnQgPSAocC5wcm90b2NvbCA9PT0gJ2h0dHBzOicpID8gJzQ0MycgOiAnODAnO1xuICAgIH1cblxuICAgIHJldHVybiBwLnByb3RvY29sICsgJy8vJyArIHAuaG9zdG5hbWUgKyAnOicgKyBwb3J0O1xuICB9XG5cbiwgaXNPcmlnaW5FcXVhbDogZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciByZXMgPSB0aGlzLmdldE9yaWdpbihhKSA9PT0gdGhpcy5nZXRPcmlnaW4oYik7XG4gICAgZGVidWcoJ3NhbWUnLCBhLCBiLCByZXMpO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuLCBpc1NjaGVtZUVxdWFsOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIChhLnNwbGl0KCc6JylbMF0gPT09IGIuc3BsaXQoJzonKVswXSk7XG4gIH1cblxuLCBhZGRQYXRoOiBmdW5jdGlvbiAodXJsLCBwYXRoKSB7XG4gICAgdmFyIHFzID0gdXJsLnNwbGl0KCc/Jyk7XG4gICAgcmV0dXJuIHFzWzBdICsgcGF0aCArIChxc1sxXSA/ICc/JyArIHFzWzFdIDogJycpO1xuICB9XG5cbiwgYWRkUXVlcnk6IGZ1bmN0aW9uICh1cmwsIHEpIHtcbiAgICByZXR1cm4gdXJsICsgKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gKCc/JyArIHEpIDogKCcmJyArIHEpKTtcbiAgfVxufTtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcImRlYnVnXCI6NTUsXCJ1cmwtcGFyc2VcIjo2MX1dLDUzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gJzEuMS40JztcblxufSx7fV0sNTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMFxudmFyIG0gPSBzICogNjBcbnZhciBoID0gbSAqIDYwXG52YXIgZCA9IGggKiAyNFxudmFyIHkgPSBkICogMzY1LjI1XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWxcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbClcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWwpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgP1xuXHRcdFx0Zm10TG9uZyh2YWwpIDpcblx0XHRcdGZtdFNob3J0KHZhbClcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArIEpTT04uc3RyaW5naWZ5KHZhbCkpXG59XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKVxuICBpZiAoc3RyLmxlbmd0aCA+IDEwMDAwKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhzdHIpXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pXG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKClcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZFxuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaFxuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbVxuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogc1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICBpZiAobXMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCdcbiAgfVxuICBpZiAobXMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCdcbiAgfVxuICBpZiAobXMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSdcbiAgfVxuICBpZiAobXMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncydcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnXG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKSB8fFxuICAgIHBsdXJhbChtcywgaCwgJ2hvdXInKSB8fFxuICAgIHBsdXJhbChtcywgbSwgJ21pbnV0ZScpIHx8XG4gICAgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJykgfHxcbiAgICBtcyArICcgbXMnXG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gIGlmIChtcyA8IG4pIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAobXMgPCBuICogMS41KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWVcbiAgfVxuICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnXG59XG5cbn0se31dLDU1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWVcbiAgICAgICAgICAgICAgICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZVxuICAgICAgICAgICAgICAgICAgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbFxuICAgICAgICAgICAgICAgICAgOiBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG4gICdsaWdodHNlYWdyZWVuJyxcbiAgJ2ZvcmVzdGdyZWVuJyxcbiAgJ2dvbGRlbnJvZCcsXG4gICdkb2RnZXJibHVlJyxcbiAgJ2RhcmtvcmNoaWQnLFxuICAnY3JpbXNvbidcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG4gIC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG4gIC8vIGV4cGxpY2l0bHlcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmIHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG4gIHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93ICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcbiAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG4gICAgLy8gZG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uKHYpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnIubWVzc2FnZTtcbiAgfVxufTtcblxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cbiAgYXJnc1swXSA9ICh1c2VDb2xvcnMgPyAnJWMnIDogJycpXG4gICAgKyB0aGlzLm5hbWVzcGFjZVxuICAgICsgKHVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKVxuICAgICsgYXJnc1swXVxuICAgICsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKVxuICAgICsgJysnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdXNlQ29sb3JzKSByZXR1cm47XG5cbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICBhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKVxuXG4gIC8vIHRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuICAgIGluZGV4Kys7XG4gICAgaWYgKCclYycgPT09IG1hdGNoKSB7XG4gICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgLy8gdGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcbiAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgcmV0dXJuICdvYmplY3QnID09PSB0eXBlb2YgY29uc29sZVxuICAgICYmIGNvbnNvbGUubG9nXG4gICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UuZGVidWcgPSBuYW1lc3BhY2VzO1xuICAgIH1cbiAgfSBjYXRjaChlKSB7fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuICB0cnkge1xuICAgIHIgPSBleHBvcnRzLnN0b3JhZ2UuZGVidWc7XG4gIH0gY2F0Y2goZSkge31cblxuICAvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG4gIGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuICAgIHIgPSBwcm9jZXNzLmVudi5ERUJVRztcbiAgfVxuXG4gIHJldHVybiByO1xufVxuXG4vKipcbiAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgbG9jYWxTdG9yYWdlLmRlYnVnYCBpbml0aWFsbHkuXG4gKi9cblxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuL2RlYnVnXCI6NTZ9XSw1NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Z1snZGVmYXVsdCddID0gY3JlYXRlRGVidWc7XG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcbmV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5leHBvcnRzLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAqL1xuXG5leHBvcnRzLm5hbWVzID0gW107XG5leHBvcnRzLnNraXBzID0gW107XG5cbi8qKlxuICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICpcbiAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuLyoqXG4gKiBQcmV2aW91cyBsb2cgdGltZXN0YW1wLlxuICovXG5cbnZhciBwcmV2VGltZTtcblxuLyoqXG4gKiBTZWxlY3QgYSBjb2xvci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuICB2YXIgaGFzaCA9IDAsIGk7XG5cbiAgZm9yIChpIGluIG5hbWVzcGFjZSkge1xuICAgIGhhc2ggID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICB9XG5cbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW01hdGguYWJzKGhhc2gpICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cbiAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgLy8gZGlzYWJsZWQ/XG4gICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSByZXR1cm47XG5cbiAgICB2YXIgc2VsZiA9IGRlYnVnO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyB0dXJuIHRoZSBgYXJndW1lbnRzYCBpbnRvIGEgcHJvcGVyIEFycmF5XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG4gICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIC8vIGFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG4gICAgZXhwb3J0cy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cbiAgICB2YXIgbG9nRm4gPSBkZWJ1Zy5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuXG4gIGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgZGVidWcuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpO1xuICBkZWJ1Zy51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICBkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cbiAgLy8gZW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmluaXQpIHtcbiAgICBleHBvcnRzLmluaXQoZGVidWcpO1xuICB9XG5cbiAgcmV0dXJuIGRlYnVnO1xufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIGV4cG9ydHMubmFtZXMgPSBbXTtcbiAgZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4gIHZhciBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuXG59LHtcIm1zXCI6NTR9XSw1NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5pZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cblxufSx7fV0sNTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyohIEpTT04gdjMuMy4yIHwgaHR0cDovL2Jlc3RpZWpzLmdpdGh1Yi5pby9qc29uMyB8IENvcHlyaWdodCAyMDEyLTIwMTQsIEtpdCBDYW1icmlkZ2UgfCBodHRwOi8va2l0Lm1pdC1saWNlbnNlLm9yZyAqL1xuOyhmdW5jdGlvbiAoKSB7XG4gIC8vIERldGVjdCB0aGUgYGRlZmluZWAgZnVuY3Rpb24gZXhwb3NlZCBieSBhc3luY2hyb25vdXMgbW9kdWxlIGxvYWRlcnMuIFRoZVxuICAvLyBzdHJpY3QgYGRlZmluZWAgY2hlY2sgaXMgbmVjZXNzYXJ5IGZvciBjb21wYXRpYmlsaXR5IHdpdGggYHIuanNgLlxuICB2YXIgaXNMb2FkZXIgPSB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZDtcblxuICAvLyBBIHNldCBvZiB0eXBlcyB1c2VkIHRvIGRpc3Rpbmd1aXNoIG9iamVjdHMgZnJvbSBwcmltaXRpdmVzLlxuICB2YXIgb2JqZWN0VHlwZXMgPSB7XG4gICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgIFwib2JqZWN0XCI6IHRydWVcbiAgfTtcblxuICAvLyBEZXRlY3QgdGhlIGBleHBvcnRzYCBvYmplY3QgZXhwb3NlZCBieSBDb21tb25KUyBpbXBsZW1lbnRhdGlvbnMuXG4gIHZhciBmcmVlRXhwb3J0cyA9IG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbiAgLy8gVXNlIHRoZSBgZ2xvYmFsYCBvYmplY3QgZXhwb3NlZCBieSBOb2RlIChpbmNsdWRpbmcgQnJvd3NlcmlmeSB2aWFcbiAgLy8gYGluc2VydC1tb2R1bGUtZ2xvYmFsc2ApLCBOYXJ3aGFsLCBhbmQgUmluZ28gYXMgdGhlIGRlZmF1bHQgY29udGV4dCxcbiAgLy8gYW5kIHRoZSBgd2luZG93YCBvYmplY3QgaW4gYnJvd3NlcnMuIFJoaW5vIGV4cG9ydHMgYSBgZ2xvYmFsYCBmdW5jdGlvblxuICAvLyBpbnN0ZWFkLlxuICB2YXIgcm9vdCA9IG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdyB8fCB0aGlzLFxuICAgICAgZnJlZUdsb2JhbCA9IGZyZWVFeHBvcnRzICYmIG9iamVjdFR5cGVzW3R5cGVvZiBtb2R1bGVdICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIHR5cGVvZiBnbG9iYWwgPT0gXCJvYmplY3RcIiAmJiBnbG9iYWw7XG5cbiAgaWYgKGZyZWVHbG9iYWwgJiYgKGZyZWVHbG9iYWxbXCJnbG9iYWxcIl0gPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbFtcIndpbmRvd1wiXSA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsW1wic2VsZlwiXSA9PT0gZnJlZUdsb2JhbCkpIHtcbiAgICByb290ID0gZnJlZUdsb2JhbDtcbiAgfVxuXG4gIC8vIFB1YmxpYzogSW5pdGlhbGl6ZXMgSlNPTiAzIHVzaW5nIHRoZSBnaXZlbiBgY29udGV4dGAgb2JqZWN0LCBhdHRhY2hpbmcgdGhlXG4gIC8vIGBzdHJpbmdpZnlgIGFuZCBgcGFyc2VgIGZ1bmN0aW9ucyB0byB0aGUgc3BlY2lmaWVkIGBleHBvcnRzYCBvYmplY3QuXG4gIGZ1bmN0aW9uIHJ1bkluQ29udGV4dChjb250ZXh0LCBleHBvcnRzKSB7XG4gICAgY29udGV4dCB8fCAoY29udGV4dCA9IHJvb3RbXCJPYmplY3RcIl0oKSk7XG4gICAgZXhwb3J0cyB8fCAoZXhwb3J0cyA9IHJvb3RbXCJPYmplY3RcIl0oKSk7XG5cbiAgICAvLyBOYXRpdmUgY29uc3RydWN0b3IgYWxpYXNlcy5cbiAgICB2YXIgTnVtYmVyID0gY29udGV4dFtcIk51bWJlclwiXSB8fCByb290W1wiTnVtYmVyXCJdLFxuICAgICAgICBTdHJpbmcgPSBjb250ZXh0W1wiU3RyaW5nXCJdIHx8IHJvb3RbXCJTdHJpbmdcIl0sXG4gICAgICAgIE9iamVjdCA9IGNvbnRleHRbXCJPYmplY3RcIl0gfHwgcm9vdFtcIk9iamVjdFwiXSxcbiAgICAgICAgRGF0ZSA9IGNvbnRleHRbXCJEYXRlXCJdIHx8IHJvb3RbXCJEYXRlXCJdLFxuICAgICAgICBTeW50YXhFcnJvciA9IGNvbnRleHRbXCJTeW50YXhFcnJvclwiXSB8fCByb290W1wiU3ludGF4RXJyb3JcIl0sXG4gICAgICAgIFR5cGVFcnJvciA9IGNvbnRleHRbXCJUeXBlRXJyb3JcIl0gfHwgcm9vdFtcIlR5cGVFcnJvclwiXSxcbiAgICAgICAgTWF0aCA9IGNvbnRleHRbXCJNYXRoXCJdIHx8IHJvb3RbXCJNYXRoXCJdLFxuICAgICAgICBuYXRpdmVKU09OID0gY29udGV4dFtcIkpTT05cIl0gfHwgcm9vdFtcIkpTT05cIl07XG5cbiAgICAvLyBEZWxlZ2F0ZSB0byB0aGUgbmF0aXZlIGBzdHJpbmdpZnlgIGFuZCBgcGFyc2VgIGltcGxlbWVudGF0aW9ucy5cbiAgICBpZiAodHlwZW9mIG5hdGl2ZUpTT04gPT0gXCJvYmplY3RcIiAmJiBuYXRpdmVKU09OKSB7XG4gICAgICBleHBvcnRzLnN0cmluZ2lmeSA9IG5hdGl2ZUpTT04uc3RyaW5naWZ5O1xuICAgICAgZXhwb3J0cy5wYXJzZSA9IG5hdGl2ZUpTT04ucGFyc2U7XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgYWxpYXNlcy5cbiAgICB2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlLFxuICAgICAgICBnZXRDbGFzcyA9IG9iamVjdFByb3RvLnRvU3RyaW5nLFxuICAgICAgICBpc1Byb3BlcnR5LCBmb3JFYWNoLCB1bmRlZjtcblxuICAgIC8vIFRlc3QgdGhlIGBEYXRlI2dldFVUQypgIG1ldGhvZHMuIEJhc2VkIG9uIHdvcmsgYnkgQFlhZmZsZS5cbiAgICB2YXIgaXNFeHRlbmRlZCA9IG5ldyBEYXRlKC0zNTA5ODI3MzM0NTczMjkyKTtcbiAgICB0cnkge1xuICAgICAgLy8gVGhlIGBnZXRVVENGdWxsWWVhcmAsIGBNb250aGAsIGFuZCBgRGF0ZWAgbWV0aG9kcyByZXR1cm4gbm9uc2Vuc2ljYWxcbiAgICAgIC8vIHJlc3VsdHMgZm9yIGNlcnRhaW4gZGF0ZXMgaW4gT3BlcmEgPj0gMTAuNTMuXG4gICAgICBpc0V4dGVuZGVkID0gaXNFeHRlbmRlZC5nZXRVVENGdWxsWWVhcigpID09IC0xMDkyNTIgJiYgaXNFeHRlbmRlZC5nZXRVVENNb250aCgpID09PSAwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDRGF0ZSgpID09PSAxICYmXG4gICAgICAgIC8vIFNhZmFyaSA8IDIuMC4yIHN0b3JlcyB0aGUgaW50ZXJuYWwgbWlsbGlzZWNvbmQgdGltZSB2YWx1ZSBjb3JyZWN0bHksXG4gICAgICAgIC8vIGJ1dCBjbGlwcyB0aGUgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBkYXRlIG1ldGhvZHMgdG8gdGhlIHJhbmdlIG9mXG4gICAgICAgIC8vIHNpZ25lZCAzMi1iaXQgaW50ZWdlcnMgKFstMiAqKiAzMSwgMiAqKiAzMSAtIDFdKS5cbiAgICAgICAgaXNFeHRlbmRlZC5nZXRVVENIb3VycygpID09IDEwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWludXRlcygpID09IDM3ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDU2Vjb25kcygpID09IDYgJiYgaXNFeHRlbmRlZC5nZXRVVENNaWxsaXNlY29uZHMoKSA9PSA3MDg7XG4gICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuXG4gICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgd2hldGhlciB0aGUgbmF0aXZlIGBKU09OLnN0cmluZ2lmeWAgYW5kIGBwYXJzZWBcbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgYXJlIHNwZWMtY29tcGxpYW50LiBCYXNlZCBvbiB3b3JrIGJ5IEtlbiBTbnlkZXIuXG4gICAgZnVuY3Rpb24gaGFzKG5hbWUpIHtcbiAgICAgIGlmIChoYXNbbmFtZV0gIT09IHVuZGVmKSB7XG4gICAgICAgIC8vIFJldHVybiBjYWNoZWQgZmVhdHVyZSB0ZXN0IHJlc3VsdC5cbiAgICAgICAgcmV0dXJuIGhhc1tuYW1lXTtcbiAgICAgIH1cbiAgICAgIHZhciBpc1N1cHBvcnRlZDtcbiAgICAgIGlmIChuYW1lID09IFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpIHtcbiAgICAgICAgLy8gSUUgPD0gNyBkb2Vzbid0IHN1cHBvcnQgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIHVzaW5nIHNxdWFyZVxuICAgICAgICAvLyBicmFja2V0IG5vdGF0aW9uLiBJRSA4IG9ubHkgc3VwcG9ydHMgdGhpcyBmb3IgcHJpbWl0aXZlcy5cbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBcImFcIlswXSAhPSBcImFcIjtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSA9PSBcImpzb25cIikge1xuICAgICAgICAvLyBJbmRpY2F0ZXMgd2hldGhlciBib3RoIGBKU09OLnN0cmluZ2lmeWAgYW5kIGBKU09OLnBhcnNlYCBhcmVcbiAgICAgICAgLy8gc3VwcG9ydGVkLlxuICAgICAgICBpc1N1cHBvcnRlZCA9IGhhcyhcImpzb24tc3RyaW5naWZ5XCIpICYmIGhhcyhcImpzb24tcGFyc2VcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdmFsdWUsIHNlcmlhbGl6ZWQgPSAne1wiYVwiOlsxLHRydWUsZmFsc2UsbnVsbCxcIlxcXFx1MDAwMFxcXFxiXFxcXG5cXFxcZlxcXFxyXFxcXHRcIl19JztcbiAgICAgICAgLy8gVGVzdCBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICBpZiAobmFtZSA9PSBcImpzb24tc3RyaW5naWZ5XCIpIHtcbiAgICAgICAgICB2YXIgc3RyaW5naWZ5ID0gZXhwb3J0cy5zdHJpbmdpZnksIHN0cmluZ2lmeVN1cHBvcnRlZCA9IHR5cGVvZiBzdHJpbmdpZnkgPT0gXCJmdW5jdGlvblwiICYmIGlzRXh0ZW5kZWQ7XG4gICAgICAgICAgaWYgKHN0cmluZ2lmeVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgLy8gQSB0ZXN0IGZ1bmN0aW9uIG9iamVjdCB3aXRoIGEgY3VzdG9tIGB0b0pTT05gIG1ldGhvZC5cbiAgICAgICAgICAgICh2YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9KS50b0pTT04gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0cmluZ2lmeVN1cHBvcnRlZCA9XG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCAzLjFiMSBhbmQgYjIgc2VyaWFsaXplIHN0cmluZywgbnVtYmVyLCBhbmQgYm9vbGVhblxuICAgICAgICAgICAgICAgIC8vIHByaW1pdGl2ZXMgYXMgb2JqZWN0IGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSgwKSA9PT0gXCIwXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgYjIsIGFuZCBKU09OIDIgc2VyaWFsaXplIHdyYXBwZWQgcHJpbWl0aXZlcyBhcyBvYmplY3RcbiAgICAgICAgICAgICAgICAvLyBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IE51bWJlcigpKSA9PT0gXCIwXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IFN0cmluZygpKSA9PSAnXCJcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgdmFsdWUgaXMgYG51bGxgLCBgdW5kZWZpbmVkYCwgb3JcbiAgICAgICAgICAgICAgICAvLyBkb2VzIG5vdCBkZWZpbmUgYSBjYW5vbmljYWwgSlNPTiByZXByZXNlbnRhdGlvbiAodGhpcyBhcHBsaWVzIHRvXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGB0b0pTT05gIHByb3BlcnRpZXMgYXMgd2VsbCwgKnVubGVzcyogdGhleSBhcmUgbmVzdGVkXG4gICAgICAgICAgICAgICAgLy8gd2l0aGluIGFuIG9iamVjdCBvciBhcnJheSkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KGdldENsYXNzKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBJRSA4IHNlcmlhbGl6ZXMgYHVuZGVmaW5lZGAgYXMgYFwidW5kZWZpbmVkXCJgLiBTYWZhcmkgPD0gNS4xLjcgYW5kXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjMgcGFzcyB0aGlzIHRlc3QuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHVuZGVmKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjcgYW5kIEZGIDMuMWIzIHRocm93IGBFcnJvcmBzIGFuZCBgVHlwZUVycm9yYHMsXG4gICAgICAgICAgICAgICAgLy8gcmVzcGVjdGl2ZWx5LCBpZiB0aGUgdmFsdWUgaXMgb21pdHRlZCBlbnRpcmVseS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgbnVtYmVyLFxuICAgICAgICAgICAgICAgIC8vIHN0cmluZywgYXJyYXksIG9iamVjdCwgQm9vbGVhbiwgb3IgYG51bGxgIGxpdGVyYWwuIFRoaXMgYXBwbGllcyB0b1xuICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCBjdXN0b20gYHRvSlNPTmAgbWV0aG9kcyBhcyB3ZWxsLCB1bmxlc3MgdGhleSBhcmUgbmVzdGVkXG4gICAgICAgICAgICAgICAgLy8gaW5zaWRlIG9iamVjdCBvciBhcnJheSBsaXRlcmFscy4gWVVJIDMuMC4wYjEgaWdub3JlcyBjdXN0b20gYHRvSlNPTmBcbiAgICAgICAgICAgICAgICAvLyBtZXRob2RzIGVudGlyZWx5LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh2YWx1ZSkgPT09IFwiMVwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt2YWx1ZV0pID09IFwiWzFdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgc2VyaWFsaXplcyBgW3VuZGVmaW5lZF1gIGFzIGBcIltdXCJgIGluc3RlYWQgb2ZcbiAgICAgICAgICAgICAgICAvLyBgXCJbbnVsbF1cImAuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZl0pID09IFwiW251bGxdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBZVUkgMy4wLjBiMSBmYWlscyB0byBzZXJpYWxpemUgYG51bGxgIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShudWxsKSA9PSBcIm51bGxcIiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIGhhbHRzIHNlcmlhbGl6YXRpb24gaWYgYW4gYXJyYXkgY29udGFpbnMgYSBmdW5jdGlvbjpcbiAgICAgICAgICAgICAgICAvLyBgWzEsIHRydWUsIGdldENsYXNzLCAxXWAgc2VyaWFsaXplcyBhcyBcIlsxLHRydWUsXSxcIi4gRkYgMy4xYjNcbiAgICAgICAgICAgICAgICAvLyBlbGlkZXMgbm9uLUpTT04gdmFsdWVzIGZyb20gb2JqZWN0cyBhbmQgYXJyYXlzLCB1bmxlc3MgdGhleVxuICAgICAgICAgICAgICAgIC8vIGRlZmluZSBjdXN0b20gYHRvSlNPTmAgbWV0aG9kcy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmLCBnZXRDbGFzcywgbnVsbF0pID09IFwiW251bGwsbnVsbCxudWxsXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIHNlcmlhbGl6YXRpb24gdGVzdC4gRkYgMy4xYjEgdXNlcyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZXNcbiAgICAgICAgICAgICAgICAvLyB3aGVyZSBjaGFyYWN0ZXIgZXNjYXBlIGNvZGVzIGFyZSBleHBlY3RlZCAoZS5nLiwgYFxcYmAgPT4gYFxcdTAwMDhgKS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoeyBcImFcIjogW3ZhbHVlLCB0cnVlLCBmYWxzZSwgbnVsbCwgXCJcXHgwMFxcYlxcblxcZlxcclxcdFwiXSB9KSA9PSBzZXJpYWxpemVkICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEgYW5kIGIyIGlnbm9yZSB0aGUgYGZpbHRlcmAgYW5kIGB3aWR0aGAgYXJndW1lbnRzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShudWxsLCB2YWx1ZSkgPT09IFwiMVwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFsxLCAyXSwgbnVsbCwgMSkgPT0gXCJbXFxuIDEsXFxuIDJcXG5dXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBKU09OIDIsIFByb3RvdHlwZSA8PSAxLjcsIGFuZCBvbGRlciBXZWJLaXQgYnVpbGRzIGluY29ycmVjdGx5XG4gICAgICAgICAgICAgICAgLy8gc2VyaWFsaXplIGV4dGVuZGVkIHllYXJzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtOC42NGUxNSkpID09ICdcIi0yNzE4MjEtMDQtMjBUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIFRoZSBtaWxsaXNlY29uZHMgYXJlIG9wdGlvbmFsIGluIEVTIDUsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKDguNjRlMTUpKSA9PSAnXCIrMjc1NzYwLTA5LTEzVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IDw9IDExLjAgaW5jb3JyZWN0bHkgc2VyaWFsaXplcyB5ZWFycyBwcmlvciB0byAwIGFzIG5lZ2F0aXZlXG4gICAgICAgICAgICAgICAgLy8gZm91ci1kaWdpdCB5ZWFycyBpbnN0ZWFkIG9mIHNpeC1kaWdpdCB5ZWFycy4gQ3JlZGl0czogQFlhZmZsZS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTYyMTk4NzU1MmU1KSkgPT0gJ1wiLTAwMDAwMS0wMS0wMVQwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS41IGFuZCBPcGVyYSA+PSAxMC41MyBpbmNvcnJlY3RseSBzZXJpYWxpemUgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgbGVzcyB0aGFuIDEwMDAuIENyZWRpdHM6IEBZYWZmbGUuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC0xKSkgPT0gJ1wiMTk2OS0xMi0zMVQyMzo1OTo1OS45OTlaXCInO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgIHN0cmluZ2lmeVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpc1N1cHBvcnRlZCA9IHN0cmluZ2lmeVN1cHBvcnRlZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUZXN0IGBKU09OLnBhcnNlYC5cbiAgICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXBhcnNlXCIpIHtcbiAgICAgICAgICB2YXIgcGFyc2UgPSBleHBvcnRzLnBhcnNlO1xuICAgICAgICAgIGlmICh0eXBlb2YgcGFyc2UgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgYjIgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYSBiYXJlIGxpdGVyYWwgaXMgcHJvdmlkZWQuXG4gICAgICAgICAgICAgIC8vIENvbmZvcm1pbmcgaW1wbGVtZW50YXRpb25zIHNob3VsZCBhbHNvIGNvZXJjZSB0aGUgaW5pdGlhbCBhcmd1bWVudCB0b1xuICAgICAgICAgICAgICAvLyBhIHN0cmluZyBwcmlvciB0byBwYXJzaW5nLlxuICAgICAgICAgICAgICBpZiAocGFyc2UoXCIwXCIpID09PSAwICYmICFwYXJzZShmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgcGFyc2luZyB0ZXN0LlxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2Uoc2VyaWFsaXplZCk7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlU3VwcG9ydGVkID0gdmFsdWVbXCJhXCJdLmxlbmd0aCA9PSA1ICYmIHZhbHVlW1wiYVwiXVswXSA9PT0gMTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuMiBhbmQgRkYgMy4xYjEgYWxsb3cgdW5lc2NhcGVkIHRhYnMgaW4gc3RyaW5ncy5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSAhcGFyc2UoJ1wiXFx0XCInKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEZGIDQuMCBhbmQgNC4wLjEgYWxsb3cgbGVhZGluZyBgK2Agc2lnbnMgYW5kIGxlYWRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAvLyBkZWNpbWFsIHBvaW50cy4gRkYgNC4wLCA0LjAuMSwgYW5kIElFIDktMTAgYWxzbyBhbGxvd1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGNlcnRhaW4gb2N0YWwgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBwYXJzZShcIjAxXCIpICE9PSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAsIDQuMC4xLCBhbmQgUmhpbm8gMS43UjMtUjQgYWxsb3cgdHJhaWxpbmcgZGVjaW1hbFxuICAgICAgICAgICAgICAgICAgICAgIC8vIHBvaW50cy4gVGhlc2UgZW52aXJvbm1lbnRzLCBhbG9uZyB3aXRoIEZGIDMuMWIxIGFuZCAyLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGFsc28gYWxsb3cgdHJhaWxpbmcgY29tbWFzIGluIEpTT04gb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIxLlwiKSAhPT0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzU3VwcG9ydGVkID0gcGFyc2VTdXBwb3J0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNbbmFtZV0gPSAhIWlzU3VwcG9ydGVkO1xuICAgIH1cblxuICAgIGlmICghaGFzKFwianNvblwiKSkge1xuICAgICAgLy8gQ29tbW9uIGBbW0NsYXNzXV1gIG5hbWUgYWxpYXNlcy5cbiAgICAgIHZhciBmdW5jdGlvbkNsYXNzID0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiLFxuICAgICAgICAgIGRhdGVDbGFzcyA9IFwiW29iamVjdCBEYXRlXVwiLFxuICAgICAgICAgIG51bWJlckNsYXNzID0gXCJbb2JqZWN0IE51bWJlcl1cIixcbiAgICAgICAgICBzdHJpbmdDbGFzcyA9IFwiW29iamVjdCBTdHJpbmddXCIsXG4gICAgICAgICAgYXJyYXlDbGFzcyA9IFwiW29iamVjdCBBcnJheV1cIixcbiAgICAgICAgICBib29sZWFuQ2xhc3MgPSBcIltvYmplY3QgQm9vbGVhbl1cIjtcblxuICAgICAgLy8gRGV0ZWN0IGluY29tcGxldGUgc3VwcG9ydCBmb3IgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIGJ5IGluZGV4LlxuICAgICAgdmFyIGNoYXJJbmRleEJ1Z2d5ID0gaGFzKFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpO1xuXG4gICAgICAvLyBEZWZpbmUgYWRkaXRpb25hbCB1dGlsaXR5IG1ldGhvZHMgaWYgdGhlIGBEYXRlYCBtZXRob2RzIGFyZSBidWdneS5cbiAgICAgIGlmICghaXNFeHRlbmRlZCkge1xuICAgICAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgICAgICAvLyBBIG1hcHBpbmcgYmV0d2VlbiB0aGUgbW9udGhzIG9mIHRoZSB5ZWFyIGFuZCB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlblxuICAgICAgICAvLyBKYW51YXJ5IDFzdCBhbmQgdGhlIGZpcnN0IG9mIHRoZSByZXNwZWN0aXZlIG1vbnRoLlxuICAgICAgICB2YXIgTW9udGhzID0gWzAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0XTtcbiAgICAgICAgLy8gSW50ZXJuYWw6IENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW4gdGhlIFVuaXggZXBvY2ggYW5kIHRoZVxuICAgICAgICAvLyBmaXJzdCBkYXkgb2YgdGhlIGdpdmVuIG1vbnRoLlxuICAgICAgICB2YXIgZ2V0RGF5ID0gZnVuY3Rpb24gKHllYXIsIG1vbnRoKSB7XG4gICAgICAgICAgcmV0dXJuIE1vbnRoc1ttb250aF0gKyAzNjUgKiAoeWVhciAtIDE5NzApICsgZmxvb3IoKHllYXIgLSAxOTY5ICsgKG1vbnRoID0gKyhtb250aCA+IDEpKSkgLyA0KSAtIGZsb29yKCh5ZWFyIC0gMTkwMSArIG1vbnRoKSAvIDEwMCkgKyBmbG9vcigoeWVhciAtIDE2MDEgKyBtb250aCkgLyA0MDApO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBJbnRlcm5hbDogRGV0ZXJtaW5lcyBpZiBhIHByb3BlcnR5IGlzIGEgZGlyZWN0IHByb3BlcnR5IG9mIHRoZSBnaXZlblxuICAgICAgLy8gb2JqZWN0LiBEZWxlZ2F0ZXMgdG8gdGhlIG5hdGl2ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBtZXRob2QuXG4gICAgICBpZiAoIShpc1Byb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHkpKSB7XG4gICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICB2YXIgbWVtYmVycyA9IHt9LCBjb25zdHJ1Y3RvcjtcbiAgICAgICAgICBpZiAoKG1lbWJlcnMuX19wcm90b19fID0gbnVsbCwgbWVtYmVycy5fX3Byb3RvX18gPSB7XG4gICAgICAgICAgICAvLyBUaGUgKnByb3RvKiBwcm9wZXJ0eSBjYW5ub3QgYmUgc2V0IG11bHRpcGxlIHRpbWVzIGluIHJlY2VudFxuICAgICAgICAgICAgLy8gdmVyc2lvbnMgb2YgRmlyZWZveCBhbmQgU2VhTW9ua2V5LlxuICAgICAgICAgICAgXCJ0b1N0cmluZ1wiOiAxXG4gICAgICAgICAgfSwgbWVtYmVycykudG9TdHJpbmcgIT0gZ2V0Q2xhc3MpIHtcbiAgICAgICAgICAgIC8vIFNhZmFyaSA8PSAyLjAuMyBkb2Vzbid0IGltcGxlbWVudCBgT2JqZWN0I2hhc093blByb3BlcnR5YCwgYnV0XG4gICAgICAgICAgICAvLyBzdXBwb3J0cyB0aGUgbXV0YWJsZSAqcHJvdG8qIHByb3BlcnR5LlxuICAgICAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAvLyBDYXB0dXJlIGFuZCBicmVhayB0aGUgb2JqZWN0J3MgcHJvdG90eXBlIGNoYWluIChzZWUgc2VjdGlvbiA4LjYuMlxuICAgICAgICAgICAgICAvLyBvZiB0aGUgRVMgNS4xIHNwZWMpLiBUaGUgcGFyZW50aGVzaXplZCBleHByZXNzaW9uIHByZXZlbnRzIGFuXG4gICAgICAgICAgICAgIC8vIHVuc2FmZSB0cmFuc2Zvcm1hdGlvbiBieSB0aGUgQ2xvc3VyZSBDb21waWxlci5cbiAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gdGhpcy5fX3Byb3RvX18sIHJlc3VsdCA9IHByb3BlcnR5IGluICh0aGlzLl9fcHJvdG9fXyA9IG51bGwsIHRoaXMpO1xuICAgICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBwcm90b3R5cGUgY2hhaW4uXG4gICAgICAgICAgICAgIHRoaXMuX19wcm90b19fID0gb3JpZ2luYWw7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBDYXB0dXJlIGEgcmVmZXJlbmNlIHRvIHRoZSB0b3AtbGV2ZWwgYE9iamVjdGAgY29uc3RydWN0b3IuXG4gICAgICAgICAgICBjb25zdHJ1Y3RvciA9IG1lbWJlcnMuY29uc3RydWN0b3I7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgdG8gc2ltdWxhdGUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW5cbiAgICAgICAgICAgIC8vIG90aGVyIGVudmlyb25tZW50cy5cbiAgICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudCA9ICh0aGlzLmNvbnN0cnVjdG9yIHx8IGNvbnN0cnVjdG9yKS5wcm90b3R5cGU7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eSBpbiB0aGlzICYmICEocHJvcGVydHkgaW4gcGFyZW50ICYmIHRoaXNbcHJvcGVydHldID09PSBwYXJlbnRbcHJvcGVydHldKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIG1lbWJlcnMgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBpc1Byb3BlcnR5LmNhbGwodGhpcywgcHJvcGVydHkpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBJbnRlcm5hbDogTm9ybWFsaXplcyB0aGUgYGZvci4uLmluYCBpdGVyYXRpb24gYWxnb3JpdGhtIGFjcm9zc1xuICAgICAgLy8gZW52aXJvbm1lbnRzLiBFYWNoIGVudW1lcmF0ZWQga2V5IGlzIHlpZWxkZWQgdG8gYSBgY2FsbGJhY2tgIGZ1bmN0aW9uLlxuICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzaXplID0gMCwgUHJvcGVydGllcywgbWVtYmVycywgcHJvcGVydHk7XG5cbiAgICAgICAgLy8gVGVzdHMgZm9yIGJ1Z3MgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQncyBgZm9yLi4uaW5gIGFsZ29yaXRobS4gVGhlXG4gICAgICAgIC8vIGB2YWx1ZU9mYCBwcm9wZXJ0eSBpbmhlcml0cyB0aGUgbm9uLWVudW1lcmFibGUgZmxhZyBmcm9tXG4gICAgICAgIC8vIGBPYmplY3QucHJvdG90eXBlYCBpbiBvbGRlciB2ZXJzaW9ucyBvZiBJRSwgTmV0c2NhcGUsIGFuZCBNb3ppbGxhLlxuICAgICAgICAoUHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlT2YgPSAwO1xuICAgICAgICB9KS5wcm90b3R5cGUudmFsdWVPZiA9IDA7XG5cbiAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBgUHJvcGVydGllc2AgY2xhc3MuXG4gICAgICAgIG1lbWJlcnMgPSBuZXcgUHJvcGVydGllcygpO1xuICAgICAgICBmb3IgKHByb3BlcnR5IGluIG1lbWJlcnMpIHtcbiAgICAgICAgICAvLyBJZ25vcmUgYWxsIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxuICAgICAgICAgIGlmIChpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFByb3BlcnRpZXMgPSBtZW1iZXJzID0gbnVsbDtcblxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIGl0ZXJhdGlvbiBhbGdvcml0aG0uXG4gICAgICAgIGlmICghc2l6ZSkge1xuICAgICAgICAgIC8vIEEgbGlzdCBvZiBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cbiAgICAgICAgICBtZW1iZXJzID0gW1widmFsdWVPZlwiLCBcInRvU3RyaW5nXCIsIFwidG9Mb2NhbGVTdHJpbmdcIiwgXCJwcm9wZXJ0eUlzRW51bWVyYWJsZVwiLCBcImlzUHJvdG90eXBlT2ZcIiwgXCJoYXNPd25Qcm9wZXJ0eVwiLCBcImNvbnN0cnVjdG9yXCJdO1xuICAgICAgICAgIC8vIElFIDw9IDgsIE1vemlsbGEgMS4wLCBhbmQgTmV0c2NhcGUgNi4yIGlnbm9yZSBzaGFkb3dlZCBub24tZW51bWVyYWJsZVxuICAgICAgICAgIC8vIHByb3BlcnRpZXMuXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgbGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGhhc1Byb3BlcnR5ID0gIWlzRnVuY3Rpb24gJiYgdHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciAhPSBcImZ1bmN0aW9uXCIgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIG9iamVjdC5oYXNPd25Qcm9wZXJ0eV0gJiYgb2JqZWN0Lmhhc093blByb3BlcnR5IHx8IGlzUHJvcGVydHk7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAvLyBHZWNrbyA8PSAxLjAgZW51bWVyYXRlcyB0aGUgYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIHVuZGVyXG4gICAgICAgICAgICAgIC8vIGNlcnRhaW4gY29uZGl0aW9uczsgSUUgZG9lcyBub3QuXG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgZWFjaCBub24tZW51bWVyYWJsZSBwcm9wZXJ0eS5cbiAgICAgICAgICAgIGZvciAobGVuZ3RoID0gbWVtYmVycy5sZW5ndGg7IHByb3BlcnR5ID0gbWVtYmVyc1stLWxlbmd0aF07IGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgY2FsbGJhY2socHJvcGVydHkpKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHNpemUgPT0gMikge1xuICAgICAgICAgIC8vIFNhZmFyaSA8PSAyLjAuNCBlbnVtZXJhdGVzIHNoYWRvd2VkIHByb3BlcnRpZXMgdHdpY2UuXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBzZXQgb2YgaXRlcmF0ZWQgcHJvcGVydGllcy5cbiAgICAgICAgICAgIHZhciBtZW1iZXJzID0ge30sIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHk7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAvLyBTdG9yZSBlYWNoIHByb3BlcnR5IG5hbWUgdG8gcHJldmVudCBkb3VibGUgZW51bWVyYXRpb24uIFRoZVxuICAgICAgICAgICAgICAvLyBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgaXMgbm90IGVudW1lcmF0ZWQgZHVlIHRvIGNyb3NzLVxuICAgICAgICAgICAgICAvLyBlbnZpcm9ubWVudCBpbmNvbnNpc3RlbmNpZXMuXG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgIWlzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkgJiYgKG1lbWJlcnNbcHJvcGVydHldID0gMSkgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBObyBidWdzIGRldGVjdGVkOyB1c2UgdGhlIHN0YW5kYXJkIGBmb3IuLi5pbmAgYWxnb3JpdGhtLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHksIGlzQ29uc3RydWN0b3I7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGlzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiAhKGlzQ29uc3RydWN0b3IgPSBwcm9wZXJ0eSA9PT0gXCJjb25zdHJ1Y3RvclwiKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgZHVlIHRvXG4gICAgICAgICAgICAvLyBjcm9zcy1lbnZpcm9ubWVudCBpbmNvbnNpc3RlbmNpZXMuXG4gICAgICAgICAgICBpZiAoaXNDb25zdHJ1Y3RvciB8fCBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCAocHJvcGVydHkgPSBcImNvbnN0cnVjdG9yXCIpKSkge1xuICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9yRWFjaChvYmplY3QsIGNhbGxiYWNrKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFB1YmxpYzogU2VyaWFsaXplcyBhIEphdmFTY3JpcHQgYHZhbHVlYCBhcyBhIEpTT04gc3RyaW5nLiBUaGUgb3B0aW9uYWxcbiAgICAgIC8vIGBmaWx0ZXJgIGFyZ3VtZW50IG1heSBzcGVjaWZ5IGVpdGhlciBhIGZ1bmN0aW9uIHRoYXQgYWx0ZXJzIGhvdyBvYmplY3QgYW5kXG4gICAgICAvLyBhcnJheSBtZW1iZXJzIGFyZSBzZXJpYWxpemVkLCBvciBhbiBhcnJheSBvZiBzdHJpbmdzIGFuZCBudW1iZXJzIHRoYXRcbiAgICAgIC8vIGluZGljYXRlcyB3aGljaCBwcm9wZXJ0aWVzIHNob3VsZCBiZSBzZXJpYWxpemVkLiBUaGUgb3B0aW9uYWwgYHdpZHRoYFxuICAgICAgLy8gYXJndW1lbnQgbWF5IGJlIGVpdGhlciBhIHN0cmluZyBvciBudW1iZXIgdGhhdCBzcGVjaWZpZXMgdGhlIGluZGVudGF0aW9uXG4gICAgICAvLyBsZXZlbCBvZiB0aGUgb3V0cHV0LlxuICAgICAgaWYgKCFoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSkge1xuICAgICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLlxuICAgICAgICB2YXIgRXNjYXBlcyA9IHtcbiAgICAgICAgICA5MjogXCJcXFxcXFxcXFwiLFxuICAgICAgICAgIDM0OiAnXFxcXFwiJyxcbiAgICAgICAgICA4OiBcIlxcXFxiXCIsXG4gICAgICAgICAgMTI6IFwiXFxcXGZcIixcbiAgICAgICAgICAxMDogXCJcXFxcblwiLFxuICAgICAgICAgIDEzOiBcIlxcXFxyXCIsXG4gICAgICAgICAgOTogXCJcXFxcdFwiXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IENvbnZlcnRzIGB2YWx1ZWAgaW50byBhIHplcm8tcGFkZGVkIHN0cmluZyBzdWNoIHRoYXQgaXRzXG4gICAgICAgIC8vIGxlbmd0aCBpcyBhdCBsZWFzdCBlcXVhbCB0byBgd2lkdGhgLiBUaGUgYHdpZHRoYCBtdXN0IGJlIDw9IDYuXG4gICAgICAgIHZhciBsZWFkaW5nWmVyb2VzID0gXCIwMDAwMDBcIjtcbiAgICAgICAgdmFyIHRvUGFkZGVkU3RyaW5nID0gZnVuY3Rpb24gKHdpZHRoLCB2YWx1ZSkge1xuICAgICAgICAgIC8vIFRoZSBgfHwgMGAgZXhwcmVzc2lvbiBpcyBuZWNlc3NhcnkgdG8gd29yayBhcm91bmQgYSBidWcgaW5cbiAgICAgICAgICAvLyBPcGVyYSA8PSA3LjU0dTIgd2hlcmUgYDAgPT0gLTBgLCBidXQgYFN0cmluZygtMCkgIT09IFwiMFwiYC5cbiAgICAgICAgICByZXR1cm4gKGxlYWRpbmdaZXJvZXMgKyAodmFsdWUgfHwgMCkpLnNsaWNlKC13aWR0aCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IERvdWJsZS1xdW90ZXMgYSBzdHJpbmcgYHZhbHVlYCwgcmVwbGFjaW5nIGFsbCBBU0NJSSBjb250cm9sXG4gICAgICAgIC8vIGNoYXJhY3RlcnMgKGNoYXJhY3RlcnMgd2l0aCBjb2RlIHVuaXQgdmFsdWVzIGJldHdlZW4gMCBhbmQgMzEpIHdpdGhcbiAgICAgICAgLy8gdGhlaXIgZXNjYXBlZCBlcXVpdmFsZW50cy4gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gYFF1b3RlKHZhbHVlKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cbiAgICAgICAgdmFyIHVuaWNvZGVQcmVmaXggPSBcIlxcXFx1MDBcIjtcbiAgICAgICAgdmFyIHF1b3RlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9ICdcIicsIGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoLCB1c2VDaGFySW5kZXggPSAhY2hhckluZGV4QnVnZ3kgfHwgbGVuZ3RoID4gMTA7XG4gICAgICAgICAgdmFyIHN5bWJvbHMgPSB1c2VDaGFySW5kZXggJiYgKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuc3BsaXQoXCJcIikgOiB2YWx1ZSk7XG4gICAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgY2hhckNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgYSBjb250cm9sIGNoYXJhY3RlciwgYXBwZW5kIGl0cyBVbmljb2RlIG9yXG4gICAgICAgICAgICAvLyBzaG9ydGhhbmQgZXNjYXBlIHNlcXVlbmNlOyBvdGhlcndpc2UsIGFwcGVuZCB0aGUgY2hhcmFjdGVyIGFzLWlzLlxuICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICBjYXNlIDg6IGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMjogY2FzZSAxMzogY2FzZSAzNDogY2FzZSA5MjpcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gRXNjYXBlc1tjaGFyQ29kZV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMzIpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB1bmljb2RlUHJlZml4ICsgdG9QYWRkZWRTdHJpbmcoMiwgY2hhckNvZGUudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdXNlQ2hhckluZGV4ID8gc3ltYm9sc1tpbmRleF0gOiB2YWx1ZS5jaGFyQXQoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgJ1wiJztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgc2VyaWFsaXplcyBhbiBvYmplY3QuIEltcGxlbWVudHMgdGhlXG4gICAgICAgIC8vIGBTdHIoa2V5LCBob2xkZXIpYCwgYEpPKHZhbHVlKWAsIGFuZCBgSkEodmFsdWUpYCBvcGVyYXRpb25zLlxuICAgICAgICB2YXIgc2VyaWFsaXplID0gZnVuY3Rpb24gKHByb3BlcnR5LCBvYmplY3QsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spIHtcbiAgICAgICAgICB2YXIgdmFsdWUsIGNsYXNzTmFtZSwgeWVhciwgbW9udGgsIGRhdGUsIHRpbWUsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIHJlc3VsdHMsIGVsZW1lbnQsIGluZGV4LCBsZW5ndGgsIHByZWZpeCwgcmVzdWx0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBOZWNlc3NhcnkgZm9yIGhvc3Qgb2JqZWN0IHN1cHBvcnQuXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGRhdGVDbGFzcyAmJiAhaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInRvSlNPTlwiKSkge1xuICAgICAgICAgICAgICBpZiAodmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCkge1xuICAgICAgICAgICAgICAgIC8vIERhdGVzIGFyZSBzZXJpYWxpemVkIGFjY29yZGluZyB0byB0aGUgYERhdGUjdG9KU09OYCBtZXRob2RcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuOS41LjQ0LiBTZWUgc2VjdGlvbiAxNS45LjEuMTVcbiAgICAgICAgICAgICAgICAvLyBmb3IgdGhlIElTTyA4NjAxIGRhdGUgdGltZSBzdHJpbmcgZm9ybWF0LlxuICAgICAgICAgICAgICAgIGlmIChnZXREYXkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIE1hbnVhbGx5IGNvbXB1dGUgdGhlIHllYXIsIG1vbnRoLCBkYXRlLCBob3VycywgbWludXRlcyxcbiAgICAgICAgICAgICAgICAgIC8vIHNlY29uZHMsIGFuZCBtaWxsaXNlY29uZHMgaWYgdGhlIGBnZXRVVEMqYCBtZXRob2RzIGFyZVxuICAgICAgICAgICAgICAgICAgLy8gYnVnZ3kuIEFkYXB0ZWQgZnJvbSBAWWFmZmxlJ3MgYGRhdGUtc2hpbWAgcHJvamVjdC5cbiAgICAgICAgICAgICAgICAgIGRhdGUgPSBmbG9vcih2YWx1ZSAvIDg2NGU1KTtcbiAgICAgICAgICAgICAgICAgIGZvciAoeWVhciA9IGZsb29yKGRhdGUgLyAzNjUuMjQyNSkgKyAxOTcwIC0gMTsgZ2V0RGF5KHllYXIgKyAxLCAwKSA8PSBkYXRlOyB5ZWFyKyspO1xuICAgICAgICAgICAgICAgICAgZm9yIChtb250aCA9IGZsb29yKChkYXRlIC0gZ2V0RGF5KHllYXIsIDApKSAvIDMwLjQyKTsgZ2V0RGF5KHllYXIsIG1vbnRoICsgMSkgPD0gZGF0ZTsgbW9udGgrKyk7XG4gICAgICAgICAgICAgICAgICBkYXRlID0gMSArIGRhdGUgLSBnZXREYXkoeWVhciwgbW9udGgpO1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGB0aW1lYCB2YWx1ZSBzcGVjaWZpZXMgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkgKHNlZSBFU1xuICAgICAgICAgICAgICAgICAgLy8gNS4xIHNlY3Rpb24gMTUuOS4xLjIpLiBUaGUgZm9ybXVsYSBgKEEgJSBCICsgQikgJSBCYCBpcyB1c2VkXG4gICAgICAgICAgICAgICAgICAvLyB0byBjb21wdXRlIGBBIG1vZHVsbyBCYCwgYXMgdGhlIGAlYCBvcGVyYXRvciBkb2VzIG5vdFxuICAgICAgICAgICAgICAgICAgLy8gY29ycmVzcG9uZCB0byB0aGUgYG1vZHVsb2Agb3BlcmF0aW9uIGZvciBuZWdhdGl2ZSBudW1iZXJzLlxuICAgICAgICAgICAgICAgICAgdGltZSA9ICh2YWx1ZSAlIDg2NGU1ICsgODY0ZTUpICUgODY0ZTU7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIGFuZCBtaWxsaXNlY29uZHMgYXJlIG9idGFpbmVkIGJ5XG4gICAgICAgICAgICAgICAgICAvLyBkZWNvbXBvc2luZyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheS4gU2VlIHNlY3Rpb24gMTUuOS4xLjEwLlxuICAgICAgICAgICAgICAgICAgaG91cnMgPSBmbG9vcih0aW1lIC8gMzZlNSkgJSAyNDtcbiAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBmbG9vcih0aW1lIC8gNmU0KSAlIDYwO1xuICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IGZsb29yKHRpbWUgLyAxZTMpICUgNjA7XG4gICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB0aW1lICUgMWUzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB5ZWFyID0gdmFsdWUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICAgIG1vbnRoID0gdmFsdWUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgICAgICAgICAgIGRhdGUgPSB2YWx1ZS5nZXRVVENEYXRlKCk7XG4gICAgICAgICAgICAgICAgICBob3VycyA9IHZhbHVlLmdldFVUQ0hvdXJzKCk7XG4gICAgICAgICAgICAgICAgICBtaW51dGVzID0gdmFsdWUuZ2V0VVRDTWludXRlcygpO1xuICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IHZhbHVlLmdldFVUQ1NlY29uZHMoKTtcbiAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHZhbHVlLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTZXJpYWxpemUgZXh0ZW5kZWQgeWVhcnMgY29ycmVjdGx5LlxuICAgICAgICAgICAgICAgIHZhbHVlID0gKHllYXIgPD0gMCB8fCB5ZWFyID49IDFlNCA/ICh5ZWFyIDwgMCA/IFwiLVwiIDogXCIrXCIpICsgdG9QYWRkZWRTdHJpbmcoNiwgeWVhciA8IDAgPyAteWVhciA6IHllYXIpIDogdG9QYWRkZWRTdHJpbmcoNCwgeWVhcikpICtcbiAgICAgICAgICAgICAgICAgIFwiLVwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbW9udGggKyAxKSArIFwiLVwiICsgdG9QYWRkZWRTdHJpbmcoMiwgZGF0ZSkgK1xuICAgICAgICAgICAgICAgICAgLy8gTW9udGhzLCBkYXRlcywgaG91cnMsIG1pbnV0ZXMsIGFuZCBzZWNvbmRzIHNob3VsZCBoYXZlIHR3b1xuICAgICAgICAgICAgICAgICAgLy8gZGlnaXRzOyBtaWxsaXNlY29uZHMgc2hvdWxkIGhhdmUgdGhyZWUuXG4gICAgICAgICAgICAgICAgICBcIlRcIiArIHRvUGFkZGVkU3RyaW5nKDIsIGhvdXJzKSArIFwiOlwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbWludXRlcykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIHNlY29uZHMpICtcbiAgICAgICAgICAgICAgICAgIC8vIE1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNS4wLCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuICAgICAgICAgICAgICAgICAgXCIuXCIgKyB0b1BhZGRlZFN0cmluZygzLCBtaWxsaXNlY29uZHMpICsgXCJaXCI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZS50b0pTT04gPT0gXCJmdW5jdGlvblwiICYmICgoY2xhc3NOYW1lICE9IG51bWJlckNsYXNzICYmIGNsYXNzTmFtZSAhPSBzdHJpbmdDbGFzcyAmJiBjbGFzc05hbWUgIT0gYXJyYXlDbGFzcykgfHwgaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInRvSlNPTlwiKSkpIHtcbiAgICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIGFkZHMgbm9uLXN0YW5kYXJkIGB0b0pTT05gIG1ldGhvZHMgdG8gdGhlXG4gICAgICAgICAgICAgIC8vIGBOdW1iZXJgLCBgU3RyaW5nYCwgYERhdGVgLCBhbmQgYEFycmF5YCBwcm90b3R5cGVzLiBKU09OIDNcbiAgICAgICAgICAgICAgLy8gaWdub3JlcyBhbGwgYHRvSlNPTmAgbWV0aG9kcyBvbiB0aGVzZSBvYmplY3RzIHVubGVzcyB0aGV5IGFyZVxuICAgICAgICAgICAgICAvLyBkZWZpbmVkIGRpcmVjdGx5IG9uIGFuIGluc3RhbmNlLlxuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gSWYgYSByZXBsYWNlbWVudCBmdW5jdGlvbiB3YXMgcHJvdmlkZWQsIGNhbGwgaXQgdG8gb2J0YWluIHRoZSB2YWx1ZVxuICAgICAgICAgICAgLy8gZm9yIHNlcmlhbGl6YXRpb24uXG4gICAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrLmNhbGwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XG4gICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBib29sZWFuQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIEJvb2xlYW5zIGFyZSByZXByZXNlbnRlZCBsaXRlcmFsbHkuXG4gICAgICAgICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSB7XG4gICAgICAgICAgICAvLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIGBJbmZpbml0eWAgYW5kIGBOYU5gIGFyZSBzZXJpYWxpemVkIGFzXG4gICAgICAgICAgICAvLyBgXCJudWxsXCJgLlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDAgPyBcIlwiICsgdmFsdWUgOiBcIm51bGxcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xuICAgICAgICAgICAgLy8gU3RyaW5ncyBhcmUgZG91YmxlLXF1b3RlZCBhbmQgZXNjYXBlZC5cbiAgICAgICAgICAgIHJldHVybiBxdW90ZShcIlwiICsgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGlzIGlzIGEgbGluZWFyIHNlYXJjaDsgcGVyZm9ybWFuY2VcbiAgICAgICAgICAgIC8vIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZiB1bmlxdWUgbmVzdGVkIG9iamVjdHMuXG4gICAgICAgICAgICBmb3IgKGxlbmd0aCA9IHN0YWNrLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgICAgICAgIGlmIChzdGFja1tsZW5ndGhdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIEN5Y2xpYyBzdHJ1Y3R1cmVzIGNhbm5vdCBiZSBzZXJpYWxpemVkIGJ5IGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbCBhbmQgaW5kZW50IG9uZSBhZGRpdGlvbmFsIGxldmVsLlxuICAgICAgICAgICAgcHJlZml4ID0gaW5kZW50YXRpb247XG4gICAgICAgICAgICBpbmRlbnRhdGlvbiArPSB3aGl0ZXNwYWNlO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBhcnJheSBlbGVtZW50cy5cbiAgICAgICAgICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gc2VyaWFsaXplKGluZGV4LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGVsZW1lbnQgPT09IHVuZGVmID8gXCJudWxsXCIgOiBlbGVtZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzLmxlbmd0aCA/ICh3aGl0ZXNwYWNlID8gXCJbXFxuXCIgKyBpbmRlbnRhdGlvbiArIHJlc3VsdHMuam9pbihcIixcXG5cIiArIGluZGVudGF0aW9uKSArIFwiXFxuXCIgKyBwcmVmaXggKyBcIl1cIiA6IChcIltcIiArIHJlc3VsdHMuam9pbihcIixcIikgKyBcIl1cIikpIDogXCJbXVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdCBtZW1iZXJzLiBNZW1iZXJzIGFyZSBzZWxlY3RlZCBmcm9tXG4gICAgICAgICAgICAgIC8vIGVpdGhlciBhIHVzZXItc3BlY2lmaWVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMsIG9yIHRoZSBvYmplY3RcbiAgICAgICAgICAgICAgLy8gaXRzZWxmLlxuICAgICAgICAgICAgICBmb3JFYWNoKHByb3BlcnRpZXMgfHwgdmFsdWUsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gc2VyaWFsaXplKHByb3BlcnR5LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT09IHVuZGVmKSB7XG4gICAgICAgICAgICAgICAgICAvLyBBY2NvcmRpbmcgdG8gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMzogXCJJZiBgZ2FwYCB7d2hpdGVzcGFjZX1cbiAgICAgICAgICAgICAgICAgIC8vIGlzIG5vdCB0aGUgZW1wdHkgc3RyaW5nLCBsZXQgYG1lbWJlcmAge3F1b3RlKHByb3BlcnR5KSArIFwiOlwifVxuICAgICAgICAgICAgICAgICAgLy8gYmUgdGhlIGNvbmNhdGVuYXRpb24gb2YgYG1lbWJlcmAgYW5kIHRoZSBgc3BhY2VgIGNoYXJhY3Rlci5cIlxuICAgICAgICAgICAgICAgICAgLy8gVGhlIFwiYHNwYWNlYCBjaGFyYWN0ZXJcIiByZWZlcnMgdG8gdGhlIGxpdGVyYWwgc3BhY2VcbiAgICAgICAgICAgICAgICAgIC8vIGNoYXJhY3Rlciwgbm90IHRoZSBgc3BhY2VgIHt3aWR0aH0gYXJndW1lbnQgcHJvdmlkZWQgdG9cbiAgICAgICAgICAgICAgICAgIC8vIGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocXVvdGUocHJvcGVydHkpICsgXCI6XCIgKyAod2hpdGVzcGFjZSA/IFwiIFwiIDogXCJcIikgKyBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzLmxlbmd0aCA/ICh3aGl0ZXNwYWNlID8gXCJ7XFxuXCIgKyBpbmRlbnRhdGlvbiArIHJlc3VsdHMuam9pbihcIixcXG5cIiArIGluZGVudGF0aW9uKSArIFwiXFxuXCIgKyBwcmVmaXggKyBcIn1cIiA6IChcIntcIiArIHJlc3VsdHMuam9pbihcIixcIikgKyBcIn1cIikpIDogXCJ7fVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBvYmplY3QgZnJvbSB0aGUgdHJhdmVyc2VkIG9iamVjdCBzdGFjay5cbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUHVibGljOiBgSlNPTi5zdHJpbmdpZnlgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cbiAgICAgICAgZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAoc291cmNlLCBmaWx0ZXIsIHdpZHRoKSB7XG4gICAgICAgICAgdmFyIHdoaXRlc3BhY2UsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCBjbGFzc05hbWU7XG4gICAgICAgICAgaWYgKG9iamVjdFR5cGVzW3R5cGVvZiBmaWx0ZXJdICYmIGZpbHRlcikge1xuICAgICAgICAgICAgaWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKGZpbHRlcikpID09IGZ1bmN0aW9uQ2xhc3MpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmaWx0ZXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHByb3BlcnR5IG5hbWVzIGFycmF5IGludG8gYSBtYWtlc2hpZnQgc2V0LlxuICAgICAgICAgICAgICBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoID0gZmlsdGVyLmxlbmd0aCwgdmFsdWU7IGluZGV4IDwgbGVuZ3RoOyB2YWx1ZSA9IGZpbHRlcltpbmRleCsrXSwgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKSksIGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcyB8fCBjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpICYmIChwcm9wZXJ0aWVzW3ZhbHVlXSA9IDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwod2lkdGgpKSA9PSBudW1iZXJDbGFzcykge1xuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBgd2lkdGhgIHRvIGFuIGludGVnZXIgYW5kIGNyZWF0ZSBhIHN0cmluZyBjb250YWluaW5nXG4gICAgICAgICAgICAgIC8vIGB3aWR0aGAgbnVtYmVyIG9mIHNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgIGlmICgod2lkdGggLT0gd2lkdGggJSAxKSA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKHdoaXRlc3BhY2UgPSBcIlwiLCB3aWR0aCA+IDEwICYmICh3aWR0aCA9IDEwKTsgd2hpdGVzcGFjZS5sZW5ndGggPCB3aWR0aDsgd2hpdGVzcGFjZSArPSBcIiBcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzKSB7XG4gICAgICAgICAgICAgIHdoaXRlc3BhY2UgPSB3aWR0aC5sZW5ndGggPD0gMTAgPyB3aWR0aCA6IHdpZHRoLnNsaWNlKDAsIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIGRpc2NhcmRzIHRoZSB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIGVtcHR5IHN0cmluZyBrZXlzXG4gICAgICAgICAgLy8gKGBcIlwiYCkgb25seSBpZiB0aGV5IGFyZSB1c2VkIGRpcmVjdGx5IHdpdGhpbiBhbiBvYmplY3QgbWVtYmVyIGxpc3RcbiAgICAgICAgICAvLyAoZS5nLiwgYCEoXCJcIiBpbiB7IFwiXCI6IDF9KWApLlxuICAgICAgICAgIHJldHVybiBzZXJpYWxpemUoXCJcIiwgKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gc291cmNlLCB2YWx1ZSksIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBcIlwiLCBbXSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIFB1YmxpYzogUGFyc2VzIGEgSlNPTiBzb3VyY2Ugc3RyaW5nLlxuICAgICAgaWYgKCFoYXMoXCJqc29uLXBhcnNlXCIpKSB7XG4gICAgICAgIHZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4gICAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgdW5lc2NhcGVkXG4gICAgICAgIC8vIGVxdWl2YWxlbnRzLlxuICAgICAgICB2YXIgVW5lc2NhcGVzID0ge1xuICAgICAgICAgIDkyOiBcIlxcXFxcIixcbiAgICAgICAgICAzNDogJ1wiJyxcbiAgICAgICAgICA0NzogXCIvXCIsXG4gICAgICAgICAgOTg6IFwiXFxiXCIsXG4gICAgICAgICAgMTE2OiBcIlxcdFwiLFxuICAgICAgICAgIDExMDogXCJcXG5cIixcbiAgICAgICAgICAxMDI6IFwiXFxmXCIsXG4gICAgICAgICAgMTE0OiBcIlxcclwiXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFN0b3JlcyB0aGUgcGFyc2VyIHN0YXRlLlxuICAgICAgICB2YXIgSW5kZXgsIFNvdXJjZTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVzZXRzIHRoZSBwYXJzZXIgc3RhdGUgYW5kIHRocm93cyBhIGBTeW50YXhFcnJvcmAuXG4gICAgICAgIHZhciBhYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgdGhyb3cgU3ludGF4RXJyb3IoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmV0dXJucyB0aGUgbmV4dCB0b2tlbiwgb3IgYFwiJFwiYCBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkXG4gICAgICAgIC8vIHRoZSBlbmQgb2YgdGhlIHNvdXJjZSBzdHJpbmcuIEEgdG9rZW4gbWF5IGJlIGEgc3RyaW5nLCBudW1iZXIsIGBudWxsYFxuICAgICAgICAvLyBsaXRlcmFsLCBvciBCb29sZWFuIGxpdGVyYWwuXG4gICAgICAgIHZhciBsZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IFNvdXJjZSwgbGVuZ3RoID0gc291cmNlLmxlbmd0aCwgdmFsdWUsIGJlZ2luLCBwb3NpdGlvbiwgaXNTaWduZWQsIGNoYXJDb2RlO1xuICAgICAgICAgIHdoaWxlIChJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMzogY2FzZSAzMjpcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHdoaXRlc3BhY2UgdG9rZW5zLCBpbmNsdWRpbmcgdGFicywgY2FycmlhZ2UgcmV0dXJucywgbGluZVxuICAgICAgICAgICAgICAgIC8vIGZlZWRzLCBhbmQgc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDEyMzogY2FzZSAxMjU6IGNhc2UgOTE6IGNhc2UgOTM6IGNhc2UgNTg6IGNhc2UgNDQ6XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgYSBwdW5jdHVhdG9yIHRva2VuIChge2AsIGB9YCwgYFtgLCBgXWAsIGA6YCwgb3IgYCxgKSBhdFxuICAgICAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgICAgICAgICAgIHZhbHVlID0gY2hhckluZGV4QnVnZ3kgPyBzb3VyY2UuY2hhckF0KEluZGV4KSA6IHNvdXJjZVtJbmRleF07XG4gICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICAgICAgLy8gYFwiYCBkZWxpbWl0cyBhIEpTT04gc3RyaW5nOyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmRcbiAgICAgICAgICAgICAgICAvLyBiZWdpbiBwYXJzaW5nIHRoZSBzdHJpbmcuIFN0cmluZyB0b2tlbnMgYXJlIHByZWZpeGVkIHdpdGggdGhlXG4gICAgICAgICAgICAgICAgLy8gc2VudGluZWwgYEBgIGNoYXJhY3RlciB0byBkaXN0aW5ndWlzaCB0aGVtIGZyb20gcHVuY3R1YXRvcnMgYW5kXG4gICAgICAgICAgICAgICAgLy8gZW5kLW9mLXN0cmluZyB0b2tlbnMuXG4gICAgICAgICAgICAgICAgZm9yICh2YWx1ZSA9IFwiQFwiLCBJbmRleCsrOyBJbmRleCA8IGxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMzIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5lc2NhcGVkIEFTQ0lJIGNvbnRyb2wgY2hhcmFjdGVycyAodGhvc2Ugd2l0aCBhIGNvZGUgdW5pdFxuICAgICAgICAgICAgICAgICAgICAvLyBsZXNzIHRoYW4gdGhlIHNwYWNlIGNoYXJhY3RlcikgYXJlIG5vdCBwZXJtaXR0ZWQuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJDb2RlID09IDkyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgcmV2ZXJzZSBzb2xpZHVzIChgXFxgKSBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGFuIGVzY2FwZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udHJvbCBjaGFyYWN0ZXIgKGluY2x1ZGluZyBgXCJgLCBgXFxgLCBhbmQgYC9gKSBvciBVbmljb2RlXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTI6IGNhc2UgMzQ6IGNhc2UgNDc6IGNhc2UgOTg6IGNhc2UgMTE2OiBjYXNlIDExMDogY2FzZSAxMDI6IGNhc2UgMTE0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2aXZlIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gVW5lc2NhcGVzW2NoYXJDb2RlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBcXHVgIG1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgYSBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgdmFsaWRhdGUgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IGNvZGUgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBiZWdpbiA9ICsrSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHBvc2l0aW9uID0gSW5kZXggKyA0OyBJbmRleCA8IHBvc2l0aW9uOyBJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBIHZhbGlkIHNlcXVlbmNlIGNvbXByaXNlcyBmb3VyIGhleGRpZ2l0cyAoY2FzZS1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zZW5zaXRpdmUpIHRoYXQgZm9ybSBhIHNpbmdsZSBoZXhhZGVjaW1hbCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcgfHwgY2hhckNvZGUgPj0gOTcgJiYgY2hhckNvZGUgPD0gMTAyIHx8IGNoYXJDb2RlID49IDY1ICYmIGNoYXJDb2RlIDw9IDcwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2aXZlIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGZyb21DaGFyQ29kZShcIjB4XCIgKyBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBBbiB1bmVzY2FwZWQgZG91YmxlLXF1b3RlIGNoYXJhY3RlciBtYXJrcyB0aGUgZW5kIG9mIHRoZVxuICAgICAgICAgICAgICAgICAgICAgIC8vIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSBJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW1pemUgZm9yIHRoZSBjb21tb24gY2FzZSB3aGVyZSBhIHN0cmluZyBpcyB2YWxpZC5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNoYXJDb2RlID49IDMyICYmIGNoYXJDb2RlICE9IDkyICYmIGNoYXJDb2RlICE9IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIHN0cmluZyBhcy1pcy5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZCByZXR1cm4gdGhlIHJldml2ZWQgc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVW50ZXJtaW5hdGVkIHN0cmluZy5cbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIG51bWJlcnMgYW5kIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgICAgICAgICAgLy8gQWR2YW5jZSBwYXN0IHRoZSBuZWdhdGl2ZSBzaWduLCBpZiBvbmUgaXMgc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0NSkge1xuICAgICAgICAgICAgICAgICAgaXNTaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgYW4gaW50ZWdlciBvciBmbG9hdGluZy1wb2ludCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpIHtcbiAgICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgemVyb2VzIGFyZSBpbnRlcnByZXRlZCBhcyBvY3RhbCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0OCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXggKyAxKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIG9jdGFsIGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpc1NpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGludGVnZXIgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgZm9yICg7IEluZGV4IDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IEluZGV4KyspO1xuICAgICAgICAgICAgICAgICAgLy8gRmxvYXRzIGNhbm5vdCBjb250YWluIGEgbGVhZGluZyBkZWNpbWFsIHBvaW50OyBob3dldmVyLCB0aGlzXG4gICAgICAgICAgICAgICAgICAvLyBjYXNlIGlzIGFscmVhZHkgYWNjb3VudGVkIGZvciBieSB0aGUgcGFyc2VyLlxuICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSA9PSA0Nikge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9ICsrSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBkZWNpbWFsIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbikpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIHRyYWlsaW5nIGRlY2ltYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgZXhwb25lbnRzLiBUaGUgYGVgIGRlbm90aW5nIHRoZSBleHBvbmVudCBpc1xuICAgICAgICAgICAgICAgICAgLy8gY2FzZS1pbnNlbnNpdGl2ZS5cbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDEwMSB8fCBjaGFyQ29kZSA9PSA2OSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHBhc3QgdGhlIHNpZ24gZm9sbG93aW5nIHRoZSBleHBvbmVudCwgaWYgb25lIGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQzIHx8IGNoYXJDb2RlID09IDQ1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZXhwb25lbnRpYWwgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgICBmb3IgKHBvc2l0aW9uID0gSW5kZXg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbikpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIGVtcHR5IGV4cG9uZW50LlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIENvZXJjZSB0aGUgcGFyc2VkIHZhbHVlIHRvIGEgSmF2YVNjcmlwdCBudW1iZXIuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gK3NvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBIG5lZ2F0aXZlIHNpZ24gbWF5IG9ubHkgcHJlY2VkZSBudW1iZXJzLlxuICAgICAgICAgICAgICAgIGlmIChpc1NpZ25lZCkge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYHRydWVgLCBgZmFsc2VgLCBhbmQgYG51bGxgIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA1KSA9PSBcImZhbHNlXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDU7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJudWxsXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVW5yZWNvZ25pemVkIHRva2VuLlxuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJldHVybiB0aGUgc2VudGluZWwgYCRgIGNoYXJhY3RlciBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkIHRoZSBlbmRcbiAgICAgICAgICAvLyBvZiB0aGUgc291cmNlIHN0cmluZy5cbiAgICAgICAgICByZXR1cm4gXCIkXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFBhcnNlcyBhIEpTT04gYHZhbHVlYCB0b2tlbi5cbiAgICAgICAgdmFyIGdldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHRzLCBoYXNNZW1iZXJzO1xuICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIiRcIikge1xuICAgICAgICAgICAgLy8gVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQuXG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmICgoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgPT0gXCJAXCIpIHtcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzZW50aW5lbCBgQGAgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQYXJzZSBvYmplY3QgYW5kIGFycmF5IGxpdGVyYWxzLlxuICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiW1wiKSB7XG4gICAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gYXJyYXksIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IGFycmF5LlxuICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgIGZvciAoOzsgaGFzTWVtYmVycyB8fCAoaGFzTWVtYmVycyA9IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAvLyBBIGNsb3Npbmcgc3F1YXJlIGJyYWNrZXQgbWFya3MgdGhlIGVuZCBvZiB0aGUgYXJyYXkgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYXJyYXkgbGl0ZXJhbCBjb250YWlucyBlbGVtZW50cywgdGhlIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0aW5nIHRoZSBwcmV2aW91cyBlbGVtZW50IGZyb20gdGhlXG4gICAgICAgICAgICAgICAgLy8gbmV4dC5cbiAgICAgICAgICAgICAgICBpZiAoaGFzTWVtYmVycykge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIl1cIikge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIGFycmF5IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIGFycmF5IGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEVsaXNpb25zIGFuZCBsZWFkaW5nIGNvbW1hcyBhcmUgbm90IHBlcm1pdHRlZC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChnZXQodmFsdWUpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgLy8gUGFyc2VzIGEgSlNPTiBvYmplY3QsIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IG9iamVjdC5cbiAgICAgICAgICAgICAgcmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgLy8gQSBjbG9zaW5nIGN1cmx5IGJyYWNlIG1hcmtzIHRoZSBlbmQgb2YgdGhlIG9iamVjdCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIn1cIikge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3QgbGl0ZXJhbCBjb250YWlucyBtZW1iZXJzLCB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRvci5cbiAgICAgICAgICAgICAgICBpZiAoaGFzTWVtYmVycykge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIn1cIikge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIG9iamVjdCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBvYmplY3QgbWVtYmVyLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIGNvbW1hcyBhcmUgbm90IHBlcm1pdHRlZCwgb2JqZWN0IHByb3BlcnR5IG5hbWVzIG11c3QgYmVcbiAgICAgICAgICAgICAgICAvLyBkb3VibGUtcXVvdGVkIHN0cmluZ3MsIGFuZCBhIGA6YCBtdXN0IHNlcGFyYXRlIGVhY2ggcHJvcGVydHlcbiAgICAgICAgICAgICAgICAvLyBuYW1lIGFuZCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIgfHwgdHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIgfHwgKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pICE9IFwiQFwiIHx8IGxleCgpICE9IFwiOlwiKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzW3ZhbHVlLnNsaWNlKDEpXSA9IGdldChsZXgoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRva2VuIGVuY291bnRlcmVkLlxuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBVcGRhdGVzIGEgdHJhdmVyc2VkIG9iamVjdCBtZW1iZXIuXG4gICAgICAgIHZhciB1cGRhdGUgPSBmdW5jdGlvbiAoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgZWxlbWVudCA9IHdhbGsoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgICAgIGlmIChlbGVtZW50ID09PSB1bmRlZikge1xuICAgICAgICAgICAgZGVsZXRlIHNvdXJjZVtwcm9wZXJ0eV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNvdXJjZVtwcm9wZXJ0eV0gPSBlbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgdHJhdmVyc2VzIGEgcGFyc2VkIEpTT04gb2JqZWN0LCBpbnZva2luZyB0aGVcbiAgICAgICAgLy8gYGNhbGxiYWNrYCBmdW5jdGlvbiBmb3IgZWFjaCB2YWx1ZS4gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gYFdhbGsoaG9sZGVyLCBuYW1lKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cbiAgICAgICAgdmFyIHdhbGsgPSBmdW5jdGlvbiAoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2VbcHJvcGVydHldLCBsZW5ndGg7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBgZm9yRWFjaGAgY2FuJ3QgYmUgdXNlZCB0byB0cmF2ZXJzZSBhbiBhcnJheSBpbiBPcGVyYSA8PSA4LjU0XG4gICAgICAgICAgICAvLyBiZWNhdXNlIGl0cyBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIGBmYWxzZWBcbiAgICAgICAgICAgIC8vIGZvciBhcnJheSBpbmRpY2VzIChlLmcuLCBgIVsxLCAyLCAzXS5oYXNPd25Qcm9wZXJ0eShcIjBcIilgKS5cbiAgICAgICAgICAgIGlmIChnZXRDbGFzcy5jYWxsKHZhbHVlKSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIGZvciAobGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBsZW5ndGgtLTspIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIGxlbmd0aCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmb3JFYWNoKHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzb3VyY2UsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUHVibGljOiBgSlNPTi5wYXJzZWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuICAgICAgICBleHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgcmVzdWx0LCB2YWx1ZTtcbiAgICAgICAgICBJbmRleCA9IDA7XG4gICAgICAgICAgU291cmNlID0gXCJcIiArIHNvdXJjZTtcbiAgICAgICAgICByZXN1bHQgPSBnZXQobGV4KCkpO1xuICAgICAgICAgIC8vIElmIGEgSlNPTiBzdHJpbmcgY29udGFpbnMgbXVsdGlwbGUgdG9rZW5zLCBpdCBpcyBpbnZhbGlkLlxuICAgICAgICAgIGlmIChsZXgoKSAhPSBcIiRcIikge1xuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmVzZXQgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrICYmIGdldENsYXNzLmNhbGwoY2FsbGJhY2spID09IGZ1bmN0aW9uQ2xhc3MgPyB3YWxrKCh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHJlc3VsdCwgdmFsdWUpLCBcIlwiLCBjYWxsYmFjaykgOiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZXhwb3J0c1tcInJ1bkluQ29udGV4dFwiXSA9IHJ1bkluQ29udGV4dDtcbiAgICByZXR1cm4gZXhwb3J0cztcbiAgfVxuXG4gIGlmIChmcmVlRXhwb3J0cyAmJiAhaXNMb2FkZXIpIHtcbiAgICAvLyBFeHBvcnQgZm9yIENvbW1vbkpTIGVudmlyb25tZW50cy5cbiAgICBydW5JbkNvbnRleHQocm9vdCwgZnJlZUV4cG9ydHMpO1xuICB9IGVsc2Uge1xuICAgIC8vIEV4cG9ydCBmb3Igd2ViIGJyb3dzZXJzIGFuZCBKYXZhU2NyaXB0IGVuZ2luZXMuXG4gICAgdmFyIG5hdGl2ZUpTT04gPSByb290LkpTT04sXG4gICAgICAgIHByZXZpb3VzSlNPTiA9IHJvb3RbXCJKU09OM1wiXSxcbiAgICAgICAgaXNSZXN0b3JlZCA9IGZhbHNlO1xuXG4gICAgdmFyIEpTT04zID0gcnVuSW5Db250ZXh0KHJvb3QsIChyb290W1wiSlNPTjNcIl0gPSB7XG4gICAgICAvLyBQdWJsaWM6IFJlc3RvcmVzIHRoZSBvcmlnaW5hbCB2YWx1ZSBvZiB0aGUgZ2xvYmFsIGBKU09OYCBvYmplY3QgYW5kXG4gICAgICAvLyByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBgSlNPTjNgIG9iamVjdC5cbiAgICAgIFwibm9Db25mbGljdFwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaXNSZXN0b3JlZCkge1xuICAgICAgICAgIGlzUmVzdG9yZWQgPSB0cnVlO1xuICAgICAgICAgIHJvb3QuSlNPTiA9IG5hdGl2ZUpTT047XG4gICAgICAgICAgcm9vdFtcIkpTT04zXCJdID0gcHJldmlvdXNKU09OO1xuICAgICAgICAgIG5hdGl2ZUpTT04gPSBwcmV2aW91c0pTT04gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKU09OMztcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICByb290LkpTT04gPSB7XG4gICAgICBcInBhcnNlXCI6IEpTT04zLnBhcnNlLFxuICAgICAgXCJzdHJpbmdpZnlcIjogSlNPTjMuc3RyaW5naWZ5XG4gICAgfTtcbiAgfVxuXG4gIC8vIEV4cG9ydCBmb3IgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLlxuICBpZiAoaXNMb2FkZXIpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIEpTT04zO1xuICAgIH0pO1xuICB9XG59KS5jYWxsKHRoaXMpO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sNTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBTaW1wbGUgcXVlcnkgc3RyaW5nIHBhcnNlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcXVlcnkgVGhlIHF1ZXJ5IHN0cmluZyB0aGF0IG5lZWRzIHRvIGJlIHBhcnNlZC5cbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBxdWVyeXN0cmluZyhxdWVyeSkge1xuICB2YXIgcGFyc2VyID0gLyhbXj0/Jl0rKT0/KFteJl0qKS9nXG4gICAgLCByZXN1bHQgPSB7fVxuICAgICwgcGFydDtcblxuICAvL1xuICAvLyBMaXR0bGUgbmlmdHkgcGFyc2luZyBoYWNrLCBsZXZlcmFnZSB0aGUgZmFjdCB0aGF0IFJlZ0V4cC5leGVjIGluY3JlbWVudHNcbiAgLy8gdGhlIGxhc3RJbmRleCBwcm9wZXJ0eSBzbyB3ZSBjYW4gY29udGludWUgZXhlY3V0aW5nIHRoaXMgbG9vcCB1bnRpbCB3ZSd2ZVxuICAvLyBwYXJzZWQgYWxsIHJlc3VsdHMuXG4gIC8vXG4gIGZvciAoO1xuICAgIHBhcnQgPSBwYXJzZXIuZXhlYyhxdWVyeSk7XG4gICAgcmVzdWx0W2RlY29kZVVSSUNvbXBvbmVudChwYXJ0WzFdKV0gPSBkZWNvZGVVUklDb21wb25lbnQocGFydFsyXSlcbiAgKTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhIHF1ZXJ5IHN0cmluZyB0byBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBPYmplY3QgdGhhdCBzaG91bGQgYmUgdHJhbnNmb3JtZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4IE9wdGlvbmFsIHByZWZpeC5cbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBxdWVyeXN0cmluZ2lmeShvYmosIHByZWZpeCkge1xuICBwcmVmaXggPSBwcmVmaXggfHwgJyc7XG5cbiAgdmFyIHBhaXJzID0gW107XG5cbiAgLy9cbiAgLy8gT3B0aW9uYWxseSBwcmVmaXggd2l0aCBhICc/JyBpZiBuZWVkZWRcbiAgLy9cbiAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgcHJlZml4KSBwcmVmaXggPSAnPyc7XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIHBhaXJzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyc9JysgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtrZXldKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhaXJzLmxlbmd0aCA/IHByZWZpeCArIHBhaXJzLmpvaW4oJyYnKSA6ICcnO1xufVxuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xuZXhwb3J0cy5zdHJpbmdpZnkgPSBxdWVyeXN0cmluZ2lmeTtcbmV4cG9ydHMucGFyc2UgPSBxdWVyeXN0cmluZztcblxufSx7fV0sNjA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENoZWNrIGlmIHdlJ3JlIHJlcXVpcmVkIHRvIGFkZCBhIHBvcnQgbnVtYmVyLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkZWZhdWx0LXBvcnRcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gcG9ydCBQb3J0IG51bWJlciB3ZSBuZWVkIHRvIGNoZWNrXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvdG9jb2wgUHJvdG9jb2wgd2UgbmVlZCB0byBjaGVjayBhZ2FpbnN0LlxuICogQHJldHVybnMge0Jvb2xlYW59IElzIGl0IGEgZGVmYXVsdCBwb3J0IGZvciB0aGUgZ2l2ZW4gcHJvdG9jb2xcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcXVpcmVkKHBvcnQsIHByb3RvY29sKSB7XG4gIHByb3RvY29sID0gcHJvdG9jb2wuc3BsaXQoJzonKVswXTtcbiAgcG9ydCA9ICtwb3J0O1xuXG4gIGlmICghcG9ydCkgcmV0dXJuIGZhbHNlO1xuXG4gIHN3aXRjaCAocHJvdG9jb2wpIHtcbiAgICBjYXNlICdodHRwJzpcbiAgICBjYXNlICd3cyc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDgwO1xuXG4gICAgY2FzZSAnaHR0cHMnOlxuICAgIGNhc2UgJ3dzcyc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDQ0MztcblxuICAgIGNhc2UgJ2Z0cCc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDIxO1xuXG4gICAgY2FzZSAnZ29waGVyJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gNzA7XG5cbiAgICBjYXNlICdmaWxlJzpcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gcG9ydCAhPT0gMDtcbn07XG5cbn0se31dLDYxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHJlcXVpcmVkID0gcmVxdWlyZSgncmVxdWlyZXMtcG9ydCcpXG4gICwgbG9sY2F0aW9uID0gcmVxdWlyZSgnLi9sb2xjYXRpb24nKVxuICAsIHFzID0gcmVxdWlyZSgncXVlcnlzdHJpbmdpZnknKVxuICAsIHByb3RvY29scmUgPSAvXihbYS16XVthLXowLTkuKy1dKjopPyhcXC9cXC8pPyhbXFxTXFxzXSopL2k7XG5cbi8qKlxuICogVGhlc2UgYXJlIHRoZSBwYXJzZSBydWxlcyBmb3IgdGhlIFVSTCBwYXJzZXIsIGl0IGluZm9ybXMgdGhlIHBhcnNlclxuICogYWJvdXQ6XG4gKlxuICogMC4gVGhlIGNoYXIgaXQgTmVlZHMgdG8gcGFyc2UsIGlmIGl0J3MgYSBzdHJpbmcgaXQgc2hvdWxkIGJlIGRvbmUgdXNpbmdcbiAqICAgIGluZGV4T2YsIFJlZ0V4cCB1c2luZyBleGVjIGFuZCBOYU4gbWVhbnMgc2V0IGFzIGN1cnJlbnQgdmFsdWUuXG4gKiAxLiBUaGUgcHJvcGVydHkgd2Ugc2hvdWxkIHNldCB3aGVuIHBhcnNpbmcgdGhpcyB2YWx1ZS5cbiAqIDIuIEluZGljYXRpb24gaWYgaXQncyBiYWNrd2FyZHMgb3IgZm9yd2FyZCBwYXJzaW5nLCB3aGVuIHNldCBhcyBudW1iZXIgaXQnc1xuICogICAgdGhlIHZhbHVlIG9mIGV4dHJhIGNoYXJzIHRoYXQgc2hvdWxkIGJlIHNwbGl0IG9mZi5cbiAqIDMuIEluaGVyaXQgZnJvbSBsb2NhdGlvbiBpZiBub24gZXhpc3RpbmcgaW4gdGhlIHBhcnNlci5cbiAqIDQuIGB0b0xvd2VyQ2FzZWAgdGhlIHJlc3VsdGluZyB2YWx1ZS5cbiAqL1xudmFyIHJ1bGVzID0gW1xuICBbJyMnLCAnaGFzaCddLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgWyc/JywgJ3F1ZXJ5J10sICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIFsnLycsICdwYXRobmFtZSddLCAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBbJ0AnLCAnYXV0aCcsIDFdLCAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgZnJvbnQuXG4gIFtOYU4sICdob3N0JywgdW5kZWZpbmVkLCAxLCAxXSwgICAgICAgLy8gU2V0IGxlZnQgb3ZlciB2YWx1ZS5cbiAgWy86KFxcZCspJC8sICdwb3J0JywgdW5kZWZpbmVkLCAxXSwgICAgLy8gUmVnRXhwIHRoZSBiYWNrLlxuICBbTmFOLCAnaG9zdG5hbWUnLCB1bmRlZmluZWQsIDEsIDFdICAgIC8vIFNldCBsZWZ0IG92ZXIuXG5dO1xuXG4vKipcbiAqIEB0eXBlZGVmIFByb3RvY29sRXh0cmFjdFxuICogQHR5cGUgT2JqZWN0XG4gKiBAcHJvcGVydHkge1N0cmluZ30gcHJvdG9jb2wgUHJvdG9jb2wgbWF0Y2hlZCBpbiB0aGUgVVJMLCBpbiBsb3dlcmNhc2UuXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IHNsYXNoZXMgYHRydWVgIGlmIHByb3RvY29sIGlzIGZvbGxvd2VkIGJ5IFwiLy9cIiwgZWxzZSBgZmFsc2VgLlxuICogQHByb3BlcnR5IHtTdHJpbmd9IHJlc3QgUmVzdCBvZiB0aGUgVVJMIHRoYXQgaXMgbm90IHBhcnQgb2YgdGhlIHByb3RvY29sLlxuICovXG5cbi8qKlxuICogRXh0cmFjdCBwcm90b2NvbCBpbmZvcm1hdGlvbiBmcm9tIGEgVVJMIHdpdGgvd2l0aG91dCBkb3VibGUgc2xhc2ggKFwiLy9cIikuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgVVJMIHdlIHdhbnQgdG8gZXh0cmFjdCBmcm9tLlxuICogQHJldHVybiB7UHJvdG9jb2xFeHRyYWN0fSBFeHRyYWN0ZWQgaW5mb3JtYXRpb24uXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFByb3RvY29sKGFkZHJlc3MpIHtcbiAgdmFyIG1hdGNoID0gcHJvdG9jb2xyZS5leGVjKGFkZHJlc3MpO1xuXG4gIHJldHVybiB7XG4gICAgcHJvdG9jb2w6IG1hdGNoWzFdID8gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKSA6ICcnLFxuICAgIHNsYXNoZXM6ICEhbWF0Y2hbMl0sXG4gICAgcmVzdDogbWF0Y2hbM11cbiAgfTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGEgcmVsYXRpdmUgVVJMIHBhdGhuYW1lIGFnYWluc3QgYSBiYXNlIFVSTCBwYXRobmFtZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVsYXRpdmUgUGF0aG5hbWUgb2YgdGhlIHJlbGF0aXZlIFVSTC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlIFBhdGhuYW1lIG9mIHRoZSBiYXNlIFVSTC5cbiAqIEByZXR1cm4ge1N0cmluZ30gUmVzb2x2ZWQgcGF0aG5hbWUuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZShyZWxhdGl2ZSwgYmFzZSkge1xuICB2YXIgcGF0aCA9IChiYXNlIHx8ICcvJykuc3BsaXQoJy8nKS5zbGljZSgwLCAtMSkuY29uY2F0KHJlbGF0aXZlLnNwbGl0KCcvJykpXG4gICAgLCBpID0gcGF0aC5sZW5ndGhcbiAgICAsIGxhc3QgPSBwYXRoW2kgLSAxXVxuICAgICwgdW5zaGlmdCA9IGZhbHNlXG4gICAgLCB1cCA9IDA7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChwYXRoW2ldID09PSAnLicpIHtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAocGF0aFtpXSA9PT0gJy4uJykge1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIGlmIChpID09PSAwKSB1bnNoaWZ0ID0gdHJ1ZTtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICBpZiAodW5zaGlmdCkgcGF0aC51bnNoaWZ0KCcnKTtcbiAgaWYgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSBwYXRoLnB1c2goJycpO1xuXG4gIHJldHVybiBwYXRoLmpvaW4oJy8nKTtcbn1cblxuLyoqXG4gKiBUaGUgYWN0dWFsIFVSTCBpbnN0YW5jZS4gSW5zdGVhZCBvZiByZXR1cm5pbmcgYW4gb2JqZWN0IHdlJ3ZlIG9wdGVkLWluIHRvXG4gKiBjcmVhdGUgYW4gYWN0dWFsIGNvbnN0cnVjdG9yIGFzIGl0J3MgbXVjaCBtb3JlIG1lbW9yeSBlZmZpY2llbnQgYW5kXG4gKiBmYXN0ZXIgYW5kIGl0IHBsZWFzZXMgbXkgT0NELlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgVVJMIHdlIHdhbnQgdG8gcGFyc2UuXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGxvY2F0aW9uIExvY2F0aW9uIGRlZmF1bHRzIGZvciByZWxhdGl2ZSBwYXRocy5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gcGFyc2VyIFBhcnNlciBmb3IgdGhlIHF1ZXJ5IHN0cmluZy5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIFVSTChhZGRyZXNzLCBsb2NhdGlvbiwgcGFyc2VyKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBVUkwpKSB7XG4gICAgcmV0dXJuIG5ldyBVUkwoYWRkcmVzcywgbG9jYXRpb24sIHBhcnNlcik7XG4gIH1cblxuICB2YXIgcmVsYXRpdmUsIGV4dHJhY3RlZCwgcGFyc2UsIGluc3RydWN0aW9uLCBpbmRleCwga2V5XG4gICAgLCBpbnN0cnVjdGlvbnMgPSBydWxlcy5zbGljZSgpXG4gICAgLCB0eXBlID0gdHlwZW9mIGxvY2F0aW9uXG4gICAgLCB1cmwgPSB0aGlzXG4gICAgLCBpID0gMDtcblxuICAvL1xuICAvLyBUaGUgZm9sbG93aW5nIGlmIHN0YXRlbWVudHMgYWxsb3dzIHRoaXMgbW9kdWxlIHR3byBoYXZlIGNvbXBhdGliaWxpdHkgd2l0aFxuICAvLyAyIGRpZmZlcmVudCBBUEk6XG4gIC8vXG4gIC8vIDEuIE5vZGUuanMncyBgdXJsLnBhcnNlYCBhcGkgd2hpY2ggYWNjZXB0cyBhIFVSTCwgYm9vbGVhbiBhcyBhcmd1bWVudHNcbiAgLy8gICAgd2hlcmUgdGhlIGJvb2xlYW4gaW5kaWNhdGVzIHRoYXQgdGhlIHF1ZXJ5IHN0cmluZyBzaG91bGQgYWxzbyBiZSBwYXJzZWQuXG4gIC8vXG4gIC8vIDIuIFRoZSBgVVJMYCBpbnRlcmZhY2Ugb2YgdGhlIGJyb3dzZXIgd2hpY2ggYWNjZXB0cyBhIFVSTCwgb2JqZWN0IGFzXG4gIC8vICAgIGFyZ3VtZW50cy4gVGhlIHN1cHBsaWVkIG9iamVjdCB3aWxsIGJlIHVzZWQgYXMgZGVmYXVsdCB2YWx1ZXMgLyBmYWxsLWJhY2tcbiAgLy8gICAgZm9yIHJlbGF0aXZlIHBhdGhzLlxuICAvL1xuICBpZiAoJ29iamVjdCcgIT09IHR5cGUgJiYgJ3N0cmluZycgIT09IHR5cGUpIHtcbiAgICBwYXJzZXIgPSBsb2NhdGlvbjtcbiAgICBsb2NhdGlvbiA9IG51bGw7XG4gIH1cblxuICBpZiAocGFyc2VyICYmICdmdW5jdGlvbicgIT09IHR5cGVvZiBwYXJzZXIpIHBhcnNlciA9IHFzLnBhcnNlO1xuXG4gIGxvY2F0aW9uID0gbG9sY2F0aW9uKGxvY2F0aW9uKTtcblxuICAvL1xuICAvLyBFeHRyYWN0IHByb3RvY29sIGluZm9ybWF0aW9uIGJlZm9yZSBydW5uaW5nIHRoZSBpbnN0cnVjdGlvbnMuXG4gIC8vXG4gIGV4dHJhY3RlZCA9IGV4dHJhY3RQcm90b2NvbChhZGRyZXNzIHx8ICcnKTtcbiAgcmVsYXRpdmUgPSAhZXh0cmFjdGVkLnByb3RvY29sICYmICFleHRyYWN0ZWQuc2xhc2hlcztcbiAgdXJsLnNsYXNoZXMgPSBleHRyYWN0ZWQuc2xhc2hlcyB8fCByZWxhdGl2ZSAmJiBsb2NhdGlvbi5zbGFzaGVzO1xuICB1cmwucHJvdG9jb2wgPSBleHRyYWN0ZWQucHJvdG9jb2wgfHwgbG9jYXRpb24ucHJvdG9jb2wgfHwgJyc7XG4gIGFkZHJlc3MgPSBleHRyYWN0ZWQucmVzdDtcblxuICAvL1xuICAvLyBXaGVuIHRoZSBhdXRob3JpdHkgY29tcG9uZW50IGlzIGFic2VudCB0aGUgVVJMIHN0YXJ0cyB3aXRoIGEgcGF0aFxuICAvLyBjb21wb25lbnQuXG4gIC8vXG4gIGlmICghZXh0cmFjdGVkLnNsYXNoZXMpIGluc3RydWN0aW9uc1syXSA9IFsvKC4qKS8sICdwYXRobmFtZSddO1xuXG4gIGZvciAoOyBpIDwgaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgaW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbnNbaV07XG4gICAgcGFyc2UgPSBpbnN0cnVjdGlvblswXTtcbiAgICBrZXkgPSBpbnN0cnVjdGlvblsxXTtcblxuICAgIGlmIChwYXJzZSAhPT0gcGFyc2UpIHtcbiAgICAgIHVybFtrZXldID0gYWRkcmVzcztcbiAgICB9IGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgcGFyc2UpIHtcbiAgICAgIGlmICh+KGluZGV4ID0gYWRkcmVzcy5pbmRleE9mKHBhcnNlKSkpIHtcbiAgICAgICAgaWYgKCdudW1iZXInID09PSB0eXBlb2YgaW5zdHJ1Y3Rpb25bMl0pIHtcbiAgICAgICAgICB1cmxba2V5XSA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKGluZGV4ICsgaW5zdHJ1Y3Rpb25bMl0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVybFtrZXldID0gYWRkcmVzcy5zbGljZShpbmRleCk7XG4gICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgoaW5kZXggPSBwYXJzZS5leGVjKGFkZHJlc3MpKSkge1xuICAgICAgdXJsW2tleV0gPSBpbmRleFsxXTtcbiAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4LmluZGV4KTtcbiAgICB9XG5cbiAgICB1cmxba2V5XSA9IHVybFtrZXldIHx8IChcbiAgICAgIHJlbGF0aXZlICYmIGluc3RydWN0aW9uWzNdID8gbG9jYXRpb25ba2V5XSB8fCAnJyA6ICcnXG4gICAgKTtcblxuICAgIC8vXG4gICAgLy8gSG9zdG5hbWUsIGhvc3QgYW5kIHByb3RvY29sIHNob3VsZCBiZSBsb3dlcmNhc2VkIHNvIHRoZXkgY2FuIGJlIHVzZWQgdG9cbiAgICAvLyBjcmVhdGUgYSBwcm9wZXIgYG9yaWdpbmAuXG4gICAgLy9cbiAgICBpZiAoaW5zdHJ1Y3Rpb25bNF0pIHVybFtrZXldID0gdXJsW2tleV0udG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIC8vXG4gIC8vIEFsc28gcGFyc2UgdGhlIHN1cHBsaWVkIHF1ZXJ5IHN0cmluZyBpbiB0byBhbiBvYmplY3QuIElmIHdlJ3JlIHN1cHBsaWVkXG4gIC8vIHdpdGggYSBjdXN0b20gcGFyc2VyIGFzIGZ1bmN0aW9uIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgYnVpbGQtaW5cbiAgLy8gcGFyc2VyLlxuICAvL1xuICBpZiAocGFyc2VyKSB1cmwucXVlcnkgPSBwYXJzZXIodXJsLnF1ZXJ5KTtcblxuICAvL1xuICAvLyBJZiB0aGUgVVJMIGlzIHJlbGF0aXZlLCByZXNvbHZlIHRoZSBwYXRobmFtZSBhZ2FpbnN0IHRoZSBiYXNlIFVSTC5cbiAgLy9cbiAgaWYgKFxuICAgICAgcmVsYXRpdmVcbiAgICAmJiBsb2NhdGlvbi5zbGFzaGVzXG4gICAgJiYgdXJsLnBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nXG4gICAgJiYgKHVybC5wYXRobmFtZSAhPT0gJycgfHwgbG9jYXRpb24ucGF0aG5hbWUgIT09ICcnKVxuICApIHtcbiAgICB1cmwucGF0aG5hbWUgPSByZXNvbHZlKHVybC5wYXRobmFtZSwgbG9jYXRpb24ucGF0aG5hbWUpO1xuICB9XG5cbiAgLy9cbiAgLy8gV2Ugc2hvdWxkIG5vdCBhZGQgcG9ydCBudW1iZXJzIGlmIHRoZXkgYXJlIGFscmVhZHkgdGhlIGRlZmF1bHQgcG9ydCBudW1iZXJcbiAgLy8gZm9yIGEgZ2l2ZW4gcHJvdG9jb2wuIEFzIHRoZSBob3N0IGFsc28gY29udGFpbnMgdGhlIHBvcnQgbnVtYmVyIHdlJ3JlIGdvaW5nXG4gIC8vIG92ZXJyaWRlIGl0IHdpdGggdGhlIGhvc3RuYW1lIHdoaWNoIGNvbnRhaW5zIG5vIHBvcnQgbnVtYmVyLlxuICAvL1xuICBpZiAoIXJlcXVpcmVkKHVybC5wb3J0LCB1cmwucHJvdG9jb2wpKSB7XG4gICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWU7XG4gICAgdXJsLnBvcnQgPSAnJztcbiAgfVxuXG4gIC8vXG4gIC8vIFBhcnNlIGRvd24gdGhlIGBhdXRoYCBmb3IgdGhlIHVzZXJuYW1lIGFuZCBwYXNzd29yZC5cbiAgLy9cbiAgdXJsLnVzZXJuYW1lID0gdXJsLnBhc3N3b3JkID0gJyc7XG4gIGlmICh1cmwuYXV0aCkge1xuICAgIGluc3RydWN0aW9uID0gdXJsLmF1dGguc3BsaXQoJzonKTtcbiAgICB1cmwudXNlcm5hbWUgPSBpbnN0cnVjdGlvblswXSB8fCAnJztcbiAgICB1cmwucGFzc3dvcmQgPSBpbnN0cnVjdGlvblsxXSB8fCAnJztcbiAgfVxuXG4gIHVybC5vcmlnaW4gPSB1cmwucHJvdG9jb2wgJiYgdXJsLmhvc3QgJiYgdXJsLnByb3RvY29sICE9PSAnZmlsZTonXG4gICAgPyB1cmwucHJvdG9jb2wgKycvLycrIHVybC5ob3N0XG4gICAgOiAnbnVsbCc7XG5cbiAgLy9cbiAgLy8gVGhlIGhyZWYgaXMganVzdCB0aGUgY29tcGlsZWQgcmVzdWx0LlxuICAvL1xuICB1cmwuaHJlZiA9IHVybC50b1N0cmluZygpO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgY29udmVuaWVuY2UgbWV0aG9kIGZvciBjaGFuZ2luZyBwcm9wZXJ0aWVzIGluIHRoZSBVUkwgaW5zdGFuY2UgdG9cbiAqIGluc3VyZSB0aGF0IHRoZXkgYWxsIHByb3BhZ2F0ZSBjb3JyZWN0bHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhcnQgICAgICAgICAgUHJvcGVydHkgd2UgbmVlZCB0byBhZGp1c3QuXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZSAgICAgICAgICBUaGUgbmV3bHkgYXNzaWduZWQgdmFsdWUuXG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IGZuICBXaGVuIHNldHRpbmcgdGhlIHF1ZXJ5LCBpdCB3aWxsIGJlIHRoZSBmdW5jdGlvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlZCB0byBwYXJzZSB0aGUgcXVlcnkuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXaGVuIHNldHRpbmcgdGhlIHByb3RvY29sLCBkb3VibGUgc2xhc2ggd2lsbCBiZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZCBmcm9tIHRoZSBmaW5hbCB1cmwgaWYgaXQgaXMgdHJ1ZS5cbiAqIEByZXR1cm5zIHtVUkx9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBzZXQocGFydCwgdmFsdWUsIGZuKSB7XG4gIHZhciB1cmwgPSB0aGlzO1xuXG4gIHN3aXRjaCAocGFydCkge1xuICAgIGNhc2UgJ3F1ZXJ5JzpcbiAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHZhbHVlICYmIHZhbHVlLmxlbmd0aCkge1xuICAgICAgICB2YWx1ZSA9IChmbiB8fCBxcy5wYXJzZSkodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncG9ydCc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKCFyZXF1aXJlZCh2YWx1ZSwgdXJsLnByb3RvY29sKSkge1xuICAgICAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICAgICAgdXJsW3BhcnRdID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lICsnOicrIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2hvc3RuYW1lJzpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuXG4gICAgICBpZiAodXJsLnBvcnQpIHZhbHVlICs9ICc6JysgdXJsLnBvcnQ7XG4gICAgICB1cmwuaG9zdCA9IHZhbHVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdob3N0JzpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuXG4gICAgICBpZiAoLzpcXGQrJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgnOicpO1xuICAgICAgICB1cmwucG9ydCA9IHZhbHVlLnBvcCgpO1xuICAgICAgICB1cmwuaG9zdG5hbWUgPSB2YWx1ZS5qb2luKCc6Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmwuaG9zdG5hbWUgPSB2YWx1ZTtcbiAgICAgICAgdXJsLnBvcnQgPSAnJztcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwcm90b2NvbCc6XG4gICAgICB1cmwucHJvdG9jb2wgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdXJsLnNsYXNoZXMgPSAhZm47XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BhdGhuYW1lJzpcbiAgICAgIHVybC5wYXRobmFtZSA9IHZhbHVlLmxlbmd0aCAmJiB2YWx1ZS5jaGFyQXQoMCkgIT09ICcvJyA/ICcvJyArIHZhbHVlIDogdmFsdWU7XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpbnMgPSBydWxlc1tpXTtcblxuICAgIGlmIChpbnNbNF0pIHVybFtpbnNbMV1dID0gdXJsW2luc1sxXV0udG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIHVybC5vcmlnaW4gPSB1cmwucHJvdG9jb2wgJiYgdXJsLmhvc3QgJiYgdXJsLnByb3RvY29sICE9PSAnZmlsZTonXG4gICAgPyB1cmwucHJvdG9jb2wgKycvLycrIHVybC5ob3N0XG4gICAgOiAnbnVsbCc7XG5cbiAgdXJsLmhyZWYgPSB1cmwudG9TdHJpbmcoKTtcblxuICByZXR1cm4gdXJsO1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIHByb3BlcnRpZXMgYmFjayBpbiB0byBhIHZhbGlkIGFuZCBmdWxsIFVSTCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5naWZ5IE9wdGlvbmFsIHF1ZXJ5IHN0cmluZ2lmeSBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyhzdHJpbmdpZnkpIHtcbiAgaWYgKCFzdHJpbmdpZnkgfHwgJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIHN0cmluZ2lmeSkgc3RyaW5naWZ5ID0gcXMuc3RyaW5naWZ5O1xuXG4gIHZhciBxdWVyeVxuICAgICwgdXJsID0gdGhpc1xuICAgICwgcHJvdG9jb2wgPSB1cmwucHJvdG9jb2w7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLmNoYXJBdChwcm90b2NvbC5sZW5ndGggLSAxKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgdmFyIHJlc3VsdCA9IHByb3RvY29sICsgKHVybC5zbGFzaGVzID8gJy8vJyA6ICcnKTtcblxuICBpZiAodXJsLnVzZXJuYW1lKSB7XG4gICAgcmVzdWx0ICs9IHVybC51c2VybmFtZTtcbiAgICBpZiAodXJsLnBhc3N3b3JkKSByZXN1bHQgKz0gJzonKyB1cmwucGFzc3dvcmQ7XG4gICAgcmVzdWx0ICs9ICdAJztcbiAgfVxuXG4gIHJlc3VsdCArPSB1cmwuaG9zdCArIHVybC5wYXRobmFtZTtcblxuICBxdWVyeSA9ICdvYmplY3QnID09PSB0eXBlb2YgdXJsLnF1ZXJ5ID8gc3RyaW5naWZ5KHVybC5xdWVyeSkgOiB1cmwucXVlcnk7XG4gIGlmIChxdWVyeSkgcmVzdWx0ICs9ICc/JyAhPT0gcXVlcnkuY2hhckF0KDApID8gJz8nKyBxdWVyeSA6IHF1ZXJ5O1xuXG4gIGlmICh1cmwuaGFzaCkgcmVzdWx0ICs9IHVybC5oYXNoO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblVSTC5wcm90b3R5cGUgPSB7IHNldDogc2V0LCB0b1N0cmluZzogdG9TdHJpbmcgfTtcblxuLy9cbi8vIEV4cG9zZSB0aGUgVVJMIHBhcnNlciBhbmQgc29tZSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgdGhhdCBtaWdodCBiZSB1c2VmdWwgZm9yXG4vLyBvdGhlcnMgb3IgdGVzdGluZy5cbi8vXG5VUkwuZXh0cmFjdFByb3RvY29sID0gZXh0cmFjdFByb3RvY29sO1xuVVJMLmxvY2F0aW9uID0gbG9sY2F0aW9uO1xuVVJMLnFzID0gcXM7XG5cbm1vZHVsZS5leHBvcnRzID0gVVJMO1xuXG59LHtcIi4vbG9sY2F0aW9uXCI6NjIsXCJxdWVyeXN0cmluZ2lmeVwiOjU5LFwicmVxdWlyZXMtcG9ydFwiOjYwfV0sNjI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2xhc2hlcyA9IC9eW0EtWmEtel1bQS1aYS16MC05Ky0uXSo6XFwvXFwvLztcblxuLyoqXG4gKiBUaGVzZSBwcm9wZXJ0aWVzIHNob3VsZCBub3QgYmUgY29waWVkIG9yIGluaGVyaXRlZCBmcm9tLiBUaGlzIGlzIG9ubHkgbmVlZGVkXG4gKiBmb3IgYWxsIG5vbiBibG9iIFVSTCdzIGFzIGEgYmxvYiBVUkwgZG9lcyBub3QgaW5jbHVkZSBhIGhhc2gsIG9ubHkgdGhlXG4gKiBvcmlnaW4uXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBpZ25vcmUgPSB7IGhhc2g6IDEsIHF1ZXJ5OiAxIH1cbiAgLCBVUkw7XG5cbi8qKlxuICogVGhlIGxvY2F0aW9uIG9iamVjdCBkaWZmZXJzIHdoZW4geW91ciBjb2RlIGlzIGxvYWRlZCB0aHJvdWdoIGEgbm9ybWFsIHBhZ2UsXG4gKiBXb3JrZXIgb3IgdGhyb3VnaCBhIHdvcmtlciB1c2luZyBhIGJsb2IuIEFuZCB3aXRoIHRoZSBibG9iYmxlIGJlZ2lucyB0aGVcbiAqIHRyb3VibGUgYXMgdGhlIGxvY2F0aW9uIG9iamVjdCB3aWxsIGNvbnRhaW4gdGhlIFVSTCBvZiB0aGUgYmxvYiwgbm90IHRoZVxuICogbG9jYXRpb24gb2YgdGhlIHBhZ2Ugd2hlcmUgb3VyIGNvZGUgaXMgbG9hZGVkIGluLiBUaGUgYWN0dWFsIG9yaWdpbiBpc1xuICogZW5jb2RlZCBpbiB0aGUgYHBhdGhuYW1lYCBzbyB3ZSBjYW4gdGhhbmtmdWxseSBnZW5lcmF0ZSBhIGdvb2QgXCJkZWZhdWx0XCJcbiAqIGxvY2F0aW9uIGZyb20gaXQgc28gd2UgY2FuIGdlbmVyYXRlIHByb3BlciByZWxhdGl2ZSBVUkwncyBhZ2Fpbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGxvYyBPcHRpb25hbCBkZWZhdWx0IGxvY2F0aW9uIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IGxvbGNhdGlvbiBvYmplY3QuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxvbGNhdGlvbihsb2MpIHtcbiAgbG9jID0gbG9jIHx8IGdsb2JhbC5sb2NhdGlvbiB8fCB7fTtcbiAgVVJMID0gVVJMIHx8IHJlcXVpcmUoJy4vJyk7XG5cbiAgdmFyIGZpbmFsZGVzdGluYXRpb24gPSB7fVxuICAgICwgdHlwZSA9IHR5cGVvZiBsb2NcbiAgICAsIGtleTtcblxuICBpZiAoJ2Jsb2I6JyA9PT0gbG9jLnByb3RvY29sKSB7XG4gICAgZmluYWxkZXN0aW5hdGlvbiA9IG5ldyBVUkwodW5lc2NhcGUobG9jLnBhdGhuYW1lKSwge30pO1xuICB9IGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlKSB7XG4gICAgZmluYWxkZXN0aW5hdGlvbiA9IG5ldyBVUkwobG9jLCB7fSk7XG4gICAgZm9yIChrZXkgaW4gaWdub3JlKSBkZWxldGUgZmluYWxkZXN0aW5hdGlvbltrZXldO1xuICB9IGVsc2UgaWYgKCdvYmplY3QnID09PSB0eXBlKSB7XG4gICAgZm9yIChrZXkgaW4gbG9jKSB7XG4gICAgICBpZiAoa2V5IGluIGlnbm9yZSkgY29udGludWU7XG4gICAgICBmaW5hbGRlc3RpbmF0aW9uW2tleV0gPSBsb2Nba2V5XTtcbiAgICB9XG5cbiAgICBpZiAoZmluYWxkZXN0aW5hdGlvbi5zbGFzaGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZpbmFsZGVzdGluYXRpb24uc2xhc2hlcyA9IHNsYXNoZXMudGVzdChsb2MuaHJlZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpbmFsZGVzdGluYXRpb247XG59O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL1wiOjYxfV19LHt9LFsxXSkoMSlcbn0pO1xuXG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvY2tqcy5qcy5tYXBcbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///11\\n\")},function(module,exports,__webpack_require__){\"use strict\";eval(\"\\n\\nvar SockJS = __webpack_require__(11);\\n\\nvar retries = 0;\\nvar sock = null;\\n\\nvar socket = function initSocket(url, handlers) {\\n  sock = new SockJS(url);\\n\\n  sock.onopen = function onopen() {\\n    retries = 0;\\n  };\\n\\n  sock.onclose = function onclose() {\\n    if (retries === 0) {\\n      handlers.close();\\n    }\\n\\n    // Try to reconnect.\\n    sock = null;\\n\\n    // After 10 retries stop trying, to prevent logspam.\\n    if (retries <= 10) {\\n      // Exponentially increase timeout to reconnect.\\n      // Respectfully copied from the package `got`.\\n      // eslint-disable-next-line no-mixed-operators, no-restricted-properties\\n      var retryInMs = 1000 * Math.pow(2, retries) + Math.random() * 100;\\n      retries += 1;\\n\\n      setTimeout(function () {\\n        socket(url, handlers);\\n      }, retryInMs);\\n    }\\n  };\\n\\n  sock.onmessage = function onmessage(e) {\\n    // This assumes that all data sent via the websocket is JSON.\\n    var msg = JSON.parse(e.data);\\n    if (handlers[msg.type]) {\\n      handlers[msg.type](msg.data);\\n    }\\n  };\\n};\\n\\nmodule.exports = socket;//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50L3NvY2tldC5qcz9lMjljIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIxMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIFNvY2tKUyA9IHJlcXVpcmUoJ3NvY2tqcy1jbGllbnQvZGlzdC9zb2NranMnKTtcblxudmFyIHJldHJpZXMgPSAwO1xudmFyIHNvY2sgPSBudWxsO1xuXG52YXIgc29ja2V0ID0gZnVuY3Rpb24gaW5pdFNvY2tldCh1cmwsIGhhbmRsZXJzKSB7XG4gIHNvY2sgPSBuZXcgU29ja0pTKHVybCk7XG5cbiAgc29jay5vbm9wZW4gPSBmdW5jdGlvbiBvbm9wZW4oKSB7XG4gICAgcmV0cmllcyA9IDA7XG4gIH07XG5cbiAgc29jay5vbmNsb3NlID0gZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAocmV0cmllcyA9PT0gMCkge1xuICAgICAgaGFuZGxlcnMuY2xvc2UoKTtcbiAgICB9XG5cbiAgICAvLyBUcnkgdG8gcmVjb25uZWN0LlxuICAgIHNvY2sgPSBudWxsO1xuXG4gICAgLy8gQWZ0ZXIgMTAgcmV0cmllcyBzdG9wIHRyeWluZywgdG8gcHJldmVudCBsb2dzcGFtLlxuICAgIGlmIChyZXRyaWVzIDw9IDEwKSB7XG4gICAgICAvLyBFeHBvbmVudGlhbGx5IGluY3JlYXNlIHRpbWVvdXQgdG8gcmVjb25uZWN0LlxuICAgICAgLy8gUmVzcGVjdGZ1bGx5IGNvcGllZCBmcm9tIHRoZSBwYWNrYWdlIGBnb3RgLlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW1peGVkLW9wZXJhdG9ycywgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzXG4gICAgICB2YXIgcmV0cnlJbk1zID0gMTAwMCAqIE1hdGgucG93KDIsIHJldHJpZXMpICsgTWF0aC5yYW5kb20oKSAqIDEwMDtcbiAgICAgIHJldHJpZXMgKz0gMTtcblxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNvY2tldCh1cmwsIGhhbmRsZXJzKTtcbiAgICAgIH0sIHJldHJ5SW5Ncyk7XG4gICAgfVxuICB9O1xuXG4gIHNvY2sub25tZXNzYWdlID0gZnVuY3Rpb24gb25tZXNzYWdlKGUpIHtcbiAgICAvLyBUaGlzIGFzc3VtZXMgdGhhdCBhbGwgZGF0YSBzZW50IHZpYSB0aGUgd2Vic29ja2V0IGlzIEpTT04uXG4gICAgdmFyIG1zZyA9IEpTT04ucGFyc2UoZS5kYXRhKTtcbiAgICBpZiAoaGFuZGxlcnNbbXNnLnR5cGVdKSB7XG4gICAgICBoYW5kbGVyc1ttc2cudHlwZV0obXNnLmRhdGEpO1xuICAgIH1cbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc29ja2V0OyJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///12\\n\")},function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\\n* loglevel - https://github.com/pimterry/loglevel\\n*\\n* Copyright (c) 2013 Tim Perry\\n* Licensed under the MIT license.\\n*/\\n(function (root, definition) {\\n    \"use strict\";\\n    if (true) {\\n        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \\'function\\' ?\\n\\t\\t\\t\\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_FACTORY__),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\\n    } else {}\\n}(this, function () {\\n    \"use strict\";\\n\\n    // Slightly dubious tricks to cut down minimized file size\\n    var noop = function() {};\\n    var undefinedType = \"undefined\";\\n\\n    var logMethods = [\\n        \"trace\",\\n        \"debug\",\\n        \"info\",\\n        \"warn\",\\n        \"error\"\\n    ];\\n\\n    // Cross-browser bind equivalent that works at least back to IE6\\n    function bindMethod(obj, methodName) {\\n        var method = obj[methodName];\\n        if (typeof method.bind === \\'function\\') {\\n            return method.bind(obj);\\n        } else {\\n            try {\\n                return Function.prototype.bind.call(method, obj);\\n            } catch (e) {\\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\\n                return function() {\\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\\n                };\\n            }\\n        }\\n    }\\n\\n    // Build the best logging method possible for this env\\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\\n    function realMethod(methodName) {\\n        if (methodName === \\'debug\\') {\\n            methodName = \\'log\\';\\n        }\\n\\n        if (typeof console === undefinedType) {\\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\\n        } else if (console[methodName] !== undefined) {\\n            return bindMethod(console, methodName);\\n        } else if (console.log !== undefined) {\\n            return bindMethod(console, \\'log\\');\\n        } else {\\n            return noop;\\n        }\\n    }\\n\\n    // These private functions always need `this` to be set properly\\n\\n    function replaceLoggingMethods(level, loggerName) {\\n        /*jshint validthis:true */\\n        for (var i = 0; i < logMethods.length; i++) {\\n            var methodName = logMethods[i];\\n            this[methodName] = (i < level) ?\\n                noop :\\n                this.methodFactory(methodName, level, loggerName);\\n        }\\n\\n        // Define log.log as an alias for log.debug\\n        this.log = this.debug;\\n    }\\n\\n    // In old IE versions, the console isn\\'t present until you first open it.\\n    // We build realMethod() replacements here that regenerate logging methods\\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\\n        return function () {\\n            if (typeof console !== undefinedType) {\\n                replaceLoggingMethods.call(this, level, loggerName);\\n                this[methodName].apply(this, arguments);\\n            }\\n        };\\n    }\\n\\n    // By default, we use closely bound real methods wherever possible, and\\n    // otherwise we wait for a console to appear, and then try again.\\n    function defaultMethodFactory(methodName, level, loggerName) {\\n        /*jshint validthis:true */\\n        return realMethod(methodName) ||\\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\\n    }\\n\\n    function Logger(name, defaultLevel, factory) {\\n      var self = this;\\n      var currentLevel;\\n      var storageKey = \"loglevel\";\\n      if (name) {\\n        storageKey += \":\" + name;\\n      }\\n\\n      function persistLevelIfPossible(levelNum) {\\n          var levelName = (logMethods[levelNum] || \\'silent\\').toUpperCase();\\n\\n          if (typeof window === undefinedType) return;\\n\\n          // Use localStorage if available\\n          try {\\n              window.localStorage[storageKey] = levelName;\\n              return;\\n          } catch (ignore) {}\\n\\n          // Use session cookie as fallback\\n          try {\\n              window.document.cookie =\\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\\n          } catch (ignore) {}\\n      }\\n\\n      function getPersistedLevel() {\\n          var storedLevel;\\n\\n          if (typeof window === undefinedType) return;\\n\\n          try {\\n              storedLevel = window.localStorage[storageKey];\\n          } catch (ignore) {}\\n\\n          // Fallback to cookies if local storage gives us nothing\\n          if (typeof storedLevel === undefinedType) {\\n              try {\\n                  var cookie = window.document.cookie;\\n                  var location = cookie.indexOf(\\n                      encodeURIComponent(storageKey) + \"=\");\\n                  if (location !== -1) {\\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\\n                  }\\n              } catch (ignore) {}\\n          }\\n\\n          // If the stored level is not valid, treat it as if nothing was stored.\\n          if (self.levels[storedLevel] === undefined) {\\n              storedLevel = undefined;\\n          }\\n\\n          return storedLevel;\\n      }\\n\\n      /*\\n       *\\n       * Public logger API - see https://github.com/pimterry/loglevel for details\\n       *\\n       */\\n\\n      self.name = name;\\n\\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\\n          \"ERROR\": 4, \"SILENT\": 5};\\n\\n      self.methodFactory = factory || defaultMethodFactory;\\n\\n      self.getLevel = function () {\\n          return currentLevel;\\n      };\\n\\n      self.setLevel = function (level, persist) {\\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\\n              level = self.levels[level.toUpperCase()];\\n          }\\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\\n              currentLevel = level;\\n              if (persist !== false) {  // defaults to true\\n                  persistLevelIfPossible(level);\\n              }\\n              replaceLoggingMethods.call(self, level, name);\\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\\n                  return \"No console available for logging\";\\n              }\\n          } else {\\n              throw \"log.setLevel() called with invalid level: \" + level;\\n          }\\n      };\\n\\n      self.setDefaultLevel = function (level) {\\n          if (!getPersistedLevel()) {\\n              self.setLevel(level, false);\\n          }\\n      };\\n\\n      self.enableAll = function(persist) {\\n          self.setLevel(self.levels.TRACE, persist);\\n      };\\n\\n      self.disableAll = function(persist) {\\n          self.setLevel(self.levels.SILENT, persist);\\n      };\\n\\n      // Initialize with the right level\\n      var initialLevel = getPersistedLevel();\\n      if (initialLevel == null) {\\n          initialLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\\n      }\\n      self.setLevel(initialLevel, false);\\n    }\\n\\n    /*\\n     *\\n     * Top-level API\\n     *\\n     */\\n\\n    var defaultLogger = new Logger();\\n\\n    var _loggersByName = {};\\n    defaultLogger.getLogger = function getLogger(name) {\\n        if (typeof name !== \"string\" || name === \"\") {\\n          throw new TypeError(\"You must supply a name when creating a logger.\");\\n        }\\n\\n        var logger = _loggersByName[name];\\n        if (!logger) {\\n          logger = _loggersByName[name] = new Logger(\\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\\n        }\\n        return logger;\\n    };\\n\\n    // Grab the current global log variable in case of overwrite\\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\\n    defaultLogger.noConflict = function() {\\n        if (typeof window !== undefinedType &&\\n               window.log === defaultLogger) {\\n            window.log = _log;\\n        }\\n\\n        return defaultLogger;\\n    };\\n\\n    defaultLogger.getLoggers = function getLoggers() {\\n        return _loggersByName;\\n    };\\n\\n    return defaultLogger;\\n}));\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvbm9kZV9tb2R1bGVzL2xvZ2xldmVsL2xpYi9sb2dsZXZlbC5qcz80YjZlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQSxLQUFLLFFBSUw7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekIsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckUsV0FBVztBQUNYOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUMiLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuKiBsb2dsZXZlbCAtIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTMgVGltIFBlcnJ5XG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiovXG4oZnVuY3Rpb24gKHJvb3QsIGRlZmluaXRpb24pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShkZWZpbml0aW9uKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QubG9nID0gZGVmaW5pdGlvbigpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy8gU2xpZ2h0bHkgZHViaW91cyB0cmlja3MgdG8gY3V0IGRvd24gbWluaW1pemVkIGZpbGUgc2l6ZVxuICAgIHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcbiAgICB2YXIgdW5kZWZpbmVkVHlwZSA9IFwidW5kZWZpbmVkXCI7XG5cbiAgICB2YXIgbG9nTWV0aG9kcyA9IFtcbiAgICAgICAgXCJ0cmFjZVwiLFxuICAgICAgICBcImRlYnVnXCIsXG4gICAgICAgIFwiaW5mb1wiLFxuICAgICAgICBcIndhcm5cIixcbiAgICAgICAgXCJlcnJvclwiXG4gICAgXTtcblxuICAgIC8vIENyb3NzLWJyb3dzZXIgYmluZCBlcXVpdmFsZW50IHRoYXQgd29ya3MgYXQgbGVhc3QgYmFjayB0byBJRTZcbiAgICBmdW5jdGlvbiBiaW5kTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgbWV0aG9kID0gb2JqW21ldGhvZE5hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZC5iaW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLmJpbmQob2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwobWV0aG9kLCBvYmopO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIE1pc3NpbmcgYmluZCBzaGltIG9yIElFOCArIE1vZGVybml6ciwgZmFsbGJhY2sgdG8gd3JhcHBpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkobWV0aG9kLCBbb2JqLCBhcmd1bWVudHNdKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgdGhlIGJlc3QgbG9nZ2luZyBtZXRob2QgcG9zc2libGUgZm9yIHRoaXMgZW52XG4gICAgLy8gV2hlcmV2ZXIgcG9zc2libGUgd2Ugd2FudCB0byBiaW5kLCBub3Qgd3JhcCwgdG8gcHJlc2VydmUgc3RhY2sgdHJhY2VzXG4gICAgZnVuY3Rpb24gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmIChtZXRob2ROYW1lID09PSAnZGVidWcnKSB7XG4gICAgICAgICAgICBtZXRob2ROYW1lID0gJ2xvZyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gbWV0aG9kIHBvc3NpYmxlLCBmb3Igbm93IC0gZml4ZWQgbGF0ZXIgYnkgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlc1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGVbbWV0aG9kTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgbWV0aG9kTmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZS5sb2cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgJ2xvZycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGVzZSBwcml2YXRlIGZ1bmN0aW9ucyBhbHdheXMgbmVlZCBgdGhpc2AgdG8gYmUgc2V0IHByb3Blcmx5XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlTG9nZ2luZ01ldGhvZHMobGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IGxvZ01ldGhvZHNbaV07XG4gICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdID0gKGkgPCBsZXZlbCkgP1xuICAgICAgICAgICAgICAgIG5vb3AgOlxuICAgICAgICAgICAgICAgIHRoaXMubWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZpbmUgbG9nLmxvZyBhcyBhbiBhbGlhcyBmb3IgbG9nLmRlYnVnXG4gICAgICAgIHRoaXMubG9nID0gdGhpcy5kZWJ1ZztcbiAgICB9XG5cbiAgICAvLyBJbiBvbGQgSUUgdmVyc2lvbnMsIHRoZSBjb25zb2xlIGlzbid0IHByZXNlbnQgdW50aWwgeW91IGZpcnN0IG9wZW4gaXQuXG4gICAgLy8gV2UgYnVpbGQgcmVhbE1ldGhvZCgpIHJlcGxhY2VtZW50cyBoZXJlIHRoYXQgcmVnZW5lcmF0ZSBsb2dnaW5nIG1ldGhvZHNcbiAgICBmdW5jdGlvbiBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzKG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbCh0aGlzLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEJ5IGRlZmF1bHQsIHdlIHVzZSBjbG9zZWx5IGJvdW5kIHJlYWwgbWV0aG9kcyB3aGVyZXZlciBwb3NzaWJsZSwgYW5kXG4gICAgLy8gb3RoZXJ3aXNlIHdlIHdhaXQgZm9yIGEgY29uc29sZSB0byBhcHBlYXIsIGFuZCB0aGVuIHRyeSBhZ2Fpbi5cbiAgICBmdW5jdGlvbiBkZWZhdWx0TWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICByZXR1cm4gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB8fFxuICAgICAgICAgICAgICAgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIExvZ2dlcihuYW1lLCBkZWZhdWx0TGV2ZWwsIGZhY3RvcnkpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBjdXJyZW50TGV2ZWw7XG4gICAgICB2YXIgc3RvcmFnZUtleSA9IFwibG9nbGV2ZWxcIjtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHN0b3JhZ2VLZXkgKz0gXCI6XCIgKyBuYW1lO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsTnVtKSB7XG4gICAgICAgICAgdmFyIGxldmVsTmFtZSA9IChsb2dNZXRob2RzW2xldmVsTnVtXSB8fCAnc2lsZW50JykudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlKSByZXR1cm47XG5cbiAgICAgICAgICAvLyBVc2UgbG9jYWxTdG9yYWdlIGlmIGF2YWlsYWJsZVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV0gPSBsZXZlbE5hbWU7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBVc2Ugc2Vzc2lvbiBjb29raWUgYXMgZmFsbGJhY2tcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID1cbiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIiArIGxldmVsTmFtZSArIFwiO1wiO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0UGVyc2lzdGVkTGV2ZWwoKSB7XG4gICAgICAgICAgdmFyIHN0b3JlZExldmVsO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUpIHJldHVybjtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0b3JlZExldmVsID0gd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XTtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBGYWxsYmFjayB0byBjb29raWVzIGlmIGxvY2FsIHN0b3JhZ2UgZ2l2ZXMgdXMgbm90aGluZ1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3RvcmVkTGV2ZWwgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHZhciBjb29raWUgPSB3aW5kb3cuZG9jdW1lbnQuY29va2llO1xuICAgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gY29va2llLmluZGV4T2YoXG4gICAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIpO1xuICAgICAgICAgICAgICAgICAgaWYgKGxvY2F0aW9uICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHN0b3JlZExldmVsID0gL14oW147XSspLy5leGVjKGNvb2tpZS5zbGljZShsb2NhdGlvbikpWzFdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgdGhlIHN0b3JlZCBsZXZlbCBpcyBub3QgdmFsaWQsIHRyZWF0IGl0IGFzIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cbiAgICAgICAgICBpZiAoc2VsZi5sZXZlbHNbc3RvcmVkTGV2ZWxdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN0b3JlZExldmVsO1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgICpcbiAgICAgICAqIFB1YmxpYyBsb2dnZXIgQVBJIC0gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbCBmb3IgZGV0YWlsc1xuICAgICAgICpcbiAgICAgICAqL1xuXG4gICAgICBzZWxmLm5hbWUgPSBuYW1lO1xuXG4gICAgICBzZWxmLmxldmVscyA9IHsgXCJUUkFDRVwiOiAwLCBcIkRFQlVHXCI6IDEsIFwiSU5GT1wiOiAyLCBcIldBUk5cIjogMyxcbiAgICAgICAgICBcIkVSUk9SXCI6IDQsIFwiU0lMRU5UXCI6IDV9O1xuXG4gICAgICBzZWxmLm1ldGhvZEZhY3RvcnkgPSBmYWN0b3J5IHx8IGRlZmF1bHRNZXRob2RGYWN0b3J5O1xuXG4gICAgICBzZWxmLmdldExldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjdXJyZW50TGV2ZWw7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnNldExldmVsID0gZnVuY3Rpb24gKGxldmVsLCBwZXJzaXN0KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJzdHJpbmdcIiAmJiBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGxldmVsID0gc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwibnVtYmVyXCIgJiYgbGV2ZWwgPj0gMCAmJiBsZXZlbCA8PSBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgICAgY3VycmVudExldmVsID0gbGV2ZWw7XG4gICAgICAgICAgICAgIGlmIChwZXJzaXN0ICE9PSBmYWxzZSkgeyAgLy8gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgICAgICAgcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZiwgbGV2ZWwsIG5hbWUpO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUgJiYgbGV2ZWwgPCBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBcIk5vIGNvbnNvbGUgYXZhaWxhYmxlIGZvciBsb2dnaW5nXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBcImxvZy5zZXRMZXZlbCgpIGNhbGxlZCB3aXRoIGludmFsaWQgbGV2ZWw6IFwiICsgbGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5zZXREZWZhdWx0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICBpZiAoIWdldFBlcnNpc3RlZExldmVsKCkpIHtcbiAgICAgICAgICAgICAgc2VsZi5zZXRMZXZlbChsZXZlbCwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuZW5hYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuVFJBQ0UsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5kaXNhYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuU0lMRU5ULCBwZXJzaXN0KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEluaXRpYWxpemUgd2l0aCB0aGUgcmlnaHQgbGV2ZWxcbiAgICAgIHZhciBpbml0aWFsTGV2ZWwgPSBnZXRQZXJzaXN0ZWRMZXZlbCgpO1xuICAgICAgaWYgKGluaXRpYWxMZXZlbCA9PSBudWxsKSB7XG4gICAgICAgICAgaW5pdGlhbExldmVsID0gZGVmYXVsdExldmVsID09IG51bGwgPyBcIldBUk5cIiA6IGRlZmF1bHRMZXZlbDtcbiAgICAgIH1cbiAgICAgIHNlbGYuc2V0TGV2ZWwoaW5pdGlhbExldmVsLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKlxuICAgICAqIFRvcC1sZXZlbCBBUElcbiAgICAgKlxuICAgICAqL1xuXG4gICAgdmFyIGRlZmF1bHRMb2dnZXIgPSBuZXcgTG9nZ2VyKCk7XG5cbiAgICB2YXIgX2xvZ2dlcnNCeU5hbWUgPSB7fTtcbiAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlciA9IGZ1bmN0aW9uIGdldExvZ2dlcihuYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIiB8fCBuYW1lID09PSBcIlwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHN1cHBseSBhIG5hbWUgd2hlbiBjcmVhdGluZyBhIGxvZ2dlci5cIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV07XG4gICAgICAgIGlmICghbG9nZ2VyKSB7XG4gICAgICAgICAgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV0gPSBuZXcgTG9nZ2VyKFxuICAgICAgICAgICAgbmFtZSwgZGVmYXVsdExvZ2dlci5nZXRMZXZlbCgpLCBkZWZhdWx0TG9nZ2VyLm1ldGhvZEZhY3RvcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgfTtcblxuICAgIC8vIEdyYWIgdGhlIGN1cnJlbnQgZ2xvYmFsIGxvZyB2YXJpYWJsZSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuICAgIHZhciBfbG9nID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpID8gd2luZG93LmxvZyA6IHVuZGVmaW5lZDtcbiAgICBkZWZhdWx0TG9nZ2VyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUgJiZcbiAgICAgICAgICAgICAgIHdpbmRvdy5sb2cgPT09IGRlZmF1bHRMb2dnZXIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2cgPSBfbG9nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG4gICAgfTtcblxuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VycyA9IGZ1bmN0aW9uIGdldExvZ2dlcnMoKSB7XG4gICAgICAgIHJldHVybiBfbG9nZ2Vyc0J5TmFtZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG59KSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///13\\n')},function(module,exports,__webpack_require__){\"use strict\";eval(\"\\nmodule.exports = function () {\\n\\treturn /[\\\\u001b\\\\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;\\n};\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvbm9kZV9tb2R1bGVzL2Fuc2ktcmVnZXgvaW5kZXguanM/MzQ5NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EsNkJBQTZCLFlBQVksSUFBSSxJQUFJLE1BQU0sSUFBSTtBQUMzRCIsImZpbGUiOiIxNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gL1tcXHUwMDFiXFx1MDA5Yl1bWygpIzs/XSooPzpbMC05XXsxLDR9KD86O1swLTldezAsNH0pKik/WzAtOUEtUFJaY2YtbnFyeT0+PF0vZztcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///14\\n\")},function(module,exports,__webpack_require__){\"use strict\";eval(\"\\nvar ansiRegex = __webpack_require__(14)();\\n\\nmodule.exports = function (str) {\\n\\treturn typeof str === 'string' ? str.replace(ansiRegex, '') : str;\\n};\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvbm9kZV9tb2R1bGVzL3N0cmlwLWFuc2kvaW5kZXguanM/OTc1MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiIxNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBhbnNpUmVnZXggPSByZXF1aXJlKCdhbnNpLXJlZ2V4JykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdHJldHVybiB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyA/IHN0ci5yZXBsYWNlKGFuc2lSZWdleCwgJycpIDogc3RyO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///15\\n\")},function(module,exports,__webpack_require__){\"use strict\";eval(\"// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\n\\n\\nvar stringifyPrimitive = function(v) {\\n  switch (typeof v) {\\n    case 'string':\\n      return v;\\n\\n    case 'boolean':\\n      return v ? 'true' : 'false';\\n\\n    case 'number':\\n      return isFinite(v) ? v : '';\\n\\n    default:\\n      return '';\\n  }\\n};\\n\\nmodule.exports = function(obj, sep, eq, name) {\\n  sep = sep || '&';\\n  eq = eq || '=';\\n  if (obj === null) {\\n    obj = undefined;\\n  }\\n\\n  if (typeof obj === 'object') {\\n    return map(objectKeys(obj), function(k) {\\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\\n      if (isArray(obj[k])) {\\n        return map(obj[k], function(v) {\\n          return ks + encodeURIComponent(stringifyPrimitive(v));\\n        }).join(sep);\\n      } else {\\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\\n      }\\n    }).join(sep);\\n\\n  }\\n\\n  if (!name) return '';\\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\\n         encodeURIComponent(stringifyPrimitive(obj));\\n};\\n\\nvar isArray = Array.isArray || function (xs) {\\n  return Object.prototype.toString.call(xs) === '[object Array]';\\n};\\n\\nfunction map (xs, f) {\\n  if (xs.map) return xs.map(f);\\n  var res = [];\\n  for (var i = 0; i < xs.length; i++) {\\n    res.push(f(xs[i], i));\\n  }\\n  return res;\\n}\\n\\nvar objectKeys = Object.keys || function (obj) {\\n  var res = [];\\n  for (var key in obj) {\\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\\n  }\\n  return res;\\n};\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzPzYwODMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjE2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG1hcChvYmplY3RLZXlzKG9iaiksIGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBtYXAob2JqW2tdLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5mdW5jdGlvbiBtYXAgKHhzLCBmKSB7XG4gIGlmICh4cy5tYXApIHJldHVybiB4cy5tYXAoZik7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIHJlcy5wdXNoKGYoeHNbaV0sIGkpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHJlcy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///16\\n\")},function(module,exports,__webpack_require__){\"use strict\";eval(\"// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\n\\n\\n// If obj.hasOwnProperty has been overridden, then calling\\n// obj.hasOwnProperty(prop) will break.\\n// See: https://github.com/joyent/node/issues/1707\\nfunction hasOwnProperty(obj, prop) {\\n  return Object.prototype.hasOwnProperty.call(obj, prop);\\n}\\n\\nmodule.exports = function(qs, sep, eq, options) {\\n  sep = sep || '&';\\n  eq = eq || '=';\\n  var obj = {};\\n\\n  if (typeof qs !== 'string' || qs.length === 0) {\\n    return obj;\\n  }\\n\\n  var regexp = /\\\\+/g;\\n  qs = qs.split(sep);\\n\\n  var maxKeys = 1000;\\n  if (options && typeof options.maxKeys === 'number') {\\n    maxKeys = options.maxKeys;\\n  }\\n\\n  var len = qs.length;\\n  // maxKeys <= 0 means that we should not limit keys count\\n  if (maxKeys > 0 && len > maxKeys) {\\n    len = maxKeys;\\n  }\\n\\n  for (var i = 0; i < len; ++i) {\\n    var x = qs[i].replace(regexp, '%20'),\\n        idx = x.indexOf(eq),\\n        kstr, vstr, k, v;\\n\\n    if (idx >= 0) {\\n      kstr = x.substr(0, idx);\\n      vstr = x.substr(idx + 1);\\n    } else {\\n      kstr = x;\\n      vstr = '';\\n    }\\n\\n    k = decodeURIComponent(kstr);\\n    v = decodeURIComponent(vstr);\\n\\n    if (!hasOwnProperty(obj, k)) {\\n      obj[k] = v;\\n    } else if (isArray(obj[k])) {\\n      obj[k].push(v);\\n    } else {\\n      obj[k] = [obj[k], v];\\n    }\\n  }\\n\\n  return obj;\\n};\\n\\nvar isArray = Array.isArray || function (xs) {\\n  return Object.prototype.toString.call(xs) === '[object Array]';\\n};\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZGVjb2RlLmpzP2IyOWEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjE3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///17\\n\")},function(module,exports,__webpack_require__){\"use strict\";eval(\"\\n\\nexports.decode = exports.parse = __webpack_require__(17);\\nexports.encode = exports.stringify = __webpack_require__(16);\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanM/NWE4ZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBIiwiZmlsZSI6IjE4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///18\\n\")},function(module,exports,__webpack_require__){\"use strict\";eval(\"\\n\\nmodule.exports = {\\n  isString: function(arg) {\\n    return typeof(arg) === 'string';\\n  },\\n  isObject: function(arg) {\\n    return typeof(arg) === 'object' && arg !== null;\\n  },\\n  isNull: function(arg) {\\n    return arg === null;\\n  },\\n  isNullOrUndefined: function(arg) {\\n    return arg == null;\\n  }\\n};\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL25vZGVfbW9kdWxlcy91cmwvdXRpbC5qcz84NmM5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc1N0cmluZzogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnc3RyaW5nJztcbiAgfSxcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xuICB9LFxuICBpc051bGw6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbE9yVW5kZWZpbmVkOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09IG51bGw7XG4gIH1cbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///19\\n\")},function(module,exports){eval('module.exports = function(module) {\\n\\tif (!module.webpackPolyfill) {\\n\\t\\tmodule.deprecate = function() {};\\n\\t\\tmodule.paths = [];\\n\\t\\t// module.parent = undefined by default\\n\\t\\tif (!module.children) module.children = [];\\n\\t\\tObject.defineProperty(module, \"loaded\", {\\n\\t\\t\\tenumerable: true,\\n\\t\\t\\tget: function() {\\n\\t\\t\\t\\treturn module.l;\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\tObject.defineProperty(module, \"id\", {\\n\\t\\t\\tenumerable: true,\\n\\t\\t\\tget: function() {\\n\\t\\t\\t\\treturn module.i;\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\tmodule.webpackPolyfill = 1;\\n\\t}\\n\\treturn module;\\n};\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzP2NlZDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///20\\n')},function(module,exports,__webpack_require__){eval(\"/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */\\n;(function(root) {\\n\\n\\t/** Detect free variables */\\n\\tvar freeExports = typeof exports == 'object' && exports &&\\n\\t\\t!exports.nodeType && exports;\\n\\tvar freeModule = typeof module == 'object' && module &&\\n\\t\\t!module.nodeType && module;\\n\\tvar freeGlobal = typeof global == 'object' && global;\\n\\tif (\\n\\t\\tfreeGlobal.global === freeGlobal ||\\n\\t\\tfreeGlobal.window === freeGlobal ||\\n\\t\\tfreeGlobal.self === freeGlobal\\n\\t) {\\n\\t\\troot = freeGlobal;\\n\\t}\\n\\n\\t/**\\n\\t * The `punycode` object.\\n\\t * @name punycode\\n\\t * @type Object\\n\\t */\\n\\tvar punycode,\\n\\n\\t/** Highest positive signed 32-bit float value */\\n\\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\\n\\n\\t/** Bootstring parameters */\\n\\tbase = 36,\\n\\ttMin = 1,\\n\\ttMax = 26,\\n\\tskew = 38,\\n\\tdamp = 700,\\n\\tinitialBias = 72,\\n\\tinitialN = 128, // 0x80\\n\\tdelimiter = '-', // '\\\\x2D'\\n\\n\\t/** Regular expressions */\\n\\tregexPunycode = /^xn--/,\\n\\tregexNonASCII = /[^\\\\x20-\\\\x7E]/, // unprintable ASCII chars + non-ASCII chars\\n\\tregexSeparators = /[\\\\x2E\\\\u3002\\\\uFF0E\\\\uFF61]/g, // RFC 3490 separators\\n\\n\\t/** Error messages */\\n\\terrors = {\\n\\t\\t'overflow': 'Overflow: input needs wider integers to process',\\n\\t\\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\\n\\t\\t'invalid-input': 'Invalid input'\\n\\t},\\n\\n\\t/** Convenience shortcuts */\\n\\tbaseMinusTMin = base - tMin,\\n\\tfloor = Math.floor,\\n\\tstringFromCharCode = String.fromCharCode,\\n\\n\\t/** Temporary variable */\\n\\tkey;\\n\\n\\t/*--------------------------------------------------------------------------*/\\n\\n\\t/**\\n\\t * A generic error utility function.\\n\\t * @private\\n\\t * @param {String} type The error type.\\n\\t * @returns {Error} Throws a `RangeError` with the applicable error message.\\n\\t */\\n\\tfunction error(type) {\\n\\t\\tthrow new RangeError(errors[type]);\\n\\t}\\n\\n\\t/**\\n\\t * A generic `Array#map` utility function.\\n\\t * @private\\n\\t * @param {Array} array The array to iterate over.\\n\\t * @param {Function} callback The function that gets called for every array\\n\\t * item.\\n\\t * @returns {Array} A new array of values returned by the callback function.\\n\\t */\\n\\tfunction map(array, fn) {\\n\\t\\tvar length = array.length;\\n\\t\\tvar result = [];\\n\\t\\twhile (length--) {\\n\\t\\t\\tresult[length] = fn(array[length]);\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n\\n\\t/**\\n\\t * A simple `Array#map`-like wrapper to work with domain name strings or email\\n\\t * addresses.\\n\\t * @private\\n\\t * @param {String} domain The domain name or email address.\\n\\t * @param {Function} callback The function that gets called for every\\n\\t * character.\\n\\t * @returns {Array} A new string of characters returned by the callback\\n\\t * function.\\n\\t */\\n\\tfunction mapDomain(string, fn) {\\n\\t\\tvar parts = string.split('@');\\n\\t\\tvar result = '';\\n\\t\\tif (parts.length > 1) {\\n\\t\\t\\t// In email addresses, only the domain name should be punycoded. Leave\\n\\t\\t\\t// the local part (i.e. everything up to `@`) intact.\\n\\t\\t\\tresult = parts[0] + '@';\\n\\t\\t\\tstring = parts[1];\\n\\t\\t}\\n\\t\\t// Avoid `split(regex)` for IE8 compatibility. See #17.\\n\\t\\tstring = string.replace(regexSeparators, '\\\\x2E');\\n\\t\\tvar labels = string.split('.');\\n\\t\\tvar encoded = map(labels, fn).join('.');\\n\\t\\treturn result + encoded;\\n\\t}\\n\\n\\t/**\\n\\t * Creates an array containing the numeric code points of each Unicode\\n\\t * character in the string. While JavaScript uses UCS-2 internally,\\n\\t * this function will convert a pair of surrogate halves (each of which\\n\\t * UCS-2 exposes as separate characters) into a single code point,\\n\\t * matching UTF-16.\\n\\t * @see `punycode.ucs2.encode`\\n\\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\\n\\t * @memberOf punycode.ucs2\\n\\t * @name decode\\n\\t * @param {String} string The Unicode input string (UCS-2).\\n\\t * @returns {Array} The new array of code points.\\n\\t */\\n\\tfunction ucs2decode(string) {\\n\\t\\tvar output = [],\\n\\t\\t    counter = 0,\\n\\t\\t    length = string.length,\\n\\t\\t    value,\\n\\t\\t    extra;\\n\\t\\twhile (counter < length) {\\n\\t\\t\\tvalue = string.charCodeAt(counter++);\\n\\t\\t\\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\\n\\t\\t\\t\\t// high surrogate, and there is a next character\\n\\t\\t\\t\\textra = string.charCodeAt(counter++);\\n\\t\\t\\t\\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\\n\\t\\t\\t\\t\\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// unmatched surrogate; only append this code unit, in case the next\\n\\t\\t\\t\\t\\t// code unit is the high surrogate of a surrogate pair\\n\\t\\t\\t\\t\\toutput.push(value);\\n\\t\\t\\t\\t\\tcounter--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\toutput.push(value);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn output;\\n\\t}\\n\\n\\t/**\\n\\t * Creates a string based on an array of numeric code points.\\n\\t * @see `punycode.ucs2.decode`\\n\\t * @memberOf punycode.ucs2\\n\\t * @name encode\\n\\t * @param {Array} codePoints The array of numeric code points.\\n\\t * @returns {String} The new Unicode string (UCS-2).\\n\\t */\\n\\tfunction ucs2encode(array) {\\n\\t\\treturn map(array, function(value) {\\n\\t\\t\\tvar output = '';\\n\\t\\t\\tif (value > 0xFFFF) {\\n\\t\\t\\t\\tvalue -= 0x10000;\\n\\t\\t\\t\\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\\n\\t\\t\\t\\tvalue = 0xDC00 | value & 0x3FF;\\n\\t\\t\\t}\\n\\t\\t\\toutput += stringFromCharCode(value);\\n\\t\\t\\treturn output;\\n\\t\\t}).join('');\\n\\t}\\n\\n\\t/**\\n\\t * Converts a basic code point into a digit/integer.\\n\\t * @see `digitToBasic()`\\n\\t * @private\\n\\t * @param {Number} codePoint The basic numeric code point value.\\n\\t * @returns {Number} The numeric value of a basic code point (for use in\\n\\t * representing integers) in the range `0` to `base - 1`, or `base` if\\n\\t * the code point does not represent a value.\\n\\t */\\n\\tfunction basicToDigit(codePoint) {\\n\\t\\tif (codePoint - 48 < 10) {\\n\\t\\t\\treturn codePoint - 22;\\n\\t\\t}\\n\\t\\tif (codePoint - 65 < 26) {\\n\\t\\t\\treturn codePoint - 65;\\n\\t\\t}\\n\\t\\tif (codePoint - 97 < 26) {\\n\\t\\t\\treturn codePoint - 97;\\n\\t\\t}\\n\\t\\treturn base;\\n\\t}\\n\\n\\t/**\\n\\t * Converts a digit/integer into a basic code point.\\n\\t * @see `basicToDigit()`\\n\\t * @private\\n\\t * @param {Number} digit The numeric value of a basic code point.\\n\\t * @returns {Number} The basic code point whose value (when used for\\n\\t * representing integers) is `digit`, which needs to be in the range\\n\\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\\n\\t * used; else, the lowercase form is used. The behavior is undefined\\n\\t * if `flag` is non-zero and `digit` has no uppercase form.\\n\\t */\\n\\tfunction digitToBasic(digit, flag) {\\n\\t\\t//  0..25 map to ASCII a..z or A..Z\\n\\t\\t// 26..35 map to ASCII 0..9\\n\\t\\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\\n\\t}\\n\\n\\t/**\\n\\t * Bias adaptation function as per section 3.4 of RFC 3492.\\n\\t * https://tools.ietf.org/html/rfc3492#section-3.4\\n\\t * @private\\n\\t */\\n\\tfunction adapt(delta, numPoints, firstTime) {\\n\\t\\tvar k = 0;\\n\\t\\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\\n\\t\\tdelta += floor(delta / numPoints);\\n\\t\\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\\n\\t\\t\\tdelta = floor(delta / baseMinusTMin);\\n\\t\\t}\\n\\t\\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\\n\\t}\\n\\n\\t/**\\n\\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\\n\\t * symbols.\\n\\t * @memberOf punycode\\n\\t * @param {String} input The Punycode string of ASCII-only symbols.\\n\\t * @returns {String} The resulting string of Unicode symbols.\\n\\t */\\n\\tfunction decode(input) {\\n\\t\\t// Don't use UCS-2\\n\\t\\tvar output = [],\\n\\t\\t    inputLength = input.length,\\n\\t\\t    out,\\n\\t\\t    i = 0,\\n\\t\\t    n = initialN,\\n\\t\\t    bias = initialBias,\\n\\t\\t    basic,\\n\\t\\t    j,\\n\\t\\t    index,\\n\\t\\t    oldi,\\n\\t\\t    w,\\n\\t\\t    k,\\n\\t\\t    digit,\\n\\t\\t    t,\\n\\t\\t    /** Cached calculation results */\\n\\t\\t    baseMinusT;\\n\\n\\t\\t// Handle the basic code points: let `basic` be the number of input code\\n\\t\\t// points before the last delimiter, or `0` if there is none, then copy\\n\\t\\t// the first basic code points to the output.\\n\\n\\t\\tbasic = input.lastIndexOf(delimiter);\\n\\t\\tif (basic < 0) {\\n\\t\\t\\tbasic = 0;\\n\\t\\t}\\n\\n\\t\\tfor (j = 0; j < basic; ++j) {\\n\\t\\t\\t// if it's not a basic code point\\n\\t\\t\\tif (input.charCodeAt(j) >= 0x80) {\\n\\t\\t\\t\\terror('not-basic');\\n\\t\\t\\t}\\n\\t\\t\\toutput.push(input.charCodeAt(j));\\n\\t\\t}\\n\\n\\t\\t// Main decoding loop: start just after the last delimiter if any basic code\\n\\t\\t// points were copied; start at the beginning otherwise.\\n\\n\\t\\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\\n\\n\\t\\t\\t// `index` is the index of the next character to be consumed.\\n\\t\\t\\t// Decode a generalized variable-length integer into `delta`,\\n\\t\\t\\t// which gets added to `i`. The overflow checking is easier\\n\\t\\t\\t// if we increase `i` as we go, then subtract off its starting\\n\\t\\t\\t// value at the end to obtain `delta`.\\n\\t\\t\\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\\n\\n\\t\\t\\t\\tif (index >= inputLength) {\\n\\t\\t\\t\\t\\terror('invalid-input');\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tdigit = basicToDigit(input.charCodeAt(index++));\\n\\n\\t\\t\\t\\tif (digit >= base || digit > floor((maxInt - i) / w)) {\\n\\t\\t\\t\\t\\terror('overflow');\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ti += digit * w;\\n\\t\\t\\t\\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\\n\\n\\t\\t\\t\\tif (digit < t) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tbaseMinusT = base - t;\\n\\t\\t\\t\\tif (w > floor(maxInt / baseMinusT)) {\\n\\t\\t\\t\\t\\terror('overflow');\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tw *= baseMinusT;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tout = output.length + 1;\\n\\t\\t\\tbias = adapt(i - oldi, out, oldi == 0);\\n\\n\\t\\t\\t// `i` was supposed to wrap around from `out` to `0`,\\n\\t\\t\\t// incrementing `n` each time, so we'll fix that now:\\n\\t\\t\\tif (floor(i / out) > maxInt - n) {\\n\\t\\t\\t\\terror('overflow');\\n\\t\\t\\t}\\n\\n\\t\\t\\tn += floor(i / out);\\n\\t\\t\\ti %= out;\\n\\n\\t\\t\\t// Insert `n` at position `i` of the output\\n\\t\\t\\toutput.splice(i++, 0, n);\\n\\n\\t\\t}\\n\\n\\t\\treturn ucs2encode(output);\\n\\t}\\n\\n\\t/**\\n\\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\\n\\t * Punycode string of ASCII-only symbols.\\n\\t * @memberOf punycode\\n\\t * @param {String} input The string of Unicode symbols.\\n\\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\\n\\t */\\n\\tfunction encode(input) {\\n\\t\\tvar n,\\n\\t\\t    delta,\\n\\t\\t    handledCPCount,\\n\\t\\t    basicLength,\\n\\t\\t    bias,\\n\\t\\t    j,\\n\\t\\t    m,\\n\\t\\t    q,\\n\\t\\t    k,\\n\\t\\t    t,\\n\\t\\t    currentValue,\\n\\t\\t    output = [],\\n\\t\\t    /** `inputLength` will hold the number of code points in `input`. */\\n\\t\\t    inputLength,\\n\\t\\t    /** Cached calculation results */\\n\\t\\t    handledCPCountPlusOne,\\n\\t\\t    baseMinusT,\\n\\t\\t    qMinusT;\\n\\n\\t\\t// Convert the input in UCS-2 to Unicode\\n\\t\\tinput = ucs2decode(input);\\n\\n\\t\\t// Cache the length\\n\\t\\tinputLength = input.length;\\n\\n\\t\\t// Initialize the state\\n\\t\\tn = initialN;\\n\\t\\tdelta = 0;\\n\\t\\tbias = initialBias;\\n\\n\\t\\t// Handle the basic code points\\n\\t\\tfor (j = 0; j < inputLength; ++j) {\\n\\t\\t\\tcurrentValue = input[j];\\n\\t\\t\\tif (currentValue < 0x80) {\\n\\t\\t\\t\\toutput.push(stringFromCharCode(currentValue));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\thandledCPCount = basicLength = output.length;\\n\\n\\t\\t// `handledCPCount` is the number of code points that have been handled;\\n\\t\\t// `basicLength` is the number of basic code points.\\n\\n\\t\\t// Finish the basic string - if it is not empty - with a delimiter\\n\\t\\tif (basicLength) {\\n\\t\\t\\toutput.push(delimiter);\\n\\t\\t}\\n\\n\\t\\t// Main encoding loop:\\n\\t\\twhile (handledCPCount < inputLength) {\\n\\n\\t\\t\\t// All non-basic code points < n have been handled already. Find the next\\n\\t\\t\\t// larger one:\\n\\t\\t\\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\\n\\t\\t\\t\\tcurrentValue = input[j];\\n\\t\\t\\t\\tif (currentValue >= n && currentValue < m) {\\n\\t\\t\\t\\t\\tm = currentValue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\\n\\t\\t\\t// but guard against overflow\\n\\t\\t\\thandledCPCountPlusOne = handledCPCount + 1;\\n\\t\\t\\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\\n\\t\\t\\t\\terror('overflow');\\n\\t\\t\\t}\\n\\n\\t\\t\\tdelta += (m - n) * handledCPCountPlusOne;\\n\\t\\t\\tn = m;\\n\\n\\t\\t\\tfor (j = 0; j < inputLength; ++j) {\\n\\t\\t\\t\\tcurrentValue = input[j];\\n\\n\\t\\t\\t\\tif (currentValue < n && ++delta > maxInt) {\\n\\t\\t\\t\\t\\terror('overflow');\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (currentValue == n) {\\n\\t\\t\\t\\t\\t// Represent delta as a generalized variable-length integer\\n\\t\\t\\t\\t\\tfor (q = delta, k = base; /* no condition */; k += base) {\\n\\t\\t\\t\\t\\t\\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\\n\\t\\t\\t\\t\\t\\tif (q < t) {\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tqMinusT = q - t;\\n\\t\\t\\t\\t\\t\\tbaseMinusT = base - t;\\n\\t\\t\\t\\t\\t\\toutput.push(\\n\\t\\t\\t\\t\\t\\t\\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\tq = floor(qMinusT / baseMinusT);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\\n\\t\\t\\t\\t\\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\\n\\t\\t\\t\\t\\tdelta = 0;\\n\\t\\t\\t\\t\\t++handledCPCount;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t++delta;\\n\\t\\t\\t++n;\\n\\n\\t\\t}\\n\\t\\treturn output.join('');\\n\\t}\\n\\n\\t/**\\n\\t * Converts a Punycode string representing a domain name or an email address\\n\\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\\n\\t * it doesn't matter if you call it on a string that has already been\\n\\t * converted to Unicode.\\n\\t * @memberOf punycode\\n\\t * @param {String} input The Punycoded domain name or email address to\\n\\t * convert to Unicode.\\n\\t * @returns {String} The Unicode representation of the given Punycode\\n\\t * string.\\n\\t */\\n\\tfunction toUnicode(input) {\\n\\t\\treturn mapDomain(input, function(string) {\\n\\t\\t\\treturn regexPunycode.test(string)\\n\\t\\t\\t\\t? decode(string.slice(4).toLowerCase())\\n\\t\\t\\t\\t: string;\\n\\t\\t});\\n\\t}\\n\\n\\t/**\\n\\t * Converts a Unicode string representing a domain name or an email address to\\n\\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\\n\\t * i.e. it doesn't matter if you call it with a domain that's already in\\n\\t * ASCII.\\n\\t * @memberOf punycode\\n\\t * @param {String} input The domain name or email address to convert, as a\\n\\t * Unicode string.\\n\\t * @returns {String} The Punycode representation of the given domain name or\\n\\t * email address.\\n\\t */\\n\\tfunction toASCII(input) {\\n\\t\\treturn mapDomain(input, function(string) {\\n\\t\\t\\treturn regexNonASCII.test(string)\\n\\t\\t\\t\\t? 'xn--' + encode(string)\\n\\t\\t\\t\\t: string;\\n\\t\\t});\\n\\t}\\n\\n\\t/*--------------------------------------------------------------------------*/\\n\\n\\t/** Define the public API */\\n\\tpunycode = {\\n\\t\\t/**\\n\\t\\t * A string representing the current Punycode.js version number.\\n\\t\\t * @memberOf punycode\\n\\t\\t * @type String\\n\\t\\t */\\n\\t\\t'version': '1.4.1',\\n\\t\\t/**\\n\\t\\t * An object of methods to convert from JavaScript's internal character\\n\\t\\t * representation (UCS-2) to Unicode code points, and back.\\n\\t\\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\\n\\t\\t * @memberOf punycode\\n\\t\\t * @type Object\\n\\t\\t */\\n\\t\\t'ucs2': {\\n\\t\\t\\t'decode': ucs2decode,\\n\\t\\t\\t'encode': ucs2encode\\n\\t\\t},\\n\\t\\t'decode': decode,\\n\\t\\t'encode': encode,\\n\\t\\t'toASCII': toASCII,\\n\\t\\t'toUnicode': toUnicode\\n\\t};\\n\\n\\t/** Expose `punycode` */\\n\\t// Some AMD build optimizers, like r.js, check for specific condition patterns\\n\\t// like the following:\\n\\tif (\\n\\t\\ttrue\\n\\t) {\\n\\t\\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\\n\\t\\t\\treturn punycode;\\n\\t\\t}).call(exports, __webpack_require__, exports, module),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\\n\\t} else {}\\n\\n}(this));\\n\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(20)(module), __webpack_require__(0)))//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL25vZGVfbW9kdWxlcy9ub2RlLWxpYnMtYnJvd3Nlci9ub2RlX21vZHVsZXMvcHVueWNvZGUvcHVueWNvZGUuanM/ZGU5NSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoic0RBQUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLFlBQVksU0FBUztBQUNyQjtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFx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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFBQTtBQUNILEVBQUUsUUFhRjs7QUFFQSxDQUFDIiwiZmlsZSI6IjIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS40LjEgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS40LjEnLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7XG5cdFx0XHQvLyBpbiBOb2RlLmpzLCBpby5qcywgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///21\\n\")},function(module,exports,__webpack_require__){\"use strict\";eval(\"// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\n\\n\\nvar punycode = __webpack_require__(21);\\nvar util = __webpack_require__(19);\\n\\nexports.parse = urlParse;\\nexports.resolve = urlResolve;\\nexports.resolveObject = urlResolveObject;\\nexports.format = urlFormat;\\n\\nexports.Url = Url;\\n\\nfunction Url() {\\n  this.protocol = null;\\n  this.slashes = null;\\n  this.auth = null;\\n  this.host = null;\\n  this.port = null;\\n  this.hostname = null;\\n  this.hash = null;\\n  this.search = null;\\n  this.query = null;\\n  this.pathname = null;\\n  this.path = null;\\n  this.href = null;\\n}\\n\\n// Reference: RFC 3986, RFC 1808, RFC 2396\\n\\n// define these here so at least they only have to be\\n// compiled once on the first module load.\\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\\n    portPattern = /:[0-9]*$/,\\n\\n    // Special case for a simple path URL\\n    simplePathPattern = /^(\\\\/\\\\/?(?!\\\\/)[^\\\\?\\\\s]*)(\\\\?[^\\\\s]*)?$/,\\n\\n    // RFC 2396: characters reserved for delimiting URLs.\\n    // We actually just auto-escape these.\\n    delims = ['<', '>', '\\\"', '`', ' ', '\\\\r', '\\\\n', '\\\\t'],\\n\\n    // RFC 2396: characters not allowed for various reasons.\\n    unwise = ['{', '}', '|', '\\\\\\\\', '^', '`'].concat(delims),\\n\\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\\n    autoEscape = ['\\\\''].concat(unwise),\\n    // Characters that are never ever allowed in a hostname.\\n    // Note that any invalid chars are also handled, but these\\n    // are the ones that are *expected* to be seen, so we fast-path\\n    // them.\\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\\n    hostEndingChars = ['/', '?', '#'],\\n    hostnameMaxLen = 255,\\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\\n    // protocols that can allow \\\"unsafe\\\" and \\\"unwise\\\" chars.\\n    unsafeProtocol = {\\n      'javascript': true,\\n      'javascript:': true\\n    },\\n    // protocols that never have a hostname.\\n    hostlessProtocol = {\\n      'javascript': true,\\n      'javascript:': true\\n    },\\n    // protocols that always contain a // bit.\\n    slashedProtocol = {\\n      'http': true,\\n      'https': true,\\n      'ftp': true,\\n      'gopher': true,\\n      'file': true,\\n      'http:': true,\\n      'https:': true,\\n      'ftp:': true,\\n      'gopher:': true,\\n      'file:': true\\n    },\\n    querystring = __webpack_require__(18);\\n\\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\\n  if (url && util.isObject(url) && url instanceof Url) return url;\\n\\n  var u = new Url;\\n  u.parse(url, parseQueryString, slashesDenoteHost);\\n  return u;\\n}\\n\\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\\n  if (!util.isString(url)) {\\n    throw new TypeError(\\\"Parameter 'url' must be a string, not \\\" + typeof url);\\n  }\\n\\n  // Copy chrome, IE, opera backslash-handling behavior.\\n  // Back slashes before the query string get converted to forward slashes\\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\\n  var queryIndex = url.indexOf('?'),\\n      splitter =\\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\\n      uSplit = url.split(splitter),\\n      slashRegex = /\\\\\\\\/g;\\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\\n  url = uSplit.join(splitter);\\n\\n  var rest = url;\\n\\n  // trim before proceeding.\\n  // This is to support parse stuff like \\\"  http://foo.com  \\\\n\\\"\\n  rest = rest.trim();\\n\\n  if (!slashesDenoteHost && url.split('#').length === 1) {\\n    // Try fast path regexp\\n    var simplePath = simplePathPattern.exec(rest);\\n    if (simplePath) {\\n      this.path = rest;\\n      this.href = rest;\\n      this.pathname = simplePath[1];\\n      if (simplePath[2]) {\\n        this.search = simplePath[2];\\n        if (parseQueryString) {\\n          this.query = querystring.parse(this.search.substr(1));\\n        } else {\\n          this.query = this.search.substr(1);\\n        }\\n      } else if (parseQueryString) {\\n        this.search = '';\\n        this.query = {};\\n      }\\n      return this;\\n    }\\n  }\\n\\n  var proto = protocolPattern.exec(rest);\\n  if (proto) {\\n    proto = proto[0];\\n    var lowerProto = proto.toLowerCase();\\n    this.protocol = lowerProto;\\n    rest = rest.substr(proto.length);\\n  }\\n\\n  // figure out if it's got a host\\n  // user@server is *always* interpreted as a hostname, and url\\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\\n  // how the browser resolves relative URLs.\\n  if (slashesDenoteHost || proto || rest.match(/^\\\\/\\\\/[^@\\\\/]+@[^@\\\\/]+/)) {\\n    var slashes = rest.substr(0, 2) === '//';\\n    if (slashes && !(proto && hostlessProtocol[proto])) {\\n      rest = rest.substr(2);\\n      this.slashes = true;\\n    }\\n  }\\n\\n  if (!hostlessProtocol[proto] &&\\n      (slashes || (proto && !slashedProtocol[proto]))) {\\n\\n    // there's a hostname.\\n    // the first instance of /, ?, ;, or # ends the host.\\n    //\\n    // If there is an @ in the hostname, then non-host chars *are* allowed\\n    // to the left of the last @ sign, unless some host-ending character\\n    // comes *before* the @-sign.\\n    // URLs are obnoxious.\\n    //\\n    // ex:\\n    // http://a@b@c/ => user:a@b host:c\\n    // http://a@b?@c => user:a host:c path:/?@c\\n\\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\\n    // Review our test case against browsers more comprehensively.\\n\\n    // find the first instance of any hostEndingChars\\n    var hostEnd = -1;\\n    for (var i = 0; i < hostEndingChars.length; i++) {\\n      var hec = rest.indexOf(hostEndingChars[i]);\\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\\n        hostEnd = hec;\\n    }\\n\\n    // at this point, either we have an explicit point where the\\n    // auth portion cannot go past, or the last @ char is the decider.\\n    var auth, atSign;\\n    if (hostEnd === -1) {\\n      // atSign can be anywhere.\\n      atSign = rest.lastIndexOf('@');\\n    } else {\\n      // atSign must be in auth portion.\\n      // http://a@b/c@d => host:b auth:a path:/c@d\\n      atSign = rest.lastIndexOf('@', hostEnd);\\n    }\\n\\n    // Now we have a portion which is definitely the auth.\\n    // Pull that off.\\n    if (atSign !== -1) {\\n      auth = rest.slice(0, atSign);\\n      rest = rest.slice(atSign + 1);\\n      this.auth = decodeURIComponent(auth);\\n    }\\n\\n    // the host is the remaining to the left of the first non-host char\\n    hostEnd = -1;\\n    for (var i = 0; i < nonHostChars.length; i++) {\\n      var hec = rest.indexOf(nonHostChars[i]);\\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\\n        hostEnd = hec;\\n    }\\n    // if we still have not hit it, then the entire thing is a host.\\n    if (hostEnd === -1)\\n      hostEnd = rest.length;\\n\\n    this.host = rest.slice(0, hostEnd);\\n    rest = rest.slice(hostEnd);\\n\\n    // pull out port.\\n    this.parseHost();\\n\\n    // we've indicated that there is a hostname,\\n    // so even if it's empty, it has to be present.\\n    this.hostname = this.hostname || '';\\n\\n    // if hostname begins with [ and ends with ]\\n    // assume that it's an IPv6 address.\\n    var ipv6Hostname = this.hostname[0] === '[' &&\\n        this.hostname[this.hostname.length - 1] === ']';\\n\\n    // validate a little.\\n    if (!ipv6Hostname) {\\n      var hostparts = this.hostname.split(/\\\\./);\\n      for (var i = 0, l = hostparts.length; i < l; i++) {\\n        var part = hostparts[i];\\n        if (!part) continue;\\n        if (!part.match(hostnamePartPattern)) {\\n          var newpart = '';\\n          for (var j = 0, k = part.length; j < k; j++) {\\n            if (part.charCodeAt(j) > 127) {\\n              // we replace non-ASCII char with a temporary placeholder\\n              // we need this to make sure size of hostname is not\\n              // broken by replacing non-ASCII by nothing\\n              newpart += 'x';\\n            } else {\\n              newpart += part[j];\\n            }\\n          }\\n          // we test again with ASCII char only\\n          if (!newpart.match(hostnamePartPattern)) {\\n            var validParts = hostparts.slice(0, i);\\n            var notHost = hostparts.slice(i + 1);\\n            var bit = part.match(hostnamePartStart);\\n            if (bit) {\\n              validParts.push(bit[1]);\\n              notHost.unshift(bit[2]);\\n            }\\n            if (notHost.length) {\\n              rest = '/' + notHost.join('.') + rest;\\n            }\\n            this.hostname = validParts.join('.');\\n            break;\\n          }\\n        }\\n      }\\n    }\\n\\n    if (this.hostname.length > hostnameMaxLen) {\\n      this.hostname = '';\\n    } else {\\n      // hostnames are always lower case.\\n      this.hostname = this.hostname.toLowerCase();\\n    }\\n\\n    if (!ipv6Hostname) {\\n      // IDNA Support: Returns a punycoded representation of \\\"domain\\\".\\n      // It only converts parts of the domain name that\\n      // have non-ASCII characters, i.e. it doesn't matter if\\n      // you call it with a domain that already is ASCII-only.\\n      this.hostname = punycode.toASCII(this.hostname);\\n    }\\n\\n    var p = this.port ? ':' + this.port : '';\\n    var h = this.hostname || '';\\n    this.host = h + p;\\n    this.href += this.host;\\n\\n    // strip [ and ] from the hostname\\n    // the host field still retains them, though\\n    if (ipv6Hostname) {\\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\\n      if (rest[0] !== '/') {\\n        rest = '/' + rest;\\n      }\\n    }\\n  }\\n\\n  // now rest is set to the post-host stuff.\\n  // chop off any delim chars.\\n  if (!unsafeProtocol[lowerProto]) {\\n\\n    // First, make 100% sure that any \\\"autoEscape\\\" chars get\\n    // escaped, even if encodeURIComponent doesn't think they\\n    // need to be.\\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\\n      var ae = autoEscape[i];\\n      if (rest.indexOf(ae) === -1)\\n        continue;\\n      var esc = encodeURIComponent(ae);\\n      if (esc === ae) {\\n        esc = escape(ae);\\n      }\\n      rest = rest.split(ae).join(esc);\\n    }\\n  }\\n\\n\\n  // chop off from the tail first.\\n  var hash = rest.indexOf('#');\\n  if (hash !== -1) {\\n    // got a fragment string.\\n    this.hash = rest.substr(hash);\\n    rest = rest.slice(0, hash);\\n  }\\n  var qm = rest.indexOf('?');\\n  if (qm !== -1) {\\n    this.search = rest.substr(qm);\\n    this.query = rest.substr(qm + 1);\\n    if (parseQueryString) {\\n      this.query = querystring.parse(this.query);\\n    }\\n    rest = rest.slice(0, qm);\\n  } else if (parseQueryString) {\\n    // no query string, but parseQueryString still requested\\n    this.search = '';\\n    this.query = {};\\n  }\\n  if (rest) this.pathname = rest;\\n  if (slashedProtocol[lowerProto] &&\\n      this.hostname && !this.pathname) {\\n    this.pathname = '/';\\n  }\\n\\n  //to support http.request\\n  if (this.pathname || this.search) {\\n    var p = this.pathname || '';\\n    var s = this.search || '';\\n    this.path = p + s;\\n  }\\n\\n  // finally, reconstruct the href based on what has been validated.\\n  this.href = this.format();\\n  return this;\\n};\\n\\n// format a parsed object into a url string\\nfunction urlFormat(obj) {\\n  // ensure it's an object, and not a string url.\\n  // If it's an obj, this is a no-op.\\n  // this way, you can call url_format() on strings\\n  // to clean up potentially wonky urls.\\n  if (util.isString(obj)) obj = urlParse(obj);\\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\\n  return obj.format();\\n}\\n\\nUrl.prototype.format = function() {\\n  var auth = this.auth || '';\\n  if (auth) {\\n    auth = encodeURIComponent(auth);\\n    auth = auth.replace(/%3A/i, ':');\\n    auth += '@';\\n  }\\n\\n  var protocol = this.protocol || '',\\n      pathname = this.pathname || '',\\n      hash = this.hash || '',\\n      host = false,\\n      query = '';\\n\\n  if (this.host) {\\n    host = auth + this.host;\\n  } else if (this.hostname) {\\n    host = auth + (this.hostname.indexOf(':') === -1 ?\\n        this.hostname :\\n        '[' + this.hostname + ']');\\n    if (this.port) {\\n      host += ':' + this.port;\\n    }\\n  }\\n\\n  if (this.query &&\\n      util.isObject(this.query) &&\\n      Object.keys(this.query).length) {\\n    query = querystring.stringify(this.query);\\n  }\\n\\n  var search = this.search || (query && ('?' + query)) || '';\\n\\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\\n\\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\\n  // unless they had them to begin with.\\n  if (this.slashes ||\\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\\n    host = '//' + (host || '');\\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\\n  } else if (!host) {\\n    host = '';\\n  }\\n\\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\\n  if (search && search.charAt(0) !== '?') search = '?' + search;\\n\\n  pathname = pathname.replace(/[?#]/g, function(match) {\\n    return encodeURIComponent(match);\\n  });\\n  search = search.replace('#', '%23');\\n\\n  return protocol + host + pathname + search + hash;\\n};\\n\\nfunction urlResolve(source, relative) {\\n  return urlParse(source, false, true).resolve(relative);\\n}\\n\\nUrl.prototype.resolve = function(relative) {\\n  return this.resolveObject(urlParse(relative, false, true)).format();\\n};\\n\\nfunction urlResolveObject(source, relative) {\\n  if (!source) return relative;\\n  return urlParse(source, false, true).resolveObject(relative);\\n}\\n\\nUrl.prototype.resolveObject = function(relative) {\\n  if (util.isString(relative)) {\\n    var rel = new Url();\\n    rel.parse(relative, false, true);\\n    relative = rel;\\n  }\\n\\n  var result = new Url();\\n  var tkeys = Object.keys(this);\\n  for (var tk = 0; tk < tkeys.length; tk++) {\\n    var tkey = tkeys[tk];\\n    result[tkey] = this[tkey];\\n  }\\n\\n  // hash is always overridden, no matter what.\\n  // even href=\\\"\\\" will remove it.\\n  result.hash = relative.hash;\\n\\n  // if the relative url is empty, then there's nothing left to do here.\\n  if (relative.href === '') {\\n    result.href = result.format();\\n    return result;\\n  }\\n\\n  // hrefs like //foo/bar always cut to the protocol.\\n  if (relative.slashes && !relative.protocol) {\\n    // take everything except the protocol from relative\\n    var rkeys = Object.keys(relative);\\n    for (var rk = 0; rk < rkeys.length; rk++) {\\n      var rkey = rkeys[rk];\\n      if (rkey !== 'protocol')\\n        result[rkey] = relative[rkey];\\n    }\\n\\n    //urlParse appends trailing / to urls like http://www.example.com\\n    if (slashedProtocol[result.protocol] &&\\n        result.hostname && !result.pathname) {\\n      result.path = result.pathname = '/';\\n    }\\n\\n    result.href = result.format();\\n    return result;\\n  }\\n\\n  if (relative.protocol && relative.protocol !== result.protocol) {\\n    // if it's a known url protocol, then changing\\n    // the protocol does weird things\\n    // first, if it's not file:, then we MUST have a host,\\n    // and if there was a path\\n    // to begin with, then we MUST have a path.\\n    // if it is file:, then the host is dropped,\\n    // because that's known to be hostless.\\n    // anything else is assumed to be absolute.\\n    if (!slashedProtocol[relative.protocol]) {\\n      var keys = Object.keys(relative);\\n      for (var v = 0; v < keys.length; v++) {\\n        var k = keys[v];\\n        result[k] = relative[k];\\n      }\\n      result.href = result.format();\\n      return result;\\n    }\\n\\n    result.protocol = relative.protocol;\\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\\n      var relPath = (relative.pathname || '').split('/');\\n      while (relPath.length && !(relative.host = relPath.shift()));\\n      if (!relative.host) relative.host = '';\\n      if (!relative.hostname) relative.hostname = '';\\n      if (relPath[0] !== '') relPath.unshift('');\\n      if (relPath.length < 2) relPath.unshift('');\\n      result.pathname = relPath.join('/');\\n    } else {\\n      result.pathname = relative.pathname;\\n    }\\n    result.search = relative.search;\\n    result.query = relative.query;\\n    result.host = relative.host || '';\\n    result.auth = relative.auth;\\n    result.hostname = relative.hostname || relative.host;\\n    result.port = relative.port;\\n    // to support http.request\\n    if (result.pathname || result.search) {\\n      var p = result.pathname || '';\\n      var s = result.search || '';\\n      result.path = p + s;\\n    }\\n    result.slashes = result.slashes || relative.slashes;\\n    result.href = result.format();\\n    return result;\\n  }\\n\\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\\n      isRelAbs = (\\n          relative.host ||\\n          relative.pathname && relative.pathname.charAt(0) === '/'\\n      ),\\n      mustEndAbs = (isRelAbs || isSourceAbs ||\\n                    (result.host && relative.pathname)),\\n      removeAllDots = mustEndAbs,\\n      srcPath = result.pathname && result.pathname.split('/') || [],\\n      relPath = relative.pathname && relative.pathname.split('/') || [],\\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\\n\\n  // if the url is a non-slashed url, then relative\\n  // links like ../.. should be able\\n  // to crawl up to the hostname, as well.  This is strange.\\n  // result.protocol has already been set by now.\\n  // Later on, put the first path part into the host field.\\n  if (psychotic) {\\n    result.hostname = '';\\n    result.port = null;\\n    if (result.host) {\\n      if (srcPath[0] === '') srcPath[0] = result.host;\\n      else srcPath.unshift(result.host);\\n    }\\n    result.host = '';\\n    if (relative.protocol) {\\n      relative.hostname = null;\\n      relative.port = null;\\n      if (relative.host) {\\n        if (relPath[0] === '') relPath[0] = relative.host;\\n        else relPath.unshift(relative.host);\\n      }\\n      relative.host = null;\\n    }\\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\\n  }\\n\\n  if (isRelAbs) {\\n    // it's absolute.\\n    result.host = (relative.host || relative.host === '') ?\\n                  relative.host : result.host;\\n    result.hostname = (relative.hostname || relative.hostname === '') ?\\n                      relative.hostname : result.hostname;\\n    result.search = relative.search;\\n    result.query = relative.query;\\n    srcPath = relPath;\\n    // fall through to the dot-handling below.\\n  } else if (relPath.length) {\\n    // it's relative\\n    // throw away the existing file, and take the new path instead.\\n    if (!srcPath) srcPath = [];\\n    srcPath.pop();\\n    srcPath = srcPath.concat(relPath);\\n    result.search = relative.search;\\n    result.query = relative.query;\\n  } else if (!util.isNullOrUndefined(relative.search)) {\\n    // just pull out the search.\\n    // like href='?foo'.\\n    // Put this after the other two cases because it simplifies the booleans\\n    if (psychotic) {\\n      result.hostname = result.host = srcPath.shift();\\n      //occationaly the auth can get stuck only in host\\n      //this especially happens in cases like\\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\\n                       result.host.split('@') : false;\\n      if (authInHost) {\\n        result.auth = authInHost.shift();\\n        result.host = result.hostname = authInHost.shift();\\n      }\\n    }\\n    result.search = relative.search;\\n    result.query = relative.query;\\n    //to support http.request\\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\\n      result.path = (result.pathname ? result.pathname : '') +\\n                    (result.search ? result.search : '');\\n    }\\n    result.href = result.format();\\n    return result;\\n  }\\n\\n  if (!srcPath.length) {\\n    // no path at all.  easy.\\n    // we've already handled the other stuff above.\\n    result.pathname = null;\\n    //to support http.request\\n    if (result.search) {\\n      result.path = '/' + result.search;\\n    } else {\\n      result.path = null;\\n    }\\n    result.href = result.format();\\n    return result;\\n  }\\n\\n  // if a url ENDs in . or .., then it must get a trailing slash.\\n  // however, if it ends in anything else non-slashy,\\n  // then it must NOT get a trailing slash.\\n  var last = srcPath.slice(-1)[0];\\n  var hasTrailingSlash = (\\n      (result.host || relative.host || srcPath.length > 1) &&\\n      (last === '.' || last === '..') || last === '');\\n\\n  // strip single dots, resolve double dots to parent dir\\n  // if the path tries to go above the root, `up` ends up > 0\\n  var up = 0;\\n  for (var i = srcPath.length; i >= 0; i--) {\\n    last = srcPath[i];\\n    if (last === '.') {\\n      srcPath.splice(i, 1);\\n    } else if (last === '..') {\\n      srcPath.splice(i, 1);\\n      up++;\\n    } else if (up) {\\n      srcPath.splice(i, 1);\\n      up--;\\n    }\\n  }\\n\\n  // if the path is allowed to go above the root, restore leading ..s\\n  if (!mustEndAbs && !removeAllDots) {\\n    for (; up--; up) {\\n      srcPath.unshift('..');\\n    }\\n  }\\n\\n  if (mustEndAbs && srcPath[0] !== '' &&\\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\\n    srcPath.unshift('');\\n  }\\n\\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\\n    srcPath.push('');\\n  }\\n\\n  var isAbsolute = srcPath[0] === '' ||\\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\\n\\n  // put the host back\\n  if (psychotic) {\\n    result.hostname = result.host = isAbsolute ? '' :\\n                                    srcPath.length ? srcPath.shift() : '';\\n    //occationaly the auth can get stuck only in host\\n    //this especially happens in cases like\\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\\n                     result.host.split('@') : false;\\n    if (authInHost) {\\n      result.auth = authInHost.shift();\\n      result.host = result.hostname = authInHost.shift();\\n    }\\n  }\\n\\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\\n\\n  if (mustEndAbs && !isAbsolute) {\\n    srcPath.unshift('');\\n  }\\n\\n  if (!srcPath.length) {\\n    result.pathname = null;\\n    result.path = null;\\n  } else {\\n    result.pathname = srcPath.join('/');\\n  }\\n\\n  //to support request.http\\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\\n    result.path = (result.pathname ? result.pathname : '') +\\n                  (result.search ? result.search : '');\\n  }\\n  result.auth = relative.auth || result.auth;\\n  result.slashes = result.slashes || relative.slashes;\\n  result.href = result.format();\\n  return result;\\n};\\n\\nUrl.prototype.parseHost = function() {\\n  var host = this.host;\\n  var port = portPattern.exec(host);\\n  if (port) {\\n    port = port[0];\\n    if (port !== ':') {\\n      this.port = port.substr(1);\\n    }\\n    host = host.substr(0, host.length - port.length);\\n  }\\n  if (host) this.hostname = host;\\n};\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL25vZGVfbW9kdWxlcy91cmwvdXJsLmpzPzQ3ZTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsS0FBSzs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSwyQ0FBMkMsS0FBSztBQUNoRCwwQ0FBMEMsS0FBSztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsTUFBTTtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmV4cG9ydHMuVXJsID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG4gICAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiB1dGlsLmlzT2JqZWN0KHVybCkgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSByZXR1cm4gdXJsO1xuXG4gIHZhciB1ID0gbmV3IFVybDtcbiAgdS5wYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgcmV0dXJuIHU7XG59XG5cblVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICghdXRpbC5pc1N0cmluZyh1cmwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIC8vIENvcHkgY2hyb21lLCBJRSwgb3BlcmEgYmFja3NsYXNoLWhhbmRsaW5nIGJlaGF2aW9yLlxuICAvLyBCYWNrIHNsYXNoZXMgYmVmb3JlIHRoZSBxdWVyeSBzdHJpbmcgZ2V0IGNvbnZlcnRlZCB0byBmb3J3YXJkIHNsYXNoZXNcbiAgLy8gU2VlOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjU5MTZcbiAgdmFyIHF1ZXJ5SW5kZXggPSB1cmwuaW5kZXhPZignPycpLFxuICAgICAgc3BsaXR0ZXIgPVxuICAgICAgICAgIChxdWVyeUluZGV4ICE9PSAtMSAmJiBxdWVyeUluZGV4IDwgdXJsLmluZGV4T2YoJyMnKSkgPyAnPycgOiAnIycsXG4gICAgICB1U3BsaXQgPSB1cmwuc3BsaXQoc3BsaXR0ZXIpLFxuICAgICAgc2xhc2hSZWdleCA9IC9cXFxcL2c7XG4gIHVTcGxpdFswXSA9IHVTcGxpdFswXS5yZXBsYWNlKHNsYXNoUmVnZXgsICcvJyk7XG4gIHVybCA9IHVTcGxpdC5qb2luKHNwbGl0dGVyKTtcblxuICB2YXIgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG4gICAgdmFyIHNpbXBsZVBhdGggPSBzaW1wbGVQYXRoUGF0dGVybi5leGVjKHJlc3QpO1xuICAgIGlmIChzaW1wbGVQYXRoKSB7XG4gICAgICB0aGlzLnBhdGggPSByZXN0O1xuICAgICAgdGhpcy5ocmVmID0gcmVzdDtcbiAgICAgIHRoaXMucGF0aG5hbWUgPSBzaW1wbGVQYXRoWzFdO1xuICAgICAgaWYgKHNpbXBsZVBhdGhbMl0pIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBzaW1wbGVQYXRoWzJdO1xuICAgICAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnNlYXJjaC5zdWJzdHIoMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLnNlYXJjaC5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgaWYgKHByb3RvKSB7XG4gICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICB2YXIgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm90b2NvbCA9IGxvd2VyUHJvdG87XG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XG4gIH1cblxuICAvLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxuICAvLyB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXG4gIC8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3NcbiAgLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkge1xuICAgIHZhciBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcblxuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgLy9cbiAgICAvLyBleDpcbiAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcblxuICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbiAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgIHZhciBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxuICAgIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKVxuICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuXG4gICAgdGhpcy5ob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcblxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgdGhpcy5wYXJzZUhvc3QoKTtcblxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcblxuICAgIC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4gICAgLy8gYXNzdW1lIHRoYXQgaXQncyBhbiBJUHY2IGFkZHJlc3MuXG4gICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxuICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcblxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgY29udGludWU7XG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG4gICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueWNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAvLyBoYXZlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBBU0NJSS1vbmx5LlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHB1bnljb2RlLnRvQVNDSUkodGhpcy5ob3N0bmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHAgPSB0aGlzLnBvcnQgPyAnOicgKyB0aGlzLnBvcnQgOiAnJztcbiAgICB2YXIgaCA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG4gICAgdGhpcy5ob3N0ID0gaCArIHA7XG4gICAgdGhpcy5ocmVmICs9IHRoaXMuaG9zdDtcblxuICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgaWYgKHJlc3RbMF0gIT09ICcvJykge1xuICAgICAgICByZXN0ID0gJy8nICsgcmVzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cbiAgLy8gY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLlxuICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XG5cbiAgICAvLyBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgXCJhdXRvRXNjYXBlXCIgY2hhcnMgZ2V0XG4gICAgLy8gZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5XG4gICAgLy8gbmVlZCB0byBiZS5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldO1xuICAgICAgaWYgKHJlc3QuaW5kZXhPZihhZSkgPT09IC0xKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0O1xuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAodXRpbC5pc1N0cmluZyhvYmopKSBvYmogPSB1cmxQYXJzZShvYmopO1xuICBpZiAoIShvYmogaW5zdGFuY2VvZiBVcmwpKSByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopO1xuICByZXR1cm4gb2JqLmZvcm1hdCgpO1xufVxuXG5VcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXV0aCA9IHRoaXMuYXV0aCB8fCAnJztcbiAgaWYgKGF1dGgpIHtcbiAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIGF1dGggPSBhdXRoLnJlcGxhY2UoLyUzQS9pLCAnOicpO1xuICAgIGF1dGggKz0gJ0AnO1xuICB9XG5cbiAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCB8fCAnJyxcbiAgICAgIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCAnJyxcbiAgICAgIGhhc2ggPSB0aGlzLmhhc2ggfHwgJycsXG4gICAgICBob3N0ID0gZmFsc2UsXG4gICAgICBxdWVyeSA9ICcnO1xuXG4gIGlmICh0aGlzLmhvc3QpIHtcbiAgICBob3N0ID0gYXV0aCArIHRoaXMuaG9zdDtcbiAgfSBlbHNlIGlmICh0aGlzLmhvc3RuYW1lKSB7XG4gICAgaG9zdCA9IGF1dGggKyAodGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgPT09IC0xID9cbiAgICAgICAgdGhpcy5ob3N0bmFtZSA6XG4gICAgICAgICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScpO1xuICAgIGlmICh0aGlzLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdGhpcy5wb3J0O1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnF1ZXJ5ICYmXG4gICAgICB1dGlsLmlzT2JqZWN0KHRoaXMucXVlcnkpICYmXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJyc7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICBpZiAodGhpcy5zbGFzaGVzIHx8XG4gICAgICAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2g7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2g7XG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcblxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIGlmICh1dGlsLmlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICB2YXIgdGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgZm9yICh2YXIgdGsgPSAwOyB0ayA8IHRrZXlzLmxlbmd0aDsgdGsrKykge1xuICAgIHZhciB0a2V5ID0gdGtleXNbdGtdO1xuICAgIHJlc3VsdFt0a2V5XSA9IHRoaXNbdGtleV07XG4gIH1cblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIHZhciBya2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICBmb3IgKHZhciByayA9IDA7IHJrIDwgcmtleXMubGVuZ3RoOyByaysrKSB7XG4gICAgICB2YXIgcmtleSA9IHJrZXlzW3JrXTtcbiAgICAgIGlmIChya2V5ICE9PSAncHJvdG9jb2wnKVxuICAgICAgICByZXN1bHRbcmtleV0gPSByZWxhdGl2ZVtya2V5XTtcbiAgICB9XG5cbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJlxuICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XG4gICAgLy8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgIC8vIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5nc1xuICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgIC8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXG4gICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgIGlmICghc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICAgICAgdmFyIGsgPSBrZXlzW3ZdO1xuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXN1bHQucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcbiAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsYXRpdmUucGF0aG5hbWU7XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnO1xuICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0O1xuICAgIHJlc3VsdC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQucGF0aG5hbWUgfHwgcmVzdWx0LnNlYXJjaCkge1xuICAgICAgdmFyIHAgPSByZXN1bHQucGF0aG5hbWUgfHwgJyc7XG4gICAgICB2YXIgcyA9IHJlc3VsdC5zZWFyY2ggfHwgJyc7XG4gICAgICByZXN1bHQucGF0aCA9IHAgKyBzO1xuICAgIH1cbiAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBpc1NvdXJjZUFicyA9IChyZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSxcbiAgICAgIGlzUmVsQWJzID0gKFxuICAgICAgICAgIHJlbGF0aXZlLmhvc3QgfHxcbiAgICAgICAgICByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgKSxcbiAgICAgIG11c3RFbmRBYnMgPSAoaXNSZWxBYnMgfHwgaXNTb3VyY2VBYnMgfHxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lKSksXG4gICAgICByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicyxcbiAgICAgIHNyY1BhdGggPSByZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHBzeWNob3RpYyA9IHJlc3VsdC5wcm90b2NvbCAmJiAhc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF07XG5cbiAgLy8gaWYgdGhlIHVybCBpcyBhIG5vbi1zbGFzaGVkIHVybCwgdGhlbiByZWxhdGl2ZVxuICAvLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXG4gIC8vIHRvIGNyYXdsIHVwIHRvIHRoZSBob3N0bmFtZSwgYXMgd2VsbC4gIFRoaXMgaXMgc3RyYW5nZS5cbiAgLy8gcmVzdWx0LnByb3RvY29sIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IG5vdy5cbiAgLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAnJztcbiAgICByZXN1bHQucG9ydCA9IG51bGw7XG4gICAgaWYgKHJlc3VsdC5ob3N0KSB7XG4gICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHNyY1BhdGhbMF0gPSByZXN1bHQuaG9zdDtcbiAgICAgIGVsc2Ugc3JjUGF0aC51bnNoaWZ0KHJlc3VsdC5ob3N0KTtcbiAgICB9XG4gICAgcmVzdWx0Lmhvc3QgPSAnJztcbiAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgIHJlbGF0aXZlLmhvc3RuYW1lID0gbnVsbDtcbiAgICAgIHJlbGF0aXZlLnBvcnQgPSBudWxsO1xuICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcbiAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09ICcnKSByZWxQYXRoWzBdID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgZWxzZSByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7XG4gICAgICB9XG4gICAgICByZWxhdGl2ZS5ob3N0ID0gbnVsbDtcbiAgICB9XG4gICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09ICcnIHx8IHNyY1BhdGhbMF0gPT09ICcnKTtcbiAgfVxuXG4gIGlmIChpc1JlbEFicykge1xuICAgIC8vIGl0J3MgYWJzb2x1dGUuXG4gICAgcmVzdWx0Lmhvc3QgPSAocmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA6IHJlc3VsdC5ob3N0O1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IChyZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNyY1BhdGggPSByZWxQYXRoO1xuICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICB9IGVsc2UgaWYgKHJlbFBhdGgubGVuZ3RoKSB7XG4gICAgLy8gaXQncyByZWxhdGl2ZVxuICAgIC8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuICAgIGlmICghc3JjUGF0aCkgc3JjUGF0aCA9IFtdO1xuICAgIHNyY1BhdGgucG9wKCk7XG4gICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gIH0gZWxzZSBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0IHx8IHNyY1BhdGgubGVuZ3RoID4gMSkgJiZcbiAgICAgIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgfHwgbGFzdCA9PT0gJycpO1xuXG4gIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmXG4gICAgICAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQXQoMCkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgKHNyY1BhdGguam9pbignLycpLnN1YnN0cigtMSkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnB1c2goJycpO1xuICB9XG5cbiAgdmFyIGlzQWJzb2x1dGUgPSBzcmNQYXRoWzBdID09PSAnJyB8fFxuICAgICAgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJyk7XG5cbiAgLy8gcHV0IHRoZSBob3N0IGJhY2tcbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/ICcnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7XG4gICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB0aGlzLmhvc3RuYW1lID0gaG9zdDtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///22\\n\")},function(module,exports,__webpack_require__){\"use strict\";eval(\"/* WEBPACK VAR INJECTION */(function(__resourceQuery) {\\n\\n/* global __resourceQuery WorkerGlobalScope self */\\n/* eslint prefer-destructuring: off */\\n\\nvar url = __webpack_require__(22);\\nvar stripAnsi = __webpack_require__(15);\\nvar log = __webpack_require__(13).getLogger('webpack-dev-server');\\nvar socket = __webpack_require__(12);\\nvar overlay = __webpack_require__(10);\\n\\nfunction getCurrentScriptSource() {\\n  // `document.currentScript` is the most accurate way to find the current script,\\n  // but is not supported in all browsers.\\n  if (document.currentScript) {\\n    return document.currentScript.getAttribute('src');\\n  }\\n  // Fall back to getting all scripts in the document.\\n  var scriptElements = document.scripts || [];\\n  var currentScript = scriptElements[scriptElements.length - 1];\\n  if (currentScript) {\\n    return currentScript.getAttribute('src');\\n  }\\n  // Fail as there was no script to use.\\n  throw new Error('[WDS] Failed to get current script source.');\\n}\\n\\nvar urlParts = void 0;\\nvar hotReload = true;\\nif (typeof window !== 'undefined') {\\n  var qs = window.location.search.toLowerCase();\\n  hotReload = qs.indexOf('hotreload=false') === -1;\\n}\\nif (true) {\\n  // If this bundle is inlined, use the resource query to get the correct url.\\n  urlParts = url.parse(__resourceQuery.substr(1));\\n} else { var scriptHost; }\\n\\nif (!urlParts.port || urlParts.port === '0') {\\n  urlParts.port = self.location.port;\\n}\\n\\nvar _hot = false;\\nvar initial = true;\\nvar currentHash = '';\\nvar useWarningOverlay = false;\\nvar useErrorOverlay = false;\\nvar useProgress = false;\\n\\nvar INFO = 'info';\\nvar WARNING = 'warning';\\nvar ERROR = 'error';\\nvar NONE = 'none';\\n\\n// Set the default log level\\nlog.setDefaultLevel(INFO);\\n\\n// Send messages to the outside, so plugins can consume it.\\nfunction sendMsg(type, data) {\\n  if (typeof self !== 'undefined' && (typeof WorkerGlobalScope === 'undefined' || !(self instanceof WorkerGlobalScope))) {\\n    self.postMessage({\\n      type: 'webpack' + type,\\n      data: data\\n    }, '*');\\n  }\\n}\\n\\nvar onSocketMsg = {\\n  hot: function hot() {\\n    _hot = true;\\n    log.info('[WDS] Hot Module Replacement enabled.');\\n  },\\n  invalid: function invalid() {\\n    log.info('[WDS] App updated. Recompiling...');\\n    // fixes #1042. overlay doesn't clear if errors are fixed but warnings remain.\\n    if (useWarningOverlay || useErrorOverlay) overlay.clear();\\n    sendMsg('Invalid');\\n  },\\n  hash: function hash(_hash) {\\n    currentHash = _hash;\\n  },\\n\\n  'still-ok': function stillOk() {\\n    log.info('[WDS] Nothing changed.');\\n    if (useWarningOverlay || useErrorOverlay) overlay.clear();\\n    sendMsg('StillOk');\\n  },\\n  'log-level': function logLevel(level) {\\n    var hotCtx = __webpack_require__(5);\\n    if (hotCtx.keys().indexOf('./log') !== -1) {\\n      hotCtx('./log').setLogLevel(level);\\n    }\\n    switch (level) {\\n      case INFO:\\n      case ERROR:\\n        log.setLevel(level);\\n        break;\\n      case WARNING:\\n        // loglevel's warning name is different from webpack's\\n        log.setLevel('warn');\\n        break;\\n      case NONE:\\n        log.disableAll();\\n        break;\\n      default:\\n        log.error('[WDS] Unknown clientLogLevel \\\\'' + level + '\\\\'');\\n    }\\n  },\\n  overlay: function overlay(value) {\\n    if (typeof document !== 'undefined') {\\n      if (typeof value === 'boolean') {\\n        useWarningOverlay = false;\\n        useErrorOverlay = value;\\n      } else if (value) {\\n        useWarningOverlay = value.warnings;\\n        useErrorOverlay = value.errors;\\n      }\\n    }\\n  },\\n  progress: function progress(_progress) {\\n    if (typeof document !== 'undefined') {\\n      useProgress = _progress;\\n    }\\n  },\\n\\n  'progress-update': function progressUpdate(data) {\\n    if (useProgress) log.info('[WDS] ' + data.percent + '% - ' + data.msg + '.');\\n  },\\n  ok: function ok() {\\n    sendMsg('Ok');\\n    if (useWarningOverlay || useErrorOverlay) overlay.clear();\\n    if (initial) return initial = false; // eslint-disable-line no-return-assign\\n    reloadApp();\\n  },\\n\\n  'content-changed': function contentChanged() {\\n    log.info('[WDS] Content base changed. Reloading...');\\n    self.location.reload();\\n  },\\n  warnings: function warnings(_warnings) {\\n    log.warn('[WDS] Warnings while compiling.');\\n    var strippedWarnings = _warnings.map(function (warning) {\\n      return stripAnsi(warning);\\n    });\\n    sendMsg('Warnings', strippedWarnings);\\n    for (var i = 0; i < strippedWarnings.length; i++) {\\n      log.warn(strippedWarnings[i]);\\n    }\\n    if (useWarningOverlay) overlay.showMessage(_warnings);\\n\\n    if (initial) return initial = false; // eslint-disable-line no-return-assign\\n    reloadApp();\\n  },\\n  errors: function errors(_errors) {\\n    log.error('[WDS] Errors while compiling. Reload prevented.');\\n    var strippedErrors = _errors.map(function (error) {\\n      return stripAnsi(error);\\n    });\\n    sendMsg('Errors', strippedErrors);\\n    for (var i = 0; i < strippedErrors.length; i++) {\\n      log.error(strippedErrors[i]);\\n    }\\n    if (useErrorOverlay) overlay.showMessage(_errors);\\n    initial = false;\\n  },\\n  error: function error(_error) {\\n    log.error(_error);\\n  },\\n  close: function close() {\\n    log.error('[WDS] Disconnected!');\\n    sendMsg('Close');\\n  }\\n};\\n\\nvar hostname = urlParts.hostname;\\nvar protocol = urlParts.protocol;\\n\\n// check ipv4 and ipv6 `all hostname`\\nif (hostname === '0.0.0.0' || hostname === '::') {\\n  // why do we need this check?\\n  // hostname n/a for file protocol (example, when using electron, ionic)\\n  // see: https://github.com/webpack/webpack-dev-server/pull/384\\n  // eslint-disable-next-line no-bitwise\\n  if (self.location.hostname && !!~self.location.protocol.indexOf('http')) {\\n    hostname = self.location.hostname;\\n  }\\n}\\n\\n// `hostname` can be empty when the script path is relative. In that case, specifying\\n// a protocol would result in an invalid URL.\\n// When https is used in the app, secure websockets are always necessary\\n// because the browser doesn't accept non-secure websockets.\\nif (hostname && (self.location.protocol === 'https:' || urlParts.hostname === '0.0.0.0')) {\\n  protocol = self.location.protocol;\\n}\\n\\nvar socketUrl = url.format({\\n  protocol: protocol,\\n  auth: urlParts.auth,\\n  hostname: hostname,\\n  port: urlParts.port,\\n  pathname: urlParts.path == null || urlParts.path === '/' ? '/sockjs-node' : urlParts.path\\n});\\n\\nsocket(socketUrl, onSocketMsg);\\n\\nvar isUnloading = false;\\nself.addEventListener('beforeunload', function () {\\n  isUnloading = true;\\n});\\n\\nfunction reloadApp() {\\n  if (isUnloading || !hotReload) {\\n    return;\\n  }\\n  if (_hot) {\\n    log.info('[WDS] App hot update...');\\n    // eslint-disable-next-line global-require\\n    var hotEmitter = __webpack_require__(3);\\n    hotEmitter.emit('webpackHotUpdate', currentHash);\\n    if (typeof self !== 'undefined' && self.window) {\\n      // broadcast update to window\\n      self.postMessage('webpackHotUpdate' + currentHash, '*');\\n    }\\n  } else {\\n    var rootWindow = self;\\n    // use parent window for reload (in case we're in an iframe with no valid src)\\n    var intervalId = self.setInterval(function () {\\n      if (rootWindow.location.protocol !== 'about:') {\\n        // reload immediately if protocol is valid\\n        applyReload(rootWindow, intervalId);\\n      } else {\\n        rootWindow = rootWindow.parent;\\n        if (rootWindow.parent === rootWindow) {\\n          // if parent equals current window we've reached the root which would continue forever, so trigger a reload anyways\\n          applyReload(rootWindow, intervalId);\\n        }\\n      }\\n    });\\n  }\\n\\n  function applyReload(rootWindow, intervalId) {\\n    clearInterval(intervalId);\\n    log.info('[WDS] App updated. Reloading...');\\n    rootWindow.location.reload();\\n  }\\n}\\n/* WEBPACK VAR INJECTION */}.call(this, \\\"?http://172.16.154.8:8081\\\"))//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50PzRjMjMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudD9lNWRkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJ1REFBQTs7QUFFQTtBQUNBOztBQUVBLFVDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsVUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQ0FBLElEQUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxNQ0FBLG1CRE1EOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUJDQUEsc0JEQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG1CQUFtQiw2QkFBNkI7QUFDaEQ7QUFDQTtBQUNBOztBQUVBLHdDQUF3QztBQUN4QztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDIiwiZmlsZSI6IjIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgX19yZXNvdXJjZVF1ZXJ5IFdvcmtlckdsb2JhbFNjb3BlIHNlbGYgKi9cbi8qIGVzbGludCBwcmVmZXItZGVzdHJ1Y3R1cmluZzogb2ZmICovXG5cbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKTtcbnZhciBzdHJpcEFuc2kgPSByZXF1aXJlKCdzdHJpcC1hbnNpJyk7XG52YXIgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKS5nZXRMb2dnZXIoJ3dlYnBhY2stZGV2LXNlcnZlcicpO1xudmFyIHNvY2tldCA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG52YXIgb3ZlcmxheSA9IHJlcXVpcmUoJy4vb3ZlcmxheScpO1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50U2NyaXB0U291cmNlKCkge1xuICAvLyBgZG9jdW1lbnQuY3VycmVudFNjcmlwdGAgaXMgdGhlIG1vc3QgYWNjdXJhdGUgd2F5IHRvIGZpbmQgdGhlIGN1cnJlbnQgc2NyaXB0LFxuICAvLyBidXQgaXMgbm90IHN1cHBvcnRlZCBpbiBhbGwgYnJvd3NlcnMuXG4gIGlmIChkb2N1bWVudC5jdXJyZW50U2NyaXB0KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuZ2V0QXR0cmlidXRlKCdzcmMnKTtcbiAgfVxuICAvLyBGYWxsIGJhY2sgdG8gZ2V0dGluZyBhbGwgc2NyaXB0cyBpbiB0aGUgZG9jdW1lbnQuXG4gIHZhciBzY3JpcHRFbGVtZW50cyA9IGRvY3VtZW50LnNjcmlwdHMgfHwgW107XG4gIHZhciBjdXJyZW50U2NyaXB0ID0gc2NyaXB0RWxlbWVudHNbc2NyaXB0RWxlbWVudHMubGVuZ3RoIC0gMV07XG4gIGlmIChjdXJyZW50U2NyaXB0KSB7XG4gICAgcmV0dXJuIGN1cnJlbnRTY3JpcHQuZ2V0QXR0cmlidXRlKCdzcmMnKTtcbiAgfVxuICAvLyBGYWlsIGFzIHRoZXJlIHdhcyBubyBzY3JpcHQgdG8gdXNlLlxuICB0aHJvdyBuZXcgRXJyb3IoJ1tXRFNdIEZhaWxlZCB0byBnZXQgY3VycmVudCBzY3JpcHQgc291cmNlLicpO1xufVxuXG52YXIgdXJsUGFydHMgPSB2b2lkIDA7XG52YXIgaG90UmVsb2FkID0gdHJ1ZTtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICB2YXIgcXMgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnRvTG93ZXJDYXNlKCk7XG4gIGhvdFJlbG9hZCA9IHFzLmluZGV4T2YoJ2hvdHJlbG9hZD1mYWxzZScpID09PSAtMTtcbn1cbmlmICh0eXBlb2YgX19yZXNvdXJjZVF1ZXJ5ID09PSAnc3RyaW5nJyAmJiBfX3Jlc291cmNlUXVlcnkpIHtcbiAgLy8gSWYgdGhpcyBidW5kbGUgaXMgaW5saW5lZCwgdXNlIHRoZSByZXNvdXJjZSBxdWVyeSB0byBnZXQgdGhlIGNvcnJlY3QgdXJsLlxuICB1cmxQYXJ0cyA9IHVybC5wYXJzZShfX3Jlc291cmNlUXVlcnkuc3Vic3RyKDEpKTtcbn0gZWxzZSB7XG4gIC8vIEVsc2UsIGdldCB0aGUgdXJsIGZyb20gdGhlIDxzY3JpcHQ+IHRoaXMgZmlsZSB3YXMgY2FsbGVkIHdpdGguXG4gIHZhciBzY3JpcHRIb3N0ID0gZ2V0Q3VycmVudFNjcmlwdFNvdXJjZSgpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbiAgc2NyaXB0SG9zdCA9IHNjcmlwdEhvc3QucmVwbGFjZSgvXFwvW15cXC9dKyQvLCAnJyk7XG4gIHVybFBhcnRzID0gdXJsLnBhcnNlKHNjcmlwdEhvc3QgfHwgJy8nLCBmYWxzZSwgdHJ1ZSk7XG59XG5cbmlmICghdXJsUGFydHMucG9ydCB8fCB1cmxQYXJ0cy5wb3J0ID09PSAnMCcpIHtcbiAgdXJsUGFydHMucG9ydCA9IHNlbGYubG9jYXRpb24ucG9ydDtcbn1cblxudmFyIF9ob3QgPSBmYWxzZTtcbnZhciBpbml0aWFsID0gdHJ1ZTtcbnZhciBjdXJyZW50SGFzaCA9ICcnO1xudmFyIHVzZVdhcm5pbmdPdmVybGF5ID0gZmFsc2U7XG52YXIgdXNlRXJyb3JPdmVybGF5ID0gZmFsc2U7XG52YXIgdXNlUHJvZ3Jlc3MgPSBmYWxzZTtcblxudmFyIElORk8gPSAnaW5mbyc7XG52YXIgV0FSTklORyA9ICd3YXJuaW5nJztcbnZhciBFUlJPUiA9ICdlcnJvcic7XG52YXIgTk9ORSA9ICdub25lJztcblxuLy8gU2V0IHRoZSBkZWZhdWx0IGxvZyBsZXZlbFxubG9nLnNldERlZmF1bHRMZXZlbChJTkZPKTtcblxuLy8gU2VuZCBtZXNzYWdlcyB0byB0aGUgb3V0c2lkZSwgc28gcGx1Z2lucyBjYW4gY29uc3VtZSBpdC5cbmZ1bmN0aW9uIHNlbmRNc2codHlwZSwgZGF0YSkge1xuICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmICh0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgPT09ICd1bmRlZmluZWQnIHx8ICEoc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlKSkpIHtcbiAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgIHR5cGU6ICd3ZWJwYWNrJyArIHR5cGUsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSwgJyonKTtcbiAgfVxufVxuXG52YXIgb25Tb2NrZXRNc2cgPSB7XG4gIGhvdDogZnVuY3Rpb24gaG90KCkge1xuICAgIF9ob3QgPSB0cnVlO1xuICAgIGxvZy5pbmZvKCdbV0RTXSBIb3QgTW9kdWxlIFJlcGxhY2VtZW50IGVuYWJsZWQuJyk7XG4gIH0sXG4gIGludmFsaWQ6IGZ1bmN0aW9uIGludmFsaWQoKSB7XG4gICAgbG9nLmluZm8oJ1tXRFNdIEFwcCB1cGRhdGVkLiBSZWNvbXBpbGluZy4uLicpO1xuICAgIC8vIGZpeGVzICMxMDQyLiBvdmVybGF5IGRvZXNuJ3QgY2xlYXIgaWYgZXJyb3JzIGFyZSBmaXhlZCBidXQgd2FybmluZ3MgcmVtYWluLlxuICAgIGlmICh1c2VXYXJuaW5nT3ZlcmxheSB8fCB1c2VFcnJvck92ZXJsYXkpIG92ZXJsYXkuY2xlYXIoKTtcbiAgICBzZW5kTXNnKCdJbnZhbGlkJyk7XG4gIH0sXG4gIGhhc2g6IGZ1bmN0aW9uIGhhc2goX2hhc2gpIHtcbiAgICBjdXJyZW50SGFzaCA9IF9oYXNoO1xuICB9LFxuXG4gICdzdGlsbC1vayc6IGZ1bmN0aW9uIHN0aWxsT2soKSB7XG4gICAgbG9nLmluZm8oJ1tXRFNdIE5vdGhpbmcgY2hhbmdlZC4nKTtcbiAgICBpZiAodXNlV2FybmluZ092ZXJsYXkgfHwgdXNlRXJyb3JPdmVybGF5KSBvdmVybGF5LmNsZWFyKCk7XG4gICAgc2VuZE1zZygnU3RpbGxPaycpO1xuICB9LFxuICAnbG9nLWxldmVsJzogZnVuY3Rpb24gbG9nTGV2ZWwobGV2ZWwpIHtcbiAgICB2YXIgaG90Q3R4ID0gcmVxdWlyZS5jb250ZXh0KCd3ZWJwYWNrL2hvdCcsIGZhbHNlLCAvXlxcLlxcL2xvZyQvKTtcbiAgICBpZiAoaG90Q3R4LmtleXMoKS5pbmRleE9mKCcuL2xvZycpICE9PSAtMSkge1xuICAgICAgaG90Q3R4KCcuL2xvZycpLnNldExvZ0xldmVsKGxldmVsKTtcbiAgICB9XG4gICAgc3dpdGNoIChsZXZlbCkge1xuICAgICAgY2FzZSBJTkZPOlxuICAgICAgY2FzZSBFUlJPUjpcbiAgICAgICAgbG9nLnNldExldmVsKGxldmVsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFdBUk5JTkc6XG4gICAgICAgIC8vIGxvZ2xldmVsJ3Mgd2FybmluZyBuYW1lIGlzIGRpZmZlcmVudCBmcm9tIHdlYnBhY2snc1xuICAgICAgICBsb2cuc2V0TGV2ZWwoJ3dhcm4nKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE5PTkU6XG4gICAgICAgIGxvZy5kaXNhYmxlQWxsKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbG9nLmVycm9yKCdbV0RTXSBVbmtub3duIGNsaWVudExvZ0xldmVsIFxcJycgKyBsZXZlbCArICdcXCcnKTtcbiAgICB9XG4gIH0sXG4gIG92ZXJsYXk6IGZ1bmN0aW9uIG92ZXJsYXkodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHVzZVdhcm5pbmdPdmVybGF5ID0gZmFsc2U7XG4gICAgICAgIHVzZUVycm9yT3ZlcmxheSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICB1c2VXYXJuaW5nT3ZlcmxheSA9IHZhbHVlLndhcm5pbmdzO1xuICAgICAgICB1c2VFcnJvck92ZXJsYXkgPSB2YWx1ZS5lcnJvcnM7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwcm9ncmVzczogZnVuY3Rpb24gcHJvZ3Jlc3MoX3Byb2dyZXNzKSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHVzZVByb2dyZXNzID0gX3Byb2dyZXNzO1xuICAgIH1cbiAgfSxcblxuICAncHJvZ3Jlc3MtdXBkYXRlJzogZnVuY3Rpb24gcHJvZ3Jlc3NVcGRhdGUoZGF0YSkge1xuICAgIGlmICh1c2VQcm9ncmVzcykgbG9nLmluZm8oJ1tXRFNdICcgKyBkYXRhLnBlcmNlbnQgKyAnJSAtICcgKyBkYXRhLm1zZyArICcuJyk7XG4gIH0sXG4gIG9rOiBmdW5jdGlvbiBvaygpIHtcbiAgICBzZW5kTXNnKCdPaycpO1xuICAgIGlmICh1c2VXYXJuaW5nT3ZlcmxheSB8fCB1c2VFcnJvck92ZXJsYXkpIG92ZXJsYXkuY2xlYXIoKTtcbiAgICBpZiAoaW5pdGlhbCkgcmV0dXJuIGluaXRpYWwgPSBmYWxzZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXR1cm4tYXNzaWduXG4gICAgcmVsb2FkQXBwKCk7XG4gIH0sXG5cbiAgJ2NvbnRlbnQtY2hhbmdlZCc6IGZ1bmN0aW9uIGNvbnRlbnRDaGFuZ2VkKCkge1xuICAgIGxvZy5pbmZvKCdbV0RTXSBDb250ZW50IGJhc2UgY2hhbmdlZC4gUmVsb2FkaW5nLi4uJyk7XG4gICAgc2VsZi5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgfSxcbiAgd2FybmluZ3M6IGZ1bmN0aW9uIHdhcm5pbmdzKF93YXJuaW5ncykge1xuICAgIGxvZy53YXJuKCdbV0RTXSBXYXJuaW5ncyB3aGlsZSBjb21waWxpbmcuJyk7XG4gICAgdmFyIHN0cmlwcGVkV2FybmluZ3MgPSBfd2FybmluZ3MubWFwKGZ1bmN0aW9uICh3YXJuaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaXBBbnNpKHdhcm5pbmcpO1xuICAgIH0pO1xuICAgIHNlbmRNc2coJ1dhcm5pbmdzJywgc3RyaXBwZWRXYXJuaW5ncyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpcHBlZFdhcm5pbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsb2cud2FybihzdHJpcHBlZFdhcm5pbmdzW2ldKTtcbiAgICB9XG4gICAgaWYgKHVzZVdhcm5pbmdPdmVybGF5KSBvdmVybGF5LnNob3dNZXNzYWdlKF93YXJuaW5ncyk7XG5cbiAgICBpZiAoaW5pdGlhbCkgcmV0dXJuIGluaXRpYWwgPSBmYWxzZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXR1cm4tYXNzaWduXG4gICAgcmVsb2FkQXBwKCk7XG4gIH0sXG4gIGVycm9yczogZnVuY3Rpb24gZXJyb3JzKF9lcnJvcnMpIHtcbiAgICBsb2cuZXJyb3IoJ1tXRFNdIEVycm9ycyB3aGlsZSBjb21waWxpbmcuIFJlbG9hZCBwcmV2ZW50ZWQuJyk7XG4gICAgdmFyIHN0cmlwcGVkRXJyb3JzID0gX2Vycm9ycy5tYXAoZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICByZXR1cm4gc3RyaXBBbnNpKGVycm9yKTtcbiAgICB9KTtcbiAgICBzZW5kTXNnKCdFcnJvcnMnLCBzdHJpcHBlZEVycm9ycyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpcHBlZEVycm9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgbG9nLmVycm9yKHN0cmlwcGVkRXJyb3JzW2ldKTtcbiAgICB9XG4gICAgaWYgKHVzZUVycm9yT3ZlcmxheSkgb3ZlcmxheS5zaG93TWVzc2FnZShfZXJyb3JzKTtcbiAgICBpbml0aWFsID0gZmFsc2U7XG4gIH0sXG4gIGVycm9yOiBmdW5jdGlvbiBlcnJvcihfZXJyb3IpIHtcbiAgICBsb2cuZXJyb3IoX2Vycm9yKTtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIGxvZy5lcnJvcignW1dEU10gRGlzY29ubmVjdGVkIScpO1xuICAgIHNlbmRNc2coJ0Nsb3NlJyk7XG4gIH1cbn07XG5cbnZhciBob3N0bmFtZSA9IHVybFBhcnRzLmhvc3RuYW1lO1xudmFyIHByb3RvY29sID0gdXJsUGFydHMucHJvdG9jb2w7XG5cbi8vIGNoZWNrIGlwdjQgYW5kIGlwdjYgYGFsbCBob3N0bmFtZWBcbmlmIChob3N0bmFtZSA9PT0gJzAuMC4wLjAnIHx8IGhvc3RuYW1lID09PSAnOjonKSB7XG4gIC8vIHdoeSBkbyB3ZSBuZWVkIHRoaXMgY2hlY2s/XG4gIC8vIGhvc3RuYW1lIG4vYSBmb3IgZmlsZSBwcm90b2NvbCAoZXhhbXBsZSwgd2hlbiB1c2luZyBlbGVjdHJvbiwgaW9uaWMpXG4gIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay1kZXYtc2VydmVyL3B1bGwvMzg0XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gIGlmIChzZWxmLmxvY2F0aW9uLmhvc3RuYW1lICYmICEhfnNlbGYubG9jYXRpb24ucHJvdG9jb2wuaW5kZXhPZignaHR0cCcpKSB7XG4gICAgaG9zdG5hbWUgPSBzZWxmLmxvY2F0aW9uLmhvc3RuYW1lO1xuICB9XG59XG5cbi8vIGBob3N0bmFtZWAgY2FuIGJlIGVtcHR5IHdoZW4gdGhlIHNjcmlwdCBwYXRoIGlzIHJlbGF0aXZlLiBJbiB0aGF0IGNhc2UsIHNwZWNpZnlpbmdcbi8vIGEgcHJvdG9jb2wgd291bGQgcmVzdWx0IGluIGFuIGludmFsaWQgVVJMLlxuLy8gV2hlbiBodHRwcyBpcyB1c2VkIGluIHRoZSBhcHAsIHNlY3VyZSB3ZWJzb2NrZXRzIGFyZSBhbHdheXMgbmVjZXNzYXJ5XG4vLyBiZWNhdXNlIHRoZSBicm93c2VyIGRvZXNuJ3QgYWNjZXB0IG5vbi1zZWN1cmUgd2Vic29ja2V0cy5cbmlmIChob3N0bmFtZSAmJiAoc2VsZi5sb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHBzOicgfHwgdXJsUGFydHMuaG9zdG5hbWUgPT09ICcwLjAuMC4wJykpIHtcbiAgcHJvdG9jb2wgPSBzZWxmLmxvY2F0aW9uLnByb3RvY29sO1xufVxuXG52YXIgc29ja2V0VXJsID0gdXJsLmZvcm1hdCh7XG4gIHByb3RvY29sOiBwcm90b2NvbCxcbiAgYXV0aDogdXJsUGFydHMuYXV0aCxcbiAgaG9zdG5hbWU6IGhvc3RuYW1lLFxuICBwb3J0OiB1cmxQYXJ0cy5wb3J0LFxuICBwYXRobmFtZTogdXJsUGFydHMucGF0aCA9PSBudWxsIHx8IHVybFBhcnRzLnBhdGggPT09ICcvJyA/ICcvc29ja2pzLW5vZGUnIDogdXJsUGFydHMucGF0aFxufSk7XG5cbnNvY2tldChzb2NrZXRVcmwsIG9uU29ja2V0TXNnKTtcblxudmFyIGlzVW5sb2FkaW5nID0gZmFsc2U7XG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgaXNVbmxvYWRpbmcgPSB0cnVlO1xufSk7XG5cbmZ1bmN0aW9uIHJlbG9hZEFwcCgpIHtcbiAgaWYgKGlzVW5sb2FkaW5nIHx8ICFob3RSZWxvYWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKF9ob3QpIHtcbiAgICBsb2cuaW5mbygnW1dEU10gQXBwIGhvdCB1cGRhdGUuLi4nKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2xvYmFsLXJlcXVpcmVcbiAgICB2YXIgaG90RW1pdHRlciA9IHJlcXVpcmUoJ3dlYnBhY2svaG90L2VtaXR0ZXInKTtcbiAgICBob3RFbWl0dGVyLmVtaXQoJ3dlYnBhY2tIb3RVcGRhdGUnLCBjdXJyZW50SGFzaCk7XG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLndpbmRvdykge1xuICAgICAgLy8gYnJvYWRjYXN0IHVwZGF0ZSB0byB3aW5kb3dcbiAgICAgIHNlbGYucG9zdE1lc3NhZ2UoJ3dlYnBhY2tIb3RVcGRhdGUnICsgY3VycmVudEhhc2gsICcqJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciByb290V2luZG93ID0gc2VsZjtcbiAgICAvLyB1c2UgcGFyZW50IHdpbmRvdyBmb3IgcmVsb2FkIChpbiBjYXNlIHdlJ3JlIGluIGFuIGlmcmFtZSB3aXRoIG5vIHZhbGlkIHNyYylcbiAgICB2YXIgaW50ZXJ2YWxJZCA9IHNlbGYuc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHJvb3RXaW5kb3cubG9jYXRpb24ucHJvdG9jb2wgIT09ICdhYm91dDonKSB7XG4gICAgICAgIC8vIHJlbG9hZCBpbW1lZGlhdGVseSBpZiBwcm90b2NvbCBpcyB2YWxpZFxuICAgICAgICBhcHBseVJlbG9hZChyb290V2luZG93LCBpbnRlcnZhbElkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3RXaW5kb3cgPSByb290V2luZG93LnBhcmVudDtcbiAgICAgICAgaWYgKHJvb3RXaW5kb3cucGFyZW50ID09PSByb290V2luZG93KSB7XG4gICAgICAgICAgLy8gaWYgcGFyZW50IGVxdWFscyBjdXJyZW50IHdpbmRvdyB3ZSd2ZSByZWFjaGVkIHRoZSByb290IHdoaWNoIHdvdWxkIGNvbnRpbnVlIGZvcmV2ZXIsIHNvIHRyaWdnZXIgYSByZWxvYWQgYW55d2F5c1xuICAgICAgICAgIGFwcGx5UmVsb2FkKHJvb3RXaW5kb3csIGludGVydmFsSWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseVJlbG9hZChyb290V2luZG93LCBpbnRlcnZhbElkKSB7XG4gICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcbiAgICBsb2cuaW5mbygnW1dEU10gQXBwIHVwZGF0ZWQuIFJlbG9hZGluZy4uLicpO1xuICAgIHJvb3RXaW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gIH1cbn0iLG51bGxdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///23\\n\")},function(module,exports,__webpack_require__){\"use strict\";eval(\"/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;\\n\\nvar _typeof = typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; };\\n\\nconsole.log('START WEEX VUE RENDER: 1.0.26, Build 2018-05-28 14:19.');\\n\\n(function (global, factory) {\\n  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\\n\\t\\t\\t\\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_FACTORY__),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;\\n})(undefined, function () {\\n  'use strict';\\n\\n  function __$styleInject(css, returnValue) {\\n    if (typeof document === 'undefined') {\\n      return returnValue;\\n    }\\n    css = css || '';\\n    var head = document.head || document.getElementsByTagName('head')[0];\\n    var style = document.createElement('style');\\n    style.type = 'text/css';\\n    head.appendChild(style);\\n\\n    if (style.styleSheet) {\\n      style.styleSheet.cssText = css;\\n    } else {\\n      style.appendChild(document.createTextNode(css));\\n    }\\n    return returnValue;\\n  }\\n\\n  __$styleInject(\\\"/*\\\\n * Licensed to the Apache Software Foundation (ASF) under one\\\\n * or more contributor license agreements.  See the NOTICE file\\\\n * distributed with this work for additional information\\\\n * regarding copyright ownership.  The ASF licenses this file\\\\n * to you under the Apache License, Version 2.0 (the\\\\n * \\\\\\\"License\\\\\\\"); you may not use this file except in compliance\\\\n * with the License.  You may obtain a copy of the License at\\\\n *\\\\n *   http://www.apache.org/licenses/LICENSE-2.0\\\\n *\\\\n * Unless required by applicable law or agreed to in writing,\\\\n * software distributed under the License is distributed on an\\\\n * \\\\\\\"AS IS\\\\\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\\\n * KIND, either express or implied.  See the License for the\\\\n * specific language governing permissions and limitations\\\\n * under the License.\\\\n */\\\\n \\\\n.weex-root,\\\\n.weex-root * {\\\\n  color: initial;\\\\n  cursor: initial;\\\\n  direction: initial;\\\\n  /* In chrome, there's a chance that user set the miximum font-size to \\\\n  a abnormal smaller size. But actually the smaller size is never working\\\\n  if this font / font-size default value is set to initial. Perhaps a bug\\\\n  for chrome. */\\\\n  font: initial;\\\\n  font-size: initial;\\\\n  font-family: initial;\\\\n  font-style: initial;\\\\n  font-variant: initial;\\\\n  font-weight: initial;\\\\n  line-height: initial;\\\\n  text-align: initial;\\\\n  text-indent: initial;\\\\n  visibility: initial;\\\\n  white-space: initial;\\\\n  word-spacing: initial;\\\\n  font-family: BlinkMacSystemFont, 'Source Sans Pro', 'Helvetica Neue', Helvetica, Arial, sans-serif;\\\\n}\\\\n\\\\n.weex-root,\\\\n.weex-root *,\\\\n.weex-root *::before,\\\\n.weex-root *::after {\\\\n  -webkit-box-sizing: border-box;\\\\n          box-sizing: border-box;\\\\n  -webkit-text-size-adjust: none;\\\\n     -moz-text-size-adjust: none;\\\\n      -ms-text-size-adjust: none;\\\\n          text-size-adjust: none;\\\\n}\\\\n\\\\n.weex-root a,\\\\n.weex-root button,\\\\n.weex-root [role=\\\\\\\"button\\\\\\\"],\\\\n.weex-root input,\\\\n.weex-root label,\\\\n.weex-root select,\\\\n.weex-root textarea {\\\\n      touch-action: manipulation;\\\\n}\\\\n\\\\n.weex-root p,\\\\n.weex-root ol,\\\\n.weex-root ul,\\\\n.weex-root dl,\\\\n.weex-root figure {\\\\n  margin: 0;\\\\n  padding: 0;\\\\n}\\\\n\\\\n.weex-root li {\\\\n  list-style: none;\\\\n}\\\\n\\\\n.weex-root figure {\\\\n  margin: 0;\\\\n}\\\\n\\\\n.weex-root textarea {\\\\n  resize: none;\\\\n}\\\\n\\\\n/* show no scroll bar. */\\\\n::-webkit-scrollbar {\\\\n  display: none;\\\\n}\\\\n\\\", undefined);\\n\\n  __$styleInject(\\\"/*\\\\n * Licensed to the Apache Software Foundation (ASF) under one\\\\n * or more contributor license agreements.  See the NOTICE file\\\\n * distributed with this work for additional information\\\\n * regarding copyright ownership.  The ASF licenses this file\\\\n * to you under the Apache License, Version 2.0 (the\\\\n * \\\\\\\"License\\\\\\\"); you may not use this file except in compliance\\\\n * with the License.  You may obtain a copy of the License at\\\\n *\\\\n *   http://www.apache.org/licenses/LICENSE-2.0\\\\n *\\\\n * Unless required by applicable law or agreed to in writing,\\\\n * software distributed under the License is distributed on an\\\\n * \\\\\\\"AS IS\\\\\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\\\n * KIND, either express or implied.  See the License for the\\\\n * specific language governing permissions and limitations\\\\n * under the License.\\\\n */\\\\n \\\\n.weex-root * {\\\\n  border-width: 0;\\\\n  border-color: inherit;\\\\n  border-style: solid;\\\\n}\\\\n\\\\ndiv.weex-root {\\\\n  min-height: 100%;\\\\n}\\\\n\\\\n/**\\\\n * slider will overflow in horizontal axis, which will cause container\\\\n * horizontally expanding. below styles will prevent this from happening.\\\\n */\\\\n.weex-root {\\\\n  width: 100%;\\\\n  overflow-x: hidden;\\\\n}\\\\n\\\\n.weex-root figure {\\\\n  background-repeat: no-repeat;\\\\n  background-position: 50% 50%;\\\\n}\\\\n\\\\n.weex-flex-ct {\\\\n  display: -webkit-box;\\\\n  display: -webkit-flex;\\\\n  display: flex;\\\\n}\\\\n\\\\n.weex-ct {\\\\n  -webkit-box-sizing: border-box;\\\\n          box-sizing: border-box;\\\\n  display: -webkit-box;\\\\n  display: -webkit-flex;\\\\n  display: flex;\\\\n  position: relative;\\\\n  -webkit-box-orient: vertical;\\\\n  -webkit-box-direction: normal;\\\\n  -webkit-flex-direction: column;\\\\n          flex-direction: column;\\\\n  -webkit-flex-shrink: 0;\\\\n          flex-shrink: 0;\\\\n  -webkit-box-flex: 0;\\\\n  -webkit-flex-grow: 0;\\\\n          flex-grow: 0;\\\\n  -webkit-flex-basis: auto;\\\\n          flex-basis: auto;\\\\n  -webkit-box-align: stretch;\\\\n  -webkit-align-items: stretch;\\\\n          align-items: stretch;\\\\n  -webkit-align-content: flex-start;\\\\n          align-content: flex-start;\\\\n  border: 0 solid black;\\\\n  margin: 0;\\\\n  padding: 0;\\\\n  min-width: 0;\\\\n}\\\\n\\\\n.weex-ct.horizontal {\\\\n  -webkit-box-orient: horizontal;\\\\n  -webkit-box-direction: normal;\\\\n  -webkit-flex-direction: row;\\\\n          flex-direction: row;\\\\n}\\\\n\\\\n.weex-el {\\\\n  display: block;\\\\n  -webkit-box-sizing: border-box;\\\\n          box-sizing: border-box;\\\\n  position: relative;\\\\n  -webkit-flex-shrink: 0;\\\\n          flex-shrink: 0;\\\\n  -webkit-box-flex: 0;\\\\n  -webkit-flex-grow: 0;\\\\n          flex-grow: 0;\\\\n  -webkit-flex-basis: auto;\\\\n          flex-basis: auto;\\\\n  border: 0 solid black;\\\\n  margin: 0;\\\\n  padding: 0;\\\\n  min-width: 0;\\\\n}\\\\n\\\\n.weex-text {\\\\n  display: -webkit-box;\\\\n  display: -moz-box;\\\\n  -webkit-box-orient: vertical;\\\\n  position: relative;\\\\n  white-space: pre-wrap;  /* not using 'pre': support auto line feed. */\\\\n  font-size: 0.4266666666666667rem;\\\\n  word-wrap: break-word;\\\\n  overflow: hidden; /* it'll be clipped if the height is not high enough. */\\\\n}\\\\n\\\\n.weex-image {\\\\n  background-repeat: no-repeat;\\\\n  background-position: 50% 50%;\\\\n  background-size: 100% 100%;\\\\n}\\\\n\\\\n.weex-a {\\\\n  text-decoration: none;\\\\n}\\\\n\\\\n.weex-ios-sticky {\\\\n  position: -webkit-sticky !important;\\\\n  position: sticky !important;\\\\n  z-index: 9999;\\\\n  top: 0;\\\\n}\\\\n\\\\n.weex-fixed {\\\\n  position: fixed;\\\\n  z-index: 1;\\\\n}\\\\n\\\\n.weex-sticky {\\\\n  position: fixed;\\\\n  top: 0;\\\\n  z-index: 9999;\\\\n}\\\\n\\\", undefined);\\n\\n  // 7.1.4 ToInteger\\n  var ceil = Math.ceil;\\n  var floor = Math.floor;\\n  var _toInteger = function _toInteger(it) {\\n    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\\n  };\\n\\n  // 7.2.1 RequireObjectCoercible(argument)\\n  var _defined = function _defined(it) {\\n    if (it == undefined) {\\n      throw TypeError(\\\"Can't call method on  \\\" + it);\\n    }\\n    return it;\\n  };\\n\\n  // true  -> String#at\\n  // false -> String#codePointAt\\n  var _stringAt = function _stringAt(TO_STRING) {\\n    return function (that, pos) {\\n      var s = String(_defined(that));\\n      var i = _toInteger(pos);\\n      var l = s.length;\\n      var a, b;\\n      if (i < 0 || i >= l) {\\n        return TO_STRING ? '' : undefined;\\n      }\\n      a = s.charCodeAt(i);\\n      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\\n    };\\n  };\\n\\n  var _library = false;\\n\\n  function createCommonjsModule(fn, module) {\\n    return module = { exports: {} }, fn(module, module.exports), module.exports;\\n  }\\n\\n  var _global = createCommonjsModule(function (module) {\\n    // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\\n    var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self\\n    // eslint-disable-next-line no-new-func\\n    : Function('return this')();\\n    if (typeof __g == 'number') {\\n      __g = global;\\n    } // eslint-disable-line no-undef\\n  });\\n\\n  var _core = createCommonjsModule(function (module) {\\n    var core = module.exports = { version: '2.5.2' };\\n    if (typeof __e == 'number') {\\n      __e = core;\\n    } // eslint-disable-line no-undef\\n  });\\n\\n  var _core_1 = _core.version;\\n\\n  var _isObject = function _isObject(it) {\\n    return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) === 'object' ? it !== null : typeof it === 'function';\\n  };\\n\\n  var _anObject = function _anObject(it) {\\n    if (!_isObject(it)) {\\n      throw TypeError(it + ' is not an object!');\\n    }\\n    return it;\\n  };\\n\\n  var _fails = function _fails(exec) {\\n    try {\\n      return !!exec();\\n    } catch (e) {\\n      return true;\\n    }\\n  };\\n\\n  // Thank's IE8 for his funny defineProperty\\n  var _descriptors = !_fails(function () {\\n    return Object.defineProperty({}, 'a', { get: function get() {\\n        return 7;\\n      } }).a != 7;\\n  });\\n\\n  var document$1 = _global.document;\\n  // typeof document.createElement is 'object' in old IE\\n  var is = _isObject(document$1) && _isObject(document$1.createElement);\\n  var _domCreate = function _domCreate(it) {\\n    return is ? document$1.createElement(it) : {};\\n  };\\n\\n  var _ie8DomDefine = !_descriptors && !_fails(function () {\\n    return Object.defineProperty(_domCreate('div'), 'a', { get: function get() {\\n        return 7;\\n      } }).a != 7;\\n  });\\n\\n  // 7.1.1 ToPrimitive(input [, PreferredType])\\n\\n  // instead of the ES6 spec version, we didn't implement @@toPrimitive case\\n  // and the second argument - flag - preferred type is a string\\n  var _toPrimitive = function _toPrimitive(it, S) {\\n    if (!_isObject(it)) {\\n      return it;\\n    }\\n    var fn, val;\\n    if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) {\\n      return val;\\n    }\\n    if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) {\\n      return val;\\n    }\\n    if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) {\\n      return val;\\n    }\\n    throw TypeError(\\\"Can't convert object to primitive value\\\");\\n  };\\n\\n  var dP = Object.defineProperty;\\n\\n  var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {\\n    _anObject(O);\\n    P = _toPrimitive(P, true);\\n    _anObject(Attributes);\\n    if (_ie8DomDefine) {\\n      try {\\n        return dP(O, P, Attributes);\\n      } catch (e) {/* empty */}\\n    }\\n    if ('get' in Attributes || 'set' in Attributes) {\\n      throw TypeError('Accessors not supported!');\\n    }\\n    if ('value' in Attributes) {\\n      O[P] = Attributes.value;\\n    }\\n    return O;\\n  };\\n\\n  var _objectDp = {\\n    f: f\\n  };\\n\\n  var _propertyDesc = function _propertyDesc(bitmap, value) {\\n    return {\\n      enumerable: !(bitmap & 1),\\n      configurable: !(bitmap & 2),\\n      writable: !(bitmap & 4),\\n      value: value\\n    };\\n  };\\n\\n  var _hide = _descriptors ? function (object, key, value) {\\n    return _objectDp.f(object, key, _propertyDesc(1, value));\\n  } : function (object, key, value) {\\n    object[key] = value;\\n    return object;\\n  };\\n\\n  var hasOwnProperty = {}.hasOwnProperty;\\n  var _has = function _has(it, key) {\\n    return hasOwnProperty.call(it, key);\\n  };\\n\\n  var id = 0;\\n  var px = Math.random();\\n  var _uid = function _uid(key) {\\n    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\\n  };\\n\\n  var _redefine = createCommonjsModule(function (module) {\\n    var SRC = _uid('src');\\n    var TO_STRING = 'toString';\\n    var $toString = Function[TO_STRING];\\n    var TPL = ('' + $toString).split(TO_STRING);\\n\\n    _core.inspectSource = function (it) {\\n      return $toString.call(it);\\n    };\\n\\n    (module.exports = function (O, key, val, safe) {\\n      var isFunction = typeof val == 'function';\\n      if (isFunction) {\\n        _has(val, 'name') || _hide(val, 'name', key);\\n      }\\n      if (O[key] === val) {\\n        return;\\n      }\\n      if (isFunction) {\\n        _has(val, SRC) || _hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));\\n      }\\n      if (O === _global) {\\n        O[key] = val;\\n      } else if (!safe) {\\n        delete O[key];\\n        _hide(O, key, val);\\n      } else if (O[key]) {\\n        O[key] = val;\\n      } else {\\n        _hide(O, key, val);\\n      }\\n      // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\\n    })(Function.prototype, TO_STRING, function toString() {\\n      return typeof this == 'function' && this[SRC] || $toString.call(this);\\n    });\\n  });\\n\\n  var _aFunction = function _aFunction(it) {\\n    if (typeof it != 'function') {\\n      throw TypeError(it + ' is not a function!');\\n    }\\n    return it;\\n  };\\n\\n  // optional / simple context binding\\n\\n  var _ctx = function _ctx(fn, that, length) {\\n    _aFunction(fn);\\n    if (that === undefined) {\\n      return fn;\\n    }\\n    switch (length) {\\n      case 1:\\n        return function (a) {\\n          return fn.call(that, a);\\n        };\\n      case 2:\\n        return function (a, b) {\\n          return fn.call(that, a, b);\\n        };\\n      case 3:\\n        return function (a, b, c) {\\n          return fn.call(that, a, b, c);\\n        };\\n    }\\n    return function () /* ...args */{\\n      return fn.apply(that, arguments);\\n    };\\n  };\\n\\n  var PROTOTYPE = 'prototype';\\n\\n  var $export = function $export(type, name, source) {\\n    var IS_FORCED = type & $export.F;\\n    var IS_GLOBAL = type & $export.G;\\n    var IS_STATIC = type & $export.S;\\n    var IS_PROTO = type & $export.P;\\n    var IS_BIND = type & $export.B;\\n    var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE];\\n    var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});\\n    var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});\\n    var key, own, out, exp;\\n    if (IS_GLOBAL) {\\n      source = name;\\n    }\\n    for (key in source) {\\n      // contains in native\\n      own = !IS_FORCED && target && target[key] !== undefined;\\n      // export native or passed\\n      out = (own ? target : source)[key];\\n      // bind timers to global for call from export context\\n      exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;\\n      // extend global\\n      if (target) {\\n        _redefine(target, key, out, type & $export.U);\\n      }\\n      // export\\n      if (exports[key] != out) {\\n        _hide(exports, key, exp);\\n      }\\n      if (IS_PROTO && expProto[key] != out) {\\n        expProto[key] = out;\\n      }\\n    }\\n  };\\n  _global.core = _core;\\n  // type bitmap\\n  $export.F = 1; // forced\\n  $export.G = 2; // global\\n  $export.S = 4; // static\\n  $export.P = 8; // proto\\n  $export.B = 16; // bind\\n  $export.W = 32; // wrap\\n  $export.U = 64; // safe\\n  $export.R = 128; // real proto method for `library`\\n  var _export = $export;\\n\\n  var _iterators = {};\\n\\n  var toString = {}.toString;\\n\\n  var _cof = function _cof(it) {\\n    return toString.call(it).slice(8, -1);\\n  };\\n\\n  // fallback for non-array-like ES3 and non-enumerable old V8 strings\\n\\n  // eslint-disable-next-line no-prototype-builtins\\n  var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\\n    return _cof(it) == 'String' ? it.split('') : Object(it);\\n  };\\n\\n  // to indexed object, toObject with fallback for non-array-like ES3 strings\\n\\n\\n  var _toIobject = function _toIobject(it) {\\n    return _iobject(_defined(it));\\n  };\\n\\n  // 7.1.15 ToLength\\n\\n  var min = Math.min;\\n  var _toLength = function _toLength(it) {\\n    return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\\n  };\\n\\n  var max = Math.max;\\n  var min$1 = Math.min;\\n  var _toAbsoluteIndex = function _toAbsoluteIndex(index, length) {\\n    index = _toInteger(index);\\n    return index < 0 ? max(index + length, 0) : min$1(index, length);\\n  };\\n\\n  // false -> Array#indexOf\\n  // true  -> Array#includes\\n\\n\\n  var _arrayIncludes = function _arrayIncludes(IS_INCLUDES) {\\n    return function ($this, el, fromIndex) {\\n      var O = _toIobject($this);\\n      var length = _toLength(O.length);\\n      var index = _toAbsoluteIndex(fromIndex, length);\\n      var value;\\n      // Array#includes uses SameValueZero equality algorithm\\n      // eslint-disable-next-line no-self-compare\\n      if (IS_INCLUDES && el != el) {\\n        while (length > index) {\\n          value = O[index++];\\n          // eslint-disable-next-line no-self-compare\\n          if (value != value) {\\n            return true;\\n          }\\n          // Array#indexOf ignores holes, Array#includes - not\\n        }\\n      } else {\\n        for (; length > index; index++) {\\n          if (IS_INCLUDES || index in O) {\\n            if (O[index] === el) {\\n              return IS_INCLUDES || index || 0;\\n            }\\n          }\\n        }\\n      }return !IS_INCLUDES && -1;\\n    };\\n  };\\n\\n  var SHARED = '__core-js_shared__';\\n  var store = _global[SHARED] || (_global[SHARED] = {});\\n  var _shared = function _shared(key) {\\n    return store[key] || (store[key] = {});\\n  };\\n\\n  var shared = _shared('keys');\\n\\n  var _sharedKey = function _sharedKey(key) {\\n    return shared[key] || (shared[key] = _uid(key));\\n  };\\n\\n  var arrayIndexOf = _arrayIncludes(false);\\n  var IE_PROTO$1 = _sharedKey('IE_PROTO');\\n\\n  var _objectKeysInternal = function _objectKeysInternal(object, names) {\\n    var O = _toIobject(object);\\n    var i = 0;\\n    var result = [];\\n    var key;\\n    for (key in O) {\\n      if (key != IE_PROTO$1) {\\n        _has(O, key) && result.push(key);\\n      }\\n    }\\n    // Don't enum bug & hidden keys\\n    while (names.length > i) {\\n      if (_has(O, key = names[i++])) {\\n        ~arrayIndexOf(result, key) || result.push(key);\\n      }\\n    }\\n    return result;\\n  };\\n\\n  // IE 8- don't enum bug keys\\n  var _enumBugKeys = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');\\n\\n  // 19.1.2.14 / 15.2.3.14 Object.keys(O)\\n\\n\\n  var _objectKeys = Object.keys || function keys(O) {\\n    return _objectKeysInternal(O, _enumBugKeys);\\n  };\\n\\n  var _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties) {\\n    _anObject(O);\\n    var keys = _objectKeys(Properties);\\n    var length = keys.length;\\n    var i = 0;\\n    var P;\\n    while (length > i) {\\n      _objectDp.f(O, P = keys[i++], Properties[P]);\\n    }\\n    return O;\\n  };\\n\\n  var document$2 = _global.document;\\n  var _html = document$2 && document$2.documentElement;\\n\\n  // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\\n\\n\\n  var IE_PROTO = _sharedKey('IE_PROTO');\\n  var Empty = function Empty() {/* empty */};\\n  var PROTOTYPE$1 = 'prototype';\\n\\n  // Create object with fake `null` prototype: use iframe Object with cleared prototype\\n  var _createDict = function createDict() {\\n    // Thrash, waste and sodomy: IE GC bug\\n    var iframe = _domCreate('iframe');\\n    var i = _enumBugKeys.length;\\n    var lt = '<';\\n    var gt = '>';\\n    var iframeDocument;\\n    iframe.style.display = 'none';\\n    _html.appendChild(iframe);\\n    iframe.src = 'javascript:'; // eslint-disable-line no-script-url\\n    // createDict = iframe.contentWindow.Object;\\n    // html.removeChild(iframe);\\n    iframeDocument = iframe.contentWindow.document;\\n    iframeDocument.open();\\n    iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\\n    iframeDocument.close();\\n    _createDict = iframeDocument.F;\\n    while (i--) {\\n      delete _createDict[PROTOTYPE$1][_enumBugKeys[i]];\\n    }\\n    return _createDict();\\n  };\\n\\n  var _objectCreate = Object.create || function create(O, Properties) {\\n    var result;\\n    if (O !== null) {\\n      Empty[PROTOTYPE$1] = _anObject(O);\\n      result = new Empty();\\n      Empty[PROTOTYPE$1] = null;\\n      // add \\\"__proto__\\\" for Object.getPrototypeOf polyfill\\n      result[IE_PROTO] = O;\\n    } else {\\n      result = _createDict();\\n    }\\n    return Properties === undefined ? result : _objectDps(result, Properties);\\n  };\\n\\n  var _wks = createCommonjsModule(function (module) {\\n    var store = _shared('wks');\\n\\n    var _Symbol = _global.Symbol;\\n    var USE_SYMBOL = typeof _Symbol == 'function';\\n\\n    var $exports = module.exports = function (name) {\\n      return store[name] || (store[name] = USE_SYMBOL && _Symbol[name] || (USE_SYMBOL ? _Symbol : _uid)('Symbol.' + name));\\n    };\\n\\n    $exports.store = store;\\n  });\\n\\n  var def = _objectDp.f;\\n\\n  var TAG = _wks('toStringTag');\\n\\n  var _setToStringTag = function _setToStringTag(it, tag, stat) {\\n    if (it && !_has(it = stat ? it : it.prototype, TAG)) {\\n      def(it, TAG, { configurable: true, value: tag });\\n    }\\n  };\\n\\n  var IteratorPrototype = {};\\n\\n  // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\\n  _hide(IteratorPrototype, _wks('iterator'), function () {\\n    return this;\\n  });\\n\\n  var _iterCreate = function _iterCreate(Constructor, NAME, next) {\\n    Constructor.prototype = _objectCreate(IteratorPrototype, { next: _propertyDesc(1, next) });\\n    _setToStringTag(Constructor, NAME + ' Iterator');\\n  };\\n\\n  // 7.1.13 ToObject(argument)\\n\\n  var _toObject = function _toObject(it) {\\n    return Object(_defined(it));\\n  };\\n\\n  // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\\n\\n\\n  var IE_PROTO$2 = _sharedKey('IE_PROTO');\\n  var ObjectProto = Object.prototype;\\n\\n  var _objectGpo = Object.getPrototypeOf || function (O) {\\n    O = _toObject(O);\\n    if (_has(O, IE_PROTO$2)) {\\n      return O[IE_PROTO$2];\\n    }\\n    if (typeof O.constructor == 'function' && O instanceof O.constructor) {\\n      return O.constructor.prototype;\\n    }return O instanceof Object ? ObjectProto : null;\\n  };\\n\\n  var ITERATOR = _wks('iterator');\\n  var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`\\n  var FF_ITERATOR = '@@iterator';\\n  var KEYS = 'keys';\\n  var VALUES = 'values';\\n\\n  var returnThis = function returnThis() {\\n    return this;\\n  };\\n\\n  var _iterDefine = function _iterDefine(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {\\n    _iterCreate(Constructor, NAME, next);\\n    var getMethod = function getMethod(kind) {\\n      if (!BUGGY && kind in proto) {\\n        return proto[kind];\\n      }\\n      switch (kind) {\\n        case KEYS:\\n          return function keys() {\\n            return new Constructor(this, kind);\\n          };\\n        case VALUES:\\n          return function values() {\\n            return new Constructor(this, kind);\\n          };\\n      }return function entries() {\\n        return new Constructor(this, kind);\\n      };\\n    };\\n    var TAG = NAME + ' Iterator';\\n    var DEF_VALUES = DEFAULT == VALUES;\\n    var VALUES_BUG = false;\\n    var proto = Base.prototype;\\n    var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];\\n    var $default = $native || getMethod(DEFAULT);\\n    var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;\\n    var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;\\n    var methods, key, IteratorPrototype;\\n    // Fix native\\n    if ($anyNative) {\\n      IteratorPrototype = _objectGpo($anyNative.call(new Base()));\\n      if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {\\n        // Set @@toStringTag to native iterators\\n        _setToStringTag(IteratorPrototype, TAG, true);\\n        // fix for some old engines\\n        if (!_library && !_has(IteratorPrototype, ITERATOR)) {\\n          _hide(IteratorPrototype, ITERATOR, returnThis);\\n        }\\n      }\\n    }\\n    // fix Array#{values, @@iterator}.name in V8 / FF\\n    if (DEF_VALUES && $native && $native.name !== VALUES) {\\n      VALUES_BUG = true;\\n      $default = function values() {\\n        return $native.call(this);\\n      };\\n    }\\n    // Define iterator\\n    if ((!_library || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {\\n      _hide(proto, ITERATOR, $default);\\n    }\\n    // Plug for library\\n    _iterators[NAME] = $default;\\n    _iterators[TAG] = returnThis;\\n    if (DEFAULT) {\\n      methods = {\\n        values: DEF_VALUES ? $default : getMethod(VALUES),\\n        keys: IS_SET ? $default : getMethod(KEYS),\\n        entries: $entries\\n      };\\n      if (FORCED) {\\n        for (key in methods) {\\n          if (!(key in proto)) {\\n            _redefine(proto, key, methods[key]);\\n          }\\n        }\\n      } else {\\n        _export(_export.P + _export.F * (BUGGY || VALUES_BUG), NAME, methods);\\n      }\\n    }\\n    return methods;\\n  };\\n\\n  var $at = _stringAt(true);\\n\\n  // 21.1.3.27 String.prototype[@@iterator]()\\n  _iterDefine(String, 'String', function (iterated) {\\n    this._t = String(iterated); // target\\n    this._i = 0; // next index\\n    // 21.1.5.2.1 %StringIteratorPrototype%.next()\\n  }, function () {\\n    var O = this._t;\\n    var index = this._i;\\n    var point;\\n    if (index >= O.length) {\\n      return { value: undefined, done: true };\\n    }\\n    point = $at(O, index);\\n    this._i += point.length;\\n    return { value: point, done: false };\\n  });\\n\\n  // call something on iterator step with safe closing on error\\n\\n  var _iterCall = function _iterCall(iterator, fn, value, entries) {\\n    try {\\n      return entries ? fn(_anObject(value)[0], value[1]) : fn(value);\\n      // 7.4.6 IteratorClose(iterator, completion)\\n    } catch (e) {\\n      var ret = iterator['return'];\\n      if (ret !== undefined) {\\n        _anObject(ret.call(iterator));\\n      }\\n      throw e;\\n    }\\n  };\\n\\n  // check on default Array iterator\\n\\n  var ITERATOR$1 = _wks('iterator');\\n  var ArrayProto = Array.prototype;\\n\\n  var _isArrayIter = function _isArrayIter(it) {\\n    return it !== undefined && (_iterators.Array === it || ArrayProto[ITERATOR$1] === it);\\n  };\\n\\n  var _createProperty = function _createProperty(object, index, value) {\\n    if (index in object) {\\n      _objectDp.f(object, index, _propertyDesc(0, value));\\n    } else {\\n      object[index] = value;\\n    }\\n  };\\n\\n  // getting tag from 19.1.3.6 Object.prototype.toString()\\n\\n  var TAG$1 = _wks('toStringTag');\\n  // ES3 wrong here\\n  var ARG = _cof(function () {\\n    return arguments;\\n  }()) == 'Arguments';\\n\\n  // fallback for IE11 Script Access Denied error\\n  var tryGet = function tryGet(it, key) {\\n    try {\\n      return it[key];\\n    } catch (e) {/* empty */}\\n  };\\n\\n  var _classof = function _classof(it) {\\n    var O, T, B;\\n    return it === undefined ? 'Undefined' : it === null ? 'Null'\\n    // @@toStringTag case\\n    : typeof (T = tryGet(O = Object(it), TAG$1)) == 'string' ? T\\n    // builtinTag case\\n    : ARG ? _cof(O)\\n    // ES3 arguments fallback\\n    : (B = _cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\\n  };\\n\\n  var ITERATOR$2 = _wks('iterator');\\n\\n  var core_getIteratorMethod = _core.getIteratorMethod = function (it) {\\n    if (it != undefined) {\\n      return it[ITERATOR$2] || it['@@iterator'] || _iterators[_classof(it)];\\n    }\\n  };\\n\\n  var ITERATOR$3 = _wks('iterator');\\n  var SAFE_CLOSING = false;\\n\\n  try {\\n    var riter = [7][ITERATOR$3]();\\n    riter['return'] = function () {\\n      SAFE_CLOSING = true;\\n    };\\n    // eslint-disable-next-line no-throw-literal\\n  } catch (e) {/* empty */}\\n\\n  var _iterDetect = function _iterDetect(exec, skipClosing) {\\n    if (!skipClosing && !SAFE_CLOSING) {\\n      return false;\\n    }\\n    var safe = false;\\n    try {\\n      var arr = [7];\\n      var iter = arr[ITERATOR$3]();\\n      iter.next = function () {\\n        return { done: safe = true };\\n      };\\n      arr[ITERATOR$3] = function () {\\n        return iter;\\n      };\\n      exec(arr);\\n    } catch (e) {/* empty */}\\n    return safe;\\n  };\\n\\n  _export(_export.S + _export.F * !_iterDetect(function (iter) {}), 'Array', {\\n    // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)\\n    from: function from(arrayLike /*  mapfn = undefined, thisArg = undefined */) {\\n      var O = _toObject(arrayLike);\\n      var C = typeof this == 'function' ? this : Array;\\n      var aLen = arguments.length;\\n      var mapfn = aLen > 1 ? arguments[1] : undefined;\\n      var mapping = mapfn !== undefined;\\n      var index = 0;\\n      var iterFn = core_getIteratorMethod(O);\\n      var length, result, step, iterator;\\n      if (mapping) {\\n        mapfn = _ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);\\n      }\\n      // if object isn't iterable or it's array with default iterator - use simple case\\n      if (iterFn != undefined && !(C == Array && _isArrayIter(iterFn))) {\\n        for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {\\n          _createProperty(result, index, mapping ? _iterCall(iterator, mapfn, [step.value, index], true) : step.value);\\n        }\\n      } else {\\n        length = _toLength(O.length);\\n        for (result = new C(length); length > index; index++) {\\n          _createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);\\n        }\\n      }\\n      result.length = index;\\n      return result;\\n    }\\n  });\\n\\n  var from = _core.Array.from;\\n\\n  var f$1 = Object.getOwnPropertySymbols;\\n\\n  var _objectGops = {\\n    f: f$1\\n  };\\n\\n  var f$2 = {}.propertyIsEnumerable;\\n\\n  var _objectPie = {\\n    f: f$2\\n  };\\n\\n  // 19.1.2.1 Object.assign(target, source, ...)\\n\\n\\n  var $assign = Object.assign;\\n\\n  // should work with symbols and should have deterministic property order (V8 bug)\\n  var _objectAssign = !$assign || _fails(function () {\\n    var A = {};\\n    var B = {};\\n    // eslint-disable-next-line no-undef\\n    var S = Symbol();\\n    var K = 'abcdefghijklmnopqrst';\\n    A[S] = 7;\\n    K.split('').forEach(function (k) {\\n      B[k] = k;\\n    });\\n    return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;\\n  }) ? function assign(target, source) {\\n    var arguments$1 = arguments;\\n    // eslint-disable-line no-unused-vars\\n    var T = _toObject(target);\\n    var aLen = arguments.length;\\n    var index = 1;\\n    var getSymbols = _objectGops.f;\\n    var isEnum = _objectPie.f;\\n    while (aLen > index) {\\n      var S = _iobject(arguments$1[index++]);\\n      var keys = getSymbols ? _objectKeys(S).concat(getSymbols(S)) : _objectKeys(S);\\n      var length = keys.length;\\n      var j = 0;\\n      var key;\\n      while (length > j) {\\n        if (isEnum.call(S, key = keys[j++])) {\\n          T[key] = S[key];\\n        }\\n      }\\n    }return T;\\n  } : $assign;\\n\\n  // 19.1.3.1 Object.assign(target, source)\\n\\n\\n  _export(_export.S + _export.F, 'Object', { assign: _objectAssign });\\n\\n  var assign = _core.Object.assign;\\n\\n  var gOPD = Object.getOwnPropertyDescriptor;\\n\\n  var f$3 = _descriptors ? gOPD : function getOwnPropertyDescriptor(O, P) {\\n    O = _toIobject(O);\\n    P = _toPrimitive(P, true);\\n    if (_ie8DomDefine) {\\n      try {\\n        return gOPD(O, P);\\n      } catch (e) {/* empty */}\\n    }\\n    if (_has(O, P)) {\\n      return _propertyDesc(!_objectPie.f.call(O, P), O[P]);\\n    }\\n  };\\n\\n  var _objectGopd = {\\n    f: f$3\\n  };\\n\\n  // Works with __proto__ only. Old v8 can't work with null proto objects.\\n  /* eslint-disable no-proto */\\n\\n  var check = function check(O, proto) {\\n    _anObject(O);\\n    if (!_isObject(proto) && proto !== null) {\\n      throw TypeError(proto + \\\": can't set as prototype!\\\");\\n    }\\n  };\\n  var _setProto = {\\n    set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line\\n    function (test, buggy, set) {\\n      try {\\n        set = _ctx(Function.call, _objectGopd.f(Object.prototype, '__proto__').set, 2);\\n        set(test, []);\\n        buggy = !(test instanceof Array);\\n      } catch (e) {\\n        buggy = true;\\n      }\\n      return function setPrototypeOf(O, proto) {\\n        check(O, proto);\\n        if (buggy) {\\n          O.__proto__ = proto;\\n        } else {\\n          set(O, proto);\\n        }\\n        return O;\\n      };\\n    }({}, false) : undefined),\\n    check: check\\n  };\\n\\n  // 19.1.3.19 Object.setPrototypeOf(O, proto)\\n\\n  _export(_export.S, 'Object', { setPrototypeOf: _setProto.set });\\n\\n  var setPrototypeOf = _core.Object.setPrototypeOf;\\n\\n  // 19.1.3.6 Object.prototype.toString()\\n\\n  var test = {};\\n  test[_wks('toStringTag')] = 'z';\\n  if (test + '' != '[object z]') {\\n    _redefine(Object.prototype, 'toString', function toString() {\\n      return '[object ' + _classof(this) + ']';\\n    }, true);\\n  }\\n\\n  // 22.1.3.31 Array.prototype[@@unscopables]\\n  var UNSCOPABLES = _wks('unscopables');\\n  var ArrayProto$1 = Array.prototype;\\n  if (ArrayProto$1[UNSCOPABLES] == undefined) {\\n    _hide(ArrayProto$1, UNSCOPABLES, {});\\n  }\\n  var _addToUnscopables = function _addToUnscopables(key) {\\n    ArrayProto$1[UNSCOPABLES][key] = true;\\n  };\\n\\n  var _iterStep = function _iterStep(done, value) {\\n    return { value: value, done: !!done };\\n  };\\n\\n  // 22.1.3.4 Array.prototype.entries()\\n  // 22.1.3.13 Array.prototype.keys()\\n  // 22.1.3.29 Array.prototype.values()\\n  // 22.1.3.30 Array.prototype[@@iterator]()\\n  var es6_array_iterator = _iterDefine(Array, 'Array', function (iterated, kind) {\\n    this._t = _toIobject(iterated); // target\\n    this._i = 0; // next index\\n    this._k = kind; // kind\\n    // 22.1.5.2.1 %ArrayIteratorPrototype%.next()\\n  }, function () {\\n    var O = this._t;\\n    var kind = this._k;\\n    var index = this._i++;\\n    if (!O || index >= O.length) {\\n      this._t = undefined;\\n      return _iterStep(1);\\n    }\\n    if (kind == 'keys') {\\n      return _iterStep(0, index);\\n    }\\n    if (kind == 'values') {\\n      return _iterStep(0, O[index]);\\n    }\\n    return _iterStep(0, [index, O[index]]);\\n  }, 'values');\\n\\n  // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\\n  _iterators.Arguments = _iterators.Array;\\n\\n  _addToUnscopables('keys');\\n  _addToUnscopables('values');\\n  _addToUnscopables('entries');\\n\\n  var ITERATOR$4 = _wks('iterator');\\n  var TO_STRING_TAG = _wks('toStringTag');\\n  var ArrayValues = _iterators.Array;\\n\\n  var DOMIterables = {\\n    CSSRuleList: true, // TODO: Not spec compliant, should be false.\\n    CSSStyleDeclaration: false,\\n    CSSValueList: false,\\n    ClientRectList: false,\\n    DOMRectList: false,\\n    DOMStringList: false,\\n    DOMTokenList: true,\\n    DataTransferItemList: false,\\n    FileList: false,\\n    HTMLAllCollection: false,\\n    HTMLCollection: false,\\n    HTMLFormElement: false,\\n    HTMLSelectElement: false,\\n    MediaList: true, // TODO: Not spec compliant, should be false.\\n    MimeTypeArray: false,\\n    NamedNodeMap: false,\\n    NodeList: true,\\n    PaintRequestList: false,\\n    Plugin: false,\\n    PluginArray: false,\\n    SVGLengthList: false,\\n    SVGNumberList: false,\\n    SVGPathSegList: false,\\n    SVGPointList: false,\\n    SVGStringList: false,\\n    SVGTransformList: false,\\n    SourceBufferList: false,\\n    StyleSheetList: true, // TODO: Not spec compliant, should be false.\\n    TextTrackCueList: false,\\n    TextTrackList: false,\\n    TouchList: false\\n  };\\n\\n  for (var collections = _objectKeys(DOMIterables), i = 0; i < collections.length; i++) {\\n    var NAME = collections[i];\\n    var explicit = DOMIterables[NAME];\\n    var Collection = _global[NAME];\\n    var proto = Collection && Collection.prototype;\\n    var key;\\n    if (proto) {\\n      if (!proto[ITERATOR$4]) {\\n        _hide(proto, ITERATOR$4, ArrayValues);\\n      }\\n      if (!proto[TO_STRING_TAG]) {\\n        _hide(proto, TO_STRING_TAG, NAME);\\n      }\\n      _iterators[NAME] = ArrayValues;\\n      if (explicit) {\\n        for (key in es6_array_iterator) {\\n          if (!proto[key]) {\\n            _redefine(proto, key, es6_array_iterator[key], true);\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  var _anInstance = function _anInstance(it, Constructor, name, forbiddenField) {\\n    if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {\\n      throw TypeError(name + ': incorrect invocation!');\\n    }return it;\\n  };\\n\\n  var _forOf = createCommonjsModule(function (module) {\\n    var BREAK = {};\\n    var RETURN = {};\\n    var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {\\n      var iterFn = ITERATOR ? function () {\\n        return iterable;\\n      } : core_getIteratorMethod(iterable);\\n      var f = _ctx(fn, that, entries ? 2 : 1);\\n      var index = 0;\\n      var length, step, iterator, result;\\n      if (typeof iterFn != 'function') {\\n        throw TypeError(iterable + ' is not iterable!');\\n      }\\n      // fast case for arrays with default iterator\\n      if (_isArrayIter(iterFn)) {\\n        for (length = _toLength(iterable.length); length > index; index++) {\\n          result = entries ? f(_anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);\\n          if (result === BREAK || result === RETURN) {\\n            return result;\\n          }\\n        }\\n      } else {\\n        for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {\\n          result = _iterCall(iterator, f, step.value, entries);\\n          if (result === BREAK || result === RETURN) {\\n            return result;\\n          }\\n        }\\n      }\\n    };\\n    exports.BREAK = BREAK;\\n    exports.RETURN = RETURN;\\n  });\\n\\n  // 7.3.20 SpeciesConstructor(O, defaultConstructor)\\n\\n\\n  var SPECIES = _wks('species');\\n  var _speciesConstructor = function _speciesConstructor(O, D) {\\n    var C = _anObject(O).constructor;\\n    var S;\\n    return C === undefined || (S = _anObject(C)[SPECIES]) == undefined ? D : _aFunction(S);\\n  };\\n\\n  // fast apply, http://jsperf.lnkit.com/fast-apply/5\\n  var _invoke = function _invoke(fn, args, that) {\\n    var un = that === undefined;\\n    switch (args.length) {\\n      case 0:\\n        return un ? fn() : fn.call(that);\\n      case 1:\\n        return un ? fn(args[0]) : fn.call(that, args[0]);\\n      case 2:\\n        return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);\\n      case 3:\\n        return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);\\n      case 4:\\n        return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);\\n    }return fn.apply(that, args);\\n  };\\n\\n  var process$1 = _global.process;\\n  var setTask = _global.setImmediate;\\n  var clearTask = _global.clearImmediate;\\n  var MessageChannel = _global.MessageChannel;\\n  var Dispatch = _global.Dispatch;\\n  var counter = 0;\\n  var queue = {};\\n  var ONREADYSTATECHANGE = 'onreadystatechange';\\n  var defer;\\n  var channel;\\n  var port;\\n  var run = function run() {\\n    var id = +this;\\n    // eslint-disable-next-line no-prototype-builtins\\n    if (queue.hasOwnProperty(id)) {\\n      var fn = queue[id];\\n      delete queue[id];\\n      fn();\\n    }\\n  };\\n  var listener = function listener(event) {\\n    run.call(event.data);\\n  };\\n  // Node.js 0.9+ & IE10+ has setImmediate, otherwise:\\n  if (!setTask || !clearTask) {\\n    setTask = function setImmediate(fn) {\\n      var arguments$1 = arguments;\\n\\n      var args = [];\\n      var i = 1;\\n      while (arguments.length > i) {\\n        args.push(arguments$1[i++]);\\n      }\\n      queue[++counter] = function () {\\n        // eslint-disable-next-line no-new-func\\n        _invoke(typeof fn == 'function' ? fn : Function(fn), args);\\n      };\\n      defer(counter);\\n      return counter;\\n    };\\n    clearTask = function clearImmediate(id) {\\n      delete queue[id];\\n    };\\n    // Node.js 0.8-\\n    if (_cof(process$1) == 'process') {\\n      defer = function defer(id) {\\n        process$1.nextTick(_ctx(run, id, 1));\\n      };\\n      // Sphere (JS game engine) Dispatch API\\n    } else if (Dispatch && Dispatch.now) {\\n      defer = function defer(id) {\\n        Dispatch.now(_ctx(run, id, 1));\\n      };\\n      // Browsers with MessageChannel, includes WebWorkers\\n    } else if (MessageChannel) {\\n      channel = new MessageChannel();\\n      port = channel.port2;\\n      channel.port1.onmessage = listener;\\n      defer = _ctx(port.postMessage, port, 1);\\n      // Browsers with postMessage, skip WebWorkers\\n      // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\\n    } else if (_global.addEventListener && typeof postMessage == 'function' && !_global.importScripts) {\\n      defer = function defer(id) {\\n        _global.postMessage(id + '', '*');\\n      };\\n      _global.addEventListener('message', listener, false);\\n      // IE8-\\n    } else if (ONREADYSTATECHANGE in _domCreate('script')) {\\n      defer = function defer(id) {\\n        _html.appendChild(_domCreate('script'))[ONREADYSTATECHANGE] = function () {\\n          _html.removeChild(this);\\n          run.call(id);\\n        };\\n      };\\n      // Rest old browsers\\n    } else {\\n      defer = function defer(id) {\\n        setTimeout(_ctx(run, id, 1), 0);\\n      };\\n    }\\n  }\\n  var _task = {\\n    set: setTask,\\n    clear: clearTask\\n  };\\n\\n  var macrotask = _task.set;\\n  var Observer = _global.MutationObserver || _global.WebKitMutationObserver;\\n  var process$2 = _global.process;\\n  var Promise = _global.Promise;\\n  var isNode$1 = _cof(process$2) == 'process';\\n\\n  var _microtask = function _microtask() {\\n    var head, last, notify;\\n\\n    var flush = function flush() {\\n      var parent, fn;\\n      if (isNode$1 && (parent = process$2.domain)) {\\n        parent.exit();\\n      }\\n      while (head) {\\n        fn = head.fn;\\n        head = head.next;\\n        try {\\n          fn();\\n        } catch (e) {\\n          if (head) {\\n            notify();\\n          } else {\\n            last = undefined;\\n          }\\n          throw e;\\n        }\\n      }last = undefined;\\n      if (parent) {\\n        parent.enter();\\n      }\\n    };\\n\\n    // Node.js\\n    if (isNode$1) {\\n      notify = function notify() {\\n        process$2.nextTick(flush);\\n      };\\n      // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339\\n    } else if (Observer && !(_global.navigator && _global.navigator.standalone)) {\\n      var toggle = true;\\n      var node = document.createTextNode('');\\n      new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new\\n      notify = function notify() {\\n        node.data = toggle = !toggle;\\n      };\\n      // environments with maybe non-completely correct, but existent Promise\\n    } else if (Promise && Promise.resolve) {\\n      var promise = Promise.resolve();\\n      notify = function notify() {\\n        promise.then(flush);\\n      };\\n      // for other environments - macrotask based on:\\n      // - setImmediate\\n      // - MessageChannel\\n      // - window.postMessag\\n      // - onreadystatechange\\n      // - setTimeout\\n    } else {\\n      notify = function notify() {\\n        // strange IE + webpack dev server bug - use .call(global)\\n        macrotask.call(_global, flush);\\n      };\\n    }\\n\\n    return function (fn) {\\n      var task = { fn: fn, next: undefined };\\n      if (last) {\\n        last.next = task;\\n      }\\n      if (!head) {\\n        head = task;\\n        notify();\\n      }last = task;\\n    };\\n  };\\n\\n  // 25.4.1.5 NewPromiseCapability(C)\\n\\n\\n  function PromiseCapability(C) {\\n    var resolve, reject;\\n    this.promise = new C(function ($$resolve, $$reject) {\\n      if (resolve !== undefined || reject !== undefined) {\\n        throw TypeError('Bad Promise constructor');\\n      }\\n      resolve = $$resolve;\\n      reject = $$reject;\\n    });\\n    this.resolve = _aFunction(resolve);\\n    this.reject = _aFunction(reject);\\n  }\\n\\n  var f$4 = function f$4(C) {\\n    return new PromiseCapability(C);\\n  };\\n\\n  var _newPromiseCapability = {\\n    f: f$4\\n  };\\n\\n  var _perform = function _perform(exec) {\\n    try {\\n      return { e: false, v: exec() };\\n    } catch (e) {\\n      return { e: true, v: e };\\n    }\\n  };\\n\\n  var _promiseResolve = function _promiseResolve(C, x) {\\n    _anObject(C);\\n    if (_isObject(x) && x.constructor === C) {\\n      return x;\\n    }\\n    var promiseCapability = _newPromiseCapability.f(C);\\n    var resolve = promiseCapability.resolve;\\n    resolve(x);\\n    return promiseCapability.promise;\\n  };\\n\\n  var _redefineAll = function _redefineAll(target, src, safe) {\\n    for (var key in src) {\\n      _redefine(target, key, src[key], safe);\\n    }\\n    return target;\\n  };\\n\\n  var SPECIES$1 = _wks('species');\\n\\n  var _setSpecies = function _setSpecies(KEY) {\\n    var C = _global[KEY];\\n    if (_descriptors && C && !C[SPECIES$1]) {\\n      _objectDp.f(C, SPECIES$1, {\\n        configurable: true,\\n        get: function get() {\\n          return this;\\n        }\\n      });\\n    }\\n  };\\n\\n  var task = _task.set;\\n  var microtask = _microtask();\\n\\n  var PROMISE = 'Promise';\\n  var TypeError$1 = _global.TypeError;\\n  var process = _global.process;\\n  var $Promise = _global[PROMISE];\\n  var isNode = _classof(process) == 'process';\\n  var empty = function empty() {/* empty */};\\n  var Internal;\\n  var newGenericPromiseCapability;\\n  var OwnPromiseCapability;\\n  var Wrapper;\\n  var newPromiseCapability = newGenericPromiseCapability = _newPromiseCapability.f;\\n\\n  var USE_NATIVE = !!function () {\\n    try {\\n      // correct subclassing with @@species support\\n      var promise = $Promise.resolve(1);\\n      var FakePromise = (promise.constructor = {})[_wks('species')] = function (exec) {\\n        exec(empty, empty);\\n      };\\n      // unhandled rejections tracking support, NodeJS Promise without it fails @@species test\\n      return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;\\n    } catch (e) {/* empty */}\\n  }();\\n\\n  // helpers\\n  var isThenable = function isThenable(it) {\\n    var then;\\n    return _isObject(it) && typeof (then = it.then) == 'function' ? then : false;\\n  };\\n  var notify = function notify(promise, isReject) {\\n    if (promise._n) {\\n      return;\\n    }\\n    promise._n = true;\\n    var chain = promise._c;\\n    microtask(function () {\\n      var value = promise._v;\\n      var ok = promise._s == 1;\\n      var i = 0;\\n      var run = function run(reaction) {\\n        var handler = ok ? reaction.ok : reaction.fail;\\n        var resolve = reaction.resolve;\\n        var reject = reaction.reject;\\n        var domain = reaction.domain;\\n        var result, then;\\n        try {\\n          if (handler) {\\n            if (!ok) {\\n              if (promise._h == 2) {\\n                onHandleUnhandled(promise);\\n              }\\n              promise._h = 1;\\n            }\\n            if (handler === true) {\\n              result = value;\\n            } else {\\n              if (domain) {\\n                domain.enter();\\n              }\\n              result = handler(value);\\n              if (domain) {\\n                domain.exit();\\n              }\\n            }\\n            if (result === reaction.promise) {\\n              reject(TypeError$1('Promise-chain cycle'));\\n            } else if (then = isThenable(result)) {\\n              then.call(result, resolve, reject);\\n            } else {\\n              resolve(result);\\n            }\\n          } else {\\n            reject(value);\\n          }\\n        } catch (e) {\\n          reject(e);\\n        }\\n      };\\n      while (chain.length > i) {\\n        run(chain[i++]);\\n      } // variable length - can't use forEach\\n      promise._c = [];\\n      promise._n = false;\\n      if (isReject && !promise._h) {\\n        onUnhandled(promise);\\n      }\\n    });\\n  };\\n  var onUnhandled = function onUnhandled(promise) {\\n    task.call(_global, function () {\\n      var value = promise._v;\\n      var unhandled = isUnhandled(promise);\\n      var result, handler, console;\\n      if (unhandled) {\\n        result = _perform(function () {\\n          if (isNode) {\\n            process.emit('unhandledRejection', value, promise);\\n          } else if (handler = _global.onunhandledrejection) {\\n            handler({ promise: promise, reason: value });\\n          } else if ((console = _global.console) && console.error) {\\n            console.error('Unhandled promise rejection', value);\\n          }\\n        });\\n        // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\\n        promise._h = isNode || isUnhandled(promise) ? 2 : 1;\\n      }promise._a = undefined;\\n      if (unhandled && result.e) {\\n        throw result.v;\\n      }\\n    });\\n  };\\n  var isUnhandled = function isUnhandled(promise) {\\n    if (promise._h == 1) {\\n      return false;\\n    }\\n    var chain = promise._a || promise._c;\\n    var i = 0;\\n    var reaction;\\n    while (chain.length > i) {\\n      reaction = chain[i++];\\n      if (reaction.fail || !isUnhandled(reaction.promise)) {\\n        return false;\\n      }\\n    }return true;\\n  };\\n  var onHandleUnhandled = function onHandleUnhandled(promise) {\\n    task.call(_global, function () {\\n      var handler;\\n      if (isNode) {\\n        process.emit('rejectionHandled', promise);\\n      } else if (handler = _global.onrejectionhandled) {\\n        handler({ promise: promise, reason: promise._v });\\n      }\\n    });\\n  };\\n  var $reject = function $reject(value) {\\n    var promise = this;\\n    if (promise._d) {\\n      return;\\n    }\\n    promise._d = true;\\n    promise = promise._w || promise; // unwrap\\n    promise._v = value;\\n    promise._s = 2;\\n    if (!promise._a) {\\n      promise._a = promise._c.slice();\\n    }\\n    notify(promise, true);\\n  };\\n  var $resolve = function $resolve(value) {\\n    var promise = this;\\n    var then;\\n    if (promise._d) {\\n      return;\\n    }\\n    promise._d = true;\\n    promise = promise._w || promise; // unwrap\\n    try {\\n      if (promise === value) {\\n        throw TypeError$1(\\\"Promise can't be resolved itself\\\");\\n      }\\n      if (then = isThenable(value)) {\\n        microtask(function () {\\n          var wrapper = { _w: promise, _d: false }; // wrap\\n          try {\\n            then.call(value, _ctx($resolve, wrapper, 1), _ctx($reject, wrapper, 1));\\n          } catch (e) {\\n            $reject.call(wrapper, e);\\n          }\\n        });\\n      } else {\\n        promise._v = value;\\n        promise._s = 1;\\n        notify(promise, false);\\n      }\\n    } catch (e) {\\n      $reject.call({ _w: promise, _d: false }, e); // wrap\\n    }\\n  };\\n\\n  // constructor polyfill\\n  if (!USE_NATIVE) {\\n    // 25.4.3.1 Promise(executor)\\n    $Promise = function Promise(executor) {\\n      _anInstance(this, $Promise, PROMISE, '_h');\\n      _aFunction(executor);\\n      Internal.call(this);\\n      try {\\n        executor(_ctx($resolve, this, 1), _ctx($reject, this, 1));\\n      } catch (err) {\\n        $reject.call(this, err);\\n      }\\n    };\\n    // eslint-disable-next-line no-unused-vars\\n    Internal = function Promise(executor) {\\n      this._c = []; // <- awaiting reactions\\n      this._a = undefined; // <- checked in isUnhandled reactions\\n      this._s = 0; // <- state\\n      this._d = false; // <- done\\n      this._v = undefined; // <- value\\n      this._h = 0; // <- rejection state, 0 - default, 1 - handled, 2 - unhandled\\n      this._n = false; // <- notify\\n    };\\n    Internal.prototype = _redefineAll($Promise.prototype, {\\n      // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)\\n      then: function then(onFulfilled, onRejected) {\\n        var reaction = newPromiseCapability(_speciesConstructor(this, $Promise));\\n        reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;\\n        reaction.fail = typeof onRejected == 'function' && onRejected;\\n        reaction.domain = isNode ? process.domain : undefined;\\n        this._c.push(reaction);\\n        if (this._a) {\\n          this._a.push(reaction);\\n        }\\n        if (this._s) {\\n          notify(this, false);\\n        }\\n        return reaction.promise;\\n      },\\n      // 25.4.5.1 Promise.prototype.catch(onRejected)\\n      'catch': function _catch(onRejected) {\\n        return this.then(undefined, onRejected);\\n      }\\n    });\\n    OwnPromiseCapability = function OwnPromiseCapability() {\\n      var promise = new Internal();\\n      this.promise = promise;\\n      this.resolve = _ctx($resolve, promise, 1);\\n      this.reject = _ctx($reject, promise, 1);\\n    };\\n    _newPromiseCapability.f = newPromiseCapability = function newPromiseCapability(C) {\\n      return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);\\n    };\\n  }\\n\\n  _export(_export.G + _export.W + _export.F * !USE_NATIVE, { Promise: $Promise });\\n  _setToStringTag($Promise, PROMISE);\\n  _setSpecies(PROMISE);\\n  Wrapper = _core[PROMISE];\\n\\n  // statics\\n  _export(_export.S + _export.F * !USE_NATIVE, PROMISE, {\\n    // 25.4.4.5 Promise.reject(r)\\n    reject: function reject(r) {\\n      var capability = newPromiseCapability(this);\\n      var $$reject = capability.reject;\\n      $$reject(r);\\n      return capability.promise;\\n    }\\n  });\\n  _export(_export.S + _export.F * (_library || !USE_NATIVE), PROMISE, {\\n    // 25.4.4.6 Promise.resolve(x)\\n    resolve: function resolve(x) {\\n      return _promiseResolve(_library && this === Wrapper ? $Promise : this, x);\\n    }\\n  });\\n  _export(_export.S + _export.F * !(USE_NATIVE && _iterDetect(function (iter) {\\n    $Promise.all(iter)['catch'](empty);\\n  })), PROMISE, {\\n    // 25.4.4.1 Promise.all(iterable)\\n    all: function all(iterable) {\\n      var C = this;\\n      var capability = newPromiseCapability(C);\\n      var resolve = capability.resolve;\\n      var reject = capability.reject;\\n      var result = _perform(function () {\\n        var values = [];\\n        var index = 0;\\n        var remaining = 1;\\n        _forOf(iterable, false, function (promise) {\\n          var $index = index++;\\n          var alreadyCalled = false;\\n          values.push(undefined);\\n          remaining++;\\n          C.resolve(promise).then(function (value) {\\n            if (alreadyCalled) {\\n              return;\\n            }\\n            alreadyCalled = true;\\n            values[$index] = value;\\n            --remaining || resolve(values);\\n          }, reject);\\n        });\\n        --remaining || resolve(values);\\n      });\\n      if (result.e) {\\n        reject(result.v);\\n      }\\n      return capability.promise;\\n    },\\n    // 25.4.4.4 Promise.race(iterable)\\n    race: function race(iterable) {\\n      var C = this;\\n      var capability = newPromiseCapability(C);\\n      var reject = capability.reject;\\n      var result = _perform(function () {\\n        _forOf(iterable, false, function (promise) {\\n          C.resolve(promise).then(capability.resolve, reject);\\n        });\\n      });\\n      if (result.e) {\\n        reject(result.v);\\n      }\\n      return capability.promise;\\n    }\\n  });\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  /* eslint-disable */\\n\\n  var isInitialized = false;\\n\\n  // major events supported:\\n  //   panstart\\n  //   panmove\\n  //   panend\\n  //   swipe\\n  //   longpress\\n  // extra events supported:\\n  //   dualtouchstart\\n  //   dualtouch\\n  //   dualtouchend\\n  //   tap\\n  //   doubletap\\n  //   pressend\\n\\n  var doc = window.document;\\n  var docEl = doc.documentElement;\\n  var slice = Array.prototype.slice;\\n  var gestures = {};\\n  var lastTap = null;\\n\\n  /**\\n   * find the closest common ancestor\\n   * if there's no one, return null\\n   *\\n   * @param  {Element} el1 first element\\n   * @param  {Element} el2 second element\\n   * @return {Element}     common ancestor\\n   */\\n  function getCommonAncestor(el1, el2) {\\n    var el = el1;\\n    while (el) {\\n      if (el.contains(el2) || el == el2) {\\n        return el;\\n      }\\n      el = el.parentNode;\\n    }\\n    return null;\\n  }\\n\\n  /**\\n   * fire a HTMLEvent\\n   *\\n   * @param  {Element} element which element to fire a event on\\n   * @param  {string}  type    type of event\\n   * @param  {object}  extra   extra data for the event object\\n   */\\n  function fireEvent(element, type, extra) {\\n    var event = doc.createEvent('HTMLEvents');\\n    event.initEvent(type, true, true);\\n\\n    if ((typeof extra === 'undefined' ? 'undefined' : _typeof(extra)) === 'object') {\\n      for (var p in extra) {\\n        event[p] = extra[p];\\n      }\\n    }\\n\\n    /**\\n     * A flag to distinguish with other events with the same name generated\\n     * by another library in the same page.\\n     */\\n    event._for = 'weex';\\n\\n    element.dispatchEvent(event);\\n  }\\n\\n  /**\\n   * calc the transform\\n   * assume 4 points ABCD on the coordinate system\\n   * > rotateangle rotating from AB to CD\\n   * > scalescale ratio from AB to CD\\n   * > translatetranslate shift from A to C\\n   *\\n   * @param  {number} x1 abscissa of A\\n   * @param  {number} y1 ordinate of A\\n   * @param  {number} x2 abscissa of B\\n   * @param  {number} y2 ordinate of B\\n   * @param  {number} x3 abscissa of C\\n   * @param  {number} y3 ordinate of C\\n   * @param  {number} x4 abscissa of D\\n   * @param  {number} y4 ordinate of D\\n   * @return {object}    transform object like\\n   *   {rotate, scale, translate[2], matrix[3][3]}\\n   */\\n  function calc(x1, y1, x2, y2, x3, y3, x4, y4) {\\n    var rotate = Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y2 - y1, x2 - x1);\\n    var scale = Math.sqrt((Math.pow(y4 - y3, 2) + Math.pow(x4 - x3, 2)) / (Math.pow(y2 - y1, 2) + Math.pow(x2 - x1, 2)));\\n    var translate = [x3 - scale * x1 * Math.cos(rotate) + scale * y1 * Math.sin(rotate), y3 - scale * y1 * Math.cos(rotate) - scale * x1 * Math.sin(rotate)];\\n\\n    return {\\n      rotate: rotate,\\n      scale: scale,\\n      translate: translate,\\n      matrix: [[scale * Math.cos(rotate), -scale * Math.sin(rotate), translate[0]], [scale * Math.sin(rotate), scale * Math.cos(rotate), translate[1]], [0, 0, 1]]\\n    };\\n  }\\n\\n  /**\\n   * take over the touchstart events. Add new touches to the gestures.\\n   * If there is no previous records, then bind touchmove, tochend\\n   * and touchcancel events.\\n   * new touches initialized with state 'tapping', and within 500 milliseconds\\n   * if the state is still tapping, then trigger gesture 'press'.\\n   * If there are two touche points, then the 'dualtouchstart' is triggerd. The\\n   * node of the touch gesture is their cloest common ancestor.\\n   *\\n   * @event\\n   * @param  {event} event\\n   */\\n  function touchstartHandler(event) {\\n\\n    if (Object.keys(gestures).length === 0) {\\n      docEl.addEventListener('touchmove', touchmoveHandler, true);\\n      docEl.addEventListener('touchend', touchendHandler, true);\\n      docEl.addEventListener('touchcancel', touchcancelHandler, true);\\n    }\\n\\n    // record every touch\\n    for (var i = 0; i < event.changedTouches.length; i++) {\\n      var touch = event.changedTouches[i];\\n      var touchRecord = {};\\n\\n      for (var p in touch) {\\n        touchRecord[p] = touch[p];\\n      }\\n\\n      var gesture = {\\n        startTouch: touchRecord,\\n        startTime: Date.now(),\\n        status: 'tapping',\\n        element: event.srcElement || event.target,\\n        pressingHandler: setTimeout(function (element, touch) {\\n          return function () {\\n            if (gesture.status === 'tapping') {\\n              gesture.status = 'pressing';\\n\\n              fireEvent(element, 'longpress', {\\n                // add touch data for weex\\n                touch: touch,\\n                touches: event.touches,\\n                changedTouches: event.changedTouches,\\n                touchEvent: event\\n              });\\n            }\\n\\n            clearTimeout(gesture.pressingHandler);\\n            gesture.pressingHandler = null;\\n          };\\n        }(event.srcElement || event.target, event.changedTouches[i]), 500)\\n      };\\n      gestures[touch.identifier] = gesture;\\n    }\\n\\n    if (Object.keys(gestures).length == 2) {\\n      var elements = [];\\n\\n      for (var p in gestures) {\\n        elements.push(gestures[p].element);\\n      }\\n\\n      fireEvent(getCommonAncestor(elements[0], elements[1]), 'dualtouchstart', {\\n        touches: slice.call(event.touches),\\n        touchEvent: event\\n      });\\n    }\\n  }\\n\\n  /**\\n   * take over touchmove events, and handle pan and dual related gestures.\\n   *\\n   * 1. traverse every touch point\\n   * > if 'tapping' and the shift is over 10 pixles, then it's a 'panning'.\\n   * 2. if there are two touch points, then calc the tranform and trigger\\n   *   'dualtouch'.\\n   *\\n   * @event\\n   * @param  {event} event\\n   */\\n  function touchmoveHandler(event) {\\n    for (var i = 0; i < event.changedTouches.length; i++) {\\n      var touch = event.changedTouches[i];\\n      var gesture = gestures[touch.identifier];\\n\\n      if (!gesture) {\\n        return;\\n      }\\n\\n      if (!gesture.lastTouch) {\\n        gesture.lastTouch = gesture.startTouch;\\n      }\\n      if (!gesture.lastTime) {\\n        gesture.lastTime = gesture.startTime;\\n      }\\n      if (!gesture.velocityX) {\\n        gesture.velocityX = 0;\\n      }\\n      if (!gesture.velocityY) {\\n        gesture.velocityY = 0;\\n      }\\n      if (!gesture.duration) {\\n        gesture.duration = 0;\\n      }\\n\\n      var time = Date.now() - gesture.lastTime;\\n      var vx = (touch.clientX - gesture.lastTouch.clientX) / time;\\n      var vy = (touch.clientY - gesture.lastTouch.clientY) / time;\\n\\n      var RECORD_DURATION = 70;\\n      if (time > RECORD_DURATION) {\\n        time = RECORD_DURATION;\\n      }\\n      if (gesture.duration + time > RECORD_DURATION) {\\n        gesture.duration = RECORD_DURATION - time;\\n      }\\n\\n      gesture.velocityX = (gesture.velocityX * gesture.duration + vx * time) / (gesture.duration + time);\\n      gesture.velocityY = (gesture.velocityY * gesture.duration + vy * time) / (gesture.duration + time);\\n      gesture.duration += time;\\n\\n      gesture.lastTouch = {};\\n\\n      for (var p in touch) {\\n        gesture.lastTouch[p] = touch[p];\\n      }\\n      gesture.lastTime = Date.now();\\n\\n      var displacementX = touch.clientX - gesture.startTouch.clientX;\\n      var displacementY = touch.clientY - gesture.startTouch.clientY;\\n      var distance = Math.sqrt(Math.pow(displacementX, 2) + Math.pow(displacementY, 2));\\n      var isVertical = !(Math.abs(displacementX) > Math.abs(displacementY));\\n      var direction = isVertical ? displacementY >= 0 ? 'down' : 'up' : displacementX >= 0 ? 'right' : 'left';\\n\\n      // magic number 10: moving 10px means pan, not tap\\n      if ((gesture.status === 'tapping' || gesture.status === 'pressing') && distance > 10) {\\n        gesture.status = 'panning';\\n        gesture.isVertical = isVertical;\\n        gesture.direction = direction;\\n\\n        fireEvent(gesture.element, 'panstart', {\\n          touch: touch,\\n          touches: event.touches,\\n          changedTouches: event.changedTouches,\\n          touchEvent: event,\\n          isVertical: gesture.isVertical,\\n          direction: direction\\n        });\\n      }\\n\\n      if (gesture.status === 'panning') {\\n        gesture.panTime = Date.now();\\n\\n        fireEvent(gesture.element, 'panmove', {\\n          displacementX: displacementX,\\n          displacementY: displacementY,\\n          touch: touch,\\n          touches: event.touches,\\n          changedTouches: event.changedTouches,\\n          touchEvent: event,\\n          isVertical: gesture.isVertical,\\n          direction: direction\\n        });\\n      }\\n    }\\n\\n    if (Object.keys(gestures).length == 2) {\\n      var position = [];\\n      var current = [];\\n      var elements = [];\\n      var transform;\\n\\n      for (var i = 0; i < event.touches.length; i++) {\\n        var touch = event.touches[i];\\n        var gesture = gestures[touch.identifier];\\n        position.push([gesture.startTouch.clientX, gesture.startTouch.clientY]);\\n        current.push([touch.clientX, touch.clientY]);\\n      }\\n\\n      for (var p in gestures) {\\n        elements.push(gestures[p].element);\\n      }\\n\\n      transform = calc(position[0][0], position[0][1], position[1][0], position[1][1], current[0][0], current[0][1], current[1][0], current[1][1]);\\n      fireEvent(getCommonAncestor(elements[0], elements[1]), 'dualtouch', {\\n        transform: transform,\\n        touches: event.touches,\\n        touchEvent: event\\n      });\\n    }\\n  }\\n\\n  /**\\n   * handle touchend event\\n   *\\n   * 1. if there are tow touch points, then trigger 'dualtouchend'\\n   *\\n   * 2. traverse every touch piont\\n   * > if tapping, then trigger 'tap'.\\n   * If there is a tap 300 milliseconds before, then it's a 'doubletap'.\\n   * > if padding, then decide to trigger 'panend' or 'swipe'\\n   * > if pressing, then trigger 'pressend'.\\n   *\\n   * 3. remove listeners.\\n   *\\n   * @event\\n   * @param  {event} event\\n   */\\n  function touchendHandler(event) {\\n\\n    if (Object.keys(gestures).length == 2) {\\n      var elements = [];\\n      for (var p in gestures) {\\n        elements.push(gestures[p].element);\\n      }\\n      fireEvent(getCommonAncestor(elements[0], elements[1]), 'dualtouchend', {\\n        touches: slice.call(event.touches),\\n        touchEvent: event\\n      });\\n    }\\n\\n    for (var i = 0; i < event.changedTouches.length; i++) {\\n      var touch = event.changedTouches[i];\\n      var id = touch.identifier;\\n      var gesture = gestures[id];\\n\\n      if (!gesture) {\\n        continue;\\n      }\\n\\n      if (gesture.pressingHandler) {\\n        clearTimeout(gesture.pressingHandler);\\n        gesture.pressingHandler = null;\\n      }\\n\\n      if (gesture.status === 'tapping') {\\n        gesture.timestamp = Date.now();\\n        // fire click, not tap.\\n        fireEvent(gesture.element, 'weex$tap', {\\n          touch: touch,\\n          touchEvent: event\\n        });\\n\\n        if (lastTap && gesture.timestamp - lastTap.timestamp < 300) {\\n          fireEvent(gesture.element, 'doubletap', {\\n            touch: touch,\\n            touchEvent: event\\n          });\\n        }\\n\\n        lastTap = gesture;\\n      }\\n\\n      if (gesture.status === 'panning') {\\n        var now = Date.now();\\n        var duration = now - gesture.startTime;\\n        var displacementX = touch.clientX - gesture.startTouch.clientX;\\n        var displacementY = touch.clientY - gesture.startTouch.clientY;\\n\\n        var velocity = Math.sqrt(gesture.velocityY * gesture.velocityY + gesture.velocityX * gesture.velocityX);\\n        var isSwipe = velocity > 0.5 && now - gesture.lastTime < 100;\\n        var extra = {\\n          duration: duration,\\n          isSwipe: isSwipe,\\n          velocityX: gesture.velocityX,\\n          velocityY: gesture.velocityY,\\n          displacementX: displacementX,\\n          displacementY: displacementY,\\n          touch: touch,\\n          touches: event.touches,\\n          changedTouches: event.changedTouches,\\n          touchEvent: event,\\n          isVertical: gesture.isVertical,\\n          direction: gesture.direction\\n        };\\n\\n        fireEvent(gesture.element, 'panend', extra);\\n        if (isSwipe) {\\n          fireEvent(gesture.element, 'swipe', extra);\\n        }\\n      }\\n\\n      if (gesture.status === 'pressing') {\\n        fireEvent(gesture.element, 'pressend', {\\n          touch: touch,\\n          touchEvent: event\\n        });\\n      }\\n\\n      delete gestures[id];\\n    }\\n\\n    if (Object.keys(gestures).length === 0) {\\n      docEl.removeEventListener('touchmove', touchmoveHandler, false);\\n      docEl.removeEventListener('touchend', touchendHandler, false);\\n      docEl.removeEventListener('touchcancel', touchcancelHandler, false);\\n    }\\n  }\\n\\n  /**\\n   * handle touchcancel\\n   *\\n   * 1. if there are two touch points, then trigger 'dualtouchend'\\n   *\\n   * 2. traverse everty touch point:\\n   * > if pannnig, then trigger 'panend'\\n   * > if pressing, then trigger 'pressend'\\n   *\\n   * 3. remove listeners\\n   *\\n   * @event\\n   * @param  {event} event\\n   */\\n  function touchcancelHandler(event) {\\n\\n    if (Object.keys(gestures).length == 2) {\\n      var elements = [];\\n      for (var p in gestures) {\\n        elements.push(gestures[p].element);\\n      }\\n      fireEvent(getCommonAncestor(elements[0], elements[1]), 'dualtouchend', {\\n        touches: slice.call(event.touches),\\n        touchEvent: event\\n      });\\n    }\\n\\n    for (var i = 0; i < event.changedTouches.length; i++) {\\n      var touch = event.changedTouches[i];\\n      var id = touch.identifier;\\n      var gesture = gestures[id];\\n\\n      if (!gesture) {\\n        continue;\\n      }\\n\\n      if (gesture.pressingHandler) {\\n        clearTimeout(gesture.pressingHandler);\\n        gesture.pressingHandler = null;\\n      }\\n\\n      if (gesture.status === 'panning') {\\n        fireEvent(gesture.element, 'panend', {\\n          touch: touch,\\n          touches: event.touches,\\n          changedTouches: event.changedTouches,\\n          touchEvent: event\\n        });\\n      }\\n      if (gesture.status === 'pressing') {\\n        fireEvent(gesture.element, 'pressend', {\\n          touch: touch,\\n          touchEvent: event\\n        });\\n      }\\n      delete gestures[id];\\n    }\\n\\n    if (Object.keys(gestures).length === 0) {\\n      docEl.removeEventListener('touchmove', touchmoveHandler, true);\\n      docEl.removeEventListener('touchend', touchendHandler, true);\\n      docEl.removeEventListener('touchcancel', touchcancelHandler, true);\\n    }\\n  }\\n\\n  if (!isInitialized) {\\n    docEl.addEventListener('touchstart', touchstartHandler, true);\\n    isInitialized = true;\\n  }\\n\\n  var lib$2 = window.lib || (window.lib = {});\\n\\n  /**\\n   * Version class.\\n   * @class lib.env~Version\\n   * @param {String} v - version number.\\n   */\\n  function Version(v) {\\n    Object.defineProperty(this, 'val', {\\n      value: v.toString(),\\n      enumerable: true\\n    });\\n\\n    /**\\n     * larger than\\n     * @method gt\\n     * @param {String} v - version\\n     * @return {Boolean} result\\n     * @instance\\n     * @memberof Version\\n     */\\n    this.gt = function (v) {\\n      return Version.compare(this, v) > 0;\\n    };\\n\\n    /**\\n     * larger than or equal to.\\n     * @method gte\\n     * @param {String} v - version\\n     * @return {Boolean} result\\n     * @instance\\n     * @memberof Version\\n     */\\n    this.gte = function (v) {\\n      return Version.compare(this, v) >= 0;\\n    };\\n\\n    /**\\n     * less than.\\n     * @method lt\\n     * @param {String} v - version\\n     * @return {Boolean} result\\n     * @instance\\n     * @memberof Version\\n     */\\n    this.lt = function (v) {\\n      return Version.compare(this, v) < 0;\\n    };\\n\\n    /**\\n     * less than or equal to.\\n     * @method lte\\n     * @param {String} v - version\\n     * @return {Boolean} result\\n     * @instance\\n     * @memberof Version\\n     */\\n    this.lte = function (v) {\\n      return Version.compare(this, v) <= 0;\\n    };\\n\\n    /**\\n     * equal to.\\n     * @method eq\\n     * @param {String} v - version\\n     * @return {Boolean} equal to\\n     * @instance\\n     * @memberof Version\\n     */\\n    this.eq = function (v) {\\n      return Version.compare(this, v) === 0;\\n    };\\n  }\\n\\n  /**\\n   * version number string.\\n   * @method toString\\n   * @return {String} current version number string.\\n   * @instance\\n   * @memberof Version\\n   */\\n  Version.prototype.toString = function () {\\n    return this.val;\\n  };\\n\\n  /**\\n   * return current version number.\\n   * @method valueOf\\n   * @return {Boolean} version number\\n   * @instance\\n   * @memberof Version\\n   */\\n  Version.prototype.valueOf = function () {\\n    var v = this.val.split('.');\\n    var r = [];\\n    for (var i = 0; i < v.length; i++) {\\n      var n = parseInt(v[i], 10);\\n      if (isNaN(n)) {\\n        n = 0;\\n      }\\n      var s = n.toString();\\n      if (s.length < 5) {\\n        s = Array(6 - s.length).join('0') + s;\\n      }\\n      r.push(s);\\n      if (r.length === 1) {\\n        r.push('.');\\n      }\\n    }\\n    return parseFloat(r.join(''));\\n  };\\n\\n  /**\\n   * compare two versions.\\n   * @method compare\\n   * @param {String} v1 - version1\\n   * @param {String} v2 - version2\\n   * @return {Number} 0 for equality-1 for less than1 for larger than.\\n   * @memberof Version\\n   */\\n  Version.compare = function (v1, v2) {\\n    v1 = v1.toString().split('.');\\n    v2 = v2.toString().split('.');\\n    for (var i = 0; i < v1.length || i < v2.length; i++) {\\n      var n1 = parseInt(v1[i], 10);\\n      var n2 = parseInt(v2[i], 10);\\n      if (window.isNaN(n1)) {\\n        n1 = 0;\\n      }\\n      if (window.isNaN(n2)) {\\n        n2 = 0;\\n      }\\n      if (n1 < n2) {\\n        return -1;\\n      } else if (n1 > n2) {\\n        return 1;\\n      }\\n    }\\n    return 0;\\n  };\\n\\n  /**\\n   * \\n   * @method version\\n   * @param {string} v - \\n   * @return {lib.env~Version} Verson\\n   * @memberof lib\\n   */\\n  lib$2.version = function (v) {\\n    return new Version(v);\\n  };\\n\\n  var lib$3 = window.lib || (window.lib = {});\\n  var env$1 = lib$3.env || (lib$3.env = {});\\n\\n  var search = window.location.search.replace(/^\\\\?/, '');\\n  env$1.params = {};\\n  if (search) {\\n    var params = search.split('&');\\n    for (var i$1 = 0; i$1 < params.length; i$1++) {\\n      params[i$1] = params[i$1].split('=');\\n      try {\\n        env$1.params[params[i$1][0]] = decodeURIComponent(params[i$1][1]);\\n      } catch (e) {\\n        env$1.params[params[i$1][0]] = params[i$1][1];\\n      }\\n    }\\n  }\\n\\n  var lib$1 = window.lib || (window.lib = {});\\n  var env = lib$1.env || (lib$1.env = {});\\n\\n  var ua = window.navigator.userAgent;\\n  var match;\\n\\n  /**\\n   * os\\n   */\\n\\n  match = ua.match(/Windows\\\\sPhone\\\\s(?:OS\\\\s)?([\\\\d.]+)/);\\n  if (match) {\\n    /**\\n     * @type {Object}\\n     * @memberof lib.env\\n     * @property {String} name - os name, e.g. Android/AndroidPad/iPhone/iPod/iPad/Windows Phone/unknown, etc.\\n     * @property {lib.env~Version} version - os version.\\n     * @property {Boolean} isWindowsPhone\\n     * @property {Boolean} isIPhone - is iPhone/iTouch\\n     * @property {Boolean} isIPad\\n     * @property {Boolean} isIOS\\n     * @property {Boolean} isAndroid\\n     * @property {Boolean} isAndroidPad\\n     */\\n    env.os = {\\n      name: 'Windows Phone',\\n      isWindowsPhone: true,\\n      version: match[1]\\n    };\\n  } else if (!!ua.match(/Safari/) && (match = ua.match(/Android[\\\\s/]([\\\\d.]+)/))) {\\n    env.os = {\\n      version: match[1]\\n    };\\n\\n    if (ua.match(/Mobile\\\\s+Safari/)) {\\n      env.os.name = 'Android';\\n      env.os.isAndroid = true;\\n    } else {\\n      env.os.name = 'AndroidPad';\\n      env.os.isAndroidPad = true;\\n    }\\n  } else if (match = ua.match(/(iPhone|iPad|iPod)/)) {\\n    var name = match[1];\\n\\n    match = ua.match(/OS ([\\\\d_.]+) like Mac OS X/);\\n\\n    env.os = {\\n      name: name,\\n      isIPhone: name === 'iPhone' || name === 'iPod',\\n      isIPad: name === 'iPad',\\n      isIOS: true,\\n      version: match && match[1].split('_').join('.') || ''\\n    };\\n  } else {\\n    env.os = {\\n      name: 'unknown',\\n      version: '0.0.0'\\n    };\\n  }\\n\\n  if (lib$1.version) {\\n    env.os.version = lib$1.version(env.os.version);\\n  }\\n\\n  /**\\n   * browser\\n   */\\n\\n  match = ua.match(/(?:UCWEB|UCBrowser\\\\/)([\\\\d.]+)/);\\n\\n  if (match) {\\n    /**\\n     * @type {Object}\\n     * @memberof env\\n     * @property {String} name - browser namee.g. UC/QQ/Firefox/Chrome/Android/Safari/iOS Webview/Chrome Webview/IE/IEMobile/unknown, etc.\\n     * @property {env~Version} version - browser version.\\n     * @property {Boolean} isUC\\n     * @property {Boolean} isQQ\\n     * @property {Boolean} isIE\\n     * @property {Boolean} isIEMobile\\n     * @property {Boolean} isIELikeWebkit\\n     * @property {Boolean} isChrome\\n     * @property {Boolean} isAndroid\\n     * @property {Boolean} isSafari\\n     * @property {Boolean} isWebview\\n     */\\n    env.browser = {\\n      name: 'UC',\\n      isUC: true,\\n      version: match[1]\\n    };\\n  } else if (match = ua.match(/MQQBrowser\\\\/([\\\\d.]+)/)) {\\n    env.browser = {\\n      name: 'QQ',\\n      isQQ: true,\\n      version: match[1]\\n    };\\n  } else if (match = ua.match(/Firefox\\\\/([\\\\d.]+)/)) {\\n    env.browser = {\\n      name: 'Firefox',\\n      isFirefox: true,\\n      version: match[1]\\n    };\\n  } else if ((match = ua.match(/MSIE\\\\s([\\\\d.]+)/)) || (match = ua.match(/IEMobile\\\\/([\\\\d.]+)/))) {\\n    env.browser = {\\n      version: match[1]\\n    };\\n\\n    if (ua.match(/IEMobile/)) {\\n      env.browser.name = 'IEMobile';\\n      env.browser.isIEMobile = true;\\n    } else {\\n      env.browser.name = 'IE';\\n      env.browser.isIE = true;\\n    }\\n\\n    if (ua.match(/Android|iPhone/)) {\\n      env.browser.isIELikeWebkit = true;\\n    }\\n  } else if (match = ua.match(/(?:Chrome|CriOS)\\\\/([\\\\d.]+)/)) {\\n    env.browser = {\\n      name: 'Chrome',\\n      isChrome: true,\\n      version: match[1]\\n    };\\n\\n    if (ua.match(/Version\\\\/[\\\\d+.]+\\\\s*Chrome/)) {\\n      env.browser.name = 'Chrome Webview';\\n      env.browser.isWebview = true;\\n    }\\n  } else if (!!ua.match(/Safari/) && (match = ua.match(/Android[\\\\s/]([\\\\d.]+)/))) {\\n    env.browser = {\\n      name: 'Android',\\n      isAndroid: true,\\n      version: match[1]\\n    };\\n  } else if (ua.match(/iPhone|iPad|iPod/)) {\\n    if (ua.match(/Safari/)) {\\n      match = ua.match(/Version\\\\/([\\\\d.]+)/);\\n      env.browser = {\\n        name: 'Safari',\\n        isSafari: true,\\n        version: match && match[1] || ''\\n      };\\n    } else {\\n      match = ua.match(/OS ([\\\\d_.]+) like Mac OS X/);\\n      env.browser = {\\n        name: 'iOS Webview',\\n        isWebview: true,\\n        version: match && match[1].replace(/_/g, '.') || ''\\n      };\\n    }\\n  } else {\\n    env.browser = {\\n      name: 'unknown',\\n      version: '0.0.0'\\n    };\\n  }\\n\\n  if (lib$1.version) {\\n    env.browser.version = lib$1.version(env.browser.version);\\n  }\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n\\n  var toString$1 = Object.prototype.toString;\\n\\n  /**\\n   * Strict object type check. Only returns true\\n   * for plain JavaScript objects.\\n   *\\n   * @param {*} obj\\n   * @return {Boolean}\\n   */\\n  var OBJECT_STRING = '[object Object]';\\n  function isPlainObject(obj) {\\n    return toString$1.call(obj) === OBJECT_STRING;\\n  }\\n\\n  var ARRAY_STRING = '[object Array]';\\n  function isArray(arr) {\\n    return toString$1.call(arr) === ARRAY_STRING;\\n  }\\n\\n  function isPrimitive(val) {\\n    return typeof value === 'string' || typeof value === 'number' || (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'symbol' || typeof value === 'boolean';\\n  }\\n\\n  function isDef(val) {\\n    return val !== undefined && val !== null;\\n  }\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  /**\\n   * Mix properties into target object.\\n   * the rightest object's value has the highest priority.\\n   */\\n  function extend(to) {\\n    var args = [],\\n        len = arguments.length - 1;\\n    while (len-- > 0) {\\n      args[len] = arguments[len + 1];\\n    }if (!args || args.length <= 0) {\\n      return to;\\n    }\\n    args.forEach(function (from) {\\n      if ((typeof from === 'undefined' ? 'undefined' : _typeof(from)) !== 'object') {\\n        return;\\n      }\\n      for (var key in from) {\\n        to[key] = from[key];\\n      }\\n    });\\n    return to;\\n  }\\n  /**\\n   * Mix truthy or '' property values into target object.\\n   * mostly for merging styles. (that's why '' is falsy but still should be counted in.)\\n   * the rightest object's value has the highest priority.\\n   */\\n  function extendTruthy(to) {\\n    var args = [],\\n        len = arguments.length - 1;\\n    while (len-- > 0) {\\n      args[len] = arguments[len + 1];\\n    }if (!args || args.length <= 0) {\\n      return to;\\n    }\\n    args.forEach(function (from) {\\n      if ((typeof from === 'undefined' ? 'undefined' : _typeof(from)) !== 'object') {\\n        return;\\n      }\\n      var i;\\n      for (var key in from) {\\n        if (((i = from[key]) || i === '' || i === 0) && i !== 'undefined') {\\n          to[key] = i;\\n        }\\n      }\\n    });\\n    return to;\\n  }\\n  /**\\n   * Mix specified properties into target object.\\n   */\\n  function extendKeys(to, from, keys) {\\n    if (from === void 0) from = {};\\n\\n    (keys || []).forEach(function (key) {\\n      from && (to[key] = from[key]);\\n    });\\n    return to;\\n  }\\n  /**\\n   * Extract specified properties from src to target object.\\n   */\\n  function extractKeys(to, from, keys) {\\n    if (from === void 0) from = {};\\n\\n    if (!from) {\\n      return to;\\n    }\\n    (keys || []).forEach(function (key) {\\n      from && (to[key] = from[key]);\\n      from && delete from[key];\\n    });\\n    return to;\\n  }\\n  /**\\n   * Simple bind, faster than native\\n   *\\n   * @param {Function} fn\\n   * @param {Object} ctx\\n   * @return {Function}\\n   */\\n  function bind(fn, ctx) {\\n    return function (a) {\\n      var l = arguments.length;\\n      return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\\n    };\\n  }\\n  /**\\n   * Only call the func the last time before it's not that frequently called.\\n   */\\n  function debounce(func, wait) {\\n    var timerId;\\n    return function () {\\n      var args = [],\\n          len = arguments.length;\\n      while (len--) {\\n        args[len] = arguments[len];\\n      }clearTimeout(timerId);\\n      timerId = setTimeout(function later() {\\n        timerId = null;\\n        func.apply(null, args);\\n      }, wait);\\n    };\\n  }\\n  /**\\n   * Only call the func the first time before a series frequently function calls happen.\\n   */\\n  function depress(func, wait) {\\n    var timerId;\\n\\n    function later() {\\n      timerId = null;\\n    }\\n    return function () {\\n      if (!timerId) {\\n        func.apply();\\n      }\\n      clearTimeout(timerId);\\n      timerId = setTimeout(later, wait);\\n    };\\n  }\\n  /**\\n   * Only call the func every time after a wait milliseconds if it's too frequently called.\\n   */\\n  function throttle(func, wait, callLastTime) {\\n    var last = 0;\\n    var lastTimer = null;\\n    var lastTimeDuration = wait + (wait > 25 ? wait : 25); // plus half wait time.\\n    return function () {\\n      var args = [],\\n          len = arguments.length;\\n      while (len--) {\\n        args[len] = arguments[len];\\n      }var context = this;\\n      var time = new Date().getTime();\\n      if (time - last > wait) {\\n        if (callLastTime) {\\n          lastTimer && clearTimeout(lastTimer);\\n          lastTimer = setTimeout(function () {\\n            lastTimer = null;\\n            func.apply(context, args);\\n          }, lastTimeDuration);\\n        }\\n        func.apply(context, args);\\n        last = time;\\n      }\\n    };\\n  }\\n  // direction: 'l' | 'r', default is 'r'\\n  // num: how many times to loop, should be a positive integer\\n  function loopArray(arr, num, direction) {\\n    if (!isArray(arr)) {\\n      return;\\n    }\\n    var isLeft = (direction + '').toLowerCase() === 'l';\\n    var len = arr.length;\\n    num = num % len;\\n    if (num < 0) {\\n      num = -num;\\n      isLeft = !isLeft;\\n    }\\n    if (num === 0) {\\n      return arr;\\n    }\\n    var lp, rp;\\n    if (isLeft) {\\n      lp = arr.slice(0, num);\\n      rp = arr.slice(num);\\n    } else {\\n      lp = arr.slice(0, len - num);\\n      rp = arr.slice(len - num);\\n    }\\n    return rp.concat(lp);\\n  }\\n\\n  /**\\n   * Create a cached version of a pure function.\\n   */\\n  function cached(fn) {\\n    var cache = Object.create(null);\\n    return function cachedFn(str) {\\n      var hit = cache[str];\\n      return hit || (cache[str] = fn(str));\\n    };\\n  }\\n  /**\\n   * Camelize a hyphen-delmited string.\\n   */\\n  var camelizeRE = /-(\\\\w)/g;\\n  var camelize = cached(function (str) {\\n    return str.replace(camelizeRE, function (_, c) {\\n      return c.toUpperCase();\\n    });\\n  });\\n  function camelizeKeys(obj) {\\n    var res = {};\\n    for (var key in obj) {\\n      res[camelize(key)] = obj[key];\\n    }\\n    return res;\\n  }\\n  /**\\n   * Capitalize a string.\\n   */\\n  var capitalize = cached(function (str) {\\n    return str.charAt(0).toUpperCase() + str.slice(1);\\n  });\\n  /**\\n   * Hyphenate a camelCase string.\\n   */\\n  var hyphenateRE = /([^-])([A-Z])/g;\\n  var hyphenate = cached(function (str) {\\n    return str.replace(hyphenateRE, '$1-$2').replace(hyphenateRE, '$1-$2').toLowerCase();\\n  });\\n  function hyphenateKeys(obj) {\\n    var res = {};\\n    for (var key in obj) {\\n      res[hyphenate(key)] = obj[key];\\n    }\\n    return res;\\n  }\\n  var vendorsReg = /webkit-|moz-|o-|ms-/;\\n  function hyphenateStyleKeys(obj) {\\n    var res = {};\\n    for (var key in obj) {\\n      var hk = hyphenate(key).replace(vendorsReg, function ($0) {\\n        return '-' + $0;\\n      });\\n      res[hk] = obj[key];\\n    }\\n    return res;\\n  }\\n  function camelToKebab(name) {\\n    if (!name) {\\n      return '';\\n    }\\n    return name.replace(/([A-Z])/g, function (g, g1) {\\n      return \\\"-\\\" + g1.toLowerCase();\\n    });\\n  }\\n  function appendCss(css, cssId, replace) {\\n    var style = document.getElementById(cssId);\\n    if (style && replace) {\\n      style.parentNode.removeChild(style);\\n      style = null;\\n    }\\n    if (!style) {\\n      style = document.createElement('style');\\n      style.type = 'text/css';\\n      cssId && (style.id = cssId);\\n      document.getElementsByTagName('head')[0].appendChild(style);\\n    }\\n    style.appendChild(document.createTextNode(css));\\n  }\\n  function nextFrame(callback) {\\n    var runner = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (cb) {\\n      return setTimeout(cb, 16);\\n    };\\n    runner(callback);\\n  }\\n  function toCSSText(object) {\\n    if (!object) {\\n      return;\\n    }\\n    var obj = hyphenateStyleKeys(object);\\n    var cssText = '';\\n    for (var key in obj) {\\n      cssText += key + \\\":\\\" + obj[key] + \\\";\\\";\\n    }\\n    return cssText;\\n  }\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n\\n  /**\\n   * viewport priority:\\n   *\\n   * 1. meta weex-viewport (developer custom)\\n   * 2. setViewport(config) := config.width (private code) @deprecated\\n   * 3. 750 (buid time)\\n   *\\n   */\\n  var isInited = false;\\n  var DEFAULT_VIEWPORT_WIDTH = 750;\\n\\n  /**\\n   * get viewport width from weex-viewport meta.\\n   */\\n  var envViewportWidth = parseInt(750);\\n  var width = !isNaN(envViewportWidth) && envViewportWidth > 0 ? envViewportWidth : DEFAULT_VIEWPORT_WIDTH;\\n\\n  var wxViewportMeta = document.querySelector('meta[name=\\\"weex-viewport\\\"]');\\n  var metaWidth = wxViewportMeta && parseInt(wxViewportMeta.getAttribute('content'));\\n  if (metaWidth && !isNaN(metaWidth) && metaWidth > 0) {\\n    width = metaWidth;\\n  }\\n\\n  var dpr = 0;\\n  var screenWidth = 0;\\n  var screenHeight = 0;\\n\\n  var info = {\\n    dpr: dpr,\\n    scale: 0,\\n    rootValue: 0,\\n    rem: 0,\\n    deviceWidth: 0,\\n    deviceHeight: 0\\n  };\\n\\n  /**\\n   * set root font-size for rem units. If already been set, just skip this.\\n   */\\n  function setRootFont(width, viewportWidth, force) {\\n    var doc = window.document;\\n    var rem = width * 750 / viewportWidth / 10;\\n    if (!doc.documentElement) {\\n      return;\\n    }\\n    var rootFontSize = doc.documentElement.style.fontSize;\\n    if (!rootFontSize || force) {\\n      doc.documentElement.style.fontSize = rem + 'px';\\n    }\\n    info.rem = rem;\\n    info.rootValue = viewportWidth / 10;\\n  }\\n\\n  function setMetaViewport(width) {\\n    if (!wxViewportMeta) {\\n      wxViewportMeta = document.createElement('meta');\\n      wxViewportMeta.setAttribute('name', 'weex-viewport');\\n      var firstMeta = document.querySelector('meta');\\n      var head = firstMeta && firstMeta.parentElement || document.documentElement.children[0];\\n      firstMeta ? head.insertBefore(wxViewportMeta, firstMeta) : head.appendChild(wxViewportMeta);\\n    } else {\\n      var metaWidth = parseInt(wxViewportMeta.getAttribute('content'));\\n      if (metaWidth === width) {\\n        return;\\n      }\\n    }\\n    wxViewportMeta.setAttribute('content', width + '');\\n  }\\n\\n  /**\\n   * export viewport info.\\n   */\\n  function init$1(viewportWidth) {\\n    if (viewportWidth === void 0) viewportWidth = width;\\n\\n    if (!isInited) {\\n      isInited = true;\\n\\n      var doc = window.document;\\n      if (!doc) {\\n        console.error('[vue-render] window.document is undfined.');\\n        return;\\n      }\\n      if (!doc.documentElement) {\\n        console.error('[vue-render] document.documentElement is undfined.');\\n        return;\\n      }\\n\\n      dpr = info.dpr = window.devicePixelRatio;\\n      screenWidth = doc.documentElement.clientWidth;\\n      screenHeight = doc.documentElement.clientHeight;\\n\\n      var resetDeviceHeight = function resetDeviceHeight() {\\n        screenHeight = doc.documentElement.clientHeight;\\n        var env = window.weex && window.weex.config.env;\\n        info.deviceHeight = env.deviceHeight = screenHeight * dpr;\\n      };\\n\\n      // set root font for rem.\\n      setRootFont(screenWidth, viewportWidth);\\n      setMetaViewport(viewportWidth);\\n\\n      window.addEventListener('resize', resetDeviceHeight);\\n\\n      /**\\n       * why not to use window.screen.width to get screenWidth ? Because in some\\n       * old webkit browser on android system it get the device pixel width, which\\n       * is the screenWidth multiply by the device pixel ratio.\\n       * e.g. ip6 -> get 375 for virtual screen width.\\n       */\\n      var scale = screenWidth / viewportWidth;\\n      /**\\n       * 1. if set initial/maximum/mimimum-scale some how the page will have a bounce\\n       * effect when user drag the page towards horizontal axis.\\n       * 2. Due to compatibility reasons, not to use viewport meta anymore.\\n       * 3. viewport meta should always be:\\n       *    <meta name=\\\"viewport\\\"\\n       *      content=\\\"width=device-width,\\n       *      initial-scale=1,\\n       *      maximum-scale=1,\\n       *      user-scalable=no\\\" />\\n       */\\n      extend(info, {\\n        scale: scale,\\n        rootValue: viewportWidth / 10,\\n        deviceWidth: screenWidth * dpr,\\n        deviceHeight: screenHeight * dpr\\n      });\\n    }\\n\\n    return info;\\n  }\\n\\n  /**\\n   * reset viewport width and scale.\\n   * @return new scale.\\n   */\\n  function resetViewport(viewportWidth) {\\n    setRootFont(screenWidth, viewportWidth, true);\\n    setMetaViewport(viewportWidth);\\n    var newScale = screenWidth / viewportWidth;\\n    info.scale = newScale;\\n    return newScale;\\n  }\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n\\n  function extend$1(to) {\\n    var args = [],\\n        len = arguments.length - 1;\\n    while (len-- > 0) {\\n      args[len] = arguments[len + 1];\\n    }if (!args || args.length <= 0) {\\n      return to;\\n    }\\n    args.forEach(function (from) {\\n      if ((typeof from === 'undefined' ? 'undefined' : _typeof(from)) !== 'object') {\\n        return;\\n      }\\n      for (var key in from) {\\n        to[key] = from[key];\\n      }\\n    });\\n    return to;\\n  }\\n\\n  // if support passive event listeners.\\n  var _supportsPassive = false;\\n  try {\\n    document.createElement('div').addEventListener('test', function (_) {}, {\\n      get passive() {\\n        _supportsPassive = true;\\n      }\\n    });\\n  } catch (e) {\\n    // do nothing.\\n  }\\n  function supportsPassive() {\\n    return _supportsPassive;\\n  }\\n\\n  /**\\n   * Create Event.\\n   * @param {DOMString} type\\n   * @param {Object} props\\n   */\\n  function createEvent(target, type, props) {\\n    var event = new Event(type, { bubbles: false });\\n\\n    extend$1(event, props);\\n    //  phantomjs don't support customer event\\n    if (window.navigator.userAgent.toLowerCase().indexOf('phantomjs') !== -1) {\\n      return event;\\n    }\\n    try {\\n      Object.defineProperty(event, 'target', {\\n        enumerable: true,\\n        value: target\\n      });\\n    } catch (err) {\\n      return extend$1({}, event, { target: target });\\n    }\\n    return event;\\n  }\\n\\n  /**\\n   * Create a bubbable Event.\\n   * @param {DOMString} type\\n   * @param {Object} props\\n   */\\n  function createBubblesEvent(target, type, props) {\\n    var event = new Event(type, { bubbles: true });\\n    extend$1(event, props);\\n    //  phantomjs don't support customer event\\n    if (window.navigator.userAgent.toLowerCase().indexOf('phantomjs') !== -1) {\\n      return event;\\n    }\\n    try {\\n      Object.defineProperty(event, 'target', {\\n        enumerable: true,\\n        value: target\\n      });\\n    } catch (err) {\\n      return extend$1({}, event, { target: target });\\n    }\\n    return event;\\n  }\\n\\n  /**\\n   * Create Custom Event.\\n   * @param {DOMString} type\\n   * @param {Object} props\\n   */\\n  function createCustomEvent(target, type, props) {\\n    // compatibility: http://caniuse.com/#search=customevent\\n    // const event = new CustomEvent(type)\\n    var event = document.createEvent('CustomEvent');\\n    event.initCustomEvent(type, false, true, {});\\n    // event.preventDefault()\\n    // event.stopPropagation()\\n\\n    extend$1(event, props);\\n\\n    // event.target is readonly\\n    try {\\n      Object.defineProperty(event, 'target', {\\n        enumerable: true,\\n        value: target || null\\n      });\\n    } catch (err) {\\n      return extend$1({}, event, { target: target || null });\\n    }\\n\\n    return event;\\n  }\\n\\n  /**\\n   * dispatch a event on a HTML element.\\n   * @param  {HTMLElement} elm\\n   * @param  {Event} type event name.\\n   * @param  {Object} data extra data.\\n   */\\n  function dispatchNativeEvent(elm, type, data) {\\n    elm.dispatchEvent(createEvent(elm, type, data));\\n  }\\n\\n  function mapFormEvents(context) {\\n    var eventMap = {};['input', 'change', 'focus', 'blur', 'return'].forEach(function (type) {\\n      eventMap[type] = function (event) {\\n        if (context.$el) {\\n          event.value = context.$el.value;\\n          // for the sake of v-model, a input event must be emitted.\\n          if (type === 'input') {\\n            context.$emit(type, event);\\n          }\\n        }\\n      };\\n    });\\n    return eventMap;\\n  }\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  var scaleStyles = ['width', 'height', 'left', 'right', 'top', 'bottom', 'border', 'borderRadius', 'borderWidth', 'borderLeft', 'borderRight', 'borderTop', 'borderBottom', 'borderLeftWidth', 'borderRightWidth', 'borderTopWidth', 'borderBottomWidth', 'margin', 'marginLeft', 'marginRight', 'marginTop', 'marginBottom', 'padding', 'paddingLeft', 'paddingRight', 'paddingTop', 'paddingBottom', 'fontSize', 'lineHeight', 'transform', 'webkitTransform', 'WebkitTransform', 'mozTransform', 'MozTransform', 'itemSize'];\\n\\n  var vendorReg = /webkit|moz/i;\\n  function hyphen(key) {\\n    return hyphenate(key.replace(vendorReg, function ($0) {\\n      return \\\"-\\\" + $0.toLowerCase() + \\\"-\\\";\\n    }));\\n  }\\n\\n  function getAllStyles() {\\n    return Object.keys(scaleStyles.reduce(function (pre, key) {\\n      pre[key] = 1;\\n      pre[hyphen(key)] = 1;\\n      return pre;\\n    }, {}));\\n  }\\n\\n  var allStyles = getAllStyles();\\n\\n  var config = {\\n    scrollableTypes: ['scroller', 'list', 'waterfall'],\\n    gestureEvents: ['panstart', 'panmove', 'panend', 'swipe', 'longpress', 'tap'],\\n    // these components should not bind events with .native.\\n    weexBuiltInComponents: ['div', 'container', 'text', 'image', 'img', 'cell', 'a'],\\n    bindingStyleNamesForPx2Rem: allStyles\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  /**\\n   * whether ct contains el.\\n   * @param {HTMLElement} container\\n   * @param {HTMLElement} target\\n   */\\n  function contains(container, target, includeSelf) {\\n    if (includeSelf && container === target) {\\n      return true;\\n    }\\n    return container.contains ? container.contains(target) && container !== target : container.compareDocumentPosition(target) & 16 !== 0;\\n  }\\n\\n  function insideA(el) {\\n    if (typeof el._insideA === 'boolean') {\\n      return el._insideA;\\n    }\\n    var parent = el.parentElement;\\n    var parents = [];\\n    var checkParents = function checkParents(inside) {\\n      for (var i = 0, l = parents.length; i < l; i++) {\\n        parents[i]._insideA = inside;\\n      }\\n    };\\n    var check = function check(inside) {\\n      el._insideA = inside;\\n      checkParents(inside);\\n      return inside;\\n    };\\n    while (parent !== document.body) {\\n      if (parent.tagName.toLowerCase() === 'a') {\\n        return check(true);\\n      }\\n      if (typeof parent._insideA === 'boolean') {\\n        return check(parent._insideA);\\n      }\\n      parents.push(parent);\\n      parent = parent.parentElement;\\n    }\\n    return check(false);\\n  }\\n\\n  /**\\n   * get parent scroller vComponent.\\n   * return a VueComponent or null.\\n   */\\n  function getParentScroller(vm) {\\n    if (!vm) {\\n      return null;\\n    }\\n    if (vm._parentScroller) {\\n      return vm._parentScroller;\\n    }\\n    function _getParentScroller(parent) {\\n      if (!parent) {\\n        return;\\n      }\\n      if (config.scrollableTypes.indexOf(parent.weexType) > -1) {\\n        vm._parentScroller = parent;\\n        return parent;\\n      }\\n      return _getParentScroller(parent.$parent);\\n    }\\n    return _getParentScroller(vm.$parent);\\n  }\\n\\n  /**\\n   * get scroller's element.\\n   * @param vm {HTMLElement | VueCOmponent} vm or element.\\n   * return the element or document.body.\\n   */\\n  function getParentScrollerElement(vm) {\\n    if (!vm) {\\n      return null;\\n    }\\n    var el = vm instanceof HTMLElement ? vm : vm.$el;\\n    if (!el || el.nodeType !== 1) {\\n      return;\\n    }\\n    if (vm._parentScroller) {\\n      return vm._parentScroller;\\n    }\\n    function _getParentScroller(parent) {\\n      if (!parent) {\\n        return;\\n      }\\n      var tagName = parent.tagName.toLowerCase();\\n      if (tagName === 'body' || tagName === 'main' && config.scrollableTypes.indexOf(parent.getAttribute('weex-type')) > -1) {\\n        vm._parentScroller = parent;\\n        return parent;\\n      }\\n      return _getParentScroller(parent.parentElement);\\n    }\\n    return _getParentScroller(el);\\n  }\\n\\n  function horizontalBalance(rect, ctRect) {\\n    return rect.left < ctRect.right && rect.right > ctRect.left;\\n  }\\n\\n  function verticalBalance(rect, ctRect) {\\n    return rect.top < ctRect.bottom && rect.bottom > ctRect.top;\\n  }\\n\\n  /**\\n   * return a data array with two boolean value, which are:\\n   * 1. visible in current ct's viewport.\\n   * 2. visible with offset in current ct's viewport.\\n   */\\n  function hasIntersection(rect, ctRect, dir, offset) {\\n    dir = dir || 'up';\\n    var isHorizontal = dir === 'left' || dir === 'right';\\n    var isVertical = dir === 'up' || dir === 'down';\\n    if (isHorizontal && !verticalBalance(rect, ctRect)) {\\n      return [false, false];\\n    }\\n    if (isVertical && !horizontalBalance(rect, ctRect)) {\\n      return [false, false];\\n    }\\n    offset = offset ? parseInt(offset) * weex.config.env.scale : 0;\\n    switch (dir) {\\n      case 'up':\\n        return [rect.top < ctRect.bottom && rect.bottom > ctRect.top, rect.top < ctRect.bottom + offset && rect.bottom > ctRect.top - offset];\\n      case 'down':\\n        return [rect.bottom > ctRect.top && rect.top < ctRect.bottom, rect.bottom > ctRect.top - offset && rect.top < ctRect.bottom + offset];\\n      case 'left':\\n        return [rect.left < ctRect.right && rect.right > ctRect.left, rect.left < ctRect.right + offset && rect.right > ctRect.left - offset];\\n      case 'right':\\n        return [rect.right > ctRect.left && rect.left < ctRect.right, rect.right > ctRect.left - offset && rect.left < ctRect.right + offset];\\n    }\\n  }\\n\\n  /**\\n   * isElementVisible\\n   * @param  {HTMLElement}  el    a dom element.\\n   * @param  {HTMLElement}  container  optional, the container of this el.\\n   */\\n  function isElementVisible(el, container, dir, offset) {\\n    if (!el.getBoundingClientRect) {\\n      return false;\\n    }\\n    var bodyRect = {\\n      top: 0,\\n      left: 0,\\n      bottom: window.innerHeight,\\n      right: window.innerWidth\\n    };\\n    var ctRect = container === window || container === document.body ? bodyRect : container ? container.getBoundingClientRect() : bodyRect;\\n    return hasIntersection(el.getBoundingClientRect(), ctRect, dir, offset);\\n  }\\n\\n  // to trigger the appear/disappear event.\\n  function triggerAppearEvent(elm, evt, dir) {\\n    dispatchNativeEvent(elm, evt, {\\n      direction: dir\\n    });\\n  }\\n\\n  /**\\n   * get all event listeners. including bound handlers in all parent vnodes.\\n   */\\n  function getEventHandlers(context) {\\n    var vnode = context.$vnode;\\n    var handlers = {};\\n    var attachedVnodes = [];\\n    while (vnode) {\\n      attachedVnodes.push(vnode);\\n      vnode = vnode.parent;\\n    }\\n    attachedVnodes.forEach(function (vnode) {\\n      var parentListeners = vnode.componentOptions && vnode.componentOptions.listeners;\\n      var dataOn = vnode.data && vnode.data.on;\\n      extend(handlers, parentListeners, dataOn);\\n    });\\n    return handlers;\\n  }\\n\\n  function getAppearOffset(el) {\\n    return el && el.getAttribute('appear-offset');\\n  }\\n\\n  function updateWatchAppearList(container) {\\n    container._watchAppearList = Array.prototype.slice.call(container.querySelectorAll('[weex-appear]'));\\n  }\\n\\n  /**\\n   * inject removeChild function to watch disappear and offsetDisappear events.\\n   */\\n  if (!window._rmInjected) {\\n    window._rmInjected = true;\\n    var nativeRemove = HTMLElement.prototype.removeChild;\\n    HTMLElement.prototype.removeChild = function (el) {\\n      el._visible && triggerAppearEvent(el, 'disappear', null);\\n      el._offsetVisible && triggerAppearEvent(el, 'offsetDisappear', null);\\n      nativeRemove.apply(this, arguments);\\n    };\\n  }\\n\\n  /**\\n   * Watch element's visibility to tell whether should trigger a appear/disappear\\n   * event in scroll handler.\\n   */\\n  function watchAppear(context, fireNow) {\\n    var el = context && context.$el;\\n    if (!el || el.nodeType !== 1) {\\n      return;\\n    }\\n\\n    var isWindow = false;\\n    var container = getParentScrollerElement(context);\\n    if (!container) {\\n      return;\\n    }\\n    if (container === document.body) {\\n      isWindow = true;\\n    }\\n    /**\\n     * Code below will only exec once for binding scroll handler for parent container.\\n     */\\n    var scrollHandler = container._scrollHandler;\\n    if (!scrollHandler) {\\n      scrollHandler = container._scrollHandler = function (event$$1) {\\n        updateWatchAppearList(container);\\n        /**\\n         * detect scrolling direction.\\n         * direction only support up & down yet.\\n         * TODO: direction support left & right.\\n         */\\n        var scrollTop = isWindow ? window.pageYOffset : container.scrollTop;\\n        var preTop = container._lastScrollTop;\\n        container._lastScrollTop = scrollTop;\\n        var dir = (scrollTop < preTop ? 'down' : scrollTop > preTop ? 'up' : container._prevDirection) || null;\\n        container._prevDirection = dir;\\n        var watchAppearList = container._watchAppearList || [];\\n        var len = watchAppearList.length;\\n        for (var i = 0; i < len; i++) {\\n          var el = watchAppearList[i];\\n          var appearOffset = getAppearOffset(el);\\n          var visibleData = isElementVisible(el, container, dir, appearOffset);\\n          detectAppear(el, visibleData, dir);\\n        }\\n      };\\n      container.addEventListener('scroll', throttle(scrollHandler, 100, true));\\n    }\\n    if (fireNow) {\\n      context.$nextTick(scrollHandler);\\n    }\\n  }\\n\\n  /**\\n   * decide whether to trigger a appear/disappear event.\\n   * @param {VueComponent} context\\n   * @param {boolean} visible\\n   * @param {string} dir\\n   */\\n  function detectAppear(el, visibleData, dir, appearOffset) {\\n    if (dir === void 0) dir = null;\\n\\n    if (!el) {\\n      return;\\n    }\\n    var visible = visibleData[0];\\n    var offsetVisible = visibleData[1];\\n    /**\\n     * No matter it's binding appear/disappear or both of them. Always\\n     * should test it's visibility and change the el._visible.\\n     * If neigher has been bound, then ignore it.\\n     */\\n    /**\\n     * if the component hasn't appeared for once yet, then it shouldn't trigger\\n     * a disappear event at all.\\n     */\\n    if (el._appearedOnce || visible) {\\n      if (el._visible !== visible) {\\n        el._visible = visible;\\n        if (visible && !el._appearedOnce) {\\n          el._appearedOnce = true;\\n        }\\n        var evtName = visible ? 'appear' : 'disappear';\\n        if (el.getAttribute(\\\"data-evt-\\\" + evtName) === '') {\\n          triggerAppearEvent(el, evtName, dir);\\n        }\\n      }\\n    }\\n    if (el._offsetAppearedOnce || offsetVisible) {\\n      if (el._offsetVisible !== offsetVisible) {\\n        el._offsetVisible = offsetVisible;\\n        if (offsetVisible && !el._offsetAppearedOnce) {\\n          el._offsetAppearedOnce = true;\\n        }\\n        var evt = offsetVisible ? ['offset-appear', 'offsetAppear'] : ['offset-disappear', 'offsetDisappear'];\\n        if (el.getAttribute(\\\"data-evt-\\\" + evt[0]) === '') {\\n          triggerAppearEvent(el, evt[1], dir);\\n        }\\n      }\\n    }\\n  }\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n\\n  var lazyloadAttr = 'data-img-src';\\n  var placeholderAttr = 'placeholder';\\n\\n  function preLoadImg(src, loadCallback, errorCallback) {\\n    var img = new Image();\\n    img.onload = loadCallback ? loadCallback.bind(img) : null;\\n    img.onerror = errorCallback ? errorCallback.bind(img) : null;\\n    img.src = src;\\n  }\\n\\n  function applySrc(item, src, placeholderSrc) {\\n    if (!src) {\\n      return;\\n    }\\n    function finallCb() {\\n      delete item._src_loading;\\n    }\\n\\n    if (window._processImgSrc) {\\n      src = window._processImgSrc(src, item);\\n      if (placeholderSrc) {\\n        placeholderSrc = window._processImgSrc(placeholderSrc, item);\\n      }\\n    }\\n\\n    if (item._src_loading === src) {\\n      return;\\n    }\\n\\n    /**\\n     * 1. apply src immediately in case javscript blocks the image loading\\n     *  before next tick.\\n     */\\n    item.style.backgroundImage = \\\"url(\\\" + (src || '') + \\\")\\\";\\n    item.removeAttribute(lazyloadAttr);\\n    /**\\n     * 2. then load the img src with Image constructor (but would not post\\n     *  a request again), just to trigger the load event.\\n     */\\n    item._src_loading = src;\\n    preLoadImg(src, function (evt) {\\n      item.style.backgroundImage = \\\"url(\\\" + (src || '') + \\\")\\\";\\n      var ref = this;\\n      var naturalWidth = ref.width;\\n      var naturalHeight = ref.height;\\n      var params = {\\n        success: true,\\n        size: { naturalWidth: naturalWidth, naturalHeight: naturalHeight }\\n      };\\n      dispatchNativeEvent(item, 'load', params);\\n      finallCb();\\n    }, function (evt) {\\n      var params = {\\n        success: false,\\n        size: { naturalWidth: 0, naturalHeight: 0 }\\n      };\\n      dispatchNativeEvent(item, 'load', params);\\n      if (placeholderSrc) {\\n        preLoadImg(placeholderSrc, function () {\\n          item.style.backgroundImage = \\\"url(\\\" + (placeholderSrc || '') + \\\")\\\";\\n        });\\n      }\\n      finallCb();\\n    });\\n  }\\n\\n  function getCtScroller(el) {\\n    if (!el) {\\n      return;\\n    }\\n    var scroller = el._ptScroller;\\n    if (!scroller) {\\n      var pt = el.parentElement;\\n      while (pt && pt !== document.body) {\\n        if ((pt.className + '' || '').match(/weex-list|weex-scroller|weex-waterfall/)) {\\n          scroller = pt;\\n          break;\\n        }\\n        pt = pt.parentElement;\\n      }\\n      scroller = pt;\\n      el._ptScroller = pt;\\n    }\\n    return scroller;\\n  }\\n\\n  function fireLazyload(el, ignoreVisibility) {\\n    if (Array.isArray(el)) {\\n      return el.forEach(function (ct) {\\n        return fireLazyload(ct);\\n      });\\n    }\\n    el = el || document.body;\\n    if (!el) {\\n      return;\\n    }\\n    var imgs = (el || document.body).querySelectorAll(\\\"[\\\" + lazyloadAttr + \\\"]\\\");\\n    if (el.getAttribute(lazyloadAttr)) {\\n      imgs = [el];\\n    }\\n    for (var i = 0; i < imgs.length; i++) {\\n      var img = imgs[i];\\n      if (typeof ignoreVisibility === 'boolean' && ignoreVisibility) {\\n        applySrc(img, img.getAttribute(lazyloadAttr), img.getAttribute(placeholderAttr));\\n      } else if (isElementVisible(img, getCtScroller(el))[0]) {\\n        applySrc(img, img.getAttribute(lazyloadAttr), img.getAttribute(placeholderAttr));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * cache a throttle lazyload function for every container element\\n   * once for different wait times separate.\\n   *   the architecture of this cache:\\n   *      cache: {\\n   *        el.id: {\\n   *          wait: throttledFunction () { ... }\\n   *        }\\n   *      }\\n   */\\n  var cache = {};\\n  var _uid$2 = 1;\\n  function getThrottleLazyload(wait, el) {\\n    if (wait === void 0) wait = 16;\\n    if (el === void 0) el = document.body;\\n\\n    var id = +(el && el.dataset.throttleId);\\n    if (isNaN(id) || id <= 0) {\\n      id = _uid$2++;\\n      el && el.setAttribute('data-throttle-id', id + '');\\n    }\\n\\n    !cache[id] && (cache[id] = {});\\n    var throttled = cache[id][wait] || (cache[id][wait] = throttle(fireLazyload.bind(this, el), parseFloat(wait),\\n    // true for callLastTime.\\n    // to trigger once more time after the last throttled function called with a little more delay.\\n    true));\\n    return throttled;\\n  }\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n\\n  var bindingStyleNamesForPx2Rem = config.bindingStyleNamesForPx2Rem;\\n\\n  // whether to support using 0.5px to paint 1px width border.\\n  var _supportHairlines;\\n  function supportHairlines() {\\n    if (typeof _supportHairlines === 'undefined') {\\n      var dpr = window.devicePixelRatio;\\n      if (dpr && dpr >= 2 && document.documentElement) {\\n        var docElm = document.documentElement;\\n        var testElm = document.createElement('div');\\n        var fakeBody = document.createElement('body');\\n        var beforeNode = docElm.firstElementChild || docElm.firstChild;\\n        testElm.style.border = '0.5px solid transparent';\\n        fakeBody.appendChild(testElm);\\n        docElm.insertBefore(fakeBody, beforeNode);\\n        _supportHairlines = testElm.offsetHeight === 1;\\n        docElm.removeChild(fakeBody);\\n      } else {\\n        _supportHairlines = false;\\n      }\\n    }\\n    return _supportHairlines;\\n  }\\n\\n  var support = null;\\n\\n  function supportSticky() {\\n    if (support !== null) {\\n      return support;\\n    }\\n    var element = window.document.createElement('div');\\n    var elementStyle = element.style;\\n    elementStyle.cssText = 'position:-webkit-sticky;position:sticky;';\\n    support = elementStyle.position.indexOf('sticky') !== -1;\\n    return support;\\n  }\\n\\n  /**\\n   * get transformObj\\n   */\\n  function getTransformObj(elm) {\\n    var styleObj = {};\\n    if (!elm) {\\n      return styleObj;\\n    }\\n    var transformStr = elm.style.webkitTransform || elm.style.mozTransform || elm.style.transform;\\n    if (transformStr && transformStr.match(/(?: *(?:translate|rotate|scale)[^(]*\\\\([^(]+\\\\))+/i)) {\\n      styleObj = transformStr.trim().replace(/, +/g, ',').split(' ').reduce(function (pre, str) {\\n        ['translate', 'scale', 'rotate'].forEach(function (name) {\\n          if (new RegExp(name, 'i').test(str)) {\\n            pre[name] = str;\\n          }\\n        });\\n        return pre;\\n      }, {});\\n    }\\n    return styleObj;\\n  }\\n\\n  /**\\n   * translate a transform string from a transformObj.\\n   */\\n  function getTransformStr(obj) {\\n    return Object.keys(obj).reduce(function (pre, key) {\\n      return pre + obj[key] + ' ';\\n    }, '');\\n  }\\n\\n  /**\\n   * add transform style to element.\\n   * @param {HTMLElement} elm\\n   * @param {object} style: transform object, format is like this:\\n   *   {\\n   *     translate: 'translate3d(2px, 2px, 2px)',\\n   *     scale: 'scale(0.2)',\\n   *     rotate: 'rotate(30deg)'\\n   *   }\\n   * @param {boolean} replace: whether to replace all transform properties.\\n   */\\n  function addTransform(elm, style, replace) {\\n    if (!style) {\\n      return;\\n    }\\n    var styleObj = {};\\n    if (!replace) {\\n      styleObj = getTransformObj(elm);\\n    }\\n    for (var key in style) {\\n      var val = style[key];\\n      if (val) {\\n        styleObj[key] = val;\\n      }\\n    }\\n    var resStr = getTransformStr(styleObj);\\n    elm.style.webkitTransform = resStr;\\n    elm.style.mozTransform = resStr;\\n    elm.style.transform = resStr;\\n  }\\n\\n  /**\\n   * copy a transform behaviour from one element to another.\\n   * key could be: 'translate' | 'scale' | 'rotate'\\n   */\\n  function copyTransform(from, to, key) {\\n    var str;\\n    if (!key) {\\n      str = from.style.webkitTransform || from.style.mozTransform || from.style.transform;\\n    } else {\\n      var fromObj = getTransformObj(from);\\n      if (!fromObj[key]) {\\n        return;\\n      }\\n      var toObj = getTransformObj(to);\\n      toObj[key] = fromObj[key];\\n      str = getTransformStr(toObj);\\n    }\\n    to.style.webkitTransform = str;\\n    to.style.mozTransform = str;\\n    to.style.transform = str;\\n  }\\n\\n  /**\\n   * get color's r, g, b value.\\n   * @param {string} color support all kinds of value of color.\\n   */\\n  function getRgb(color) {\\n    var haxReg = /#([\\\\da-fA-F]{2})([\\\\da-fA-F]{2})([\\\\da-fA-F]{2})/;\\n    var rgbReg = /rgb\\\\((\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+)\\\\)/;\\n    var span = document.createElement('span');\\n    var body = document.body;\\n    span.style.cssText = \\\"color: \\\" + color + \\\"; width: 0px; height: 0px;\\\";\\n    body && body.appendChild(span);\\n    color = window.getComputedStyle(span).color + '';\\n    body && body.removeChild(span);\\n\\n    var match;\\n    match = color.match(haxReg);\\n    if (match) {\\n      return {\\n        r: parseInt(match[1], 16),\\n        g: parseInt(match[2], 16),\\n        b: parseInt(match[3], 16)\\n      };\\n    }\\n    match = color.match(rgbReg);\\n    if (match) {\\n      return {\\n        r: parseInt(match[1]),\\n        g: parseInt(match[2]),\\n        b: parseInt(match[3])\\n      };\\n    }\\n  }\\n\\n  /**\\n   * get style sheet with owner node's id\\n   * @param {string} id owner node id.\\n   */\\n  function getStyleSheetById(id) {\\n    if (!id) {\\n      return;\\n    }\\n    var styleSheets = document.styleSheets;\\n    var len = styleSheets.length;\\n    for (var i = 0; i < len; i++) {\\n      var styleSheet = styleSheets[i];\\n      if (styleSheet.ownerNode.id === id) {\\n        return styleSheet;\\n      }\\n    }\\n  }\\n\\n  function getChildrenTotalWidth(children) {\\n    var len = children.length;\\n    var total = 0;\\n    for (var i = 0; i < len; i++) {\\n      total += children[i].getBoundingClientRect().width;\\n    }\\n    return total;\\n  }\\n  /**\\n   * get total content width of the element.\\n   * @param {HTMLElement} elm\\n   */\\n  function getRangeWidth(elm) {\\n    var children = elm.children;\\n    if (!children) {\\n      return elm.getBoundingClientRect().width;\\n    }\\n    if (!Range) {\\n      return getChildrenTotalWidth(children);\\n    }\\n    var range = document.createRange();\\n    if (!range.selectNodeContents) {\\n      return getChildrenTotalWidth(children);\\n    }\\n    range.selectNodeContents(elm);\\n    return range.getBoundingClientRect().width;\\n  }\\n\\n  /**\\n   * px2rem and camelize keys.\\n   */\\n  function styleObject2rem(style, rootValue) {\\n    var obj = {};\\n    for (var k in style) {\\n      var camK = camelize(k);\\n      if (bindingStyleNamesForPx2Rem.indexOf(camK) > -1) {\\n        obj[camK] = px2rem(style[k] + '', rootValue);\\n      } else {\\n        obj[camK] = style[k];\\n      }\\n    }\\n    return obj;\\n  }\\n\\n  function px2rem(px, rootValue) {\\n    return px.replace(/([+-]?\\\\d+(?:.\\\\d*)?)([p|w]x)/g, function ($0, $1, $2) {\\n      if ($2 === 'wx') {\\n        // 'wx' -> px\\n        return $1 + 'px';\\n      } else {\\n        // 'px' -> rem\\n        var pxVal = parseFloat($1);\\n        var sign = pxVal > 0 ? 1 : pxVal < 0 ? -1 : 0;\\n        if (Math.abs(pxVal) <= 1) {\\n          return supportHairlines() ? sign * 0.5 + \\\"px\\\" : sign * 1 + \\\"px\\\";\\n        }\\n        return pxVal / (rootValue || window.weex.config.env.rem) + 'rem';\\n      }\\n    });\\n  }\\n\\n  function rem2px(rem, rootValue) {\\n    return rem.replace(/([+-]?\\\\d+(?:.\\\\d*)?)rem/g, function ($0, $1) {\\n      return parseFloat($1) * (rootValue || window.weex.config.env.rem) + 'px';\\n    });\\n  }\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n\\n  var utils = Object.freeze({\\n    extend: extend,\\n    extendTruthy: extendTruthy,\\n    extendKeys: extendKeys,\\n    extractKeys: extractKeys,\\n    bind: bind,\\n    debounce: debounce,\\n    depress: depress,\\n    throttle: throttle,\\n    loopArray: loopArray,\\n    cached: cached,\\n    camelize: camelize,\\n    camelizeKeys: camelizeKeys,\\n    capitalize: capitalize,\\n    hyphenate: hyphenate,\\n    hyphenateKeys: hyphenateKeys,\\n    hyphenateStyleKeys: hyphenateStyleKeys,\\n    camelToKebab: camelToKebab,\\n    appendCss: appendCss,\\n    nextFrame: nextFrame,\\n    toCSSText: toCSSText,\\n    supportsPassive: supportsPassive,\\n    createEvent: createEvent,\\n    createBubblesEvent: createBubblesEvent,\\n    createCustomEvent: createCustomEvent,\\n    dispatchNativeEvent: dispatchNativeEvent,\\n    mapFormEvents: mapFormEvents,\\n    contains: contains,\\n    insideA: insideA,\\n    getParentScroller: getParentScroller,\\n    getParentScrollerElement: getParentScrollerElement,\\n    hasIntersection: hasIntersection,\\n    isElementVisible: isElementVisible,\\n    getEventHandlers: getEventHandlers,\\n    watchAppear: watchAppear,\\n    detectAppear: detectAppear,\\n    applySrc: applySrc,\\n    fireLazyload: fireLazyload,\\n    getThrottleLazyload: getThrottleLazyload,\\n    supportHairlines: supportHairlines,\\n    supportSticky: supportSticky,\\n    getTransformObj: getTransformObj,\\n    getTransformStr: getTransformStr,\\n    addTransform: addTransform,\\n    copyTransform: copyTransform,\\n    getRgb: getRgb,\\n    getStyleSheetById: getStyleSheetById,\\n    getRangeWidth: getRangeWidth,\\n    styleObject2rem: styleObject2rem,\\n    px2rem: px2rem,\\n    rem2px: rem2px,\\n    isPlainObject: isPlainObject,\\n    isArray: isArray,\\n    isPrimitive: isPrimitive,\\n    isDef: isDef\\n  });\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  /**\\n   * get WXEnvironment info.\\n   * @param  {object} viewportInfo: info about viewport.\\n   * @param  {object} envInfo: info parsed from lib.env.\\n   */\\n  function initEnv(viewportInfo, envInfo) {\\n    var browserName = envInfo.browser ? envInfo.browser.name : navigator.appName;\\n    var browserVersion = envInfo.browser ? envInfo.browser.version.val : null;\\n    var osName = envInfo.os.name;\\n    if (osName.match(/(iPhone|iPad|iPod)/i)) {\\n      osName = 'iOS';\\n    } else if (osName.match(/Android/i)) {\\n      osName = 'android';\\n    }\\n    var osVersion = envInfo.os.version.val;\\n    var env = {\\n      platform: 'Web',\\n      weexVersion: '1.0.26',\\n      userAgent: navigator.userAgent,\\n      appName: browserName,\\n      appVersion: browserVersion,\\n      osName: osName,\\n      osVersion: osVersion,\\n      deviceModel: envInfo.os.name || null\\n    };\\n    /**\\n     * viewportInfo: scale, deviceWidth, deviceHeight. dpr\\n     */\\n    return extend(viewportInfo, env);\\n  }\\n\\n  // const viewportInfo = initViewport()\\n\\n  // 750 by default currently\\n  // const scale = viewportInfo.scale\\n\\n  // const units = {\\n  //   REM: 12 * scale,\\n  //   VW: viewportInfo.deviceWidth / 100,\\n  //   VH: viewportInfo.deviceHeight / 100,\\n  //   VMIN: Math.min(viewportInfo.deviceWidth, viewportInfo.deviceHeight) / 100,\\n  //   VMAX: Math.max(viewportInfo.deviceWidth, viewportInfo.deviceHeight) / 100,\\n  //   CM: 96 / 2.54 * scale,\\n  //   MM: 96 / 25.4 * scale,\\n  //   Q: 96 / 25.4 / 4 * scale,\\n  //   IN: 96 * scale,\\n  //   PT: 96 / 72 * scale,\\n  //   PC: 96 / 6 * scale,\\n  //   PX: scale\\n  // }\\n\\n  // Object.freeze(units)\\n  // Object.freeze(env)\\n\\n  // window.CSS_UNIT = units\\n  window.WXEnvironment = initEnv(init$1(), window.lib.env);\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  /* global Vue */\\n\\n  var weexModules = {};\\n  var _roots = [];\\n\\n  var weex$4 = {\\n    __vue__: null,\\n    utils: utils,\\n    // units: window.CSS_UNIT,\\n    config: {\\n      env: window.WXEnvironment,\\n      bundleUrl: location.href\\n    },\\n\\n    _components: {},\\n    _modules: weexModules,\\n\\n    _meta: {\\n      mounted: {},\\n      updated: {},\\n      destroyed: {},\\n      requiredModules: {},\\n      apiCalled: {},\\n      perf: {}\\n    },\\n\\n    document: {\\n      body: {}\\n    },\\n\\n    requireModule: function requireModule(moduleName) {\\n      var metaMod = weex$4._meta.requiredModules;\\n      if (!metaMod[moduleName]) {\\n        metaMod[moduleName] = 0;\\n      }\\n      metaMod[moduleName]++;\\n      return weexModules[moduleName];\\n    },\\n\\n    registerModule: function registerModule() {\\n      var args = [],\\n          len = arguments.length;\\n      while (len--) {\\n        args[len] = arguments[len];\\n      }return (ref = this).registerApiModule.apply(ref, args);\\n      var ref;\\n    },\\n\\n    support: function support(feature) {\\n      if (feature === void 0) feature = '';\\n\\n      var match = (feature + '').match(/@(component|module)\\\\/(\\\\w+)(.\\\\w+)?/);\\n      if (match) {\\n        var type = match[1];\\n        var mod = match[2];\\n        var method = match[3];\\n        method = method && method.replace(/^\\\\./, '');\\n        switch (type) {\\n          case 'component':\\n            return typeof this._components[mod] !== 'undefined';\\n          case 'module':\\n            var module = weexModules[mod];\\n            return module && method ? !!module[method] : !!module;\\n        }\\n      } else {\\n        console.warn(\\\"[vue-render] invalid argument for weex.support: \\\" + feature);\\n        return null;\\n      }\\n    },\\n\\n    /**\\n     * Register a new vue instance in this weex instance. Put its root element into weex.document.body.children, so\\n     * that user can use weex.document.body to walk through all dom structures in all vue instances in the page.\\n     */\\n    registerVueInstance: function registerVueInstance(instance) {\\n      if (!instance instanceof Vue) {\\n        return;\\n      }\\n      var root = instance.$root;\\n      if (!root || !root.$el) {\\n        return;\\n      }\\n      this.document.body.children.push(root.$el);\\n    },\\n\\n    // @deprecated\\n    require: function require() {\\n      var args = [],\\n          len = arguments.length;\\n      while (len--) {\\n        args[len] = arguments[len];\\n      }console.log(\\\"[Vue Render] \\\\\\\"weex.require\\\\\\\" is deprecated, please use \\\\\\\"weex.requireModule\\\\\\\" instead.\\\");\\n      return (ref = this).requireModule.apply(ref, args);\\n      var ref;\\n    },\\n\\n    // @deprecated\\n    // TODO: rename to registerModule\\n    registerApiModule: function registerApiModule(name, module, meta) {\\n      if (!weexModules[name]) {\\n        weexModules[name] = {};\\n      }\\n      if (!!meta && meta.registerType === 'assignment') {\\n        weexModules[name] = module;\\n      } else {\\n        var loop = function loop(key) {\\n          if (module.hasOwnProperty(key)) {\\n            weexModules[name][key] = function () {\\n              var called = weex$4._meta.apiCalled;\\n              if (!called[name]) {\\n                called[name] = {};\\n              }\\n              var calledMod = called[name];\\n              if (!calledMod[key]) {\\n                calledMod[key] = 0;\\n              }\\n              calledMod[key]++;\\n              return module[key].apply(weex$4, arguments);\\n            };\\n          }\\n        };\\n\\n        for (var key in module) {\\n          loop(key);\\n        }\\n      }\\n    },\\n\\n    registerComponent: function registerComponent(name, component) {\\n      if (!this.__vue__) {\\n        return console.log('[Vue Render] Vue is not found. Please import Vue.js before register a component.');\\n      }\\n      this._components[name] = 0;\\n      if (component._css) {\\n        var css = component._css.replace(/\\\\b[+-]?[\\\\d.]+rem;?\\\\b/g, function (m) {\\n          return parseFloat(m) * 75 * weex$4.config.env.scale + 'px';\\n        });\\n        appendCss(css, \\\"weex-cmp-\\\" + name);\\n        delete component._css;\\n      }\\n      this.__vue__.component(name, component);\\n    },\\n\\n    // @deprecated\\n    getRoot: function getRoot() {},\\n\\n    // @deprecated\\n    sender: {\\n      performCallback: function performCallback(callback, data, keepAlive) {\\n        if (typeof callback === 'function') {\\n          return callback(data);\\n        }\\n        return null;\\n      }\\n    },\\n\\n    // @deprecated\\n    install: function install(module) {\\n      module.init(this);\\n    }\\n  };\\n\\n  Object.defineProperty(weex$4.document.body, 'children', {\\n    get: function get() {\\n      return _roots;\\n    }\\n  });['on', 'once', 'off', 'emit'].forEach(function (method) {\\n    weex$4[method] = function () {\\n      var args = [],\\n          len = arguments.length;\\n      while (len--) {\\n        args[len] = arguments[len];\\n      }if (!this._vue) {\\n        this._vue = new this.__vue__();\\n      }\\n      return (ref = this._vue)[\\\"$\\\" + method].apply(ref, args);\\n      var ref;\\n    };\\n  });\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  function getInlineStyle(vnode) {\\n    var data = vnode.data || {};\\n    return extendTruthy({}, data.staticStyle, data.style);\\n  }\\n\\n  function extractComponentStyle(context) {\\n    return getComponentInlineStyle(context);\\n    // return getComponentStyle(context, true)\\n  }\\n\\n  function getComponentInlineStyle(context) {\\n    var vnode = context && context.$vnode;\\n    if (!vnode) {\\n      return {};\\n    }\\n    var style = {};\\n    while (vnode) {\\n      extend(style, getInlineStyle(vnode));\\n      vnode = vnode.parent;\\n    }\\n    return style;\\n  }\\n\\n  var text$2 = {\\n    transform: function transform(style) {\\n      var lines = style.lines;\\n      if (lines > 0) {\\n        return Object.assign(style, {\\n          overflow: 'hidden',\\n          textOverflow: 'ellipsis',\\n          WebkitLineClamp: lines\\n        });\\n      }\\n      return style;\\n    }\\n  };\\n\\n  var tagMap$1 = {\\n    text: text$2\\n  };\\n\\n  var getTransformer$1 = function getTransformer$1(tag) {\\n    return tagMap$1[tag];\\n  };\\n\\n  var transformer = {\\n    getTransformer: getTransformer$1\\n  };\\n\\n  var getTransformer = transformer.getTransformer;\\n\\n  var getTransformer_1 = getTransformer;\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  var weexBuiltInComponents = config.weexBuiltInComponents;\\n\\n  var appearEventsMap = {\\n    appear: 'appear',\\n    disappear: 'disappear',\\n    offsetAppear: 'offset-appear',\\n    offsetDisappear: 'offset-disappear'\\n  };\\n\\n  /**\\n   * remove text nodes in the nodes array.\\n   * @param  {Array} nodes\\n   * @return {Array} nodes without text nodes.\\n   */\\n  function trimTextVNodes(vnodes) {\\n    if (isArray(vnodes)) {\\n      return vnodes.filter(function (vnode) {\\n        return !!vnode.tag;\\n      });\\n    }\\n    return vnodes;\\n  }\\n\\n  /**\\n   * ==================================================\\n   * method to transform args passed to createElement\\n   * for render function.\\n   * ==================================================\\n   */\\n\\n  // should share with precompiler.\\n  var metaMap = {\\n    figure: ['img', 'image', 'figure'],\\n    p: ['text', 'p'],\\n    div: ['container', 'div'],\\n    section: ['cell']\\n  };\\n\\n  var checkMap = Object.keys(metaMap).reduce(function (pre, targetTag) {\\n    var tagArr = metaMap[targetTag];\\n    tagArr.forEach(function (fromTag) {\\n      pre[fromTag] = targetTag;\\n    });\\n    return pre;\\n  }, {});\\n\\n  var _stdTagMap = {\\n    p: 'text',\\n    figure: 'image',\\n    section: 'cell'\\n  };\\n  function getStdTag(tag) {\\n    var stdTag = _stdTagMap[tag];\\n    return stdTag || tag;\\n  }\\n\\n  var precompiledClassMap = {\\n    div: {\\n      'weex-ct': true,\\n      'weex-div': true\\n    },\\n    image: {\\n      'weex-el': true,\\n      'weex-image': true\\n    },\\n    text: {\\n      'weex-el': true,\\n      'weex-text': true\\n    },\\n    cell: {\\n      'weex-ct': true,\\n      'weex-cell': true\\n    },\\n    a: {\\n      'weex-ct': true,\\n      'weex-a': true\\n    }\\n  };\\n\\n  function isPrecompiled(tag) {\\n    return config.weexBuiltInComponents.indexOf(tag) > -1;\\n  }\\n\\n  function transformRender(ctx, h) {\\n    return function (tag, data, children, normalizationType, alwaysNormalize) {\\n      if (isArray(data) || isPrimitive(data)) {\\n        normalizationType = children;\\n        children = data;\\n        data = {};\\n      }\\n      if (!isDef(data)) {\\n        data = {};\\n      }\\n      if (isDef(data.is)) {\\n        tag = data.is;\\n      }\\n      if (typeof tag === 'string') {\\n        data = transformData(this, data, tag);\\n        tag = transformTag(this, tag);\\n      } else {\\n        // direct component options / constructor\\n        data = transformData(this, data, undefined);\\n      }\\n      return h.call(this, tag, data, children, normalizationType, alwaysNormalize);\\n    }.bind(ctx);\\n  }\\n\\n  function transformTag(ctx, tag) {\\n    var elementTag = checkMap[tag];\\n    return elementTag || tag;\\n  }\\n\\n  /**\\n   * Tell whether a element is contained in a element who has\\n   * a attribute 'bubble'=true.\\n   * @param {HTMLElement} el\\n   */\\n  // function inBubble (el) {\\n  //   if (typeof el._inBubble === 'boolean') {\\n  //     return el._inBubble\\n  //   }\\n  //   const parents = []\\n  //   let parent = el.parentElement\\n  //   let inBubble\\n  //   while (parent && parent !== document.body) {\\n  //     if (typeof parent._inBubble === 'boolean') {\\n  //       inBubble = parent._inBubble\\n  //       break\\n  //     }\\n  //     const attr = parent.getAttribute('bubble')\\n  //     if (attr !== '') {\\n  //       inBubble = attr === true || attr === 'true'\\n  //       break\\n  //     }\\n  //     parents.push(parent)\\n  //     parent = parent.parentElement\\n  //   }\\n  //   el._inBubble = inBubble\\n  //   for (let i = 0, l = parents.length; i < l; i++) {\\n  //     parents[i]._inBubble = inBubble\\n  //   }\\n  //   return inBubble\\n  // }\\n\\n  function bindEvents(ctx, evts, attrs, tag, appearAttached) {\\n    for (var key in evts) {\\n      var appearEvtName = appearEventsMap[key];\\n      if (appearEvtName) {\\n        attrs[\\\"data-evt-\\\" + appearEvtName] = '';\\n        if (!appearAttached.value) {\\n          appearAttached.value = true;\\n          attrs['weex-appear'] = '';\\n        }\\n      } else {\\n        attrs[\\\"data-evt-\\\" + key] = '';\\n        if (key !== 'click') {\\n          // should stop propagation by default.\\n          // TODO: should test inBubble first.\\n          var handler = evts[key];\\n          if (isArray(evts[key])) {\\n            handler.unshift(ctx.$stopPropagation);\\n          } else {\\n            evts[key] = [ctx.$stopPropagation, handler];\\n          }\\n        }\\n      }\\n    }\\n    if (evts.click) {\\n      evts.weex$tap = evts.click;\\n      evts.click = ctx.$stopOuterA;\\n    }\\n    if (evts.scroll) {\\n      evts.weex$scroll = evts.scroll;\\n      delete evts.scroll;\\n    }\\n  }\\n\\n  function transformOn(ctx, data, tag) {\\n    var on = data.on;\\n    var nativeOn = data.nativeOn;\\n    if (weexBuiltInComponents.indexOf(tag) > -1) {\\n      /**\\n       * for div, image, text, cell, a, ...\\n       * user should bind all events without .native.\\n       */\\n      nativeOn = null;\\n      delete data.nativeOn;\\n    }\\n    if (isDef(weex._components[tag])) {\\n      /**\\n       * for slider, list, ...\\n       * user should bind events without .native.\\n       * in our events handling, all events should transfer to\\n       * .native binding.\\n       */\\n      delete data.nativeOn;\\n      nativeOn = null;\\n      if (on) {\\n        nativeOn = data.nativeOn = on;\\n      }\\n      on = null;\\n      delete data.on;\\n    }\\n\\n    var attrs = data.attrs;\\n    if (!attrs) {\\n      attrs = data.attrs = {};\\n    }\\n\\n    var appearAttached = {\\n      value: false\\n    };\\n    if (on) {\\n      bindEvents(ctx, on, attrs, tag, appearAttached);\\n    }\\n    if (nativeOn) {\\n      bindEvents(ctx, nativeOn, attrs, tag, appearAttached);\\n    }\\n\\n    /**\\n     * binding a weex$tap to <a> element to stop propagation if there\\n     * is no bubbles=true flag showing on parents.\\n     */\\n    if (tag === 'a') {\\n      if (!on) {\\n        on = data.on = {};\\n      }\\n      // if (!checkBubble(el)) {\\n      var evt = on['weex$tap'];\\n      if (!evt) {\\n        on['weex$tap'] = ctx.$stopPropagation;\\n      } else if (Array.isArray(evt)) {\\n        evt.unshift(ctx.$stopPropagation);\\n      } else {\\n        evt = [ctx.$stopPropagation, evt];\\n      }\\n      // }\\n    }\\n  }\\n\\n  function transformClass(data, tag) {\\n    var classData = data.class;\\n    var tagClassObj = precompiledClassMap[tag];\\n    if (!classData) {\\n      classData = data.class = [];\\n    }\\n    if (classData && isArray(classData)) {\\n      data.class = classData.concat(Object.keys(tagClassObj));\\n    } else if ((typeof classData === 'undefined' ? 'undefined' : _typeof(classData)) === 'object') {\\n      Object.assign(classData, tagClassObj);\\n    }\\n  }\\n\\n  function transformStyle(ctx, data, tag) {\\n    var style = data.style;\\n    if (!style) {\\n      return;\\n    }\\n    var transformer = getTransformer_1(getStdTag(tag));\\n    if (transformer) {\\n      data.style = ctx._px2rem(transformer.transform(style), 75);\\n    } else {\\n      data.style = ctx._px2rem(style, 75);\\n    }\\n  }\\n\\n  /**\\n   * transformAttrs:\\n   *  - add weex-type attrs for precompiledTags.\\n   *  - image.resize: transform to directive weex-resize.\\n   */\\n  function transformAttrs(data, tag) {\\n    var attrs = data.attrs;\\n    var directives = data.directives;\\n    if (!attrs) {\\n      attrs = data.attrs = {};\\n    }\\n    attrs['weex-type'] = tag;\\n    if (tag === 'image') {\\n      var src = attrs.src;\\n      var resize = attrs.resize;\\n      if (src) {\\n        attrs['data-img-src'] = src;\\n      }\\n      if (resize) {\\n        if (!directives) {\\n          directives = data.directives = [];\\n        }\\n        directives.push({\\n          name: 'weex-resize',\\n          value: attrs.resize\\n        });\\n      }\\n    }\\n  }\\n\\n  function transformData(ctx, data, tag) {\\n    if (isArray(data)) {\\n      // parameter data is ommited.\\n      return data;\\n    }\\n    var isP = isPrecompiled(tag);\\n    // class\\n    isP && transformClass(data, tag);\\n    // style\\n    transformStyle(ctx, data, tag);\\n    // attrs\\n    isP && transformAttrs(data, tag);\\n    // on\\n    transformOn(ctx, data, tag);\\n    return data;\\n  }\\n\\n  function mapNativeEvents(ctx, map) {\\n    var eventMap = {};\\n    var loop = function loop(origEvent) {\\n      eventMap[origEvent] = function (evt) {\\n        var el = evt.target;\\n        dispatchNativeEvent(el, map[origEvent]);\\n      };\\n    };\\n\\n    for (var origEvent in map) {\\n      loop(origEvent);\\n    }return eventMap;\\n  }\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n\\n  var core = Object.freeze({\\n    extractComponentStyle: extractComponentStyle,\\n    getComponentInlineStyle: getComponentInlineStyle,\\n    trimTextVNodes: trimTextVNodes,\\n    transformRender: transformRender,\\n    transformTag: transformTag,\\n    transformData: transformData,\\n    mapNativeEvents: mapNativeEvents\\n  });\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  var scrollableTypes = config.scrollableTypes;\\n\\n  var lazyloadWatched = false;\\n  function watchLazyload() {\\n    lazyloadWatched = true;['scroll',\\n    // 'transitionend',\\n    // 'webkitTransitionEnd',\\n    // 'animationend',\\n    // 'webkitAnimationEnd',\\n    'resize'].forEach(function (evt) {\\n      window.addEventListener(evt, getThrottleLazyload(25, document.body));\\n    });\\n    /**\\n     * In case the users use the body's overflow to scroll. Then the scroll\\n     * event would not be triggered on the window object but on the body.\\n     */\\n    document.body.addEventListener('scroll', getThrottleLazyload(25, document.body));\\n  }\\n\\n  var idCnt = 0;\\n  var appearWatched = false;\\n\\n  /**\\n   * during updating, the appear watcher binding on the appearWatched context\\n   * should be triggered within a debounced wrapper.\\n   * If the updating interval is shorter then 50 ms, then the appear events will\\n   * ignore the change in the previous 50 ms due to the debounce wrapper.\\n   */\\n  var debouncedWatchAppear = debounce(function () {\\n    watchAppear(appearWatched, true);\\n  }, 50);\\n\\n  /**\\n   * if it's a scrollable tag, then watch appear events for it.\\n   */\\n  function watchAppearForScrollables(tagName, context) {\\n    // when this is a scroller/list/waterfall\\n    if (scrollableTypes.indexOf(tagName) > -1) {\\n      var sd = context.scrollDirection;\\n      if (!sd || sd !== 'horizontal') {\\n        appearWatched = context;\\n        watchAppear(context, true);\\n      }\\n    }\\n  }\\n\\n  var base$1 = {\\n    beforeCreate: function beforeCreate() {\\n      if (!lazyloadWatched) {\\n        watchLazyload();\\n      }\\n    },\\n\\n    updated: function updated() {\\n      var el = this.$el;\\n      if (!el || el.nodeType !== 1) {\\n        return;\\n      }\\n      if (this._rootId) {\\n        if (el.className.indexOf('weex-root') <= -1) {\\n          el.classList.add('weex-root');\\n          el.classList.add('weex-ct');\\n          el.setAttribute('data-wx-root-id', this._rootId);\\n        }\\n      }\\n\\n      var tagName = this.$options && this.$options._componentTag;\\n      var metaUp = weex._meta.updated;\\n      if (!metaUp[tagName]) {\\n        metaUp[tagName] = 0;\\n      }\\n      metaUp[tagName]++;\\n      // will check appearing when no other changes in latest 50ms.\\n      debouncedWatchAppear();\\n      /**\\n       * since the updating of component may affect the layout, the lazyloading should\\n       * be fired.\\n       */\\n      this._fireLazyload();\\n    },\\n\\n    mounted: function mounted() {\\n      var tagName = this.$options && this.$options._componentTag;\\n      var el = this.$el;\\n      if (!el || el.nodeType !== 1) {\\n        return;\\n      }\\n      if (typeof weex._components[tagName] !== 'undefined') {\\n        weex._components[tagName]++;\\n      }\\n      var metaMt = weex._meta.mounted;\\n      if (!metaMt[tagName]) {\\n        metaMt[tagName] = 0;\\n      }\\n      metaMt[tagName]++;\\n\\n      watchAppearForScrollables(tagName, this);\\n\\n      // when this is the root element of Vue instance.\\n      if (this === this.$root) {\\n        var rootId = \\\"wx-root-\\\" + idCnt++;\\n        if (!weex._root) {\\n          weex._root = {};\\n        }\\n        weex._root[rootId] = this;\\n        this._rootId = rootId;\\n        if (el.nodeType !== 1) {\\n          return;\\n        }\\n        el.classList.add('weex-root');\\n        el.classList.add('weex-ct');\\n        el.setAttribute('data-wx-root-id', rootId);\\n\\n        /**\\n         * there's no scrollable component in this page. That is to say,\\n         * the page is using body scrolling instead of scrollabe components.\\n         * Then the appear watcher should be attached on the body.\\n         */\\n        if (!appearWatched) {\\n          appearWatched = this;\\n          watchAppear(this, true);\\n        }\\n\\n        this._fireLazyload(el);\\n      }\\n\\n      // give warning for not using $processStyle in vue-loader config.\\n      // if (!warned && !window._style_processing_added) {\\n      //   warnProcessStyle()\\n      // }\\n    },\\n\\n    destroyed: function destroyed() {\\n      var el = this.$el;\\n      if (!el || el.nodeType !== 1) {\\n        return;\\n      }\\n      /**\\n       * if the destroyed element is above another panel with images inside, and the images\\n       * moved into the viewport, then the lazyloading should be triggered.\\n       */\\n      if (this._rootId) {\\n        delete weex._root[this._rootId];\\n        delete this._rootId;\\n      }\\n      var tagName = this.$options && this.$options._componentTag;\\n      if (typeof weex._components[tagName] !== 'undefined') {\\n        weex._components[tagName]--;\\n      }\\n      var metaDs = weex._meta.destroyed;\\n      if (!metaDs[tagName]) {\\n        metaDs[tagName] = 0;\\n      }\\n      metaDs[tagName]++;\\n      this._fireLazyload();\\n    },\\n\\n    methods: {\\n      _fireLazyload: function _fireLazyload(el) {\\n        getThrottleLazyload(25, el || document.body)();\\n      }\\n    }\\n  };\\n\\n  var event$1 = {\\n    methods: {\\n      // deprecated.\\n      $stopOutterA: function $stopOutterA(e) {\\n        return this.$stopOuterA(e);\\n      },\\n\\n      $stopOuterA: function $stopOuterA(e) {\\n        if (e && e.preventDefault && e.target) {\\n          if (insideA(e.target)) {\\n            e.preventDefault();\\n          }\\n        }\\n      },\\n\\n      $stopPropagation: function $stopPropagation(e) {\\n        if (e && e.stopPropagation) {\\n          e.stopPropagation();\\n        }\\n      }\\n    }\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n\\n  var bindingStyleNamesForPx2Rem$1 = config.bindingStyleNamesForPx2Rem;\\n\\n  var style = {\\n    methods: {\\n      _px2rem: function _px2rem(value, rootValue) {\\n        var this$1 = this;\\n\\n        if (typeof value === 'string') {\\n          return (value + '').replace(/[+-]?\\\\d+(?:.\\\\d*)?[pw]x/gi, function ($0) {\\n            return weex.utils.px2rem($0, rootValue);\\n          });\\n        }\\n        if (typeof value === 'number') {\\n          return weex.utils.px2rem(value + '', rootValue);\\n        }\\n        if (isPlainObject(value)) {\\n          for (var k in value) {\\n            if (value.hasOwnProperty(k) && bindingStyleNamesForPx2Rem$1.indexOf(k) > -1) {\\n              value[k] = weex.utils.px2rem(value[k] + '', rootValue);\\n            }\\n          }\\n          return value;\\n        }\\n        if (isArray(value)) {\\n          for (var i = 0, l = value.length; i < l; i++) {\\n            this$1._px2rem(value[i], rootValue);\\n          }\\n          return value;\\n        }\\n      },\\n\\n      _processExclusiveStyle: function _processExclusiveStyle(styleObj, rootValue, tagName) {\\n        var transformer = getTransformer_1(tagName);\\n        return this._px2rem(transformer.transform(styleObj), rootValue);\\n      },\\n\\n      _getParentRect: function _getParentRect() {\\n        var el = this.$el;\\n        var parent = el && el.parentElement;\\n        return parent && parent.getBoundingClientRect();\\n      }\\n    }\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n\\n  // input and textare has some common api and event\\n  var findEnterKeyType = function findEnterKeyType(key) {\\n    var keys = ['default', 'go', 'next', 'search', 'send'];\\n    if (keys.indexOf(key) > -1) {\\n      return key;\\n    }\\n    return 'done';\\n  };\\n\\n  var inputCommon = {\\n    methods: {\\n      focus: function focus() {\\n        this.$el && this.$el.focus();\\n      },\\n      blur: function blur() {\\n        this.$el && this.$el.blur();\\n      },\\n\\n      setSelectionRange: function setSelectionRange(start, end) {\\n        try {\\n          this.$el.setSelectionRange(start, end);\\n        } catch (e) {}\\n      },\\n\\n      getSelectionRange: function getSelectionRange(callback) {\\n        try {\\n          var selection = window.getSelection();\\n          var str = selection.toString();\\n          var selectionStart = this.$el.value.indexOf(str);\\n          var selectionEnd = selectionStart === -1 ? selectionStart : selectionStart + str.length;\\n          callback && callback({\\n            selectionStart: selectionStart,\\n            selectionEnd: selectionEnd\\n          });\\n        } catch (e) {\\n          callback && callback(new Error('[vue-render] getSelection is not supported.'));\\n        }\\n      },\\n\\n      getEditSelectionRange: function getEditSelectionRange(callback) {\\n        this.getSelectionRange(callback);\\n      },\\n\\n      // support enter key event\\n      createKeyboardEvent: function createKeyboardEvent(events) {\\n        var customKeyType = this.returnKeyType;\\n        if (customKeyType) {\\n          var keyboardEvents = {\\n            'keyup': function keyup(ev) {\\n              var code = ev.keyCode;\\n              var key = ev.key;\\n              if (code === 13) {\\n                if (!key || key.toLowerCase() === 'tab') {\\n                  key = 'next';\\n                }\\n                dispatchNativeEvent(ev.target, 'return', {\\n                  key: key,\\n                  returnKeyType: findEnterKeyType(customKeyType),\\n                  value: ev.target.value\\n                });\\n              }\\n            }\\n          };\\n          events = extend(events, keyboardEvents);\\n        }\\n        return events;\\n      }\\n    }\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  var sticky = {\\n    destroyed: function destroyed() {\\n      if (!this._stickyAdded) {\\n        return;\\n      }\\n      var scroller = getParentScroller(this);\\n      if (!scroller) {\\n        return;\\n      }\\n      delete scroller._stickyChildren[this._uid];\\n    },\\n\\n    methods: {\\n      _addSticky: function _addSticky() {\\n        var el = this.$el;\\n        if (!el || el.nodeType === 1) {\\n          return;\\n        }\\n        el.classList.add('sticky');\\n        if (!this._placeholder) {\\n          this._placeholder = el.cloneNode(true);\\n        }\\n        this._placeholder.style.display = 'block';\\n        this._placeholder.style.width = this.$el.offsetWidth + 'px';\\n        this._placeholder.style.height = this.$el.offsetHeight + 'px';\\n        el.parentNode.insertBefore(this._placeholder, this.$el);\\n      },\\n\\n      _removeSticky: function _removeSticky() {\\n        var el = this.$el;\\n        if (!el || el.nodeType === 1) {\\n          return;\\n        }\\n        el.classList.remove('sticky');\\n        if (this._placeholder) {\\n          this._placeholder.parentNode.removeChild(this._placeholder);\\n        }\\n        this._placeholder = null;\\n      }\\n    }\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  window.global = window;\\n  window.weex = weex$4;\\n\\n  weex$4._styleMap = {};['getComponentInlineStyle', 'extractComponentStyle', 'mapNativeEvents', 'trimTextVNodes'].forEach(function (method) {\\n    weex$4[method] = core[method].bind(weex$4);\\n  });\\n\\n  weex$4.mixins = {\\n    inputCommon: inputCommon\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  var _inited$1 = false;\\n\\n  var renderFunctionPlugin = {\\n    init: function init(weex) {\\n      if (_inited$1) {\\n        return;\\n      }\\n      _inited$1 = true;\\n      var Vue = weex.__vue__;\\n      var _render = Vue.prototype._render;\\n      Vue.prototype._render = function () {\\n        var weexRender = this._weexRender;\\n        var tag = this.$options && this.$options._componentTag;\\n        if (!weexRender && !isDef(weex._components[tag])) {\\n          var origRender = this.$options.render;\\n          weexRender = this._weexRender = function (h) {\\n            var args = [],\\n                len = arguments.length - 1;\\n            while (len-- > 0) {\\n              args[len] = arguments[len + 1];\\n            }return origRender.call.apply(origRender, [this, transformRender(this, h)].concat(args));\\n          };\\n          this.$options.render = weexRender;\\n        }\\n        return _render.call(this);\\n      };\\n    }\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  if (global.Vue) {\\n    setVue(global.Vue);\\n  }\\n\\n  function setVue(vue) {\\n    if (!vue) {\\n      throw new Error('[Vue Render] Vue not found. Please make sure vue 2.x runtime is imported.');\\n    }\\n    if (global.weex.__vue__) {\\n      return;\\n    }\\n    global.weex.__vue__ = vue;\\n    weex.install(renderFunctionPlugin);\\n    console.log(\\\"[Vue Render] install Vue \\\" + vue.version + \\\".\\\");\\n  }\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  /**\\n   * init weex.\\n   * @param  {Vue$2} Vue: Vue Constructor.\\n   * @param  {object} options: extend weex plugins.\\n   *         - components.\\n   *         - modules.\\n   */\\n  var _inited = false;\\n  function init(Vue /* options = {}*/) {\\n    if (_inited) {\\n      return;\\n    }\\n    _inited = true;\\n\\n    setVue(Vue);\\n\\n    Vue.prototype.$getConfig = function () {\\n      console.warn('[Vue Render] \\\"this.$getConfig\\\" is deprecated, please use \\\"weex.config\\\" instead.');\\n      return weex.config;\\n    };\\n\\n    var htmlRegex = /^html:/i;\\n    Vue.config.isReservedTag = function (tag) {\\n      return htmlRegex.test(tag);\\n    };\\n    Vue.config.parsePlatformTagName = function (tag) {\\n      return tag.replace(htmlRegex, '');\\n    };\\n\\n    function isWeexTag(tag) {\\n      return typeof weex._components[tag] !== 'undefined';\\n    }\\n    var oldGetTagNamespace = Vue.config.getTagNamespace;\\n    Vue.config.getTagNamespace = function (tag) {\\n      if (isWeexTag(tag)) {\\n        return;\\n      }\\n      return oldGetTagNamespace(tag);\\n    };\\n\\n    Vue.mixin(base$1);\\n    Vue.mixin(event$1);\\n    Vue.mixin(style);\\n    Vue.mixin(sticky);\\n  }\\n\\n  // auto init in dist mode.\\n  if (typeof window !== 'undefined' && window.Vue) {\\n    init(window.Vue);\\n  }\\n\\n  weex.init = init;\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n\\n  /**\\n   * @fileOverview Input component.\\n   * Support v-model only if vue version is larger than 2.2.0\\n   */\\n  var mapFormEvents$1;\\n  var appendCss$1;\\n\\n  var ID_PREFIX_PLACEHOLDER_COLOR = 'wipt_plc_';\\n  var ID_PREFIX_INPUT = 'wipt_';\\n  var idCount = 0;\\n\\n  function setPlaceholderColor(inputVm, placeholderColor) {\\n    if (!placeholderColor) {\\n      return;\\n    }\\n    var vendors = ['::-webkit-input-placeholder', ':-moz-placeholder', '::-moz-placeholder', ':-ms-input-placeholder', ':placeholder-shown'];\\n    var id = inputVm._id;\\n    appendCss$1(vendors.map(function (vendor, idx) {\\n      return \\\"#\\\" + ID_PREFIX_INPUT + id + vendors[idx] + \\\"{color:\\\" + placeholderColor + \\\";}\\\";\\n    }).join(''), \\\"\\\" + ID_PREFIX_PLACEHOLDER_COLOR + id, true);\\n  }\\n\\n  function processStyle(vm) {\\n    var styles = getComponentInlineStyle(vm);\\n    var phColor = styles.placeholderColor || styles['placeholder-color'];\\n    if (phColor) {\\n      setPlaceholderColor(vm, phColor);\\n    }\\n    return styles;\\n  }\\n\\n  function getInput(weex) {\\n    var ref = weex.mixins;\\n    var inputCommon = ref.inputCommon;\\n\\n    return {\\n      name: 'weex-input',\\n      mixins: [inputCommon],\\n      props: {\\n        type: {\\n          type: String,\\n          default: 'text',\\n          validator: function validator(value) {\\n            return ['email', 'number', 'password', 'search', 'tel', 'text', 'url', 'date', 'datetime', 'time'].indexOf(value) !== -1;\\n          }\\n        },\\n        value: String,\\n        placeholder: String,\\n        disabled: {\\n          type: [String, Boolean],\\n          default: false\\n        },\\n        autofocus: {\\n          type: [String, Boolean],\\n          default: false\\n        },\\n        maxlength: [String, Number],\\n        returnKeyType: String\\n      },\\n\\n      render: function render(createElement) {\\n        if (!this._id) {\\n          this._id = idCount++;\\n        }\\n        var events = mapFormEvents$1(this);\\n        return createElement('html:input', {\\n          attrs: {\\n            'weex-type': 'input',\\n            id: \\\"\\\" + ID_PREFIX_INPUT + this._id,\\n            type: this.type,\\n            value: this.value,\\n            disabled: this.disabled !== 'false' && this.disabled !== false,\\n            autofocus: this.autofocus !== 'false' && this.autofocus !== false,\\n            placeholder: this.placeholder,\\n            maxlength: this.maxlength,\\n            'returnKeyType': this.returnKeyType\\n          },\\n          domProps: {\\n            value: this.value\\n          },\\n          on: this.createKeyboardEvent(events),\\n          staticClass: 'weex-input weex-el',\\n          staticStyle: processStyle(this)\\n        });\\n      }\\n    };\\n  }\\n\\n  var input = {\\n    init: function init(weex) {\\n      mapFormEvents$1 = weex.utils.mapFormEvents;\\n      appendCss$1 = weex.utils.appendCss;\\n\\n      weex.registerComponent('input', getInput(weex));\\n    }\\n  };\\n\\n  __$styleInject(\\\"/*\\\\n * Licensed to the Apache Software Foundation (ASF) under one\\\\n * or more contributor license agreements.  See the NOTICE file\\\\n * distributed with this work for additional information\\\\n * regarding copyright ownership.  The ASF licenses this file\\\\n * to you under the Apache License, Version 2.0 (the\\\\n * \\\\\\\"License\\\\\\\"); you may not use this file except in compliance\\\\n * with the License.  You may obtain a copy of the License at\\\\n *\\\\n *   http://www.apache.org/licenses/LICENSE-2.0\\\\n *\\\\n * Unless required by applicable law or agreed to in writing,\\\\n * software distributed under the License is distributed on an\\\\n * \\\\\\\"AS IS\\\\\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\\\n * KIND, either express or implied.  See the License for the\\\\n * specific language governing permissions and limitations\\\\n * under the License.\\\\n */\\\\n\\\\n.weex-switch {\\\\n  border: 0.013333rem solid #dfdfdf;\\\\n  cursor: pointer;\\\\n  vertical-align: middle;\\\\n  -webkit-user-select: none;\\\\n     -moz-user-select: none;\\\\n      -ms-user-select: none;\\\\n          user-select: none;\\\\n  -webkit-box-sizing: content-box;\\\\n          box-sizing: content-box;\\\\n  background-clip: content-box;\\\\n  color: #64bd63;\\\\n  width: 1.333333rem;\\\\n  height: 0.8rem;\\\\n  background-color: white;\\\\n  border-color: #dfdfdf;\\\\n  -webkit-box-shadow: #dfdfdf 0 0 0 0 inset;\\\\n          box-shadow: #dfdfdf 0 0 0 0 inset;\\\\n  border-radius: 0.8rem;\\\\n  -webkit-transition: border 0.4s, background-color 1.2s, -webkit-box-shadow 0.4s;\\\\n  transition: border 0.4s, background-color 1.2s, -webkit-box-shadow 0.4s;\\\\n  transition: border 0.4s, box-shadow 0.4s, background-color 1.2s;\\\\n  transition: border 0.4s, box-shadow 0.4s, background-color 1.2s, -webkit-box-shadow 0.4s;\\\\n}\\\\n\\\\n.weex-switch-checked {\\\\n  background-color: #64bd63;\\\\n  border-color: #64bd63;\\\\n  -webkit-box-shadow: #64bd63 0 0 0 0.533333rem inset;\\\\n          box-shadow: #64bd63 0 0 0 0.533333rem inset;\\\\n}\\\\n\\\\n.weex-switch-checked.weex-switch-disabled {\\\\n  opacity: 0.3\\\\n}\\\\n\\\\n.weex-switch-disabled {\\\\n  background-color: #EEEEEE;\\\\n}\\\\n\\\\n.weex-switch-inner {\\\\n  width: 0.8rem;\\\\n  height: 0.8rem;\\\\n  background: #fff;\\\\n  border-radius: 100%;\\\\n  -webkit-box-shadow: 0 0.013333rem 0.04rem rgba(0, 0, 0, 0.4);\\\\n          box-shadow: 0 0.013333rem 0.04rem rgba(0, 0, 0, 0.4);\\\\n  position: absolute;\\\\n  top: 0;\\\\n  left: 0;\\\\n  -webkit-transition: background-color 0.4s, left 0.2s;\\\\n  transition: background-color 0.4s, left 0.2s;\\\\n}\\\\n\\\\n.weex-switch-checked > .weex-switch-inner {\\\\n  left: 0.533333rem;\\\\n}\\\\n\\\", undefined);\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  function getSwitch(weex) {\\n    var extractComponentStyle = weex.extractComponentStyle;\\n    var ref = weex.utils;\\n    var dispatchNativeEvent = ref.dispatchNativeEvent;\\n\\n    return {\\n      name: 'weex-switch',\\n      props: {\\n        checked: {\\n          type: [Boolean, String],\\n          default: false\\n        },\\n        disabled: {\\n          type: [Boolean, String],\\n          default: false\\n        },\\n        // Border color  when the switch is turned off\\n        tintColor: String,\\n        // Background color when the switch is turned on.\\n        onTintColor: String,\\n        // Color of the foreground switch grip.\\n        thumbTintColor: String\\n      },\\n      data: function data() {\\n        return {\\n          isChecked: this.checked !== 'false' && this.checked !== false,\\n          isDisabled: this.disabled !== 'false' && this.disabled !== false\\n        };\\n      },\\n      computed: {\\n        wrapperClass: function wrapperClass() {\\n          var classArray = ['weex-el', 'weex-switch'];\\n          this.isChecked && classArray.push('weex-switch-checked');\\n          this.isDisabled && classArray.push('weex-switch-disabled');\\n          return classArray.join(' ');\\n        },\\n        mergeStyle: function mergeStyle() {\\n          var style = extractComponentStyle(this);\\n          var ref = this;\\n          var tintColor = ref.tintColor;\\n          var onTintColor = ref.onTintColor;\\n          var isChecked = ref.isChecked;\\n          var isDisabled = ref.isDisabled;\\n\\n          if (!isChecked && tintColor) {\\n            Object.assign(style, {\\n              borderColor: tintColor,\\n              boxShadow: tintColor + \\\" 0 0 0 0 inset\\\"\\n            });\\n          }\\n\\n          if (isChecked && onTintColor) {\\n            Object.assign(style, {\\n              backgroundColor: onTintColor,\\n              color: onTintColor,\\n              borderColor: onTintColor,\\n              boxShadow: onTintColor + \\\" 0 0 0 0.533333rem inset\\\"\\n            });\\n          }\\n\\n          isDisabled && Object.assign(style, {\\n            opacity: 0.3\\n          });\\n\\n          return style;\\n        },\\n        smallStyle: function smallStyle() {\\n          var ref = this;\\n          var thumbTintColor = ref.thumbTintColor;\\n          var smallStyle = {};\\n\\n          if (thumbTintColor) {\\n            smallStyle = {\\n              background: thumbTintColor\\n            };\\n          }\\n          return smallStyle;\\n        }\\n      },\\n      methods: {\\n        toggle: function toggle() {\\n          // TODO: handle the events\\n          if (!this.isDisabled) {\\n            this.isChecked = !this.isChecked;\\n            dispatchNativeEvent(this.$el, 'change', { value: this.isChecked });\\n          }\\n        }\\n      },\\n\\n      mounted: function mounted() {\\n        var this$1 = this;\\n\\n        var el = this.$el;\\n        if (el && el.nodeType === 1) {\\n          if (!this._removeClickHandler) {\\n            var handler = function handler(evt) {\\n              this$1.toggle();\\n            };\\n            this._removeClickHandler = el.removeEventListener.bind(el, 'weex$tap', handler);\\n            el.addEventListener('weex$tap', handler);\\n          }\\n        }\\n      },\\n\\n      beforeDestroy: function beforeDestroy() {\\n        var rm = this._removeClickHandler;\\n        if (rm) {\\n          rm();\\n          delete this._removeClickHandler;\\n        }\\n      },\\n\\n      render: function render(createElement) {\\n        return createElement('span', {\\n          attrs: { 'weex-type': 'switch' },\\n          staticClass: this.wrapperClass,\\n          staticStyle: this.mergeStyle\\n        }, [createElement('small', {\\n          staticClass: 'weex-switch-inner',\\n          staticStyle: this.smallStyle\\n        })]);\\n      }\\n    };\\n  }\\n\\n  var _switch = {\\n    init: function init(weex) {\\n      weex.registerComponent('switch', getSwitch(weex));\\n    }\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n\\n  var DEFAULT_OFFSET_ACCURACY = 10;\\n  var DEFAULT_LOADMORE_OFFSET = 0;\\n\\n  function getThrottledScroll(context) {\\n    var scale = weex.config.env.scale;\\n    if (!context._throttleScroll) {\\n      var wrapper = context.$refs.wrapper;\\n      var inner = context.$refs.inner;\\n      var preOffset = (context.scrollDirection === 'horizontal' ? wrapper.scrollLeft : wrapper.scrollTop) || 0;\\n      context._throttleScroll = weex.utils.throttle(function (evt) {\\n        var offset = context.scrollDirection === 'horizontal' ? wrapper.scrollLeft : wrapper.scrollTop;\\n        var indent = parseInt(context.offsetAccuracy) * scale;\\n        function triggerScroll() {\\n          var rect = inner.getBoundingClientRect();\\n          var evtObj = {\\n            contentSize: { width: rect.width, height: rect.height },\\n            contentOffset: {\\n              x: wrapper.scrollLeft,\\n              /**\\n               * positive direciton for y-axis is down.\\n               * so should use negative operation on scrollTop.\\n               *\\n               *  (0,0)---------------\\x3e x\\n               *       |\\n               *       |\\n               *       |\\n               *       |\\n               *       v y\\n               *\\n               */\\n              y: -wrapper.scrollTop\\n            }\\n          };\\n          if (context.$el) {\\n            weex.utils.dispatchNativeEvent(context.$el, 'weex$scroll', evtObj);\\n          }\\n        }\\n        if (Math.abs(offset - preOffset) >= indent) {\\n          triggerScroll();\\n          preOffset = offset;\\n        }\\n      }, 16, true);\\n    }\\n    return context._throttleScroll;\\n  }\\n\\n  var scrollable$1 = {\\n    props: {\\n      loadmoreoffset: {\\n        type: [String, Number],\\n        default: DEFAULT_LOADMORE_OFFSET,\\n        validator: function validator(value) {\\n          var val = parseInt(value);\\n          return !isNaN(val) && val >= DEFAULT_LOADMORE_OFFSET;\\n        }\\n      },\\n\\n      offsetAccuracy: {\\n        type: [Number, String],\\n        default: DEFAULT_OFFSET_ACCURACY,\\n        validator: function validator(value) {\\n          var val = parseInt(value);\\n          return !isNaN(val) && val >= DEFAULT_OFFSET_ACCURACY;\\n        }\\n      }\\n    },\\n\\n    created: function created() {\\n      // should call resetLoadmore() to enable loadmore event.\\n      this._loadmoreReset = true;\\n    },\\n\\n    mounted: function mounted() {\\n      this.reloadStickyChildren();\\n    },\\n\\n    updated: function updated() {\\n      this.reloadStickyChildren();\\n    },\\n\\n    methods: {\\n      updateLayout: function updateLayout() {\\n        var wrapper = this.$refs.wrapper;\\n        if (wrapper) {\\n          var rect = wrapper.getBoundingClientRect();\\n          this._wrapperWidth = rect.width;\\n          this._wrapperHeight = rect.height;\\n        }\\n        var inner = this.$refs.inner;\\n        var children = inner && inner.children;\\n        if (inner) {\\n          var rect$1 = inner.getBoundingClientRect();\\n          this._innerWidth = rect$1.width;\\n          this._innerHeight = rect$1.height;\\n        }\\n        var loadingEl = this._loading && this._loading.$el;\\n        var refreshEl = this._refresh && this._refresh.$el;\\n        if (loadingEl) {\\n          this._innerHeight -= loadingEl.getBoundingClientRect().height;\\n        }\\n        if (refreshEl) {\\n          this._innerHeight -= refreshEl.getBoundingClientRect().height;\\n        }\\n        // inner width is always the viewport width somehow in horizontal\\n        // scoller, therefore the inner width should be reclaculated.\\n        if (this.scrollDirection === 'horizontal' && children) {\\n          this._innerWidth = weex.utils.getRangeWidth(inner);\\n        }\\n      },\\n\\n      resetLoadmore: function resetLoadmore() {\\n        this._loadmoreReset = true;\\n      },\\n\\n      /**\\n       * process sticky children in scrollable components.\\n       * current only support list and vertical scroller.\\n       */\\n      processSticky: function processSticky() {\\n        var this$1 = this;\\n\\n        /**\\n         * current browser support 'sticky' or '-webkit-sticky', so there's no need\\n         * to do further more.\\n         */\\n        var stickyChildren = this._stickyChildren;\\n        var len = stickyChildren && stickyChildren.length || 0;\\n        if (len <= 0) {\\n          return;\\n        }\\n\\n        var origSticky = weex.utils.supportSticky();\\n        // current only support list and vertical scroller.\\n        if (this.scrollDirection === 'horizontal') {\\n          return;\\n        }\\n\\n        var container = this.$el;\\n        if (!container) {\\n          return;\\n        }\\n        var scrollTop = container.scrollTop;\\n\\n        var stickyChild;\\n        for (var i = 0; i < len; i++) {\\n          stickyChild = stickyChildren[i];\\n          if (origSticky) {\\n            this$1.addSticky(stickyChild, origSticky);\\n          } else if (stickyChild._initOffsetTop < scrollTop) {\\n            this$1.addSticky(stickyChild);\\n          } else {\\n            this$1.removeSticky(stickyChild);\\n          }\\n        }\\n      },\\n\\n      addSticky: function addSticky(el, supportSticky) {\\n        if (supportSticky) {\\n          el.classList.add('weex-ios-sticky');\\n        } else {\\n          if (el._sticky === true) {\\n            return;\\n          }\\n          el._sticky = true;\\n          if (!el._placeholder) {\\n            var placeholder = el.cloneNode(true);\\n            placeholder._origNode = el;\\n            placeholder.classList.add('weex-sticky-placeholder');\\n            el._placeholder = placeholder;\\n          }\\n          el.parentNode.insertBefore(el._placeholder, el);\\n          el.style.width = window.getComputedStyle(el).width;\\n          el.classList.add('weex-sticky');\\n        }\\n      },\\n\\n      removeSticky: function removeSticky(el) {\\n        if (typeof el._sticky === 'undefined' || el._sticky === false) {\\n          return;\\n        }\\n        el._sticky = false;\\n        el.parentNode.removeChild(el._placeholder);\\n        el.classList.remove('weex-sticky');\\n      },\\n\\n      reloadStickyChildren: function reloadStickyChildren() {\\n        var container = this.$el;\\n        if (!container) {\\n          return;\\n        }\\n        var stickyChildren = [];\\n        var children = container.querySelectorAll('[sticky]');\\n        for (var i = 0, l = children.length; i < l; i++) {\\n          var child = children[i];\\n          if (/weex-sticky-placeholder/.test(child.className)) {\\n            // is a placeholder.\\n            var origNode = child._origNode;\\n            if (!origNode || !origNode.parentNode || origNode.parentNode !== child.parentNode) {\\n              child.parentNode.removeChild(child);\\n            }\\n          } else {\\n            // is a sticky node.\\n            stickyChildren.push(child);\\n            if (!child._sticky) {\\n              child._initOffsetTop = child.offsetTop;\\n            }\\n          }\\n        }\\n        this._stickyChildren = stickyChildren;\\n      },\\n\\n      handleScroll: function handleScroll(event) {\\n        weex.utils.getThrottleLazyload(25, this.$el, 'scroll')();\\n        getThrottledScroll(this)(event);\\n\\n        this.processSticky();\\n\\n        // fire loadmore event.\\n        var inner = this.$refs.inner;\\n        if (inner) {\\n          var innerLength = this.scrollDirection === 'horizontal' ? this._innerWidth : this._innerHeight;\\n          if (!this._innerLength) {\\n            this._innerLength = innerLength;\\n          }\\n          if (this._innerLength !== innerLength) {\\n            this._innerLength = innerLength;\\n            this._loadmoreReset = true;\\n          }\\n          if (this._loadmoreReset && this.reachBottom(this.loadmoreoffset)) {\\n            this._loadmoreReset = false;\\n            var el = this.$el;\\n            if (el) {\\n              weex.utils.dispatchNativeEvent(el, 'loadmore');\\n            }\\n          }\\n        }\\n      },\\n\\n      reachTop: function reachTop() {\\n        var wrapper = this.$refs.wrapper;\\n        return !!wrapper && wrapper.scrollTop <= 0;\\n      },\\n\\n      reachBottom: function reachBottom(offset) {\\n        var wrapper = this.$refs.wrapper;\\n        var inner = this.$refs.inner;\\n        offset = parseInt(offset || 0) * weex.config.env.scale;\\n\\n        if (wrapper && inner) {\\n          var key = this.scrollDirection === 'horizontal' ? 'width' : 'height';\\n          var innerLength = this[\\\"_inner\\\" + key[0].toUpperCase() + key.substr(1)];\\n          var wrapperLength = this[\\\"_wrapper\\\" + key[0].toUpperCase() + key.substr(1)];\\n          var scrollOffset = this.scrollDirection === 'horizontal' ? wrapper.scrollLeft : wrapper.scrollTop;\\n          return scrollOffset >= innerLength - wrapperLength - offset;\\n        }\\n        return false;\\n      },\\n\\n      handleTouchStart: function handleTouchStart(event) {\\n        if (this._loading || this._refresh) {\\n          var touch = event.changedTouches[0];\\n          this._touchParams = {\\n            reachTop: this.reachTop(),\\n            reachBottom: this.reachBottom(),\\n            startTouchEvent: touch,\\n            startX: touch.pageX,\\n            startY: touch.pageY,\\n            timeStamp: event.timeStamp\\n          };\\n        }\\n      },\\n\\n      handleTouchMove: function handleTouchMove(event) {\\n        if (!this._touchParams || !this._refresh && !this._loading) {\\n          return;\\n        }\\n        var inner = this.$refs.inner;\\n        var ref = this._touchParams;\\n        var startY = ref.startY;\\n        var reachTop = ref.reachTop;\\n        var reachBottom = ref.reachBottom;\\n        if (inner) {\\n          var touch = event.changedTouches[0];\\n          var offsetY = touch.pageY - startY;\\n          var dir = offsetY > 0 ? 'down' : 'up';\\n          this._touchParams.offsetY = offsetY;\\n          if (this._refresh && dir === 'down' && reachTop) {\\n            this._refresh.pullingDown(offsetY);\\n          } else if (this._loading && dir === 'up' && reachBottom) {\\n            this._loading.pullingUp(-offsetY);\\n          }\\n        }\\n      },\\n\\n      handleTouchEnd: function handleTouchEnd(event) {\\n        if (!this._touchParams || !this._refresh && !this._loading) {\\n          return;\\n        }\\n        var inner = this.$refs.inner;\\n        var ref = this._touchParams;\\n        var startY = ref.startY;\\n        var reachTop = ref.reachTop;\\n        var reachBottom = ref.reachBottom;\\n        if (inner) {\\n          var touch = event.changedTouches[0];\\n          var offsetY = touch.pageY - startY;\\n          var dir = offsetY > 0 ? 'down' : 'up';\\n          this._touchParams.offsetY = offsetY;\\n          if (this._refresh && dir === 'down' && reachTop) {\\n            this._refresh.pullingEnd();\\n          } else if (this._loading && dir === 'up' && reachBottom) {\\n            this._loading.pullingEnd();\\n          }\\n        }\\n        delete this._touchParams;\\n      }\\n    }\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  function getList(weex) {\\n    var extractComponentStyle = weex.extractComponentStyle;\\n\\n    return {\\n      name: 'weex-list',\\n      mixins: [scrollable$1],\\n      computed: {\\n        wrapperClass: function wrapperClass() {\\n          var classArray = ['weex-list', 'weex-list-wrapper', 'weex-ct'];\\n          this._refresh && classArray.push('with-refresh');\\n          this._loading && classArray.push('with-loading');\\n          return classArray.join(' ');\\n        }\\n      },\\n\\n      methods: {\\n        createChildren: function createChildren(h) {\\n          var slots = this.$slots.default || [];\\n          this._cells = slots.filter(function (vnode) {\\n            if (!vnode.tag && !vnode.componentOptions) {\\n              return false;\\n            }\\n            return true;\\n          });\\n          return [h('article', {\\n            ref: 'inner',\\n            staticClass: 'weex-list-inner weex-ct'\\n          }, this._cells)];\\n        }\\n      },\\n\\n      render: function render(createElement) {\\n        var this$1 = this;\\n\\n        this.weexType = 'list';\\n\\n        this.$nextTick(function () {\\n          this$1.updateLayout();\\n        });\\n\\n        return createElement('main', {\\n          ref: 'wrapper',\\n          attrs: { 'weex-type': 'list' },\\n          staticClass: this.wrapperClass,\\n          on: {\\n            scroll: this.handleScroll,\\n            touchstart: this.handleTouchStart,\\n            touchmove: this.handleTouchMove,\\n            touchend: this.handleTouchEnd\\n          },\\n          staticStyle: extractComponentStyle(this)\\n        }, this.createChildren(createElement));\\n      }\\n    };\\n  }\\n\\n  var list = {\\n    init: function init(weex) {\\n      weex.registerComponent('list', getList(weex));\\n    }\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n\\n  function getScroller(weex) {\\n    var extractComponentStyle = weex.extractComponentStyle;\\n\\n    return {\\n      name: 'weex-scroller',\\n      mixins: [scrollable$1],\\n      props: {\\n        scrollDirection: {\\n          type: [String],\\n          default: 'vertical',\\n          validator: function validator(value) {\\n            return ['horizontal', 'vertical'].indexOf(value) !== -1;\\n          }\\n        },\\n        scrollable: {\\n          type: [Boolean],\\n          default: true\\n        }\\n      },\\n      computed: {\\n        wrapperClass: function wrapperClass() {\\n          var classArray = ['weex-scroller', 'weex-scroller-wrapper', 'weex-ct'];\\n          if (this.scrollDirection === 'horizontal') {\\n            classArray.push('weex-scroller-horizontal');\\n          } else {\\n            classArray.push('weex-scroller-vertical');\\n          }\\n          if (!this.scrollable) {\\n            classArray.push('weex-scroller-disabled');\\n          }\\n          return classArray.join(' ');\\n        }\\n      },\\n\\n      methods: {\\n        createChildren: function createChildren(h) {\\n          var slots = this.$slots.default || [];\\n          this._cells = slots.filter(function (vnode) {\\n            if (!vnode.tag && !vnode.componentOptions) {\\n              return false;\\n            }\\n            return true;\\n          });\\n          return [h('article', {\\n            ref: 'inner',\\n            staticClass: 'weex-scroller-inner weex-ct'\\n          }, this._cells)];\\n        }\\n      },\\n\\n      render: function render(createElement) {\\n        var this$1 = this;\\n\\n        this.weexType = 'scroller';\\n\\n        /* istanbul ignore next */\\n        // if (\\\"production\\\" === 'development') {\\n        //   validateStyles('scroller', this.$vnode.data && this.$vnode.data.staticStyle)\\n        // }\\n\\n        this._cells = this.$slots.default || [];\\n        this.$nextTick(function () {\\n          this$1.updateLayout();\\n        });\\n\\n        return createElement('main', {\\n          ref: 'wrapper',\\n          attrs: { 'weex-type': 'scroller' },\\n          on: {\\n            scroll: this.handleScroll,\\n            touchstart: this.handleTouchStart,\\n            touchmove: this.handleTouchMove,\\n            touchend: this.handleTouchEnd\\n          },\\n          staticClass: this.wrapperClass,\\n          staticStyle: extractComponentStyle(this)\\n        }, this.createChildren(createElement));\\n      }\\n    };\\n  }\\n\\n  var scroller = {\\n    init: function init(weex) {\\n      weex.registerComponent('scroller', getScroller(weex));\\n    }\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND,  either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n\\n  /**\\n   * @fileoverview waterfall\\n   * NOTE: only support full screen width waterfall.\\n   */\\n\\n  var NORMAL_GAP_SIZE = 32;\\n  var DEFAULT_COLUMN_COUNT = 1;\\n\\n  function getWaterfall(weex) {\\n    var extractComponentStyle = weex.extractComponentStyle;\\n\\n    return {\\n      name: 'weex-waterfall',\\n      mixins: [scrollable$1],\\n      props: {\\n        /**\\n         * specified gap size.\\n         * value can be number or 'normal'. 'normal' (32px) by default.\\n         */\\n        columnGap: {\\n          type: [String, Number],\\n          default: 'normal',\\n          validator: function validator(val) {\\n            if (!val || val === 'normal') {\\n              return true;\\n            }\\n            val = parseInt(val);\\n            return !isNaN(val) && val > 0;\\n          }\\n        },\\n        /**\\n         * the maximum column counts.\\n         * value can be number or 'auto'. 1 by default.\\n         */\\n        columnCount: {\\n          type: [String, Number],\\n          default: DEFAULT_COLUMN_COUNT,\\n          validator: function validator(val) {\\n            val = parseInt(val);\\n            return !isNaN(val) && val > 0;\\n          }\\n        },\\n        /**\\n         * the mimimum column width.\\n         * value can be number or 'auto'. 'auto' by default.\\n         */\\n        columnWidth: {\\n          type: [String, Number],\\n          default: 'auto',\\n          validator: function validator(val) {\\n            if (!val || val === 'auto') {\\n              return true;\\n            }\\n            val = parseInt(val);\\n            return !isNaN(val) && val > 0;\\n          }\\n        }\\n      },\\n\\n      mounted: function mounted() {\\n        this._nextTick();\\n      },\\n\\n      updated: function updated() {\\n        this.$nextTick(this._nextTick());\\n      },\\n\\n      methods: {\\n        _createChildren: function _createChildren(h, rootStyle) {\\n          var this$1 = this;\\n\\n          var slots = (this.$slots.default || []).slice();\\n          this._headers = [];\\n          this._footers = [];\\n          this._others = [];\\n          var len = slots.length;\\n\\n          for (var i = 0; i < len; i++) {\\n            var vnode = slots[i];\\n            var tag = vnode.componentOptions && vnode.componentOptions.tag || vnode.tag;\\n            if (tag === 'refresh' || tag === 'loading') {\\n              continue;\\n            }\\n            if (tag === 'section') {\\n              // cell\\n              break;\\n            }\\n            if (tag === 'header') {\\n              this$1._headers.push(vnode);\\n              slots[i] = null; // should not included in footer.\\n            }\\n          }\\n\\n          for (var i$1 = len - 1; i$1 >= 0; i$1--) {\\n            var vnode$1 = slots[i$1];\\n            if (!vnode$1) {\\n              continue;\\n            } // already taken by header.\\n            var tag$1 = vnode$1.componentOptions && vnode$1.componentOptions.tag || vnode$1.tag;\\n            if (tag$1 === 'refresh' || tag$1 === 'loading') {\\n              continue;\\n            }\\n            if (tag$1 === 'section') {\\n              // cell\\n              break;\\n            }\\n            if (tag$1 === 'header') {\\n              this$1._footers.push(vnode$1);\\n            }\\n          }\\n\\n          this._cells = slots.filter(function (vnode) {\\n            if (!vnode) {\\n              return false;\\n            }\\n            var cmpOpts = vnode.componentOptions;\\n            if (!vnode.tag && !cmpOpts) {\\n              return false;\\n            }\\n            var tag = cmpOpts && cmpOpts.tag || vnode.tag;\\n            if (tag === 'refresh' || tag === 'loading') {\\n              this$1[\\\"_\\\" + tag] = vnode;\\n              return false;\\n            }\\n            if (tag !== 'section') {\\n              this$1._others.push(vnode);\\n              return false;\\n            }\\n            return true;\\n          });\\n\\n          this._reCalc(rootStyle);\\n          this._genColumns(h);\\n          var children = [];\\n          this._refresh && children.push(this._refresh);\\n          children = children.concat(this._headers);\\n          // .concat(this._others)\\n          children.push(h('html:div', {\\n            ref: 'columns',\\n            staticClass: 'weex-waterfall-inner-columns weex-ct'\\n          }, this._columns));\\n          children.push(h('html:div', {\\n            ref: 'footers',\\n            staticClass: 'weex-waterfall-footers weex-ct'\\n          }, this._footers));\\n          this._loading && children.push(this._loading);\\n          return [h('article', {\\n            ref: 'inner',\\n            staticClass: 'weex-waterfall-inner weex-ct'\\n          }, children)];\\n        },\\n\\n        _reCalc: function _reCalc(rootStyle) {\\n          /**\\n           * NOTE: columnGap and columnWidth can't both be auto.\\n           * NOTE: the formula:\\n           *  totalWidth = n * w + (n - 1) * gap\\n           * 1. if columnCount = n then calc w\\n           * 2. if columnWidth = w then calc n\\n           * 3. if columnWidth = w and columnCount = n then calc totalWidth\\n           *    3.1 if totalWidth < ctWidth then increase columnWidth\\n           *    3.2 if totalWidth > ctWidth then decrease columnCount\\n           */\\n          var width, gap, cnt, ctWidth;\\n          var scale = weex.config.env.scale;\\n          var el = this.$el;\\n          function getCtWidth(width, style) {\\n            var padding = style.padding ? parseInt(style.padding) * 2 : parseInt(style.paddingLeft || 0) + parseInt(style.paddingRight || 0);\\n            return width - padding;\\n          }\\n          if (el && el.nodeType === 1) {\\n            // already mounted\\n            var cstyle = window.getComputedStyle(el);\\n            ctWidth = getCtWidth(el.getBoundingClientRect().width, cstyle);\\n          } else {\\n            // not mounted.\\n            // only support full screen width for waterfall component.\\n            ctWidth = getCtWidth(document.documentElement.clientWidth, rootStyle);\\n          }\\n\\n          gap = this.columnGap;\\n          if (gap && gap !== 'normal') {\\n            gap = parseInt(gap);\\n          } else {\\n            gap = NORMAL_GAP_SIZE;\\n          }\\n          gap = gap * scale;\\n\\n          width = this.columnWidth;\\n          cnt = this.columnCount;\\n          if (width && width !== 'auto') {\\n            width = parseInt(width) * scale;\\n          }\\n          if (cnt && cnt !== 'auto') {\\n            cnt = parseInt(cnt);\\n          }\\n\\n          // 0. if !columnCount && !columnWidth\\n          if (cnt === 'auto' && width === 'auto') {}\\n          // 1. if columnCount = n then calc w.\\n          else if (cnt !== 'auto' && width === 'auto') {\\n              width = (ctWidth - (cnt - 1) * gap) / cnt;\\n            }\\n            // 2. if columnWidth = w then calc n.\\n            else if (cnt === 'auto' && width !== 'auto') {\\n                cnt = (ctWidth + gap) / (width + gap);\\n              }\\n              // 3. if columnWidth = w and columnCount = n then calc totalWidth\\n              else if (cnt !== 'auto' && width !== 'auto') {\\n                  var totalWidth;\\n                  var adjustCountAndWidth = function adjustCountAndWidth() {\\n                    totalWidth = cnt * width + (cnt - 1) * gap;\\n                    if (totalWidth < ctWidth) {\\n                      width += (ctWidth - totalWidth) / cnt;\\n                    } else if (totalWidth > ctWidth && cnt > 1) {\\n                      cnt--;\\n                      adjustCountAndWidth();\\n                    } else if (totalWidth > ctWidth) {\\n                      // cnt === 1\\n                      width = ctWidth;\\n                    }\\n                  };\\n                  adjustCountAndWidth();\\n                }\\n          this._columnCount = cnt;\\n          this._columnWidth = width;\\n          this._columnGap = gap;\\n        },\\n\\n        _genColumns: function _genColumns(createElement) {\\n          var this$1 = this;\\n\\n          this._columns = [];\\n          var cells = this._cells;\\n          var columnCnt = this._columnCount;\\n          var len = cells.length;\\n          var columnCells = this._columnCells = Array(columnCnt).join('.').split('.').map(function () {\\n            return [];\\n          });\\n          // spread cells to the columns using simpole polling algorithm.\\n          for (var i = 0; i < len; i++) {\\n            (cells[i].data.attrs || (cells[i].data.attrs = {}))['data-cell'] = i;\\n            columnCells[i % columnCnt].push(cells[i]);\\n          }\\n          for (var i$1 = 0; i$1 < columnCnt; i$1++) {\\n            this$1._columns.push(createElement('html:div', {\\n              ref: \\\"column\\\" + i$1,\\n              attrs: {\\n                'data-column': i$1\\n              },\\n              staticClass: 'weex-ct',\\n              staticStyle: {\\n                width: this$1._columnWidth + 'px',\\n                marginLeft: i$1 === 0 ? 0 : this$1._columnGap + 'px'\\n              }\\n            }, columnCells[i$1]));\\n          }\\n        },\\n\\n        _nextTick: function _nextTick() {\\n          this._reLayoutChildren();\\n        },\\n\\n        _reLayoutChildren: function _reLayoutChildren() {\\n          var this$1 = this;\\n\\n          /**\\n           * treat the shortest column bottom as the match standard.\\n           * whichever cell exceeded it would be rearranged.\\n           * 1. m = shortest column bottom.\\n           * 2. get all cell ids who is below m.\\n           * 3. calculate which cell should be in which column.\\n           */\\n          var columnCnt = this._columnCount;\\n          var columnDoms = [];\\n          var columnAppendFragments = [];\\n          var columnBottoms = [];\\n          var minBottom = Number.MAX_SAFE_INTEGER;\\n          var minBottomColumnIndex = 0;\\n\\n          // 1. find the shortest column bottom.\\n          for (var i = 0; i < columnCnt; i++) {\\n            var columnDom = this$1._columns[i].elm;\\n            var lastChild = columnDom.lastElementChild;\\n            var bottom = lastChild ? lastChild.getBoundingClientRect().bottom : 0;\\n            columnDoms.push(columnDom);\\n            columnBottoms[i] = bottom;\\n            columnAppendFragments.push(document.createDocumentFragment());\\n            if (bottom < minBottom) {\\n              minBottom = bottom;\\n              minBottomColumnIndex = i;\\n            }\\n          }\\n\\n          // 2. get all cell ids who is below m.\\n          var belowCellIds = [];\\n          var belowCells = {};\\n          for (var i$1 = 0; i$1 < columnCnt; i$1++) {\\n            if (i$1 === minBottomColumnIndex) {\\n              continue;\\n            }\\n            var columnDom$1 = columnDoms[i$1];\\n            var cellsInColumn = columnDom$1.querySelectorAll('section.weex-cell');\\n            var len = cellsInColumn.length;\\n            for (var j = len - 1; j >= 0; j--) {\\n              var cellDom = cellsInColumn[j];\\n              var cellRect = cellDom.getBoundingClientRect();\\n              if (cellRect.top > minBottom) {\\n                var id = ~~cellDom.getAttribute('data-cell');\\n                belowCellIds.push(id);\\n                belowCells[id] = { elm: cellDom, height: cellRect.height };\\n                columnBottoms[i$1] -= cellRect.height;\\n              }\\n            }\\n          }\\n\\n          // 3. calculate which cell should be in which column and rearrange them\\n          //  in the dom tree.\\n          belowCellIds.sort(function (a, b) {\\n            return a > b;\\n          });\\n          var cellIdsLen = belowCellIds.length;\\n          function addToShortestColumn(belowCell) {\\n            // find shortest bottom.\\n            minBottom = Math.min.apply(Math, columnBottoms);\\n            minBottomColumnIndex = columnBottoms.indexOf(minBottom);\\n            var cellElm = belowCell.elm;\\n            var cellHeight = belowCell.height;\\n            columnAppendFragments[minBottomColumnIndex].appendChild(cellElm);\\n            columnBottoms[minBottomColumnIndex] += cellHeight;\\n          }\\n          for (var i$2 = 0; i$2 < cellIdsLen; i$2++) {\\n            addToShortestColumn(belowCells[belowCellIds[i$2]]);\\n          }\\n          for (var i$3 = 0; i$3 < columnCnt; i$3++) {\\n            columnDoms[i$3].appendChild(columnAppendFragments[i$3]);\\n          }\\n        }\\n      },\\n\\n      render: function render(createElement) {\\n        var this$1 = this;\\n\\n        this.weexType = 'waterfall';\\n        this._cells = this.$slots.default || [];\\n        this.$nextTick(function () {\\n          this$1.updateLayout();\\n        });\\n        var mergedStyle = extractComponentStyle(this);\\n        return createElement('main', {\\n          ref: 'wrapper',\\n          attrs: { 'weex-type': 'waterfall' },\\n          on: {\\n            scroll: this.handleScroll,\\n            touchstart: this.handleTouchStart,\\n            touchmove: this.handleTouchMove,\\n            touchend: this.handleTouchEnd\\n          },\\n          staticClass: 'weex-waterfall weex-waterfall-wrapper weex-ct',\\n          staticStyle: mergedStyle\\n        }, this._createChildren(createElement, mergedStyle));\\n      }\\n    };\\n  }\\n\\n  var waterfall = {\\n    init: function init(weex) {\\n      weex.registerComponent('waterfall', getWaterfall(weex));\\n    }\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n\\n  function getHeader(weex) {\\n    var extractComponentStyle = weex.extractComponentStyle;\\n\\n    return {\\n      render: function render(createElement) {\\n        var attrs = this.$vnode.data.attrs;\\n        return createElement('html:header', {\\n          attrs: {\\n            'weex-type': 'header',\\n            sticky: this.$parent.weexType === 'waterfall' && typeof attrs.sticky === 'undefined' ? undefined : ''\\n          },\\n          ref: 'header',\\n          staticClass: 'weex-header weex-ct',\\n          staticStyle: extractComponentStyle(this)\\n        }, this.$slots.default);\\n      }\\n    };\\n  }\\n\\n  var header = {\\n    init: function init(weex) {\\n      weex.registerComponent('header', getHeader(weex));\\n    }\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n\\n  function getLoading() {\\n    var extractComponentStyle = weex.extractComponentStyle;\\n    var ref = weex.utils;\\n    var dispatchNativeEvent = ref.dispatchNativeEvent;\\n\\n    return {\\n      name: 'weex-loading',\\n      props: {\\n        display: {\\n          type: String,\\n          default: 'show',\\n          validator: function validator(value) {\\n            return ['show', 'hide'].indexOf(value) !== -1;\\n          }\\n        }\\n      },\\n      data: function data() {\\n        return {\\n          height: -1,\\n          viewHeight: 0\\n        };\\n      },\\n      mounted: function mounted() {\\n        this.viewHeight = this.$el.offsetHeight;\\n        if (this.display === 'hide') {\\n          this.height = 0;\\n        } else {\\n          this.height = this.viewHeight;\\n        }\\n      },\\n      watch: {\\n        height: function height(val) {\\n          var offset = val + \\\"px\\\";\\n          this.$el.style.height = offset;\\n          this.$el.style.bottom = offset;\\n        },\\n        display: function display(val) {\\n          if (val === 'hide') {\\n            this.height = 0;\\n          } else {\\n            this.height = this.viewHeight;\\n          }\\n        }\\n      },\\n      methods: {\\n        pulling: function pulling(offsetY) {\\n          if (offsetY === void 0) offsetY = 0;\\n\\n          this.height = offsetY;\\n        },\\n        pullingUp: function pullingUp(offsetY) {\\n          this.$el.style.transition = \\\"height 0s\\\";\\n          this.pulling(offsetY);\\n        },\\n        pullingEnd: function pullingEnd() {\\n          this.$el && (this.$el.style.transition = \\\"height .2s\\\");\\n          if (this.height >= this.viewHeight) {\\n            this.pulling(this.viewHeight);\\n            if (this.$el) {\\n              dispatchNativeEvent(this.$el, 'loading');\\n            }\\n          } else {\\n            this.pulling(0);\\n          }\\n        },\\n        getChildren: function getChildren() {\\n          var children = this.$slots.default || [];\\n          if (this.display === 'show') {\\n            return children;\\n          }\\n          return children.filter(function (vnode) {\\n            return vnode.componentOptions && vnode.componentOptions.tag !== 'loading-indicator';\\n          });\\n        }\\n      },\\n      render: function render(createElement) {\\n        this.$parent._loading = this;\\n        return createElement('aside', {\\n          ref: 'loading',\\n          attrs: { 'weex-type': 'loading' },\\n          staticClass: 'weex-loading weex-ct',\\n          staticStyle: extractComponentStyle(this)\\n        }, this.getChildren());\\n      }\\n    };\\n  }\\n\\n  var loading = {\\n    init: function init(weex) {\\n      weex.registerComponent('loading', getLoading(weex));\\n    }\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n\\n  function getRefresh(weex) {\\n    var extractComponentStyle = weex.extractComponentStyle;\\n    var ref = weex.utils;\\n    var dispatchNativeEvent = ref.dispatchNativeEvent;\\n\\n    return {\\n      name: 'weex-refresh',\\n      props: {\\n        display: {\\n          type: String,\\n          default: 'show',\\n          validator: function validator(value) {\\n            return ['show', 'hide'].indexOf(value) !== -1;\\n          }\\n        }\\n      },\\n      data: function data() {\\n        return {\\n          lastDy: 0,\\n          viewHeight: 0,\\n          height: -1\\n        };\\n      },\\n      mounted: function mounted() {\\n        this.viewHeight = this.$el.offsetHeight;\\n        if (this.display === 'hide') {\\n          this.height = 0;\\n        } else {\\n          this.height = this.viewHeight;\\n        }\\n      },\\n      watch: {\\n        height: function height(val) {\\n          this.$el.style.height = val + \\\"px\\\";\\n        },\\n        display: function display(val) {\\n          if (val === 'hide') {\\n            this.height = 0;\\n          } else {\\n            this.height = this.viewHeight;\\n          }\\n        }\\n      },\\n      methods: {\\n        pulling: function pulling(offsetY) {\\n          if (offsetY === void 0) offsetY = 0;\\n\\n          this.height = offsetY;\\n          if (this.$el) {\\n            dispatchNativeEvent(this.$el, 'pullingdown', {\\n              dy: offsetY - this.lastDy,\\n              pullingDistance: offsetY,\\n              viewHeight: this.viewHeight\\n            });\\n          }\\n          this.lastDy = offsetY;\\n        },\\n        pullingDown: function pullingDown(offsetY) {\\n          this.$el.style.transition = \\\"height 0s\\\";\\n          this.pulling(offsetY);\\n        },\\n        pullingEnd: function pullingEnd() {\\n          this.$el && (this.$el.style.transition = \\\"height .2s\\\");\\n          if (this.height >= this.viewHeight) {\\n            this.pulling(this.viewHeight);\\n            if (this.$el) {\\n              dispatchNativeEvent(this.$el, 'refresh');\\n            }\\n          } else {\\n            this.pulling(0);\\n          }\\n        },\\n        getChildren: function getChildren() {\\n          var children = this.$slots.default || [];\\n          if (this.display === 'show') {\\n            return children;\\n          }\\n          return children.filter(function (vnode) {\\n            return vnode.componentOptions && vnode.componentOptions.tag !== 'loading-indicator';\\n          });\\n        }\\n      },\\n      render: function render(createElement) {\\n        this.$parent._refresh = this;\\n        return createElement('aside', {\\n          ref: 'refresh',\\n          attrs: { 'weex-type': 'refresh' },\\n          staticClass: 'weex-refresh weex-ct',\\n          staticStyle: extractComponentStyle(this)\\n        }, this.getChildren());\\n      }\\n    };\\n  }\\n\\n  var refresh = {\\n    init: function init(weex) {\\n      weex.registerComponent('refresh', getRefresh(weex));\\n    }\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  var extractComponentStyle$1;\\n  var getRgb$1;\\n  var loopArray$1;\\n  var getStyleSheetById$1;\\n\\n  var _css = \\\"\\\\n.weex-refresh-indicator,\\\\n.weex-loading-indicator {\\\\n  width: 1rem !important;\\\\n  height: 1rem !important;\\\\n  -webkit-box-align: center;\\\\n  -moz-box-align: center;\\\\n  -webkit-align-items: center;\\\\n  -ms-flex-align: center;\\\\n  align-items: center;\\\\n  -webkit-box-pack: center;\\\\n  -moz-box-pack: center;\\\\n  -webkit-justify-content: center;\\\\n  -ms-flex-pack: center;\\\\n  justify-content: center;\\\\n  overflow: visible;\\\\n  background: none;\\\\n}\\\\n.weex-refresh-indicator:before,\\\\n.weex-loading-indicator:before {\\\\n  display: block;\\\\n  content: '';\\\\n  font-size: 0.16rem;\\\\n  width: 0.5em;\\\\n  height: 0.5em;\\\\n  left: 0;\\\\n  top: 0;\\\\n  border-radius: 50%;\\\\n  position: relative;\\\\n  text-indent: -9999em;\\\\n  -webkit-animation: weex-spinner 1.1s infinite ease;\\\\n  -moz-animation: weex-spinner 1.1s infinite ease;\\\\n  animation: weex-spinner 1.1s infinite ease;\\\\n}\\\\n\\\\n@-webkit-keyframes weex-spinner {\\\\n  0%,\\\\n  100% {\\\\n    box-shadow: 0em -1.3em 0em 0em #ffffff, 0.9em -0.9em 0 0em rgba(255, 255, 255, 0.2), 1.25em 0em 0 0em rgba(255, 255, 255, 0.2), 0.875em 0.875em 0 0em rgba(255, 255, 255, 0.2), 0em 1.25em 0 0em rgba(255, 255, 255, 0.2), -0.9em 0.9em 0 0em rgba(255, 255, 255, 0.2), -1.3em 0em 0 0em rgba(255, 255, 255, 0.5), -0.9em -0.9em 0 0em rgba(255, 255, 255, 0.7);\\\\n  }\\\\n  11.25% {\\\\n    box-shadow: 0em -1.3em 0em 0em rgba(255, 255, 255, 0.7), 0.9em -0.9em 0 0em #ffffff, 1.25em 0em 0 0em rgba(255, 255, 255, 0.2), 0.875em 0.875em 0 0em rgba(255, 255, 255, 0.2), 0em 1.25em 0 0em rgba(255, 255, 255, 0.2), -0.9em 0.9em 0 0em rgba(255, 255, 255, 0.2), -1.3em 0em 0 0em rgba(255, 255, 255, 0.2), -0.9em -0.9em 0 0em rgba(255, 255, 255, 0.5);\\\\n  }\\\\n  25% {\\\\n    box-shadow: 0em -1.3em 0em 0em rgba(255, 255, 255, 0.5), 0.9em -0.9em 0 0em rgba(255, 255, 255, 0.7), 1.25em 0em 0 0em #ffffff, 0.875em 0.875em 0 0em rgba(255, 255, 255, 0.2), 0em 1.25em 0 0em rgba(255, 255, 255, 0.2), -0.9em 0.9em 0 0em rgba(255, 255, 255, 0.2), -1.3em 0em 0 0em rgba(255, 255, 255, 0.2), -0.9em -0.9em 0 0em rgba(255, 255, 255, 0.2);\\\\n  }\\\\n  37.5% {\\\\n    box-shadow: 0em -1.3em 0em 0em rgba(255, 255, 255, 0.2), 0.9em -0.9em 0 0em rgba(255, 255, 255, 0.5), 1.25em 0em 0 0em rgba(255, 255, 255, 0.7), 0.875em 0.875em 0 0em #ffffff, 0em 1.25em 0 0em rgba(255, 255, 255, 0.2), -0.9em 0.9em 0 0em rgba(255, 255, 255, 0.2), -1.3em 0em 0 0em rgba(255, 255, 255, 0.2), -0.9em -0.9em 0 0em rgba(255, 255, 255, 0.2);\\\\n  }\\\\n  50% {\\\\n    box-shadow: 0em -1.3em 0em 0em rgba(255, 255, 255, 0.2), 0.9em -0.9em 0 0em rgba(255, 255, 255, 0.2), 1.25em 0em 0 0em rgba(255, 255, 255, 0.5), 0.875em 0.875em 0 0em rgba(255, 255, 255, 0.7), 0em 1.25em 0 0em #ffffff, -0.9em 0.9em 0 0em rgba(255, 255, 255, 0.2), -1.3em 0em 0 0em rgba(255, 255, 255, 0.2), -0.9em -0.9em 0 0em rgba(255, 255, 255, 0.2);\\\\n  }\\\\n  61.25% {\\\\n    box-shadow: 0em -1.3em 0em 0em rgba(255, 255, 255, 0.2), 0.9em -0.9em 0 0em rgba(255, 255, 255, 0.2), 1.25em 0em 0 0em rgba(255, 255, 255, 0.2), 0.875em 0.875em 0 0em rgba(255, 255, 255, 0.5), 0em 1.25em 0 0em rgba(255, 255, 255, 0.7), -0.9em 0.9em 0 0em #ffffff, -1.3em 0em 0 0em rgba(255, 255, 255, 0.2), -0.9em -0.9em 0 0em rgba(255, 255, 255, 0.2);\\\\n  }\\\\n  75% {\\\\n    box-shadow: 0em -1.3em 0em 0em rgba(255, 255, 255, 0.2), 0.9em -0.9em 0 0em rgba(255, 255, 255, 0.2), 1.25em 0em 0 0em rgba(255, 255, 255, 0.2), 0.875em 0.875em 0 0em rgba(255, 255, 255, 0.2), 0em 1.25em 0 0em rgba(255, 255, 255, 0.5), -0.9em 0.9em 0 0em rgba(255, 255, 255, 0.7), -1.3em 0em 0 0em #ffffff, -0.9em -0.9em 0 0em rgba(255, 255, 255, 0.2);\\\\n  }\\\\n  87.5% {\\\\n    box-shadow: 0em -1.3em 0em 0em rgba(255, 255, 255, 0.2), 0.9em -0.9em 0 0em rgba(255, 255, 255, 0.2), 1.25em 0em 0 0em rgba(255, 255, 255, 0.2), 0.875em 0.875em 0 0em rgba(255, 255, 255, 0.2), 0em 1.25em 0 0em rgba(255, 255, 255, 0.2), -0.9em 0.9em 0 0em rgba(255, 255, 255, 0.5), -1.3em 0em 0 0em rgba(255, 255, 255, 0.7), -0.9em -0.9em 0 0em #ffffff;\\\\n  }\\\\n}\\\\n\\\\n@keyframes weex-spinner {\\\\n  0%,\\\\n  100% {\\\\n    box-shadow: 0em -1.3em 0em 0em #ffffff, 0.9em -0.9em 0 0em rgba(255, 255, 255, 0.2), 1.25em 0em 0 0em rgba(255, 255, 255, 0.2), 0.875em 0.875em 0 0em rgba(255, 255, 255, 0.2), 0em 1.25em 0 0em rgba(255, 255, 255, 0.2), -0.9em 0.9em 0 0em rgba(255, 255, 255, 0.2), -1.3em 0em 0 0em rgba(255, 255, 255, 0.5), -0.9em -0.9em 0 0em rgba(255, 255, 255, 0.7);\\\\n  }\\\\n  11.25% {\\\\n    box-shadow: 0em -1.3em 0em 0em rgba(255, 255, 255, 0.7), 0.9em -0.9em 0 0em #ffffff, 1.25em 0em 0 0em rgba(255, 255, 255, 0.2), 0.875em 0.875em 0 0em rgba(255, 255, 255, 0.2), 0em 1.25em 0 0em rgba(255, 255, 255, 0.2), -0.9em 0.9em 0 0em rgba(255, 255, 255, 0.2), -1.3em 0em 0 0em rgba(255, 255, 255, 0.2), -0.9em -0.9em 0 0em rgba(255, 255, 255, 0.5);\\\\n  }\\\\n  25% {\\\\n    box-shadow: 0em -1.3em 0em 0em rgba(255, 255, 255, 0.5), 0.9em -0.9em 0 0em rgba(255, 255, 255, 0.7), 1.25em 0em 0 0em #ffffff, 0.875em 0.875em 0 0em rgba(255, 255, 255, 0.2), 0em 1.25em 0 0em rgba(255, 255, 255, 0.2), -0.9em 0.9em 0 0em rgba(255, 255, 255, 0.2), -1.3em 0em 0 0em rgba(255, 255, 255, 0.2), -0.9em -0.9em 0 0em rgba(255, 255, 255, 0.2);\\\\n  }\\\\n  37.5% {\\\\n    box-shadow: 0em -1.3em 0em 0em rgba(255, 255, 255, 0.2), 0.9em -0.9em 0 0em rgba(255, 255, 255, 0.5), 1.25em 0em 0 0em rgba(255, 255, 255, 0.7), 0.875em 0.875em 0 0em #ffffff, 0em 1.25em 0 0em rgba(255, 255, 255, 0.2), -0.9em 0.9em 0 0em rgba(255, 255, 255, 0.2), -1.3em 0em 0 0em rgba(255, 255, 255, 0.2), -0.9em -0.9em 0 0em rgba(255, 255, 255, 0.2);\\\\n  }\\\\n  50% {\\\\n    box-shadow: 0em -1.3em 0em 0em rgba(255, 255, 255, 0.2), 0.9em -0.9em 0 0em rgba(255, 255, 255, 0.2), 1.25em 0em 0 0em rgba(255, 255, 255, 0.5), 0.875em 0.875em 0 0em rgba(255, 255, 255, 0.7), 0em 1.25em 0 0em #ffffff, -0.9em 0.9em 0 0em rgba(255, 255, 255, 0.2), -1.3em 0em 0 0em rgba(255, 255, 255, 0.2), -0.9em -0.9em 0 0em rgba(255, 255, 255, 0.2);\\\\n  }\\\\n  61.25% {\\\\n    box-shadow: 0em -1.3em 0em 0em rgba(255, 255, 255, 0.2), 0.9em -0.9em 0 0em rgba(255, 255, 255, 0.2), 1.25em 0em 0 0em rgba(255, 255, 255, 0.2), 0.875em 0.875em 0 0em rgba(255, 255, 255, 0.5), 0em 1.25em 0 0em rgba(255, 255, 255, 0.7), -0.9em 0.9em 0 0em #ffffff, -1.3em 0em 0 0em rgba(255, 255, 255, 0.2), -0.9em -0.9em 0 0em rgba(255, 255, 255, 0.2);\\\\n  }\\\\n  75% {\\\\n    box-shadow: 0em -1.3em 0em 0em rgba(255, 255, 255, 0.2), 0.9em -0.9em 0 0em rgba(255, 255, 255, 0.2), 1.25em 0em 0 0em rgba(255, 255, 255, 0.2), 0.875em 0.875em 0 0em rgba(255, 255, 255, 0.2), 0em 1.25em 0 0em rgba(255, 255, 255, 0.5), -0.9em 0.9em 0 0em rgba(255, 255, 255, 0.7), -1.3em 0em 0 0em #ffffff, -0.9em -0.9em 0 0em rgba(255, 255, 255, 0.2);\\\\n  }\\\\n  87.5% {\\\\n    box-shadow: 0em -1.3em 0em 0em rgba(255, 255, 255, 0.2), 0.9em -0.9em 0 0em rgba(255, 255, 255, 0.2), 1.25em 0em 0 0em rgba(255, 255, 255, 0.2), 0.875em 0.875em 0 0em rgba(255, 255, 255, 0.2), 0em 1.25em 0 0em rgba(255, 255, 255, 0.2), -0.9em 0.9em 0 0em rgba(255, 255, 255, 0.5), -1.3em 0em 0 0em rgba(255, 255, 255, 0.7), -0.9em -0.9em 0 0em #ffffff;\\\\n  }\\\\n}\\\\n\\\";\\n\\n  function getStyleSheet(spinnerVm) {\\n    if (spinnerVm._styleSheet) {\\n      return;\\n    }\\n    spinnerVm._styleSheet = getStyleSheetById$1('weex-cmp-loading-indicator');\\n  }\\n\\n  function setKeyframeColor(spinnerVm, val) {\\n    getStyleSheet(spinnerVm);\\n    var keyframeRules = computeKeyFrameRules(val);\\n    var rules = spinnerVm._styleSheet.rules || spinnerVm._styleSheet.cssRules;\\n    for (var i = 0, l = rules.length; i < l; i++) {\\n      var item = rules.item(i);\\n      if ((item.type === CSSRule.KEYFRAMES_RULE || item.type === CSSRule.WEBKIT_KEYFRAMES_RULE) && item.name === 'weex-spinner') {\\n        var cssRules = item.cssRules;\\n        for (var j = 0, m = cssRules.length; j < m; j++) {\\n          var keyframe = cssRules[j];\\n          if (keyframe.type === CSSRule.KEYFRAME_RULE || keyframe.type === CSSRule.WEBKIT_KEYFRAME_RULE) {\\n            keyframe.style.boxShadow = keyframeRules[j];\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  function computeKeyFrameRules(rgb) {\\n    if (!rgb) {\\n      return;\\n    }\\n    var scaleArr = ['0em -1.3em 0em 0em', '0.9em -0.9em 0 0em', '1.25em 0em 0 0em', '0.875em 0.875em 0 0em', '0em 1.25em 0 0em', '-0.9em 0.9em 0 0em', '-1.3em 0em 0 0em', '-0.9em -0.9em 0 0em'];\\n    var colorArr = ['1', '0.2', '0.2', '0.2', '0.2', '0.2', '0.5', '0.7'].map(function (e) {\\n      return 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + e + ')';\\n    });\\n    var rules = [];\\n    var loop = function loop(i) {\\n      var tmpColorArr = loopArray$1(colorArr, i, 'r');\\n      rules.push(scaleArr.map(function (scaleStr, i) {\\n        return scaleStr + ' ' + tmpColorArr[i];\\n      }).join(', '));\\n    };\\n\\n    for (var i = 0; i < scaleArr.length; i++) {\\n      loop(i);\\n    }return rules;\\n  }\\n\\n  function processStyle$1(vm) {\\n    var style = extractComponentStyle$1(vm);\\n    var color = style.color;\\n    var rgb = color && getRgb$1(color);\\n    if (rgb) {\\n      setKeyframeColor(vm, rgb);\\n    }\\n    return style;\\n  }\\n\\n  var loadingIndicator = {\\n    name: 'weex-loading-indicator',\\n    render: function render(createElement) {\\n      this.weexType = 'loading-indicator';\\n      return createElement('mark', {\\n        attrs: { 'weex-type': 'loading-indicator' },\\n        staticClass: 'weex-loading-indicator weex-ct',\\n        staticStyle: processStyle$1(this)\\n      });\\n    },\\n    _css: _css\\n  };\\n\\n  var loadingIndicator$1 = {\\n    init: function init(weex) {\\n      extractComponentStyle$1 = weex.extractComponentStyle;\\n      getRgb$1 = weex.utils.getRgb;\\n      loopArray$1 = weex.utils.loopArray;\\n      getStyleSheetById$1 = weex.utils.getStyleSheetById;\\n      weex.registerComponent('loading-indicator', loadingIndicator);\\n    }\\n  };\\n\\n  __$styleInject(\\\"/*\\\\n * Licensed to the Apache Software Foundation (ASF) under one\\\\n * or more contributor license agreements.  See the NOTICE file\\\\n * distributed with this work for additional information\\\\n * regarding copyright ownership.  The ASF licenses this file\\\\n * to you under the Apache License, Version 2.0 (the\\\\n * \\\\\\\"License\\\\\\\"); you may not use this file except in compliance\\\\n * with the License.  You may obtain a copy of the License at\\\\n *\\\\n *   http://www.apache.org/licenses/LICENSE-2.0\\\\n *\\\\n * Unless required by applicable law or agreed to in writing,\\\\n * software distributed under the License is distributed on an\\\\n * \\\\\\\"AS IS\\\\\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\\\n * KIND, either express or implied.  See the License for the\\\\n * specific language governing permissions and limitations\\\\n * under the License.\\\\n */\\\\n\\\\nbody > .weex-list,\\\\nbody > .weex-scroller,\\\\nbody > .weex-waterfall {\\\\n  max-height: 100%;\\\\n}\\\\n\\\\n.weex-list-wrapper,\\\\n.weex-scroller-wrapper,\\\\n.weex-waterfall-wrapper {\\\\n  -webkit-overflow-scrolling: touch;\\\\n}\\\\n\\\\n.weex-list-wrapper,\\\\n.weex-waterfall-wrapper {\\\\n  overflow-y: scroll !important;\\\\n  overflow-x: hidden !important;\\\\n}\\\\n\\\\n.weex-list-inner,\\\\n.weex-scroller-inner,\\\\n.weex-waterfall-inner {\\\\n  -webkit-overflow-scrolling: touch;\\\\n}\\\\n\\\\n.weex-waterfall-inner-columns {\\\\n  -webkit-flex-direction: row;\\\\n  flex-direction: row;\\\\n  -webkit-box-orient: horizontal;\\\\n}\\\\n\\\\n.weex-scroller-wrapper.weex-scroller-vertical {\\\\n  overflow-x: hidden;\\\\n  overflow-y: scroll;\\\\n}\\\\n\\\\n.weex-scroller-wrapper.weex-scroller-horizontal {\\\\n  overflow-x: scroll;\\\\n  overflow-y: hidden;\\\\n}\\\\n\\\\n.weex-scroller-wrapper.weex-scroller-disabled {\\\\n  overflow-x: hidden;\\\\n  overflow-y: hidden;\\\\n}\\\\n\\\\n.weex-scroller-horizontal .weex-scroller-inner {\\\\n  -webkit-flex-direction: row;\\\\n  flex-direction: row;\\\\n  -webkit-box-orient: horizontal;\\\\n  height: 100%;\\\\n}\\\\n\\\\n.weex-cell {\\\\n  width: 100%;\\\\n}\\\\n\\\\n.weex-refresh,\\\\n.weex-loading {\\\\n  -webkit-box-align: center;\\\\n  -webkit-align-items: center;\\\\n  align-items: center;\\\\n  -webkit-box-pack: center;\\\\n  -webkit-justify-content: center;\\\\n  justify-content: center;\\\\n  width: 100%;\\\\n  overflow: hidden;\\\\n}\\\\n\\\", undefined);\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n\\n  // import cell from './cell'\\n  var modules = [list, scroller, waterfall,\\n  // cell,\\n  header, loading, refresh, loadingIndicator$1];\\n\\n  var scrollable = {\\n    init: function init(weex) {\\n      modules.forEach(function (mod) {\\n        weex.install(mod);\\n      });\\n    }\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  var TRANSITION_TIME = 400;\\n  var NEIGHBOR_SCALE_TIME = 100;\\n  var MAIN_SLIDE_OPACITY = 1;\\n  var THROTTLE_SCROLL_TIME = 25;\\n  var INTERVAL_MINIMUM = 200;\\n\\n  var slideMixin = {\\n    created: function created() {\\n      this._clones = [];\\n      this.innerOffset = 0;\\n      this._indicator = null;\\n    },\\n\\n    beforeUpdate: function beforeUpdate() {\\n      this._getWrapperSize();\\n    },\\n\\n    updated: function updated() {\\n      var this$1 = this;\\n\\n      var children = this.$children;\\n      var len = children && children.length;\\n      if (children && len > 0) {\\n        for (var i = 0; i < len; i++) {\\n          var vm = children[i];\\n          if (vm.$options._componentTag === 'indicator' || vm.$vnode.data.ref === 'indicator') {\\n            vm._watcher.get();\\n            break;\\n          }\\n        }\\n      }\\n\\n      var frameCount = this.frameCount;\\n      if (!this._preFrameCount) {\\n        this._preFrameCount = frameCount;\\n      } else if (this._preFrameCount !== frameCount) {\\n        this._resetNodes();\\n        this._preFrameCount = frameCount;\\n        var resetBlankFrame = function resetBlankFrame() {\\n          if (this$1.currentIndex >= frameCount) {\\n            // reset blank page.\\n            this$1._stopAutoPlay();\\n            this$1._slideTo(0);\\n          }\\n        };\\n        if (this._sliding) {\\n          // If it's sliding, then the currentIndex is the last frame. The actual currentIndex\\n          // should be the next index.\\n          // That is to say, this updating happens Between _parepareNodes and _rearrangeNodes,\\n          // and the sliding is not yet finished, and the state is not updated yet.\\n          setTimeout(resetBlankFrame, TRANSITION_TIME + NEIGHBOR_SCALE_TIME);\\n        } else {\\n          resetBlankFrame();\\n        }\\n      }\\n      weex.utils.fireLazyload(this.$el, true);\\n      if (this._preIndex !== this.currentIndex) {\\n        this._slideTo(this.currentIndex);\\n      }\\n    },\\n\\n    mounted: function mounted() {\\n      this._getWrapperSize();\\n      this._slideTo(this.currentIndex);\\n      weex.utils.fireLazyload(this.$el, true);\\n    },\\n\\n    methods: {\\n      _getWrapperSize: function _getWrapperSize() {\\n        var wrapper = this.$refs.wrapper;\\n        if (wrapper) {\\n          var rect = wrapper.getBoundingClientRect();\\n          this._wrapperWidth = rect.width;\\n          this._wrapperHeight = rect.height;\\n        }\\n      },\\n\\n      _formatChildren: function _formatChildren(createElement) {\\n        var this$1 = this;\\n\\n        var children = this.$slots.default || [];\\n        var indicatorVnode;\\n        var cells = children.filter(function (vnode) {\\n          if (!vnode.tag) {\\n            return false;\\n          }\\n          if (vnode.componentOptions && vnode.componentOptions.tag === 'indicator') {\\n            indicatorVnode = vnode;\\n            return false;\\n          }\\n          return true;\\n        }).map(function (vnode) {\\n          return createElement('li', {\\n            ref: 'cells',\\n            staticClass: \\\"weex-slider-cell weex-ct\\\" + (this$1.isNeighbor ? ' neighbor-cell' : '')\\n          }, [vnode]);\\n        });\\n        if (indicatorVnode) {\\n          indicatorVnode.data.attrs = indicatorVnode.data.attrs || {};\\n          indicatorVnode.data.attrs.count = cells.length;\\n          indicatorVnode.data.attrs.active = this.currentIndex;\\n          this._indicator = indicatorVnode;\\n        }\\n        return cells;\\n      },\\n\\n      _renderSlides: function _renderSlides(createElement) {\\n        this._cells = this._formatChildren(createElement);\\n        this.frameCount = this._cells.length;\\n        return createElement('nav', {\\n          ref: 'wrapper',\\n          attrs: { 'weex-type': this.isNeighbor ? 'slider-neighbor' : 'slider' },\\n          on: {\\n            touchstart: this._handleTouchStart,\\n            touchmove: weex.utils.throttle(weex.utils.bind(this._handleTouchMove, this), 25),\\n            touchend: this._handleTouchEnd,\\n            touchcancel: this._handleTouchCancel\\n          },\\n          staticClass: 'weex-slider weex-slider-wrapper weex-ct',\\n          staticStyle: weex.extractComponentStyle(this)\\n        }, [createElement('ul', {\\n          ref: 'inner',\\n          staticClass: 'weex-slider-inner weex-ct'\\n        }, this._cells), this._indicator]);\\n      },\\n\\n      // get standard index\\n      _normalizeIndex: function _normalizeIndex(index) {\\n        var newIndex = (index + this.frameCount) % this.frameCount;\\n        return Math.min(Math.max(newIndex, 0), this.frameCount - 1);\\n      },\\n\\n      _startAutoPlay: function _startAutoPlay() {\\n        if (!this.autoPlay || this.autoPlay === 'false') {\\n          return;\\n        }\\n        if (this._autoPlayTimer) {\\n          clearTimeout(this._autoPlayTimer);\\n          this._autoPlayTimer = null;\\n        }\\n        var interval = parseInt(this.interval - TRANSITION_TIME - NEIGHBOR_SCALE_TIME);\\n        interval = interval > INTERVAL_MINIMUM ? interval : INTERVAL_MINIMUM;\\n        this._autoPlayTimer = setTimeout(weex.utils.bind(this._next, this), interval);\\n      },\\n\\n      _stopAutoPlay: function _stopAutoPlay() {\\n        if (this._autoPlayTimer) {\\n          clearTimeout(this._autoPlayTimer);\\n          this._autoPlayTimer = null;\\n        }\\n      },\\n\\n      _slideTo: function _slideTo(index, isTouchScroll) {\\n        var this$1 = this;\\n\\n        if (this.frameCount <= 0) {\\n          return;\\n        }\\n        if (!this.infinite || this.infinite === 'false') {\\n          if (index === -1 || index > this.frameCount - 1) {\\n            this._slideTo(this.currentIndex);\\n            return;\\n          }\\n        }\\n        if (!this._preIndex && this._preIndex !== 0) {\\n          if (this._showNodes && this._showNodes[0]) {\\n            this._preIndex = this._showNodes[0].index;\\n          } else {\\n            this._preIndex = this.currentIndex;\\n          }\\n        }\\n\\n        if (this._sliding) {\\n          return;\\n        }\\n        this._sliding = true;\\n\\n        var newIndex = this._normalizeIndex(index);\\n        var inner = this.$refs.inner;\\n        var step = this._step = this.frameCount <= 1 ? 0 : this._preIndex - index;\\n\\n        if (inner) {\\n          this._prepareNodes();\\n          var translate = weex.utils.getTransformObj(inner).translate;\\n          var match = translate && translate.match(/translate[^(]+\\\\(([+-\\\\d.]+)/);\\n          var innerX = match && match[1] || 0;\\n          var dist = innerX - this.innerOffset;\\n          this.innerOffset += step * this._wrapperWidth;\\n          // transform the whole slides group.\\n          inner.style.webkitTransition = \\\"-webkit-transform \\\" + TRANSITION_TIME / 1000 + \\\"s ease-in-out\\\";\\n          inner.style.mozTransition = \\\"transform \\\" + TRANSITION_TIME / 1000 + \\\"s ease-in-out\\\";\\n          inner.style.transition = \\\"transform \\\" + TRANSITION_TIME / 1000 + \\\"s ease-in-out\\\";\\n          inner.style.webkitTransform = \\\"translate3d(\\\" + this.innerOffset + \\\"px, 0, 0)\\\";\\n          inner.style.mozTransform = \\\"translate3d(\\\" + this.innerOffset + \\\"px, 0, 0)\\\";\\n          inner.style.transform = \\\"translate3d(\\\" + this.innerOffset + \\\"px, 0, 0)\\\";\\n\\n          // emit scroll events.\\n          if (!isTouchScroll) {\\n            this._emitScrollEvent('scrollstart');\\n          }\\n          setTimeout(function () {\\n            this$1._throttleEmitScroll(dist, function () {\\n              this$1._emitScrollEvent('scrollend');\\n            });\\n          }, THROTTLE_SCROLL_TIME);\\n\\n          this._loopShowNodes(step);\\n\\n          setTimeout(function () {\\n            if (this$1.isNeighbor) {\\n              this$1._setNeighbors();\\n            }\\n\\n            setTimeout(function () {\\n              inner.style.webkitTransition = '';\\n              inner.style.mozTransition = '';\\n              inner.style.transition = '';\\n              for (var i = this$1._showStartIdx; i <= this$1._showEndIdx; i++) {\\n                var node = this$1._showNodes[i];\\n                if (!node) {\\n                  continue;\\n                }\\n                var elm = node.firstElementChild;\\n                elm.style.webkitTransition = '';\\n                elm.style.mozTransition = '';\\n                elm.style.transition = '';\\n              }\\n              // clean cloned nodes and rearrange slide cells.\\n              this$1._rearrangeNodes(newIndex);\\n            }, NEIGHBOR_SCALE_TIME);\\n          }, TRANSITION_TIME);\\n        }\\n\\n        if (newIndex !== this._preIndex) {\\n          weex.utils.dispatchNativeEvent(this.$el, 'change', {\\n            index: newIndex\\n          });\\n        }\\n      },\\n\\n      _clearNodesOffset: function _clearNodesOffset() {\\n        var this$1 = this;\\n\\n        var end = this._showEndIdx;\\n        for (var i = this._showStartIdx; i <= end; i++) {\\n          var node = this$1._showNodes[i];\\n          node = node && node.firstElementChild;\\n          if (!node) {\\n            continue;\\n          }\\n          weex.utils.addTransform(this$1._showNodes[i].firstElementChild, {\\n            translate: 'translate3d(0px, 0px, 0px)'\\n          });\\n        }\\n      },\\n\\n      _loopShowNodes: function _loopShowNodes(step) {\\n        var this$1 = this;\\n\\n        if (!step || this.frameCount <= 1) {\\n          return;\\n        }\\n        var sign = step > 0 ? 1 : -1;\\n        var i = step <= 0 ? this._showStartIdx : this._showEndIdx;\\n        var end = step <= 0 ? this._showEndIdx : this._showStartIdx;\\n        for (; i !== end - sign; i -= sign) {\\n          var nextIdx = i + step;\\n          this$1._showNodes[nextIdx] = this$1._showNodes[i];\\n          this$1._showNodes[nextIdx]._showIndex = nextIdx;\\n          delete this$1._showNodes[i];\\n        }\\n        this._showStartIdx += step;\\n        this._showEndIdx += step;\\n      },\\n\\n      _prepareNodes: function _prepareNodes() {\\n        // test if the next slide towards the direction exists.\\n        // e.g. currentIndex 0 -> 1: should prepare 4 slides: -1, 0, 1, 2\\n        // if not, translate a node to here, or just clone it.\\n        var step = this._step;\\n        if (!this._inited) {\\n          this._initNodes();\\n          this._inited = true;\\n          this._showNodes = {};\\n        }\\n        if (this.frameCount <= 1) {\\n          this._showStartIdx = this._showEndIdx = 0;\\n          var node = this._cells[0].elm;\\n          node.style.opacity = 1;\\n          node.style.zIndex = 99;\\n          node.index = 0;\\n          this._showNodes[0] = node;\\n          node._inShow = true;\\n          node._showIndex = 0;\\n          return;\\n        }\\n\\n        var showCount = this._showCount = Math.abs(step) + 3;\\n        this._showStartIdx = step <= 0 ? -1 : 2 - showCount;\\n        this._showEndIdx = step <= 0 ? showCount - 2 : 1;\\n        this._clearNodesOffset();\\n        this._positionNodes(this._showStartIdx, this._showEndIdx, step);\\n      },\\n\\n      _clearClones: function _clearClones() {\\n        var this$1 = this;\\n\\n        // clear all clones.\\n        Object.keys(this._clones).forEach(function (key) {\\n          this$1._clones[key].forEach(function (cloneNode) {\\n            cloneNode.parentNode.removeChild(cloneNode);\\n          });\\n          this$1._clones[key] = [];\\n        });\\n      },\\n\\n      // reset nodes' index and _inShow state. But leave the styles\\n      // as they are to prevent dom rerendering.\\n      _resetNodes: function _resetNodes() {\\n        this._clearClones();\\n        // reset status.\\n        this._cells.forEach(function (cell, idx) {\\n          var elm = cell.elm;\\n          elm.index = idx;\\n          elm._inShow = false;\\n        });\\n      },\\n\\n      _initNodes: function _initNodes() {\\n        this._cells.forEach(function (cell, idx) {\\n          var node = cell.elm;\\n          node.index = idx;\\n          node._inShow = false;\\n          node.style.zIndex = 0;\\n          node.style.opacity = 0;\\n        });\\n      },\\n\\n      _positionNodes: function _positionNodes(begin, end, step, anim) {\\n        var this$1 = this;\\n\\n        var cells = this._cells;\\n        var start = step <= 0 ? begin : end;\\n        var stop = step <= 0 ? end : begin;\\n        var sign = step <= 0 ? -1 : 1;\\n        var cellIndex = this._preIndex + sign;\\n        for (var i = start; i !== stop - sign; i = i - sign) {\\n          var node = cells[this$1._normalizeIndex(cellIndex)].elm;\\n          cellIndex = cellIndex - sign;\\n          this$1._positionNode(node, i);\\n        }\\n      },\\n\\n      /**\\n       * index: position index in the showing cells' view.\\n       */\\n      _positionNode: function _positionNode(node, index) {\\n        var holder = this._showNodes[index];\\n        if (node._inShow && (holder !== node || holder._showIndex !== index)) {\\n          if (holder && holder._isClone) {\\n            this._removeClone(holder);\\n          }\\n          node = this._getClone(node.index);\\n        } else if (node._inShow) {\\n          // holder === node\\n          return;\\n        }\\n\\n        node._inShow = true;\\n        var translateX = index * this._wrapperWidth - this.innerOffset;\\n        weex.utils.addTransform(node, {\\n          translate: \\\"translate3d(\\\" + translateX + \\\"px, 0px, 0px)\\\"\\n        });\\n        node.style.zIndex = 99 - Math.abs(index);\\n        node.style.opacity = 1;\\n        node._showIndex = index;\\n        this._showNodes[index] = node;\\n      },\\n\\n      _getClone: function _getClone(index) {\\n        var arr = this._clones[index] || (this._clones[index] = []);\\n        var origNode = this._cells[index].elm;\\n        var clone = origNode.cloneNode(true);\\n        clone._isClone = true;\\n        clone._inShow = true;\\n        // clone._inShow = origNode._inShow\\n        clone.index = origNode.index;\\n        clone.style.opacity = 0;\\n        clone.style.zIndex = 0;\\n        this.$refs.inner.appendChild(clone);\\n        arr.push(clone);\\n        return clone;\\n        // try {\\n        //   let arr = this._clones[index]\\n        //   if (!arr) {\\n        //     this._clones[index] = arr = []\\n        //   }\\n        //   if (arr.length <= 0) {\\n\\n        //   }\\n        //   return arr.pop()\\n        // } catch (err) {\\n        //   console.error('this._cells -> ', this._cells)\\n        // }\\n      },\\n\\n      _removeClone: function _removeClone(node) {\\n        var cloneArr = this._clones[node.index];\\n        var i;\\n        if (cloneArr && (i = cloneArr.indexOf(node)) > -1) {\\n          cloneArr.splice(i, 1);\\n        }\\n        try {\\n          node.parentNode.removeChild(node);\\n        } catch (err) {}\\n        // maybe cells has been updated and this clone node is already removed from the dom tree\\n        // throught _clearClones method.\\n\\n        // const idx = node.index\\n        // this._hideNode(node)\\n        // const arr = this._clones[idx]\\n        // arr.push(node)\\n      },\\n\\n      _hideNode: function _hideNode(node) {\\n        node._inShow = false;\\n        node.style.opacity = 0;\\n        node.style.zIndex = 0;\\n      },\\n\\n      /**\\n       * hide nodes from begin to end in showArray.\\n       * if it is clone node, just move the clone node to the buffer.\\n       */\\n      _clearNodes: function _clearNodes(begin, end) {\\n        var this$1 = this;\\n\\n        for (var i = begin; i <= end; i++) {\\n          var node = this$1._showNodes[i];\\n          if (!node) {\\n            return;\\n          }\\n          if (node._isClone) {\\n            this$1._removeClone(node);\\n          } else if (!node._inShow) {\\n            this$1._hideNode(node);\\n          }\\n          delete this$1._showNodes[i];\\n        }\\n      },\\n\\n      /**\\n       * copy node style props (opacity and zIndex) and transform status from\\n       * one element to another.\\n       */\\n      _copyStyle: function _copyStyle(from, to, styles, transformExtra) {\\n        if (styles === void 0) styles = ['opacity', 'zIndex'];\\n        if (transformExtra === void 0) transformExtra = {};\\n\\n        weex.utils.extendKeys(to.style, from.style, styles);\\n        var transObj = weex.utils.getTransformObj(from);\\n        for (var k in transformExtra) {\\n          transObj[k] = transformExtra[k];\\n        }\\n        weex.utils.addTransform(to, transObj);\\n        var fromInner = from.firstElementChild;\\n        var toInner = to.firstElementChild;\\n        toInner.style.opacity = fromInner.style.opacity;\\n        weex.utils.copyTransform(fromInner, toInner);\\n      },\\n\\n      /**\\n       * replace a clone node with the original node if it's not in use.\\n       */\\n      _replaceClone: function _replaceClone(clone, pos) {\\n        var this$1 = this;\\n\\n        var origCell = this._cells[clone.index];\\n        if (!origCell) {\\n          return;\\n        }\\n        var origNode = origCell.elm;\\n        if (origNode._inShow) {\\n          return;\\n        }\\n        var origShowIndex = origNode._showIndex;\\n        var styleProps = ['opacity', 'zIndex'];\\n        var cl;\\n        if (Math.abs(origShowIndex) <= 1) {\\n          // leave a clone to replace the origNode in the show zone(-1 ~ 1).\\n          cl = this._getClone(origNode.index);\\n          this._copyStyle(origNode, cl);\\n          this._showNodes[origShowIndex] = cl;\\n        }\\n        origNode._inShow = true;\\n        var transObj = weex.utils.getTransformObj(clone);\\n        transObj.translate = transObj.translate.replace(/[+-\\\\d.]+[pw]x/, function ($0) {\\n          return pos * this$1._wrapperWidth - this$1.innerOffset + 'px';\\n        });\\n        this._copyStyle(clone, origNode, styleProps, transObj);\\n        this._removeClone(clone);\\n        if (!cl) {\\n          delete this._showNodes[origShowIndex];\\n        }\\n        this._showNodes[pos] = origNode;\\n        origNode._showIndex = pos;\\n      },\\n\\n      _rearrangeNodes: function _rearrangeNodes(newIndex) {\\n        var this$1 = this;\\n\\n        if (this.frameCount <= 1) {\\n          this._sliding = false;\\n          this.currentIndex = 0;\\n          return;\\n        }\\n\\n        // clear autoPlay timer (and restart after updated hook).\\n        this._startAutoPlay();\\n\\n        /**\\n         * clean nodes. replace current node with non-cloned node.\\n         * set current index to the new index.\\n         */\\n        var shows = this._showNodes;\\n        for (var i = this._showStartIdx; i <= this._showEndIdx; i++) {\\n          shows[i]._inShow = false;\\n        }\\n        for (var i$1 = -1; i$1 <= 1; i$1++) {\\n          var node = shows[i$1];\\n          if (!node._isClone) {\\n            node._inShow = true;\\n          } else {\\n            this$1._replaceClone(node, i$1);\\n          }\\n        }\\n\\n        this._clearNodes(this._showStartIdx, -2);\\n        this._showStartIdx = -1;\\n        this._clearNodes(2, this._showEndIdx);\\n        this._showEndIdx = 1;\\n        this._sliding = false;\\n\\n        // set current index to the new index.\\n        this.currentIndex = newIndex;\\n        this._preIndex = newIndex;\\n      },\\n\\n      /**\\n       * according to the attrs: neighborScale, neighborAlpha, neighborSpace.\\n       * 1. apply the main cell transform effects.\\n       * 2. set the previous cell and the next cell's positon, scale and alpha.\\n       * 3. set other cells' scale and alpha.\\n       */\\n      _setNeighbors: function _setNeighbors() {\\n        var this$1 = this;\\n\\n        for (var i = this._showStartIdx; i <= this._showEndIdx; i++) {\\n          var elm = this$1._showNodes[i].firstElementChild;\\n          elm.style.webkitTransition = \\\"all \\\" + NEIGHBOR_SCALE_TIME / 1000 + \\\"s ease\\\";\\n          elm.style.mozTransition = \\\"all \\\" + NEIGHBOR_SCALE_TIME / 1000 + \\\"s ease\\\";\\n          elm.style.transition = \\\"all \\\" + NEIGHBOR_SCALE_TIME / 1000 + \\\"s ease\\\";\\n          var transObj = {\\n            scale: \\\"scale(\\\" + (i === 0 ? this$1.currentItemScale : this$1.neighborScale) + \\\")\\\"\\n          };\\n          var translateX = void 0;\\n          if (!this$1._neighborWidth) {\\n            this$1._neighborWidth = parseFloat(elm.style.width) || elm.getBoundingClientRect().width;\\n          }\\n          // calculate position offsets according to neighbor scales.\\n          if (Math.abs(i) === 1) {\\n            var dist = ((this$1._wrapperWidth - this$1._neighborWidth * this$1.neighborScale) / 2 + this$1.neighborSpace * weex.config.env.scale) / this$1.neighborScale;\\n            translateX = -i * dist;\\n          } else {\\n            // clear position offsets.\\n            translateX = 0;\\n          }\\n          transObj.translate = \\\"translate3d(\\\" + translateX + \\\"px, 0px, 0px)\\\";\\n          weex.utils.addTransform(elm, transObj);\\n          elm.style.opacity = i === 0 ? MAIN_SLIDE_OPACITY : this$1.neighborAlpha;\\n        }\\n      },\\n\\n      _next: function _next() {\\n        var next = this.currentIndex + 1;\\n        if (this.frameCount <= 1) {\\n          next--;\\n        }\\n        this._slideTo(next);\\n      },\\n\\n      _prev: function _prev() {\\n        var prev = this.currentIndex - 1;\\n        if (this.frameCount <= 1) {\\n          prev++;\\n        }\\n        this._slideTo(prev);\\n      },\\n\\n      _handleTouchStart: function _handleTouchStart(event) {\\n        var touch = event.changedTouches[0];\\n        this._stopAutoPlay();\\n        var inner = this.$refs.inner;\\n        this._touchParams = {\\n          originalTransform: inner.style.webkitTransform || inner.style.mozTransform || inner.style.transform,\\n          startTouchEvent: touch,\\n          startX: touch.pageX,\\n          startY: touch.pageY,\\n          timeStamp: event.timeStamp\\n        };\\n      },\\n\\n      _handleTouchMove: function _handleTouchMove(event) {\\n        var tp = this._touchParams;\\n        if (!tp) {\\n          return;\\n        }\\n        if (this._sliding) {\\n          return;\\n        }\\n        var ref = this._touchParams;\\n        var startX = ref.startX;\\n        var startY = ref.startY;\\n        var touch = event.changedTouches[0];\\n        var offsetX = touch.pageX - startX;\\n        var offsetY = touch.pageY - startY;\\n        tp.offsetX = offsetX;\\n        tp.offsetY = offsetY;\\n        var isV = tp.isVertical;\\n        if (typeof isV === 'undefined') {\\n          isV = tp.isVertical = Math.abs(offsetX) < Math.abs(offsetY);\\n          if (!isV) {\\n            this._emitScrollEvent('scrollstart');\\n          }\\n        }\\n        // vertical scroll. just ignore it.\\n        if (isV) {\\n          return;\\n        }\\n        // horizontal scroll. trigger scroll event.\\n        event.preventDefault();\\n        var inner = this.$refs.inner;\\n        if (inner && offsetX) {\\n          if (!this._nodesOffsetCleared) {\\n            this._nodesOffsetCleared = true;\\n            this._clearNodesOffset();\\n          }\\n          this._emitScrollEvent('weex$scroll', {\\n            offsetXRatio: offsetX / this._wrapperWidth\\n          });\\n          inner.style.webkitTransform = \\\"translate3d(\\\" + (this.innerOffset + offsetX) + \\\"px, 0, 0)\\\";\\n          inner.style.mozTransform = \\\"translate3d(\\\" + (this.innerOffset + offsetX) + \\\"px, 0, 0)\\\";\\n          inner.style.transform = \\\"translate3d(\\\" + (this.innerOffset + offsetX) + \\\"px, 0, 0)\\\";\\n        }\\n      },\\n\\n      _handleTouchEnd: function _handleTouchEnd(event) {\\n        this._startAutoPlay();\\n        var tp = this._touchParams;\\n        if (!tp) {\\n          return;\\n        }\\n        var isV = tp.isVertical;\\n        if (typeof isV === 'undefined') {\\n          return;\\n        }\\n        var inner = this.$refs.inner;\\n        var offsetX = tp.offsetX;\\n        if (inner) {\\n          this._nodesOffsetCleared = false;\\n          // TODO: test the velocity if it's less than 0.2.\\n          var reset = Math.abs(offsetX / this._wrapperWidth) < 0.2;\\n          var direction = offsetX > 0 ? 1 : -1;\\n          var newIndex = reset ? this.currentIndex : this.currentIndex - direction;\\n          this._slideTo(newIndex, true);\\n        }\\n        delete this._touchParams;\\n      },\\n\\n      _handleTouchCancel: function _handleTouchCancel(event) {\\n        return this._handleTouchEnd(event);\\n      },\\n\\n      _emitScrollEvent: function _emitScrollEvent(type, data) {\\n        if (data === void 0) data = {};\\n\\n        var el = this.$el;\\n        if (el) {\\n          weex.utils.dispatchNativeEvent(el, type, data);\\n        }\\n      },\\n\\n      _throttleEmitScroll: function _throttleEmitScroll(offset, callback) {\\n        var this$1 = this;\\n\\n        var i = 0;\\n        var throttleTime = THROTTLE_SCROLL_TIME;\\n        var cnt = parseInt(TRANSITION_TIME / throttleTime) - 1;\\n        var sign = offset > 0 ? 1 : -1;\\n        var r = Math.abs(offset / this._wrapperWidth);\\n        var throttledScroll = function throttledScroll() {\\n          if (++i > cnt) {\\n            return callback && callback.call(this$1);\\n          }\\n          var ratio = this$1._step === 0 ? sign * r * (1 - i / cnt) : sign * (r + (1 - r) * i / cnt);\\n          this$1._emitScrollEvent('weex$scroll', {\\n            offsetXRatio: ratio\\n          });\\n          setTimeout(throttledScroll, THROTTLE_SCROLL_TIME);\\n        };\\n        throttledScroll();\\n      }\\n    }\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  // import { validateStyles } from '../../validator'\\n  // import indicator from './indicator'\\n  var slider$1 = {\\n    mixins: [slideMixin],\\n    props: {\\n      index: {\\n        type: [String, Number],\\n        default: 0\\n      },\\n      'auto-play': {\\n        type: [String, Boolean],\\n        default: false\\n      },\\n      interval: {\\n        type: [String, Number],\\n        default: 3000\\n      },\\n      infinite: {\\n        type: [String, Boolean],\\n        default: true\\n      }\\n    },\\n\\n    watch: {\\n      index: function index() {\\n        this.currentIndex = this._normalizeIndex(this.index);\\n      }\\n    },\\n\\n    data: function data() {\\n      return {\\n        frameCount: 0,\\n        currentIndex: this.index\\n      };\\n    },\\n\\n    beforeCreate: function beforeCreate() {\\n      this.weexType = 'slider';\\n    },\\n\\n    render: function render(createElement) {\\n      /* istanbul ignore next */\\n      // if (\\\"production\\\" === 'development') {\\n      //   validateStyles('slider', this.$vnode.data && this.$vnode.data.staticStyle)\\n      // }\\n      return this._renderSlides(createElement);\\n    }\\n  };\\n\\n  var slider$2 = {\\n    init: function init(weex) {\\n      weex.registerComponent('slider', slider$1);\\n      weex.registerComponent('cycleslider', slider$1);\\n    }\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  var DEFAULT_NEIGHBOR_SPACE = 20;\\n  var DEFAULT_NEIGHBOR_ALPHA = 0.6;\\n  var DEFAULT_NEIGHBOR_SCALE = 0.8;\\n  var DEFAULT_CURRENT_ITEM_SCALE = 0.9;\\n\\n  var sliderNeighbor = {\\n    mixins: [slideMixin],\\n    props: {\\n      index: {\\n        type: [String, Number],\\n        default: 0\\n      },\\n      autoPlay: {\\n        type: [String, Boolean],\\n        default: false\\n      },\\n      interval: {\\n        type: [String, Number],\\n        default: 3000\\n      },\\n      infinite: {\\n        type: [String, Boolean],\\n        default: true\\n      },\\n      neighborSpace: {\\n        type: [String, Number],\\n        validator: function validator(val) {\\n          val = parseFloat(val);\\n          return !isNaN(val) && val > 0;\\n        },\\n        default: DEFAULT_NEIGHBOR_SPACE\\n      },\\n      neighborAlpha: {\\n        type: [String, Number],\\n        validator: function validator(val) {\\n          val = parseFloat(val);\\n          return !isNaN(val) && val >= 0 && val <= 1;\\n        },\\n        default: DEFAULT_NEIGHBOR_ALPHA\\n      },\\n      neighborScale: {\\n        type: [String, Number],\\n        validator: function validator(val) {\\n          val = parseFloat(val);\\n          return !isNaN(val) && val >= 0 && val <= 1;\\n        },\\n        default: DEFAULT_NEIGHBOR_SCALE\\n      },\\n      currentItemScale: {\\n        type: [String, Number],\\n        validator: function validator(val) {\\n          val = parseFloat(val);\\n          return !isNaN(val) && val >= 0 && val <= 1;\\n        },\\n        default: DEFAULT_CURRENT_ITEM_SCALE\\n      }\\n    },\\n\\n    watch: {\\n      index: function index() {\\n        this.currentIndex = this._normalizeIndex(this.index);\\n      }\\n    },\\n\\n    data: function data() {\\n      return {\\n        currentIndex: this.index,\\n        frameCount: 0\\n      };\\n    },\\n\\n    beforeCreate: function beforeCreate() {\\n      this.isNeighbor = true;\\n      this.weexType = 'slider-neighbor';\\n    },\\n\\n    render: function render(createElement) {\\n      return this._renderSlides(createElement);\\n    }\\n  };\\n\\n  var neighbor = {\\n    init: function init(weex) {\\n      weex.registerComponent('slider-neighbor', sliderNeighbor);\\n    }\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n\\n  var getComponentInlineStyle$1;\\n\\n  function getIndicatorItemStyle(ms, isActive) {\\n    var style = {};\\n    var bgColor = isActive ? ms['itemSelectedColor'] || ms['item-selected-color'] : ms['itemColor'] || ms['item-color'];\\n    style['background-color'] = bgColor;\\n    style['width'] = style['height'] = ms['itemSize'] || ms['item-size'];\\n    return style;\\n  }\\n\\n  function getScopeIds(context) {\\n    var scopeIds = context._scopeIds;\\n    if (scopeIds) {\\n      return scopeIds;\\n    } else {\\n      scopeIds = [];\\n    }\\n    var parent = context.$parent;\\n    while (parent) {\\n      var i = void 0;\\n      if ((i = parent.$options) && (i = i._scopeId)) {\\n        scopeIds.push(i);\\n      }\\n      parent = parent.$parent;\\n    }\\n    context._scopeIds = scopeIds;\\n    return scopeIds;\\n  }\\n\\n  function _render(context, h) {\\n    var children = [];\\n    var mergedStyle = getComponentInlineStyle$1(context);\\n    var scopeIds = getScopeIds(context);\\n    var attrs = {};\\n    for (var i = 0, l = scopeIds.length; i < l; i++) {\\n      attrs[scopeIds[i]] = '';\\n    }\\n    for (var i$1 = 0; i$1 < Number(context.count); ++i$1) {\\n      var classNames = ['weex-indicator-item weex-el'];\\n      var isActive = false;\\n      if (i$1 === Number(context.active)) {\\n        classNames.push('weex-indicator-item-active');\\n        isActive = true;\\n      }\\n      children.push(h('mark', {\\n        attrs: attrs,\\n        staticClass: classNames.join(' '),\\n        staticStyle: getIndicatorItemStyle(mergedStyle, isActive)\\n      }));\\n    }\\n    return h('nav', {\\n      attrs: { 'weex-type': 'indicator' },\\n      staticClass: 'weex-indicator weex-ct'\\n    }, [\\n    // the indicator nav may cover the slides, and may stop the\\n    // click event be triggered on the slides.\\n    // so a smaller wrapper is needed to prevent the overlap.\\n    // This wrapper will cover only the whole size of all the\\n    // indicator pointers' item-sizes.\\n    h('div', {\\n      staticClass: 'weex-indicator-inner'\\n    }, children)]);\\n  }\\n\\n  var indicator = {\\n    name: 'weex-indicator',\\n    methods: {\\n      show: function show() {\\n        this.$el.style.visibility = 'visible';\\n      }\\n    },\\n    props: {\\n      itemColor: [String],\\n      itemSelectedColor: [String],\\n      itemSize: [String]\\n    },\\n    data: function data() {\\n      return {\\n        count: 0,\\n        active: 0\\n      };\\n    },\\n    render: function render(createElement) {\\n      var ref = this.$vnode.data.attrs || {};\\n      var count = ref.count;\\n      var active = ref.active;\\n      this.count = count;\\n      this.active = active;\\n      if (!this.count) {\\n        return;\\n      }\\n      return _render(this, createElement);\\n    }\\n  };\\n\\n  var indicator$1 = {\\n    init: function init(weex) {\\n      getComponentInlineStyle$1 = weex.getComponentInlineStyle;\\n      weex.registerComponent('indicator', indicator);\\n    }\\n  };\\n\\n  __$styleInject(\\\"/*\\\\n * Licensed to the Apache Software Foundation (ASF) under one\\\\n * or more contributor license agreements.  See the NOTICE file\\\\n * distributed with this work for additional information\\\\n * regarding copyright ownership.  The ASF licenses this file\\\\n * to you under the Apache License, Version 2.0 (the\\\\n * \\\\\\\"License\\\\\\\"); you may not use this file except in compliance\\\\n * with the License.  You may obtain a copy of the License at\\\\n *\\\\n *   http://www.apache.org/licenses/LICENSE-2.0\\\\n *\\\\n * Unless required by applicable law or agreed to in writing,\\\\n * software distributed under the License is distributed on an\\\\n * \\\\\\\"AS IS\\\\\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\\\n * KIND, either express or implied.  See the License for the\\\\n * specific language governing permissions and limitations\\\\n * under the License.\\\\n */\\\\n \\\\n.weex-slider-wrapper {\\\\n  overflow: hidden;\\\\n}\\\\n\\\\n.weex-slider-inner {\\\\n  width: 100%;\\\\n  height: 100%;\\\\n  overflow: visible;\\\\n  -webkit-box-orient: horizontal;\\\\n  -webkit-box-direction: normal;\\\\n  -webkit-flex-direction: row;\\\\n          flex-direction: row;\\\\n}\\\\n\\\\n.weex-slider-cell {\\\\n  width: 100%;\\\\n  height: 100%;\\\\n  position: absolute;\\\\n  top: 0px;\\\\n  left: 0px;\\\\n  background: transparent !important;\\\\n  overflow: hidden;\\\\n  -webkit-box-align: center;\\\\n  -webkit-align-items: center;\\\\n          align-items: center;\\\\n  -webkit-box-pack: center;\\\\n  -webkit-justify-content: center;\\\\n          justify-content: center;\\\\n}\\\\n\\\\n.neighbor-cell {\\\\n  overflow: visible !important;\\\\n}\\\\n\\\\nnav.weex-indicator {\\\\n  position: absolute;\\\\n  z-index: 10;\\\\n  -webkit-box-orient: horizontal;\\\\n  -webkit-box-direction: normal;\\\\n  -webkit-flex-direction: row;\\\\n          flex-direction: row;\\\\n  margin: 0;\\\\n  padding: 0;\\\\n  -webkit-box-align: center;\\\\n  -webkit-align-items: center;\\\\n          align-items: center;\\\\n  -webkit-box-pack: center;\\\\n  -webkit-justify-content: center;\\\\n          justify-content: center;\\\\n  -webkit-transform: translate(-10rem, 0px);\\\\n          transform: translate(-10rem, 0px)\\\\n}\\\\n\\\\ndiv.weex-indicator-inner {\\\\n  -webkit-transform: translate(10rem, 0px);\\\\n          transform: translate(10rem, 0px);\\\\n  -webkit-box-orient: horizontal;\\\\n  -webkit-box-direction: normal;\\\\n  -webkit-flex-direction: row;\\\\n          flex-direction: row;\\\\n}\\\\n\\\\n.weex-indicator-item {\\\\n  display: inline-block;\\\\n  position: relative;\\\\n  border-radius: 50%;\\\\n  width: 0.266667rem;\\\\n  height: 0.266667rem;\\\\n  background-color: #BBBBBB;\\\\n}\\\\n.weex-indicator-item + .weex-indicator-item {\\\\n  margin-left: 0.133333rem;\\\\n}\\\\n\\\\n.weex-indicator-item-active {\\\\n  background-color: blue;\\\\n}\\\", undefined);\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n\\n  var slider = {\\n    init: function init(weex) {\\n      weex.install(slider$2);\\n      weex.install(neighbor);\\n      weex.install(indicator$1);\\n    }\\n  };\\n\\n  __$styleInject(\\\"/*\\\\n * Licensed to the Apache Software Foundation (ASF) under one\\\\n * or more contributor license agreements.  See the NOTICE file\\\\n * distributed with this work for additional information\\\\n * regarding copyright ownership.  The ASF licenses this file\\\\n * to you under the Apache License, Version 2.0 (the\\\\n * \\\\\\\"License\\\\\\\"); you may not use this file except in compliance\\\\n * with the License.  You may obtain a copy of the License at\\\\n *\\\\n *   http://www.apache.org/licenses/LICENSE-2.0\\\\n *\\\\n * Unless required by applicable law or agreed to in writing,\\\\n * software distributed under the License is distributed on an\\\\n * \\\\\\\"AS IS\\\\\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\\\n * KIND, either express or implied.  See the License for the\\\\n * specific language governing permissions and limitations\\\\n * under the License.\\\\n */\\\\n.weex-textarea {\\\\n  font-size: 0.426667rem\\\\n}\\\\n.weex-textarea:focus {\\\\n  outline: none;\\\\n}\\\\n\\\", undefined);\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  function getTextarea(weex) {\\n    var extractComponentStyle = weex.extractComponentStyle;\\n    var ref = weex.mixins;\\n    var inputCommon = ref.inputCommon;\\n    var ref$1 = weex.utils;\\n    var extend = ref$1.extend;\\n    var mapFormEvents = ref$1.mapFormEvents;\\n\\n    return {\\n      name: 'weex-textarea',\\n      mixins: [inputCommon],\\n      props: {\\n        value: String,\\n        placeholder: String,\\n        disabled: {\\n          type: [String, Boolean],\\n          default: false\\n        },\\n        autofocus: {\\n          type: [String, Boolean],\\n          default: false\\n        },\\n        rows: {\\n          type: [String, Number],\\n          default: 2\\n        },\\n        returnKeyType: String\\n      },\\n\\n      render: function render(createElement) {\\n        /* istanbul ignore next */\\n        // if (\\\"production\\\" === 'development') {\\n        //   validateStyles('textarea', this.$vnode.data && this.$vnode.data.staticStyle)\\n        // }\\n        var events = extend(mapFormEvents(this));\\n        return createElement('html:textarea', {\\n          attrs: {\\n            'weex-type': 'textarea',\\n            value: this.value,\\n            disabled: this.disabled !== 'false' && this.disabled !== false,\\n            autofocus: this.autofocus !== 'false' && this.autofocus !== false,\\n            placeholder: this.placeholder,\\n            rows: this.rows,\\n            'return-key-type': this.returnKeyType\\n          },\\n          domProps: {\\n            value: this.value\\n          },\\n          on: this.createKeyboardEvent(events),\\n          staticClass: 'weex-textarea weex-el',\\n          staticStyle: extractComponentStyle(this)\\n        });\\n      }\\n    };\\n  }\\n\\n  var textarea = {\\n    init: function init(weex) {\\n      weex.registerComponent('textarea', getTextarea(weex));\\n    }\\n  };\\n\\n  /*\\n  * Licensed to the Apache Software Foundation (ASF) under one\\n  * or more contributor license agreements.  See the NOTICE file\\n  * distributed with this work for additional information\\n  * regarding copyright ownership.  The ASF licenses this file\\n  * to you under the Apache License, Version 2.0 (the\\n  * \\\"License\\\"); you may not use this file except in compliance\\n  * with the License.  You may obtain a copy of the License at\\n  *\\n  *   http://www.apache.org/licenses/LICENSE-2.0\\n  *\\n  * Unless required by applicable law or agreed to in writing,\\n  * software distributed under the License is distributed on an\\n  * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n  * KIND, either express or implied.  See the License for the\\n  * specific language governing permissions and limitations\\n  * under the License.\\n  */\\n\\n  function getVideo(weex) {\\n    var extractComponentStyle = weex.extractComponentStyle;\\n    var mapNativeEvents = weex.mapNativeEvents;\\n    var ref = weex.utils;\\n    var dispatchNativeEvent = ref.dispatchNativeEvent;\\n\\n    return {\\n      name: 'weex-video',\\n      props: {\\n        src: String,\\n        playStatus: {\\n          type: String,\\n          default: 'pause',\\n          validator: function validator(value) {\\n            return ['play', 'pause'].indexOf(value) !== -1;\\n          }\\n        },\\n        autoplay: {\\n          type: [String, Boolean],\\n          default: false\\n        },\\n        autoPlay: {\\n          type: [String, Boolean],\\n          default: false\\n        },\\n        playsinline: {\\n          type: [String, Boolean],\\n          default: true\\n        },\\n        controls: {\\n          type: [String, Boolean],\\n          default: false\\n        }\\n      },\\n\\n      render: function render(createElement) {\\n        if (this.playStatus === 'play') {\\n          this.$nextTick(function () {\\n            try {\\n              this.$el && this.$el.play();\\n            } catch (err) {\\n              dispatchNativeEvent(this && this.$el, 'error', {\\n                message: err.message\\n              });\\n            }\\n          });\\n        } else if (this.playStatus === 'pause') {\\n          this.$nextTick(function () {\\n            this.$el && this.$el.pause();\\n          });\\n        }\\n\\n        return createElement('html:video', {\\n          attrs: {\\n            'weex-type': 'video',\\n            autoplay: this.autoplay !== 'false' && this.autoplay !== false || this.autoPlay !== 'false' && this.autoPlay !== false,\\n            'webkit-playsinline': this.playsinline,\\n            controls: this.controls,\\n            src: this.src\\n          },\\n          on: mapNativeEvents(this, {\\n            play: 'start',\\n            error: 'fail'\\n          }),\\n          staticClass: 'weex-video weex-el',\\n          staticStyle: extractComponentStyle(this)\\n        });\\n      }\\n    };\\n  }\\n\\n  var video = {\\n    init: function init(weex) {\\n      weex.registerComponent('video', getVideo(weex));\\n    }\\n  };\\n\\n  __$styleInject(\\\"/*\\\\n * Licensed to the Apache Software Foundation (ASF) under one\\\\n * or more contributor license agreements.  See the NOTICE file\\\\n * distributed with this work for additional information\\\\n * regarding copyright ownership.  The ASF licenses this file\\\\n * to you under the Apache License, Version 2.0 (the\\\\n * \\\\\\\"License\\\\\\\"); you may not use this file except in compliance\\\\n * with the License.  You may obtain a copy of the License at\\\\n *\\\\n *   http://www.apache.org/licenses/LICENSE-2.0\\\\n *\\\\n * Unless required by applicable law or agreed to in writing,\\\\n * software distributed under the License is distributed on an\\\\n * \\\\\\\"AS IS\\\\\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\\\n * KIND, either express or implied.  See the License for the\\\\n * specific language governing permissions and limitations\\\\n * under the License.\\\\n */\\\\n.weex-web {\\\\n  position: relative;\\\\n  width: 100%;\\\\n  height: 100%;\\\\n  border: none;\\\\n  -webkit-box-sizing: border-box;\\\\n          box-sizing: border-box;\\\\n}\\\\n\\\", undefined);\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  function getWeb(weex) {\\n    var extractComponentStyle = weex.extractComponentStyle;\\n    var ref = weex.utils;\\n    var dispatchNativeEvent = ref.dispatchNativeEvent;\\n\\n    return {\\n      data: function data() {\\n        return {\\n          currentSrc: ''\\n        };\\n      },\\n      name: 'weex-web',\\n      props: {\\n        src: String\\n      },\\n      watch: {\\n        src: function src(newVal) {\\n          this.currentSrc = newVal;\\n        }\\n      },\\n      methods: {\\n        goBack: function goBack() {\\n          var el = this.$el;\\n          if (el) {\\n            var win = el.contentWindow;\\n            try {\\n              win.history.back();\\n              this.currentSrc = win.location.href;\\n            } catch (err) {\\n              dispatchNativeEvent(el, 'error', err);\\n            }\\n          }\\n        },\\n        goForward: function goForward() {\\n          var el = this.$el;\\n          if (el) {\\n            var win = el.contentWindow;\\n            try {\\n              win.history.forward();\\n              this.currentSrc = win.location.href;\\n            } catch (err) {\\n              dispatchNativeEvent(el, 'error', err);\\n            }\\n          }\\n        },\\n        reload: function reload() {\\n          var el = this.$el;\\n          if (el) {\\n            try {\\n              el.contentWindow.location.reload();\\n              dispatchNativeEvent(el, 'pagestart', { url: this.currentSrc });\\n            } catch (err) {\\n              dispatchNativeEvent(el, 'error', err);\\n            }\\n          }\\n        }\\n      },\\n\\n      created: function created() {\\n        this.currentSrc = this.src;\\n      },\\n\\n      mounted: function mounted() {\\n        var el = this.$el;\\n        this._prevSrc = this.currentSrc;\\n        if (el) {\\n          dispatchNativeEvent(el, 'pagestart', { url: this.currentSrc });\\n        }\\n      },\\n\\n      updated: function updated() {\\n        if (this.currentSrc !== this._prevSrc) {\\n          this._prevSrc = this.currentSrc;\\n          dispatchNativeEvent(this.$el, 'pagestart', { url: this.currentSrc });\\n        }\\n      },\\n\\n      render: function render(createElement) {\\n        var this$1 = this;\\n\\n        return createElement('iframe', {\\n          attrs: {\\n            'weex-type': 'web',\\n            src: this.currentSrc\\n          },\\n          on: {\\n            load: function load(event) {\\n              this$1.$nextTick(function () {\\n                var el = this.$el;\\n                try {\\n                  var html = el.contentWindow.document.documentElement;\\n                  if (html) {\\n                    dispatchNativeEvent(el, 'pagefinish', { url: this.currentSrc });\\n                  } else {\\n                    dispatchNativeEvent(el, 'error', new Error('[vue-render]:found no page content.'));\\n                  }\\n                } catch (err) {\\n                  dispatchNativeEvent(el, 'error', err);\\n                }\\n              });\\n            }\\n          },\\n          staticClass: 'weex-web weex-el',\\n          staticStyle: extractComponentStyle(this)\\n        });\\n      }\\n    };\\n  }\\n\\n  var web = {\\n    init: function init(weex) {\\n      weex.registerComponent('web', getWeb(weex));\\n    }\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  // import a from './a'\\n  // import div from './div'\\n  // import image from './image'\\n  // import text from './text'\\n  var components = [\\n  // a,\\n  // div,\\n  // image,\\n  input, _switch, scrollable, slider,\\n  // text,\\n  textarea, video, web];\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  var supportGeolocation = 'geolocation' in navigator;\\n  var errorMsg = \\\"[h5-render]: browser doesn't support geolocation.\\\";\\n\\n  var geolocation = {\\n    // options:\\n    //   - enableHighAccuracy optional, value is true or false, false by default.\\n    //   - timeout [none-native] optional, value is a number (milliseconds), default vaule is FINFINITY.\\n    //   - maximumAge [none-native] optional, value is a number (milliseconds), default value is 0.\\n    getCurrentPosition: function getCurrentPosition(successCbId, errorCbId, options) {\\n      var this$1 = this;\\n\\n      var successCb = function successCb(pos) {\\n        return this$1.sender.performCallback(successCbId, pos);\\n      };\\n      var errorCb = function errorCb(err) {\\n        return this$1.sender.performCallback(errorCbId, err);\\n      };\\n      if (supportGeolocation) {\\n        navigator.geolocation.getCurrentPosition(successCb, errorCb, options);\\n      } else {\\n        console.warn(errorMsg);\\n        errorCb(new Error(errorMsg));\\n      }\\n    },\\n\\n    // options: the same with `getCurrentPosition`.\\n    watchPosition: function watchPosition(successCbId, errorCbId, options) {\\n      var this$1 = this;\\n\\n      var successCb = function successCb(pos) {\\n        return this$1.sender.performCallback(successCbId, pos, true);\\n      };\\n      var errorCb = function errorCb(err) {\\n        return this$1.sender.performCallback(errorCbId, err);\\n      };\\n      if (supportGeolocation) {\\n        var id = navigator.geolocation.watchPosition(function (pos) {\\n          pos.watchId = id;\\n          successCb(pos);\\n        }, errorCb, options);\\n      } else {\\n        console.warn(errorMsg);\\n        errorCb(new Error(errorMsg));\\n      }\\n    },\\n\\n    clearWatch: function clearWatch(watchId) {\\n      if (supportGeolocation) {\\n        navigator.geolocation.clearWatch(watchId);\\n      } else {\\n        console.warn(errorMsg);\\n      }\\n    }\\n  };\\n\\n  var meta = {\\n    geolocation: [{\\n      name: 'getCurrentPosition',\\n      args: ['function', 'function', 'object']\\n    }, {\\n      name: 'watchPosition',\\n      args: ['function', 'function', 'object']\\n    }, {\\n      name: 'clearWatch',\\n      args: ['string']\\n    }]\\n  };\\n\\n  var geolocation$1 = {\\n    init: function init(Weex) {\\n      Weex.registerApiModule('geolocation', geolocation, meta);\\n    }\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  /* global localStorage */\\n\\n  var supportLocalStorage = false;\\n  try {\\n    supportLocalStorage = typeof localStorage !== 'undefined';\\n  } catch (err) {\\n    // not support.\\n  }\\n\\n  var SUCCESS = 'success';\\n  var FAILED = 'failed';\\n  var INVALID_PARAM = 'invalid_param';\\n  var UNDEFINED = 'undefined';\\n\\n  function callFail(sender, callbackId, errorMsg) {\\n    sender.performCallback(callbackId, {\\n      result: FAILED,\\n      data: errorMsg || UNDEFINED\\n    });\\n  }\\n\\n  function callNotSupportFail(sender, callbackId) {\\n    sender.performCallback(callbackId, {\\n      result: FAILED,\\n      data: 'localStorage is disabled or not supported.'\\n    });\\n  }\\n\\n  var storage = {\\n\\n    /**\\n     * When passed a key name and value, will add that key to the storage,\\n     * or update that key's value if it already exists.\\n     * @param {string} key\\n     * @param {string} value not null nor undifinedbut 0 works.\\n     * @param {function} callbackId\\n     */\\n    setItem: function setItem(key, value, callbackId) {\\n      var sender = this.sender;\\n      if (!supportLocalStorage) {\\n        return callNotSupportFail(sender, callbackId);\\n      }\\n      if (!key || !value && value !== 0) {\\n        sender.performCallback(callbackId, {\\n          result: 'failed',\\n          data: INVALID_PARAM\\n        });\\n        return;\\n      }\\n      try {\\n        localStorage.setItem(key, value);\\n        sender.performCallback(callbackId, {\\n          result: SUCCESS,\\n          data: UNDEFINED\\n        });\\n      } catch (e) {\\n        // accept any exception thrown during a storage attempt as a quota error\\n        callFail(sender, callbackId);\\n      }\\n    },\\n\\n    /**\\n     * When passed a key name, will return that key's value.\\n     * @param {string} key\\n     * @param {function} callbackId\\n     */\\n    getItem: function getItem(key, callbackId) {\\n      var sender = this.sender;\\n      if (!supportLocalStorage) {\\n        return callNotSupportFail(sender, callbackId);\\n      }\\n      if (!key) {\\n        sender.performCallback(callbackId, {\\n          result: FAILED,\\n          data: INVALID_PARAM\\n        });\\n        return;\\n      }\\n      try {\\n        var val = localStorage.getItem(key);\\n        sender.performCallback(callbackId, {\\n          result: val ? SUCCESS : FAILED,\\n          data: val || UNDEFINED\\n        });\\n      } catch (e) {\\n        // accept any exception thrown during a storage attempt as a quota error\\n        callFail(sender, callbackId);\\n      }\\n    },\\n\\n    /**\\n     *When passed a key name, will remove that key from the storage.\\n     * @param {string} key\\n     * @param {function} callbackId\\n     */\\n    removeItem: function removeItem(key, callbackId) {\\n      var sender = this.sender;\\n      if (!supportLocalStorage) {\\n        return callNotSupportFail(sender, callbackId);\\n      }\\n      if (!key) {\\n        sender.performCallback(callbackId, {\\n          result: FAILED,\\n          data: INVALID_PARAM\\n        });\\n        return;\\n      }\\n      try {\\n        localStorage.removeItem(key);\\n        sender.performCallback(callbackId, {\\n          result: SUCCESS,\\n          data: UNDEFINED\\n        });\\n      } catch (e) {\\n        // accept any exception thrown during a storage attempt as a quota error\\n        callFail(sender, callbackId);\\n      }\\n    },\\n\\n    /**\\n     * Returns an integer representing the number of data items stored in the Storage object.\\n     * @param {function} callbackId\\n     */\\n    length: function length(callbackId) {\\n      var sender = this.sender;\\n      if (!supportLocalStorage) {\\n        return callNotSupportFail(sender, callbackId);\\n      }\\n      try {\\n        var len = localStorage.length;\\n        sender.performCallback(callbackId, {\\n          result: SUCCESS,\\n          data: len\\n        });\\n      } catch (e) {\\n        // accept any exception thrown during a storage attempt as a quota error\\n        callFail(sender, callbackId);\\n      }\\n    },\\n\\n    /**\\n     * Returns an array that contains all keys stored in Storage object.\\n     * @param {function} callbackId\\n     */\\n    getAllKeys: function getAllKeys(callbackId) {\\n      var sender = this.sender;\\n      if (!supportLocalStorage) {\\n        return callNotSupportFail(sender, callbackId);\\n      }\\n      try {\\n        var _arr = [];\\n        for (var i = 0; i < localStorage.length; i++) {\\n          _arr.push(localStorage.key(i));\\n        }\\n        sender.performCallback(callbackId, {\\n          result: SUCCESS,\\n          data: _arr\\n        });\\n      } catch (e) {\\n        // accept any exception thrown during a storage attempt as a quota error\\n        callFail(sender, callbackId);\\n      }\\n    }\\n  };\\n\\n  var meta$1 = {\\n    storage: [{\\n      name: 'setItem',\\n      args: ['string', 'string', 'function']\\n    }, {\\n      name: 'getItem',\\n      args: ['string', 'function']\\n    }, {\\n      name: 'removeItem',\\n      args: ['string', 'function']\\n    }, {\\n      name: 'length',\\n      args: ['function']\\n    }, {\\n      name: 'getAllKeys',\\n      args: ['function']\\n    }]\\n  };\\n\\n  var storage$1 = {\\n    init: function init(Weex) {\\n      Weex.registerApiModule('storage', storage, meta$1);\\n    }\\n  };\\n\\n  typeof window === 'undefined' && (window = { ctrl: {}, lib: {} });!window.ctrl && (window.ctrl = {});!window.lib && (window.lib = {});!function (a, b) {\\n    function c(a) {\\n      var b = {};Object.defineProperty(this, \\\"params\\\", { set: function set(a) {\\n          if (\\\"object\\\" == (typeof a === 'undefined' ? 'undefined' : _typeof(a))) {\\n            for (var c in b) {\\n              delete b[c];\\n            }for (var c in a) {\\n              b[c] = a[c];\\n            }\\n          }\\n        }, get: function get() {\\n          return b;\\n        }, enumerable: !0 }), Object.defineProperty(this, \\\"search\\\", { set: function set(a) {\\n          if (\\\"string\\\" == typeof a) {\\n            0 === a.indexOf(\\\"?\\\") && (a = a.substr(1));var c = a.split(\\\"&\\\");for (var d in b) {\\n              delete b[d];\\n            }for (var e = 0; e < c.length; e++) {\\n              var f = c[e].split(\\\"=\\\");if (void 0 !== f[1] && (f[1] = f[1].toString()), f[0]) {\\n                try {\\n                  b[decodeURIComponent(f[0])] = decodeURIComponent(f[1]);\\n                } catch (g) {\\n                  b[f[0]] = f[1];\\n                }\\n              }\\n            }\\n          }\\n        }, get: function get() {\\n          var a = [];for (var c in b) {\\n            if (void 0 !== b[c]) {\\n              if (\\\"\\\" !== b[c]) {\\n                try {\\n                  a.push(encodeURIComponent(c) + \\\"=\\\" + encodeURIComponent(b[c]));\\n                } catch (d) {\\n                  a.push(c + \\\"=\\\" + b[c]);\\n                }\\n              } else {\\n                try {\\n                  a.push(encodeURIComponent(c));\\n                } catch (d) {\\n                  a.push(c);\\n                }\\n              }\\n            }\\n          }return a.length ? \\\"?\\\" + a.join(\\\"&\\\") : \\\"\\\";\\n        }, enumerable: !0 });var c;Object.defineProperty(this, \\\"hash\\\", { set: function set(a) {\\n          \\\"string\\\" == typeof a && (a && a.indexOf(\\\"#\\\") < 0 && (a = \\\"#\\\" + a), c = a || \\\"\\\");\\n        }, get: function get() {\\n          return c;\\n        }, enumerable: !0 }), this.set = function (a) {\\n        a = a || \\\"\\\";var b;if (!(b = a.match(new RegExp(\\\"^([a-z0-9-]+:)?[/]{2}(?:([^@/:?]+)(?::([^@/:]+))?@)?([^:/?#]+)(?:[:]([0-9]+))?([/][^?#;]*)?(?:[?]([^#]*))?([#][^?]*)?$\\\", \\\"i\\\")))) {\\n          throw new Error(\\\"Wrong uri scheme.\\\");\\n        }this.protocol = b[1] || (\\\"object\\\" == (typeof location === 'undefined' ? 'undefined' : _typeof(location)) ? location.protocol : \\\"\\\"), this.username = b[2] || \\\"\\\", this.password = b[3] || \\\"\\\", this.hostname = this.host = b[4], this.port = b[5] || \\\"\\\", this.pathname = b[6] || \\\"/\\\", this.search = b[7] || \\\"\\\", this.hash = b[8] || \\\"\\\", this.origin = this.protocol + \\\"//\\\" + this.hostname;\\n      }, this.toString = function () {\\n        var a = this.protocol + \\\"//\\\";return this.username && (a += this.username, this.password && (a += \\\":\\\" + this.password), a += \\\"@\\\"), a += this.host, this.port && \\\"80\\\" !== this.port && (a += \\\":\\\" + this.port), this.pathname && (a += this.pathname), this.search && (a += this.search), this.hash && (a += this.hash), a;\\n      }, a && this.set(a.toString());\\n    }b.httpurl = function (a) {\\n      return new c(a);\\n    };\\n  }(window, window.lib || (window.lib = {}));var httpurl_common = window.lib['httpurl'];\\n\\n  var strictUriEncode = function strictUriEncode(str) {\\n    return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {\\n      return '%' + c.charCodeAt(0).toString(16).toUpperCase();\\n    });\\n  };\\n\\n  /*\\n  object-assign\\n  (c) Sindre Sorhus\\n  @license MIT\\n  */\\n\\n  /* eslint-disable no-unused-vars */\\n  var getOwnPropertySymbols = Object.getOwnPropertySymbols;\\n  var hasOwnProperty$1 = Object.prototype.hasOwnProperty;\\n  var propIsEnumerable = Object.prototype.propertyIsEnumerable;\\n\\n  function toObject$1(val) {\\n    if (val === null || val === undefined) {\\n      throw new TypeError('Object.assign cannot be called with null or undefined');\\n    }\\n\\n    return Object(val);\\n  }\\n\\n  function shouldUseNative() {\\n    try {\\n      if (!Object.assign) {\\n        return false;\\n      }\\n\\n      // Detect buggy property enumeration order in older V8 versions.\\n\\n      // https://bugs.chromium.org/p/v8/issues/detail?id=4118\\n      var test1 = new String('abc'); // eslint-disable-line no-new-wrappers\\n      test1[5] = 'de';\\n      if (Object.getOwnPropertyNames(test1)[0] === '5') {\\n        return false;\\n      }\\n\\n      // https://bugs.chromium.org/p/v8/issues/detail?id=3056\\n      var test2 = {};\\n      for (var i = 0; i < 10; i++) {\\n        test2['_' + String.fromCharCode(i)] = i;\\n      }\\n      var order2 = Object.getOwnPropertyNames(test2).map(function (n) {\\n        return test2[n];\\n      });\\n      if (order2.join('') !== '0123456789') {\\n        return false;\\n      }\\n\\n      // https://bugs.chromium.org/p/v8/issues/detail?id=3056\\n      var test3 = {};\\n      'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\\n        test3[letter] = letter;\\n      });\\n      if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {\\n        return false;\\n      }\\n\\n      return true;\\n    } catch (err) {\\n      // We don't expect any of the above to throw, but better to be safe.\\n      return false;\\n    }\\n  }\\n\\n  var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {\\n    var arguments$1 = arguments;\\n\\n    var from;\\n    var to = toObject$1(target);\\n    var symbols;\\n\\n    for (var s = 1; s < arguments.length; s++) {\\n      from = Object(arguments$1[s]);\\n\\n      for (var key in from) {\\n        if (hasOwnProperty$1.call(from, key)) {\\n          to[key] = from[key];\\n        }\\n      }\\n\\n      if (getOwnPropertySymbols) {\\n        symbols = getOwnPropertySymbols(from);\\n        for (var i = 0; i < symbols.length; i++) {\\n          if (propIsEnumerable.call(from, symbols[i])) {\\n            to[symbols[i]] = from[symbols[i]];\\n          }\\n        }\\n      }\\n    }\\n\\n    return to;\\n  };\\n\\n  function encoderForArrayFormat(opts) {\\n    switch (opts.arrayFormat) {\\n      case 'index':\\n        return function (key, value, index) {\\n          return value === null ? [encode(key, opts), '[', index, ']'].join('') : [encode(key, opts), '[', encode(index, opts), ']=', encode(value, opts)].join('');\\n        };\\n\\n      case 'bracket':\\n        return function (key, value) {\\n          return value === null ? encode(key, opts) : [encode(key, opts), '[]=', encode(value, opts)].join('');\\n        };\\n\\n      default:\\n        return function (key, value) {\\n          return value === null ? encode(key, opts) : [encode(key, opts), '=', encode(value, opts)].join('');\\n        };\\n    }\\n  }\\n\\n  function parserForArrayFormat(opts) {\\n    var result;\\n\\n    switch (opts.arrayFormat) {\\n      case 'index':\\n        return function (key, value, accumulator) {\\n          result = /\\\\[(\\\\d*)\\\\]$/.exec(key);\\n\\n          key = key.replace(/\\\\[\\\\d*\\\\]$/, '');\\n\\n          if (!result) {\\n            accumulator[key] = value;\\n            return;\\n          }\\n\\n          if (accumulator[key] === undefined) {\\n            accumulator[key] = {};\\n          }\\n\\n          accumulator[key][result[1]] = value;\\n        };\\n\\n      case 'bracket':\\n        return function (key, value, accumulator) {\\n          result = /(\\\\[\\\\])$/.exec(key);\\n          key = key.replace(/\\\\[\\\\]$/, '');\\n\\n          if (!result) {\\n            accumulator[key] = value;\\n            return;\\n          } else if (accumulator[key] === undefined) {\\n            accumulator[key] = [value];\\n            return;\\n          }\\n\\n          accumulator[key] = [].concat(accumulator[key], value);\\n        };\\n\\n      default:\\n        return function (key, value, accumulator) {\\n          if (accumulator[key] === undefined) {\\n            accumulator[key] = value;\\n            return;\\n          }\\n\\n          accumulator[key] = [].concat(accumulator[key], value);\\n        };\\n    }\\n  }\\n\\n  function encode(value, opts) {\\n    if (opts.encode) {\\n      return opts.strict ? strictUriEncode(value) : encodeURIComponent(value);\\n    }\\n\\n    return value;\\n  }\\n\\n  function keysSorter(input) {\\n    if (Array.isArray(input)) {\\n      return input.sort();\\n    } else if ((typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object') {\\n      return keysSorter(Object.keys(input)).sort(function (a, b) {\\n        return Number(a) - Number(b);\\n      }).map(function (key) {\\n        return input[key];\\n      });\\n    }\\n\\n    return input;\\n  }\\n\\n  var extract = function extract(str) {\\n    return str.split('?')[1] || '';\\n  };\\n\\n  var parse = function parse(str, opts) {\\n    opts = objectAssign({ arrayFormat: 'none' }, opts);\\n\\n    var formatter = parserForArrayFormat(opts);\\n\\n    // Create an object with no prototype\\n    // https://github.com/sindresorhus/query-string/issues/47\\n    var ret = Object.create(null);\\n\\n    if (typeof str !== 'string') {\\n      return ret;\\n    }\\n\\n    str = str.trim().replace(/^(\\\\?|#|&)/, '');\\n\\n    if (!str) {\\n      return ret;\\n    }\\n\\n    str.split('&').forEach(function (param) {\\n      var parts = param.replace(/\\\\+/g, ' ').split('=');\\n      // Firefox (pre 40) decodes `%3D` to `=`\\n      // https://github.com/sindresorhus/query-string/pull/37\\n      var key = parts.shift();\\n      var val = parts.length > 0 ? parts.join('=') : undefined;\\n\\n      // missing `=` should be `null`:\\n      // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\\n      val = val === undefined ? null : decodeURIComponent(val);\\n\\n      formatter(decodeURIComponent(key), val, ret);\\n    });\\n\\n    return Object.keys(ret).sort().reduce(function (result, key) {\\n      var val = ret[key];\\n      if (Boolean(val) && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && !Array.isArray(val)) {\\n        // Sort object keys, not values\\n        result[key] = keysSorter(val);\\n      } else {\\n        result[key] = val;\\n      }\\n\\n      return result;\\n    }, Object.create(null));\\n  };\\n\\n  var stringify = function stringify(obj, opts) {\\n    var defaults = {\\n      encode: true,\\n      strict: true,\\n      arrayFormat: 'none'\\n    };\\n\\n    opts = objectAssign(defaults, opts);\\n\\n    var formatter = encoderForArrayFormat(opts);\\n\\n    return obj ? Object.keys(obj).sort().map(function (key) {\\n      var val = obj[key];\\n\\n      if (val === undefined) {\\n        return '';\\n      }\\n\\n      if (val === null) {\\n        return encode(key, opts);\\n      }\\n\\n      if (Array.isArray(val)) {\\n        var result = [];\\n\\n        val.slice().forEach(function (val2) {\\n          if (val2 === undefined) {\\n            return;\\n          }\\n\\n          result.push(formatter(key, val2, result.length));\\n        });\\n\\n        return result.join('&');\\n      }\\n\\n      return encode(key, opts) + '=' + encode(val, opts);\\n    }).filter(function (x) {\\n      return x.length > 0;\\n    }).join('&') : '';\\n  };\\n\\n  var queryString = {\\n    extract: extract,\\n    parse: parse,\\n    stringify: stringify\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  /* global lib, XMLHttpRequest */\\n  /* deps: httpurl */\\n\\n  var utils$1;\\n\\n  var jsonpCnt = 0;\\n  var ERROR_STATE = -1;\\n\\n  function _jsonp(config, callback, progressCallback) {\\n    var cbName = config.jsonpCallbackName || 'jsonp_' + ++jsonpCnt;\\n    var url;\\n\\n    if (!config.url) {\\n      console.error('[h5-render] config.url should be set in _jsonp for \\\\'fetch\\\\' API.');\\n    }\\n\\n    global[cbName] = function (cb) {\\n      return function (response) {\\n        callback({\\n          status: 200,\\n          ok: true,\\n          statusText: 'OK',\\n          data: response\\n        });\\n        delete global[cb];\\n      };\\n    }(cbName);\\n\\n    var script = document.createElement('script');\\n    try {\\n      url = lib.httpurl(config.url);\\n    } catch (err) {\\n      console.error('[h5-render] invalid config.url in _jsonp for \\\\'fetch\\\\' API: ' + config.url);\\n    }\\n    url.params.callback = cbName;\\n    script.type = 'text/javascript';\\n    script.src = url.toString();\\n    // script.onerror is not working on IE or safari.\\n    // but they are not considered here.\\n    script.onerror = function (cb) {\\n      return function (err) {\\n        console.error('[h5-render] unexpected error in _jsonp for \\\\'fetch\\\\' API', err);\\n        callback({\\n          status: ERROR_STATE,\\n          ok: false,\\n          statusText: '',\\n          data: ''\\n        });\\n        delete global[cb];\\n      };\\n    }(cbName);\\n    var head = document.getElementsByTagName('head')[0];\\n    head.insertBefore(script, null);\\n  }\\n\\n  function _xhr(config, callback, progressCallback) {\\n    var xhr = new XMLHttpRequest();\\n    xhr.responseType = config.type;\\n    xhr.open(config.method, config.url, true);\\n\\n    // cors cookie support\\n    if (config.withCredentials === true) {\\n      xhr.withCredentials = true;\\n    }\\n\\n    var headers = config.headers || {};\\n    for (var k in headers) {\\n      xhr.setRequestHeader(k, headers[k]);\\n    }\\n\\n    xhr.onload = function (res) {\\n      callback({\\n        status: xhr.status,\\n        ok: xhr.status >= 200 && xhr.status < 300,\\n        statusText: xhr.statusText,\\n        data: xhr.response,\\n        headers: xhr.getAllResponseHeaders().split('\\\\n').reduce(function (obj, headerStr) {\\n          var headerArr = headerStr.match(/(.+): (.+)/);\\n          if (headerArr) {\\n            obj[headerArr[1]] = headerArr[2];\\n          }\\n          return obj;\\n        }, {})\\n      });\\n    };\\n\\n    if (progressCallback) {\\n      xhr.onprogress = function (e) {\\n        progressCallback({\\n          readyState: xhr.readyState,\\n          status: xhr.status,\\n          length: e.loaded,\\n          total: e.total,\\n          statusText: xhr.statusText,\\n          headers: xhr.getAllResponseHeaders().split('\\\\n').reduce(function (obj, headerStr) {\\n            var headerArr = headerStr.match(/(.+): (.+)/);\\n            if (headerArr) {\\n              obj[headerArr[1]] = headerArr[2];\\n            }\\n            return obj;\\n          }, {})\\n        });\\n      };\\n    }\\n\\n    xhr.onerror = function (err) {\\n      console.error('[h5-render] unexpected error in _xhr for \\\\'fetch\\\\' API', err);\\n      callback({\\n        status: ERROR_STATE,\\n        ok: false,\\n        statusText: '',\\n        data: ''\\n      });\\n    };\\n\\n    xhr.send(config.body || null);\\n  }\\n\\n  var stream = {\\n\\n    /**\\n     * sendHttp\\n     * @deprecated\\n     * Note: This API is deprecated. Please use stream.fetch instead.\\n     * send a http request through XHR.\\n     * @param  {obj} params\\n     *  - method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'HEAD' | 'PATCH',\\n     *  - url: url requested\\n     * @param  {string} callbackId\\n     */\\n    sendHttp: function sendHttp(param, callbackId) {\\n      if (typeof param === 'string') {\\n        try {\\n          param = JSON.parse(param);\\n        } catch (e) {\\n          return;\\n        }\\n      }\\n      if ((typeof param === 'undefined' ? 'undefined' : _typeof(param)) !== 'object' || !param.url) {\\n        return console.error('[h5-render] invalid config or invalid config.url for sendHttp API');\\n      }\\n\\n      var sender = this.sender;\\n      var method = param.method || 'GET';\\n      var xhr = new XMLHttpRequest();\\n      xhr.open(method, param.url, true);\\n      xhr.onload = function () {\\n        sender.performCallback(callbackId, this.responseText);\\n      };\\n      xhr.onerror = function (error) {\\n        return console.error('[h5-render] unexpected error in sendHttp API', error);\\n        // sender.performCallback(\\n        //   callbackId,\\n        //   new Error('unexpected error in sendHttp API')\\n        // )\\n      };\\n      xhr.send();\\n    },\\n\\n    /**\\n     * fetch\\n     * use stream.fetch to request for a json file, a plain text file or\\n     * a arraybuffer for a file stream. (You can use Blob and FileReader\\n     * API implemented by most modern browsers to read a arraybuffer.)\\n     * @param  {object} options config options\\n     *   - method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'HEAD' | 'PATCH'\\n     *   - headers {obj}\\n     *   - url {string}\\n     *   - mode {string} 'cors' | 'no-cors' | 'same-origin' | 'navigate'\\n     *   - withCredentials {boolean}\\n     *   - body\\n     *   - type {string} 'json' | 'jsonp' | 'text'\\n     * @param  {string} callbackId\\n     * @param  {string} progressCallbackId\\n     */\\n    fetch: function fetch(options, callbackId, progressCallbackId) {\\n      var DEFAULT_METHOD = 'GET';\\n      var DEFAULT_MODE = 'cors';\\n      var DEFAULT_TYPE = 'text';\\n\\n      var methodOptions = ['GET', 'POST', 'PUT', 'DELETE', 'HEAD', 'PATCH'];\\n      var modeOptions = ['cors', 'no-cors', 'same-origin', 'navigate'];\\n      var typeOptions = ['text', 'json', 'jsonp', 'arraybuffer'];\\n\\n      // const fallback = false  // fallback from 'fetch' API to XHR.\\n      var sender = this.sender;\\n\\n      var config = utils$1.extend({}, options);\\n\\n      // validate options.method\\n      if (typeof config.method === 'undefined') {\\n        config.method = DEFAULT_METHOD;\\n        console.warn('[h5-render] options.method for \\\\'fetch\\\\' API has been set to ' + 'default value \\\\'' + config.method + '\\\\'');\\n      } else if (methodOptions.indexOf((config.method + '').toUpperCase()) === -1) {\\n        return console.error('[h5-render] options.method \\\\'' + config.method + '\\\\' for \\\\'fetch\\\\' API should be one of ' + methodOptions + '.');\\n      }\\n\\n      // validate options.url\\n      if (!config.url) {\\n        return console.error('[h5-render] options.url should be set for \\\\'fetch\\\\' API.');\\n      }\\n\\n      // validate body content for method 'GET'.\\n      if (config.method.toUpperCase() === 'GET') {\\n        var body = config.body;\\n        if (utils$1.isPlainObject(body)) {\\n          body = queryString.stringify(body);\\n        }\\n        var url = config.url;\\n        var hashIdx = url.indexOf('#');\\n        hashIdx <= -1 && (hashIdx = url.length);\\n        var hash = url.substr(hashIdx);\\n        if (hash && hash[0] === '#') {\\n          hash = hash.substr(1);\\n        }\\n        url = url.substring(0, hashIdx);\\n        if (body) {\\n          url += (config.url.indexOf('?') <= -1 ? '?' : '&') + body;\\n        }\\n        url += '#' + hash;\\n        config.url = url;\\n      }\\n\\n      // validate options.mode\\n      if (typeof config.mode === 'undefined') {\\n        config.mode = DEFAULT_MODE;\\n      } else if (modeOptions.indexOf((config.mode + '').toLowerCase()) === -1) {\\n        return console.error('[h5-render] options.mode \\\\'' + config.mode + '\\\\' for \\\\'fetch\\\\' API should be one of ' + modeOptions + '.');\\n      }\\n\\n      // validate options.type\\n      if (typeof config.type === 'undefined') {\\n        config.type = DEFAULT_TYPE;\\n        console.warn('[h5-render] options.type for \\\\'fetch\\\\' API has been set to ' + 'default value \\\\'' + config.type + '\\\\'.');\\n      } else if (typeOptions.indexOf((config.type + '').toLowerCase()) === -1) {\\n        return console.error('[h5-render] options.type \\\\'' + config.type + '\\\\' for \\\\'fetch\\\\' API should be one of ' + typeOptions + '.');\\n      }\\n\\n      // validate options.headers\\n      config.headers = config.headers || {};\\n      if (!utils$1.isPlainObject(config.headers)) {\\n        return console.error('[h5-render] options.headers should be a plain object');\\n      }\\n\\n      // validate options.timeout\\n      config.timeout = parseInt(config.timeout, 10) || 2500;\\n\\n      var _callArgs = [config, function (res) {\\n        sender.performCallback(callbackId, res);\\n      }];\\n      if (progressCallbackId) {\\n        _callArgs.push(function (res) {\\n          // Set 'keepAlive' to true for sending continuous callbacks\\n          sender.performCallback(progressCallbackId, res, true);\\n        });\\n      }\\n\\n      if (config.type === 'jsonp') {\\n        _jsonp.apply(this, _callArgs);\\n      } else {\\n        _xhr.apply(this, _callArgs);\\n      }\\n    }\\n\\n  };\\n\\n  var meta$2 = {\\n    stream: [{\\n      name: 'sendHttp',\\n      args: ['object', 'function']\\n    }, {\\n      name: 'fetch',\\n      args: ['object', 'function', 'function']\\n    }]\\n  };\\n\\n  var stream$1 = {\\n    init: function init(Weex) {\\n      utils$1 = Weex.utils;\\n      Weex.registerApiModule('stream', stream, meta$2);\\n    }\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  /**\\n  \\n  AUCTION:\\n  taskQueue\\n  Clipboard.setString()  NOW not works, facing to user-act lose of taskQueue.\\n  \\n  works in Chrome Firefox Opera. but not in Safari.\\n  @see https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand#Browser_compatibility\\n  \\n  Clipboard.getString() unimplemented. There is no easy way to do paste from clipboard to js variable.\\n  \\n  So look out your app behavior, when downgrade to html5 render.\\n  Any idea is welcome.\\n  **/\\n\\n  var WEEX_CLIPBOARD_ID = '__weex_clipboard_id__';\\n\\n  var clipboard = {\\n\\n    getString: function getString(callbackId) {\\n      // not supported in html5\\n      console.log('clipboard.getString() is not supported now.');\\n    },\\n\\n    setString: function setString(text) {\\n      // not support safari\\n      if (typeof text === 'string' && text !== '' && document.execCommand) {\\n        var tempInput = element();\\n        tempInput.value = text;\\n\\n        tempInput.select();\\n        document.execCommand('copy');\\n        // var out = document.execCommand('copy');\\n        // console.log(\\\"execCommand out is \\\" + out);\\n        tempInput.value = '';\\n        tempInput.blur();\\n      } else {\\n        console.log('only support string input now');\\n      }\\n    }\\n\\n  };\\n\\n  function element() {\\n    var tempInput = document.getElementById(WEEX_CLIPBOARD_ID);\\n    if (!tempInput) {\\n      tempInput = document.createElement('input');\\n      tempInput.setAttribute('id', WEEX_CLIPBOARD_ID);\\n      tempInput.style.cssText = 'height:1px;width:1px;border:none;';\\n      // tempInput.style.cssText = \\\"height:40px;width:300px;border:solid;\\\"\\n      document.body.appendChild(tempInput);\\n    }\\n    return tempInput;\\n  }\\n\\n  var meta$3 = {\\n    clipboard: [{\\n      name: 'getString',\\n      args: ['function']\\n    }, {\\n      name: 'setString',\\n      args: ['string']\\n    }]\\n  };\\n\\n  var clipboard$1 = {\\n    init: function init(Weex) {\\n      Weex.registerApiModule('clipboard', clipboard, meta$3);\\n    }\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  var event$2 = {\\n    /**\\n     * openUrl\\n     * @param  {string} url\\n     */\\n    openURL: function openURL(url) {\\n      location.href = url;\\n    }\\n\\n  };\\n\\n  var meta$4 = {\\n    event: [{\\n      name: 'openURL',\\n      args: ['string']\\n    }]\\n  };\\n\\n  var eventModule = {\\n    init: function init(Weex) {\\n      Weex.registerApiModule('event', event$2, meta$4);\\n    }\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  var utils$2 = {};\\n  var endEvent;\\n  var styleName;\\n\\n  var DESIGN_ROOT_VALUE = 75;\\n\\n  var EVENT_NAME_MAP = {\\n    transition: 'transitionend',\\n    WebkitTransition: 'webkitTransitionEnd',\\n    MozTransition: 'mozTransitionEnd',\\n    OTransition: 'oTransitionEnd',\\n    msTransition: 'MSTransitionEnd'\\n  };\\n\\n  function detectEvents() {\\n    var testEl = document.createElement('div');\\n    var style = testEl.style;\\n    for (var name in EVENT_NAME_MAP) {\\n      if (name in style) {\\n        endEvent = EVENT_NAME_MAP[name];\\n        styleName = name;\\n        break;\\n      }\\n    }\\n  }\\n\\n  detectEvents();\\n\\n  function transitionOnce(vnode, config, callback) {\\n    var nextFrame = utils$2.nextFrame;\\n    var toCSSText = utils$2.toCSSText;\\n    var styleObject2rem = utils$2.styleObject2rem;\\n    var isArray = utils$2.isArray;\\n\\n    if (isArray(vnode)) {\\n      vnode = vnode[0];\\n    }\\n\\n    var duration = config.duration || 0; // ms\\n    var timing = config.timingFunction || 'linear';\\n    var delay = config.delay || 0; // ms\\n\\n    // TODO: parse transition properties\\n    var transitionValue = \\\"all \\\" + duration + \\\"ms \\\" + timing + \\\" \\\" + delay + \\\"ms\\\";\\n\\n    var dom = vnode instanceof HTMLElement ? vnode : vnode.$el;\\n    // trigger image lazyloading by force.\\n    dom && weex.utils.fireLazyload(dom, true);\\n\\n    var transitionEndHandler = function transitionEndHandler(event) {\\n      event && event.stopPropagation();\\n      if (endEvent) {\\n        dom.removeEventListener(endEvent, transitionEndHandler);\\n        dom.style[styleName] = '';\\n      }\\n      callback();\\n    };\\n    if (endEvent) {\\n      dom.style[styleName] = transitionValue;\\n      dom.addEventListener(endEvent, transitionEndHandler);\\n    }\\n    nextFrame(function () {\\n      dom.style.cssText += toCSSText(styleObject2rem(config.styles, DESIGN_ROOT_VALUE) || {});\\n    });\\n  }\\n\\n  var animation = {\\n    /**\\n     * transition\\n     * @param  {String} vnode\\n     * @param  {Object} config\\n     * @param  {String} callback\\n     */\\n    transition: function transition(vnode, config, callback) {\\n      if (!config.styles) {\\n        return;\\n      }\\n      return transitionOnce(vnode, config, function () {\\n        callback && callback();\\n      });\\n    }\\n  };\\n\\n  var animation$1 = {\\n    init: function init(weex) {\\n      var extendKeys = weex.utils.extendKeys;\\n      extendKeys(utils$2, weex.utils, ['nextFrame', 'toCSSText', 'styleObject2rem',\\n      // 'autoPrefix',\\n      // 'normalizeStyle',\\n      'isArray']);\\n\\n      weex.registerModule('animation', animation);\\n    }\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  var utils$3 = {};\\n\\n  function now() {\\n    var now = window.performance && window.performance.now ? window.performance.now.bind(window.performance) : Date.now;\\n    return now();\\n  }\\n\\n  function scrollElement(dSuffix, position) {\\n    if (this === document.body || this === window && window.scrollTo) {\\n      return window.scrollTo(0, position);\\n    }\\n    this[\\\"scroll\\\" + dSuffix] = position;\\n  }\\n  /**\\n   * self invoked function that, given a context, steps through scrolling\\n   * @method step\\n   * @param {Object} context\\n   */\\n  function step$1(context) {\\n    // call method again on next available frame\\n    context.frame = window.requestAnimationFrame(step$1.bind(window, context));\\n    var time = now();\\n    var elapsed = (time - context.startTime) / 468;\\n    // avoid elapsed times higher than one\\n    elapsed = elapsed > 1 ? 1 : elapsed;\\n    // apply easing to elapsed time\\n    var value = ease(elapsed);\\n    var currentPosition = context.startPosition + (context.position - context.startPosition) * value;\\n    context.method.call(context.scrollable, context.dSuffix, currentPosition);\\n    // return when end points have been reached\\n    /**\\n      * NOTE: should use ~~ to parse position number into integer. Otherwise\\n      * this two float numbers maybe have a slicely little difference, which\\n      * will cause this function never to stop.\\n    */\\n    if (~~currentPosition === ~~context.position) {\\n      window.cancelAnimationFrame(context.frame);\\n      return;\\n    }\\n  }\\n  /**\\n   * returns result of applying ease math function to a number\\n   * @method ease\\n   * @param {Number} k\\n   * @returns {Number}\\n   */\\n  function ease(k) {\\n    return 0.5 * (1 - Math.cos(Math.PI * k));\\n  }\\n  var dom = {\\n    /**\\n     * scrollToElement\\n     * @param  {Vnode | VComponent} vnode\\n     * @param  {Object} options {offset:Number}\\n     *   ps: scroll-to has 'ease' and 'duration'(ms) as options.\\n     */\\n    scrollToElement: function scrollToElement(vnode, options) {\\n      var isArray = utils$3.isArray;\\n      var getParentScrollerElement = utils$3.getParentScrollerElement;\\n      if (isArray(vnode)) {\\n        vnode = vnode[0];\\n      }\\n      var isElement = vnode instanceof HTMLElement;\\n      var el = isElement ? vnode : vnode.$el || vnode.elm;\\n      var ct = getParentScrollerElement(vnode);\\n      var scroller = ct.__vue__;\\n      var isWindow = ct === document.body;\\n      var scrollDirection = isWindow ? 'vertical' : scroller && scroller.scrollDirection || 'vertical';\\n      if (ct && el) {\\n        var dSuffix = {\\n          horizontal: 'Left',\\n          vertical: 'Top'\\n        }[scrollDirection];\\n        var ctRect = ct.getBoundingClientRect();\\n        var elRect = el.getBoundingClientRect();\\n        /**\\n          * if it's a waterfall, and you want to scroll to a header, then just\\n          * scroll to the top.\\n        */\\n        if (!isElement && scroller && scroller.weexType === 'waterfall' && scroller._headers && scroller._headers.indexOf(vnode.$vnode || vnode) > -1) {\\n          // it's in waterfall. just scroll to the top.\\n          elRect = ct.firstElementChild.getBoundingClientRect();\\n        }\\n        var dir = dSuffix.toLowerCase();\\n        var offset = (isWindow ? 0 : ct[\\\"scroll\\\" + dSuffix]) + elRect[dir] - ctRect[dir];\\n        if (options) {\\n          offset += options.offset && options.offset * weex.config.env.scale || 0;\\n        } else {}\\n        if (options && options.animated === false) {\\n          return scrollElement.call(ct, dSuffix, offset);\\n        }\\n        step$1({\\n          scrollable: ct,\\n          startTime: now(),\\n          frame: null,\\n          startPosition: isWindow ? window.pageYOffset : ct[\\\"scroll\\\" + dSuffix],\\n          position: offset,\\n          method: scrollElement,\\n          dSuffix: dSuffix\\n        });\\n      }\\n    },\\n    /**\\n     * getComponentRect\\n     * @param {String} vnode\\n     * @param {Function} callback\\n     */\\n    getComponentRect: function getComponentRect(vnode, callback) {\\n      var isArray = utils$3.isArray;\\n      if (isArray(vnode)) {\\n        vnode = vnode[0];\\n      }\\n      var scale = window.weex.config.env.scale;\\n      var info = {\\n        result: false\\n      };\\n      var rectKeys = ['width', 'height', 'top', 'bottom', 'left', 'right'];\\n\\n      function recalc(rect) {\\n        var res = {};\\n        rectKeys.forEach(function (key) {\\n          if (rect[key]) {\\n            res[key] = rect[key] / scale;\\n          }\\n        });\\n        return res;\\n      }\\n      if (vnode && vnode === 'viewport') {\\n        info.result = true;\\n        info.size = recalc({\\n          width: document.documentElement.clientWidth,\\n          height: document.documentElement.clientHeight,\\n          top: 0,\\n          left: 0,\\n          right: document.documentElement.clientWidth,\\n          bottom: document.documentElement.clientHeight\\n        });\\n      } else if (vnode) {\\n        var el = vnode instanceof HTMLElement ? vnode : vnode.$el;\\n        if (el.getBoundingClientRect) {\\n          info.result = true;\\n          info.size = recalc(el.getBoundingClientRect());\\n        } else {\\n          info.result = false;\\n        }\\n      }\\n      var message = info.result ? info : {\\n        result: false,\\n        errMsg: 'Illegal parameter'\\n      };\\n      callback && callback(message);\\n      return message;\\n    },\\n    /**\\n     * for adding fontFace\\n     * @param {string} key fontFace\\n     * @param {object} styles rules\\n     */\\n    addRule: function addRule(key, styles) {\\n      var camelToKebab = utils$3.camelToKebab;\\n      var appendCss = utils$3.appendCss;\\n      key = camelToKebab(key);\\n      var stylesText = '';\\n      for (var k in styles) {\\n        if (styles.hasOwnProperty(k)) {\\n          stylesText += camelToKebab(k) + ':' + styles[k] + ';';\\n        }\\n      }\\n      var styleText = \\\"@\\\" + key + \\\"{\\\" + stylesText + \\\"}\\\";\\n      appendCss(styleText, 'dom-added-rules');\\n    }\\n  };\\n  var dom$1 = {\\n    init: function init(weex) {\\n      var extendKeys = weex.utils.extendKeys;\\n      extendKeys(utils$3, weex.utils, ['camelToKebab', 'appendCss', 'isArray', 'getParentScrollerElement']);\\n      weex.registerModule('dom', dom);\\n    }\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  /**\\n   * globalEvent API:\\n   * @doc http://weex.apache.org/cn/references/modules/globalevent.html\\n   */\\n  // track varies kinds of events and listeners.\\n  var handlerTraker = {};\\n\\n  var globalEvent = {\\n    /**\\n     * addEventListener\\n     * NOTE: one callback can only be bound to the same event once. Bind a callback twice doesn't\\n     *  mean it will be called twice when the event fired once.\\n     * @param {string} evt - the event name to add a listener on.\\n     */\\n    addEventListener: function addEventListener(evt, callback) {\\n      if (!callback) {\\n        return;\\n      }\\n      var handlers = handlerTraker[evt];\\n      if (!handlers) {\\n        handlers = handlerTraker[evt] = [];\\n      }\\n      var len = handlers.length;\\n      for (var i = 0; i < len; i++) {\\n        if (handlers[i] === callback) {\\n          // this callback is already bound. no need to bind it again.\\n          return;\\n        }\\n      }\\n      handlers.push(callback);\\n      document.addEventListener(evt, callback);\\n    },\\n\\n    /**\\n     * removeEventListener\\n     * NOTE: remove all the event handlers for the specified event type.\\n     * @param {string} evt - the event name to remove a listener from.\\n     */\\n    removeEventListener: function removeEventListener(evt) {\\n      var handlers = handlerTraker[evt];\\n      if (!handlers) {\\n        // evt handlers has been already removed.\\n        return;\\n      }\\n      handlers.forEach(function (cb) {\\n        return document.removeEventListener(evt, cb);\\n      });\\n      delete handlerTraker[evt];\\n    }\\n  };\\n\\n  var globalEvent$1 = {\\n    init: function init(weex) {\\n      weex.registerModule('globalEvent', globalEvent);\\n    }\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  var queue$1 = [];\\n  var isProcessing = false;\\n  var toastWin;\\n  var TOAST_WIN_CLASS_NAME = 'weex-toast';\\n  var TOAST_TRANSITION_DURATION = 0.4;\\n\\n  var DEFAULT_DURATION = 0.8;\\n\\n  function showToastWindow(msg, callback) {\\n    if (!toastWin) {\\n      toastWin = document.createElement('div');\\n      toastWin.classList.add(TOAST_WIN_CLASS_NAME);\\n      toastWin.classList.add('hide');\\n      document.body.appendChild(toastWin);\\n    }\\n    toastWin.textContent = msg;\\n    setTimeout(function () {\\n      toastWin.classList.remove('hide');\\n      callback && callback();\\n    }, 16);\\n  }\\n\\n  function hideToastWindow(callback) {\\n    if (!toastWin) {\\n      return;\\n    }\\n    toastWin.classList.add('hide');\\n    setTimeout(function () {\\n      callback && callback();\\n    }, TOAST_TRANSITION_DURATION * 1000);\\n  }\\n\\n  var _toast = {\\n    push: function push(msg, duration) {\\n      queue$1.push({\\n        msg: msg,\\n        duration: duration || DEFAULT_DURATION\\n      });\\n      this.show();\\n    },\\n\\n    show: function show() {\\n      var that = this;\\n\\n      // All messages had been toasted already, so remove the toast window,\\n      if (!queue$1.length) {\\n        toastWin && toastWin.parentNode.removeChild(toastWin);\\n        toastWin = null;\\n        return;\\n      }\\n\\n      // the previous toast is not ended yet.\\n      if (isProcessing) {\\n        return;\\n      }\\n      isProcessing = true;\\n\\n      var toastInfo = queue$1.shift();\\n      showToastWindow(toastInfo.msg, function () {\\n        setTimeout(function () {\\n          hideToastWindow(function () {\\n            isProcessing = false;\\n            that.show();\\n          });\\n        }, toastInfo.duration * 1000);\\n      });\\n    }\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n\\n  // there will be only one instance of modal.\\n  var MODAL_WRAP_CLASS = 'weex-modal-wrap';\\n  var MODAL_NODE_CLASS = 'weex-modal-node';\\n\\n  function Modal() {\\n    this.wrap = document.querySelector(MODAL_WRAP_CLASS);\\n    this.node = document.querySelector(MODAL_NODE_CLASS);\\n    if (!this.wrap) {\\n      this.createWrap();\\n    }\\n    if (!this.node) {\\n      this.createNode();\\n    }\\n    this.clearNode();\\n    this.createNodeContent();\\n    this.bindEvents();\\n  }\\n\\n  Modal.prototype = {\\n\\n    show: function show() {\\n      this.wrap.style.display = 'block';\\n      this.node.classList.remove('hide');\\n    },\\n\\n    destroy: function destroy() {\\n      document.body.removeChild(this.wrap);\\n      document.body.removeChild(this.node);\\n      this.wrap = null;\\n      this.node = null;\\n    },\\n\\n    createWrap: function createWrap() {\\n      this.wrap = document.createElement('div');\\n      this.wrap.className = MODAL_WRAP_CLASS;\\n      document.body.appendChild(this.wrap);\\n    },\\n\\n    createNode: function createNode() {\\n      this.node = document.createElement('div');\\n      this.node.classList.add(MODAL_NODE_CLASS, 'hide');\\n      document.body.appendChild(this.node);\\n    },\\n\\n    clearNode: function clearNode() {\\n      this.node.innerHTML = '';\\n    },\\n\\n    createNodeContent: function createNodeContent() {\\n\\n      // do nothing.\\n      // child classes can override this method.\\n    },\\n\\n    bindEvents: function bindEvents() {\\n      this.wrap.addEventListener('click', function (e) {\\n        e.preventDefault();\\n        e.stopPropagation();\\n      });\\n    }\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  var CONTENT_CLASS = 'content';\\n  var MSG_CLASS = 'content-msg';\\n  var BUTTON_GROUP_CLASS = 'btn-group';\\n  var BUTTON_CLASS = 'btn';\\n\\n  function Alert(config) {\\n    this.msg = config.message || '';\\n    this.callback = config.callback;\\n    this.okTitle = config.okTitle || 'OK';\\n    Modal.call(this);\\n    this.node.classList.add('weex-alert');\\n  }\\n\\n  Alert.prototype = Object.create(Modal.prototype);\\n\\n  Alert.prototype.createNodeContent = function () {\\n    var content = document.createElement('div');\\n    content.classList.add(CONTENT_CLASS);\\n    this.node.appendChild(content);\\n\\n    var msg = document.createElement('div');\\n    msg.classList.add(MSG_CLASS);\\n    msg.appendChild(document.createTextNode(this.msg));\\n    content.appendChild(msg);\\n\\n    var buttonGroup = document.createElement('div');\\n    buttonGroup.classList.add(BUTTON_GROUP_CLASS);\\n    this.node.appendChild(buttonGroup);\\n    var button = document.createElement('div');\\n    button.classList.add(BUTTON_CLASS, 'alert-ok');\\n    button.appendChild(document.createTextNode(this.okTitle));\\n    buttonGroup.appendChild(button);\\n  };\\n\\n  Alert.prototype.bindEvents = function () {\\n    Modal.prototype.bindEvents.call(this);\\n    var button = this.node.querySelector('.' + BUTTON_CLASS);\\n    button.addEventListener('click', function () {\\n      this.destroy();\\n      this.callback && this.callback();\\n    }.bind(this));\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  var CONTENT_CLASS$1 = 'content';\\n  var MSG_CLASS$1 = 'content-msg';\\n  var BUTTON_GROUP_CLASS$1 = 'btn-group';\\n  var BUTTON_CLASS$1 = 'btn';\\n\\n  function Confirm(config) {\\n    this.msg = config.message || '';\\n    this.callback = config.callback;\\n    this.okTitle = config.okTitle || 'OK';\\n    this.cancelTitle = config.cancelTitle || 'Cancel';\\n    Modal.call(this);\\n    this.node.classList.add('weex-confirm');\\n  }\\n\\n  Confirm.prototype = Object.create(Modal.prototype);\\n\\n  Confirm.prototype.createNodeContent = function () {\\n    var content = document.createElement('div');\\n    content.classList.add(CONTENT_CLASS$1);\\n    this.node.appendChild(content);\\n\\n    var msg = document.createElement('div');\\n    msg.classList.add(MSG_CLASS$1);\\n    msg.appendChild(document.createTextNode(this.msg));\\n    content.appendChild(msg);\\n\\n    var buttonGroup = document.createElement('div');\\n    buttonGroup.classList.add(BUTTON_GROUP_CLASS$1);\\n    this.node.appendChild(buttonGroup);\\n    var btnOk = document.createElement('div');\\n    btnOk.appendChild(document.createTextNode(this.okTitle));\\n    btnOk.classList.add('btn-ok', BUTTON_CLASS$1);\\n    var btnCancel = document.createElement('div');\\n    btnCancel.appendChild(document.createTextNode(this.cancelTitle));\\n    btnCancel.classList.add('btn-cancel', BUTTON_CLASS$1);\\n    buttonGroup.appendChild(btnOk);\\n    buttonGroup.appendChild(btnCancel);\\n    this.node.appendChild(buttonGroup);\\n  };\\n\\n  Confirm.prototype.bindEvents = function () {\\n    Modal.prototype.bindEvents.call(this);\\n    var btnOk = this.node.querySelector('.' + BUTTON_CLASS$1 + '.btn-ok');\\n    var btnCancel = this.node.querySelector('.' + BUTTON_CLASS$1 + '.btn-cancel');\\n    btnOk.addEventListener('click', function () {\\n      this.destroy();\\n      this.callback && this.callback(this.okTitle);\\n    }.bind(this));\\n    btnCancel.addEventListener('click', function () {\\n      this.destroy();\\n      this.callback && this.callback(this.cancelTitle);\\n    }.bind(this));\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  var CONTENT_CLASS$2 = 'content';\\n  var MSG_CLASS$2 = 'content-msg';\\n  var BUTTON_GROUP_CLASS$2 = 'btn-group';\\n  var BUTTON_CLASS$2 = 'btn';\\n  var INPUT_WRAP_CLASS = 'input-wrap';\\n  var INPUT_CLASS = 'input';\\n\\n  function Prompt(config) {\\n    this.msg = config.message || '';\\n    this.defaultMsg = config.default || '';\\n    this.callback = config.callback;\\n    this.okTitle = config.okTitle || 'OK';\\n    this.cancelTitle = config.cancelTitle || 'Cancel';\\n    Modal.call(this);\\n    this.node.classList.add('weex-prompt');\\n  }\\n\\n  Prompt.prototype = Object.create(Modal.prototype);\\n\\n  Prompt.prototype.createNodeContent = function () {\\n    var content = document.createElement('div');\\n    content.classList.add(CONTENT_CLASS$2);\\n    this.node.appendChild(content);\\n\\n    var msg = document.createElement('div');\\n    msg.classList.add(MSG_CLASS$2);\\n    msg.appendChild(document.createTextNode(this.msg));\\n    content.appendChild(msg);\\n\\n    var inputWrap = document.createElement('div');\\n    inputWrap.classList.add(INPUT_WRAP_CLASS);\\n    content.appendChild(inputWrap);\\n    var input = document.createElement('input');\\n    input.classList.add(INPUT_CLASS);\\n    input.type = 'text';\\n    input.autofocus = true;\\n    input.placeholder = this.defaultMsg;\\n    inputWrap.appendChild(input);\\n\\n    var buttonGroup = document.createElement('div');\\n    buttonGroup.classList.add(BUTTON_GROUP_CLASS$2);\\n    var btnOk = document.createElement('div');\\n    btnOk.appendChild(document.createTextNode(this.okTitle));\\n    btnOk.classList.add('btn-ok', BUTTON_CLASS$2);\\n    var btnCancel = document.createElement('div');\\n    btnCancel.appendChild(document.createTextNode(this.cancelTitle));\\n    btnCancel.classList.add('btn-cancel', BUTTON_CLASS$2);\\n    buttonGroup.appendChild(btnOk);\\n    buttonGroup.appendChild(btnCancel);\\n    this.node.appendChild(buttonGroup);\\n  };\\n\\n  Prompt.prototype.bindEvents = function () {\\n    Modal.prototype.bindEvents.call(this);\\n    var btnOk = this.node.querySelector('.' + BUTTON_CLASS$2 + '.btn-ok');\\n    var btnCancel = this.node.querySelector('.' + BUTTON_CLASS$2 + '.btn-cancel');\\n    var that = this;\\n    btnOk.addEventListener('click', function () {\\n      var val = document.querySelector('input').value;\\n      this.destroy();\\n      this.callback && this.callback({\\n        result: that.okTitle,\\n        data: val\\n      });\\n    }.bind(this));\\n    btnCancel.addEventListener('click', function () {\\n      var val = document.querySelector('input').value;\\n      this.destroy();\\n      this.callback && this.callback({\\n        result: that.cancelTitle,\\n        data: val\\n      });\\n    }.bind(this));\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  var _css$1 = \\\"\\\\n.weex-toast {\\\\n  font-size: 0.426667rem;\\\\n  line-height: 0.426667rem;\\\\n  position: fixed;\\\\n  z-index: 1999999999;\\\\n  box-sizing: border-box;\\\\n  max-width: 80%;\\\\n  bottom: 50%;\\\\n  left: 50%;\\\\n  padding: 0.213333rem;\\\\n  background-color: #000;\\\\n  color: #fff;\\\\n  text-align: center;\\\\n  opacity: 0.7;\\\\n  -webkit-transition: all 0.4s ease-in-out;\\\\n  -moz-transition: all 0.4s ease-in-out;\\\\n  -ms-transition: all 0.4s ease-in-out;\\\\n  transition: all 0.4s ease-in-out;\\\\n  border-radius: 0.066667rem;\\\\n  -webkit-transform: translateX(-50%);\\\\n  -moz-transform: translateX(-50%);\\\\n  -ms-transform: translateX(-50%);\\\\n  transform: translateX(-50%);\\\\n}\\\\n\\\\n.weex-toast.hide {\\\\n  opacity: 0;\\\\n}\\\\n\\\\n.weex-alert .weex-alert-ok {\\\\n  width: 100%;\\\\n}\\\\n\\\\n.weex-confirm .btn-group .btn {\\\\n  float: left;\\\\n  width: 50%;\\\\n}\\\\n\\\\n.weex-confirm .btn-group .btn.btn-ok {\\\\n  border-right: 0.013333rem solid #ddd;\\\\n}\\\\n\\\\n.weex-modal-wrap {\\\\n  display: none;\\\\n  position: fixed;\\\\n  z-index: 999999999;\\\\n  top: 0;\\\\n  left: 0;\\\\n  width: 100%;\\\\n  height: 100%;\\\\n  background-color: #000;\\\\n  opacity: 0.5;\\\\n}\\\\n\\\\n.weex-modal-node {\\\\n  position: fixed;\\\\n  z-index: 9999999999;\\\\n  top: 50%;\\\\n  left: 50%;\\\\n  width: 6.666667rem;\\\\n  min-height: 2.666667rem;\\\\n  border-radius: 0.066667rem;\\\\n  -webkit-transform: translate(-50%, -50%);\\\\n  -moz-transform: translate(-50%, -50%);\\\\n  -ms-transform: translate(-50%, -50%);\\\\n  transform: translate(-50%, -50%);\\\\n  background-color: #fff;\\\\n}\\\\n\\\\n.weex-modal-node.hide {\\\\n  display: none;\\\\n}\\\\n\\\\n.weex-modal-node .content {\\\\n  display: -webkit-box;\\\\n  display: -webkit-flex;\\\\n  display: -moz-box;\\\\n  display: -ms-flexbox;\\\\n  display: flex;\\\\n  -webkit-box-orient: vertical;\\\\n  -webkit-flex-direction: column;\\\\n  -moz-box-orient: vertical;\\\\n  -moz-box-direction: normal;\\\\n  -ms-flex-direction: column;\\\\n      flex-direction: column;\\\\n  -webkit-box-align: center;\\\\n  -webkit-align-items: center;\\\\n  -ms-flex-align: center;\\\\n  -moz-box-align: center;\\\\n  -ms-flex-align: center;\\\\n  align-items: center;\\\\n  -webkit-box-pack: center;\\\\n  -webkit-justify-content: center;\\\\n  -moz-box-pack: center;\\\\n  -ms-flex-pack: center;\\\\n  justify-content: center;\\\\n  width: 100%;\\\\n  min-height: 1.866667rem;\\\\n  box-sizing: border-box;\\\\n  font-size: 0.426667rem;\\\\n  line-height: 0.426667rem;\\\\n  padding: 0.213333rem;\\\\n  border-bottom: 0.013333rem solid #ddd;\\\\n}\\\\n\\\\n.weex-modal-node .btn-group {\\\\n  width: 100%;\\\\n  height: 0.8rem;\\\\n  font-size: 0.373333rem;\\\\n  text-align: center;\\\\n  margin: 0;\\\\n  padding: 0;\\\\n  border: none;\\\\n}\\\\n\\\\n.weex-modal-node .btn-group .btn {\\\\n  text-align: center;\\\\n}\\\\n\\\\n.weex-modal-node .btn-group .btn {\\\\n  box-sizing: border-box;\\\\n  height: 0.8rem;\\\\n  line-height: 0.8rem;\\\\n  margin: 0;\\\\n  padding: 0;\\\\n  border: none;\\\\n  background: none;\\\\n  text-align: center;\\\\n}\\\\n\\\\n.weex-prompt .input-wrap {\\\\n  box-sizing: border-box;\\\\n  width: 100%;\\\\n  margin-top: 0.133333rem;\\\\n  height: 0.96rem;\\\\n}\\\\n\\\\n.weex-prompt .input-wrap .input {\\\\n  box-sizing: border-box;\\\\n  width: 100%;\\\\n  height: 0.56rem;\\\\n  line-height: 0.56rem;\\\\n  font-size: 0.426667rem;\\\\n  border: 0.013333rem solid #999;\\\\n}\\\\n\\\\n.weex-prompt .btn-group .btn {\\\\n  float: left;\\\\n  width: 50%;\\\\n}\\\\n\\\\n.weex-prompt .btn-group .btn.btn-ok {\\\\n  border-right: 0.013333rem solid #ddd;\\\\n}\\\\n\\\";\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  // TODO: rewrite the modal styles\\n  var modal = {\\n\\n    // duration: default is 0.8 seconds.\\n    toast: function toast(config) {\\n      _toast.push(config.message, config.duration);\\n    },\\n\\n    // config:\\n    //  - message: string\\n    //  - okTitle: title of ok button\\n    //  - callback\\n    alert: function alert(config, callback) {\\n      config.callback = function () {\\n        callback && callback();\\n      };\\n      new Alert(config).show();\\n    },\\n\\n    // config:\\n    //  - message: string\\n    //  - okTitle: title of ok button\\n    //  - cancelTitle: title of cancel button\\n    //  - callback\\n    confirm: function confirm(config, callback) {\\n      config.callback = function (val) {\\n        callback && callback(val);\\n      };\\n      new Confirm(config).show();\\n    },\\n\\n    // config:\\n    //  - message: string\\n    //  - okTitle: title of ok button\\n    //  - cancelTitle: title of cancel button\\n    //  - callback\\n    prompt: function prompt(config, callback) {\\n      config.callback = function (val) {\\n        callback && callback(val);\\n      };\\n      new Prompt(config).show();\\n    }\\n  };\\n\\n  var modal$1 = {\\n    init: function init(Weex) {\\n      Weex.utils.appendCss(_css$1, 'weex-mud-modal');\\n      Weex.registerModule('modal', modal);\\n    }\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n\\n  /**\\n   * Navigator module\\n   */\\n  var navigatorModule = {\\n    push: function push(config, callback) {\\n      window.location.href = config.url;\\n      callback && callback();\\n    },\\n\\n    pop: function pop(config, callback) {\\n      window.history.back();\\n      callback && callback();\\n    }\\n  };\\n\\n  var navigatorModule$1 = {\\n    init: function init(weex) {\\n      weex.registerModule('navigator', navigatorModule);\\n    }\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n\\n  /**\\n   * Webview module\\n   */\\n  var isArray$1;\\n\\n  var webview = {\\n    goBack: function goBack(vnode) {\\n      if (isArray$1(vnode)) {\\n        vnode = vnode[0];\\n      }\\n      if (vnode && typeof vnode.goBack === 'function') {\\n        vnode.goBack();\\n      }\\n    },\\n    goForward: function goForward(vnode) {\\n      if (isArray$1(vnode)) {\\n        vnode = vnode[0];\\n      }\\n      if (vnode && typeof vnode.goForward === 'function') {\\n        vnode.goForward();\\n      }\\n    },\\n    reload: function reload(vnode) {\\n      if (isArray$1(vnode)) {\\n        vnode = vnode[0];\\n      }\\n      if (vnode && typeof vnode.reload === 'function') {\\n        vnode.reload();\\n      }\\n    }\\n  };\\n\\n  var webview$1 = {\\n    init: function init(weex) {\\n      isArray$1 = weex.utils.isArray;\\n      weex.registerModule('webview', webview);\\n    }\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  /**\\n   * websocket module\\n   */\\n  /*global WebSocket*/\\n  var websocket$1 = function () {\\n    var registerListeners = ['onopen', 'onmessage', 'onerror', 'onclose'];\\n    var ws = {\\n      INSTANCE: null,\\n      WebSocket: function (_WebSocket) {\\n        function WebSocket(_x, _x2) {\\n          return _WebSocket.apply(this, arguments);\\n        }\\n\\n        WebSocket.toString = function () {\\n          return _WebSocket.toString();\\n        };\\n\\n        return WebSocket;\\n      }(function (url, protocol) {\\n        if (!url) {\\n          ws.INSTANCE = null;\\n          return;\\n        }\\n        if (!protocol) {\\n          ws.INSTANCE = new WebSocket(url);\\n        } else {\\n          ws.INSTANCE = new WebSocket(url, protocol);\\n        }\\n        return ws.INSTANCE;\\n      }),\\n      send: function send(messages) {\\n        ws.INSTANCE && ws.INSTANCE.send(messages);\\n      },\\n      close: function close() {\\n        ws.INSTANCE && ws.INSTANCE.close();\\n      }\\n    };\\n    var loop = function loop(i) {\\n      if (registerListeners.hasOwnProperty(i)) {\\n        Object.defineProperty(ws, registerListeners[i], {\\n          get: function get() {\\n            return ws.INSTANCE && ws.INSTANCE[registerListeners[i]];\\n          },\\n          set: function set(fn) {\\n            if (ws.INSTANCE) {\\n              ws.INSTANCE[registerListeners[i]] = fn;\\n            }\\n          }\\n        });\\n      }\\n    };\\n\\n    for (var i in registerListeners) {\\n      loop(i);\\n    }return ws;\\n  }();\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  // TODO: rewrite the module meta\\n  var websocket = {\\n    init: function init(Weex) {\\n      Weex.registerModule('webSocket', websocket$1, { registerType: 'assignment' });\\n    }\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n\\n  var meta$5 = {\\n    /**\\n     * setViewport.\\n     * Changing viewport design width at runtime.\\n     */\\n    setViewport: function setViewport(options) {\\n      if (!options) {\\n        console.error(\\\"[vue-render] set viewport width invalid options: \\\" + options);\\n      }\\n      var newWidth = parseInt(options.width);\\n      if (!isNaN(newWidth) && newWidth > 0) {\\n        resetViewport(options.width);\\n      } else {\\n        console.error(\\\"[vue-render] set viewport width invalid options.width: \\\" + options.width);\\n      }\\n    }\\n  };\\n\\n  var meta$6 = {\\n    init: function init(weex) {\\n      weex.registerModule('meta', meta$5);\\n    }\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n\\n  // modules from render/browesr (legacy modules)\\n\\n  // custom modules\\n  var modules$1 = [geolocation$1, storage$1, stream$1, clipboard$1, eventModule, modal$1, websocket, animation$1, dom$1, globalEvent$1, navigatorModule$1, webview$1, meta$6];\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  var valMap = {\\n    contain: 'contain',\\n    cover: 'cover',\\n    stretch: '100% 100%'\\n  };\\n  var vals = Object.keys(valMap);\\n  var defaultVal = 'stretch';\\n\\n  var resize = {\\n    init: function init(weex) {\\n      weex.__vue__.directive('weex-resize', function (el, binding) {\\n        if (el.tagName.toLowerCase() !== 'figure') {\\n          return;\\n        }\\n        var value = binding.value;\\n        var oldValue = binding.oldvalue;\\n        if (value === oldValue) {\\n          return;\\n        }\\n        if (vals.indexOf(value) <= -1) {\\n          value = defaultVal;\\n        }\\n        el.style.backgroundSize = valMap[value];\\n      });\\n    }\\n  };\\n\\n  /*\\n   * Licensed to the Apache Software Foundation (ASF) under one\\n   * or more contributor license agreements.  See the NOTICE file\\n   * distributed with this work for additional information\\n   * regarding copyright ownership.  The ASF licenses this file\\n   * to you under the Apache License, Version 2.0 (the\\n   * \\\"License\\\"); you may not use this file except in compliance\\n   * with the License.  You may obtain a copy of the License at\\n   *\\n   *   http://www.apache.org/licenses/LICENSE-2.0\\n   *\\n   * Unless required by applicable law or agreed to in writing,\\n   * software distributed under the License is distributed on an\\n   * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n   * KIND, either express or implied.  See the License for the\\n   * specific language governing permissions and limitations\\n   * under the License.\\n   */\\n  var directives = {\\n    resize: resize\\n  };\\n\\n  var preInit = weex.init;\\n\\n  weex.init = function () {\\n    preInit.apply(weex, arguments);\\n    var plugins = components.concat(modules$1);\\n\\n    plugins.forEach(function (plugin) {\\n      weex.install(plugin);\\n    });\\n\\n    for (var k in directives) {\\n      weex.install(directives[k]);\\n    }\\n  };\\n\\n  if (global.Vue) {\\n    weex.init(global.Vue);\\n  }\\n\\n  return weex;\\n});\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(0)))//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW50ZWdlci5qcz9lMjg4Iiwid2VicGFjazovLy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZWZpbmVkLmpzP2Y3YjIiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1hdC5qcz8xZDY5Iiwid2VicGFjazovLy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19saWJyYXJ5LmpzPzhiNzgiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2dsb2JhbC5qcz9mODYxIiwid2VicGFjazovLy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzP2U0ZTYiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLW9iamVjdC5qcz8yYjg0Iiwid2VicGFjazovLy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hbi1vYmplY3QuanM/Mzk1NSIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmFpbHMuanM/YzBmNiIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanM/ZTJlNSIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcz9kYTNhIiwid2VicGFjazovLy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcz80ZjI5Iiwid2VicGFjazovLy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1wcmltaXRpdmUuanM/MTAwOCIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwLmpzPzk4YWIiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanM/NWEzYSIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGlkZS5qcz8xZjAzIiwid2VicGFjazovLy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oYXMuanM/ZDhhOCIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdWlkLmpzPzQ1MDkiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLmpzP2E4NWMiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2EtZnVuY3Rpb24uanM/OTU0NCIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY3R4LmpzPzBlMjYiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2V4cG9ydC5qcz8yMmZlIiwid2VicGFjazovLy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyYXRvcnMuanM/NzgxZCIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29mLmpzP2EyY2UiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lvYmplY3QuanM/NWY0NSIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW9iamVjdC5qcz80NmFiIiwid2VicGFjazovLy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanM/ZDdkMCIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tYWJzb2x1dGUtaW5kZXguanM/ZDc0NCIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanM/YzMzZCIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLmpzPzI2NzkiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC1rZXkuanM/N2Y0ZiIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanM/N2FhZSIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcz80OTlmIiwid2VicGFjazovLy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy5qcz8zNTQ2Iiwid2VicGFjazovLy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHBzLmpzPzVkMGQiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2h0bWwuanM/NzIyNSIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qcz84NGMzIiwid2VicGFjazovLy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MuanM/MDUzNiIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanM/ZmU0ZSIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1jcmVhdGUuanM/NTMzYSIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tb2JqZWN0LmpzP2E5MTEiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1ncG8uanM/YjI0NCIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1kZWZpbmUuanM/YTY5NSIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzPzJmMjYiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY2FsbC5qcz82YWM4Iiwid2VicGFjazovLy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzP2IxY2IiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qcz9lM2MxIiwid2VicGFjazovLy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jbGFzc29mLmpzPzE2ZDciLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzPzJiNTIiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzPzVkYjAiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZyb20uanM/MmQwOCIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvZm4vYXJyYXkvZnJvbS5qcz85MTUxIiwid2VicGFjazovLy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wcy5qcz84YmUyIiwid2VicGFjazovLy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtcGllLmpzPzUxNTkiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1hc3NpZ24uanM/NmYyZiIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcz9lMWMyIiwid2VicGFjazovLy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9mbi9vYmplY3QvYXNzaWduLmpzPzI4NjUiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BkLmpzP2RjMmQiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC1wcm90by5qcz9jMjQ2Iiwid2VicGFjazovLy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qcz8xYTkxIiwid2VicGFjazovLy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcz9mNTg1Iiwid2VicGFjazovLy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nLmpzPzQwZDYiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qcz9jODUzIiwid2VicGFjazovLy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLXN0ZXAuanM/MzljNiIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanM/NzM0MSIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzPzM1OWMiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FuLWluc3RhbmNlLmpzPzlhOTIiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2Zvci1vZi5qcz9kMmI0Iiwid2VicGFjazovLy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzPzUwOGEiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ludm9rZS5qcz8zMzM2Iiwid2VicGFjazovLy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190YXNrLmpzPzMwMTgiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21pY3JvdGFzay5qcz8zZjBiIiwid2VicGFjazovLy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5LmpzP2Y0NjIiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3BlcmZvcm0uanM/YWU1MCIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcHJvbWlzZS1yZXNvbHZlLmpzPzBmMzgiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLWFsbC5qcz8xMzg1Iiwid2VicGFjazovLy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtc3BlY2llcy5qcz9kMDFkIiwid2VicGFjazovLy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5wcm9taXNlLmpzPzZkYjAiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9saWIvZ2VzdHVyZS5qcz81MjY0Iiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvbGliL2VudmQvdmVyc2lvbi5qcz85ZjJiIiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvbGliL2VudmQvcGFyYW1zLmpzPzM2NjQiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9saWIvZW52ZC9pbmRleC5qcz81ZDdjIiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvdXRpbHMvdHlwZS5qcz80NjlmIiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvdXRpbHMvZnVuYy5qcz81YmIyIiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvd2VleC92aWV3cG9ydC5qcz8wNTg5Iiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvdXRpbHMvZXZlbnQuanM/OTQ4MSIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL2NvbmZpZy5qcz9mN2MyIiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvdXRpbHMvY29tcG9uZW50LmpzP2U0YjkiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy91dGlscy9sYXp5bG9hZC5qcz8yOWZiIiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvdXRpbHMvc3R5bGUuanM/YzY4NyIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL3V0aWxzL2luZGV4LmpzP2ZiZjAiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy93ZWV4L3d4LWVudi5qcz9jMGViIiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvd2VleC9pbnN0YW5jZS5qcz8zNDYxIiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvY29yZS9zdHlsZS5qcz9hMTllIiwid2VicGFjazovLy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvd3h2LXRyYW5zZm9ybWVyL3RyYW5zZm9ybWVyL3RleHQuanM/YzExYyIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3d4di10cmFuc2Zvcm1lci90cmFuc2Zvcm1lci9pbmRleC5qcz9kMjJjIiwid2VicGFjazovLy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvd3h2LXRyYW5zZm9ybWVyL2luZGV4LmpzPzAwZmQiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9jb3JlL25vZGUuanM/ZTc2NyIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL2NvcmUvaW5kZXguanM/MGNjMyIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL21peGlucy9iYXNlLmpzP2UwZDUiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9taXhpbnMvZXZlbnQuanM/NDI0MyIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL21peGlucy9zdHlsZS5qcz80NGUyIiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvbWl4aW5zL2lucHV0LWNvbW1vbi5qcz80Yzg1Iiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvbWl4aW5zL3N0aWNreS5qcz84OWNiIiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvbWl4aW5zL2luZGV4LmpzPzI4YzQiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy93ZWV4L2dsb2JhbC5qcz82NjhlIiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvd2VleC9yZW5kZXItZnVuY3Rpb24uanM/NmU2NCIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL3dlZXgvaW5kZXguanM/MDE2ZiIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL2luZGV4LmpzP2NkNDkiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL2lucHV0L2luZGV4LmpzP2QzOWEiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3N3aXRjaC9pbmRleC5qcz81NTJlIiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvY29tcG9uZW50cy9zY3JvbGxhYmxlL21peGlucy9zY3JvbGxhYmxlLmpzP2MzMGMiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3Njcm9sbGFibGUvbWl4aW5zL2luZGV4LmpzPzU0MTAiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3Njcm9sbGFibGUvbGlzdC5qcz85MmY4Iiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvY29tcG9uZW50cy9zY3JvbGxhYmxlL3Njcm9sbGVyLmpzPzJlMzkiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3Njcm9sbGFibGUvd2F0ZXJmYWxsLmpzPzFjOWQiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3Njcm9sbGFibGUvaGVhZGVyLmpzPzBmNDAiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3Njcm9sbGFibGUvbG9hZGluZy5qcz8yODNjIiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvY29tcG9uZW50cy9zY3JvbGxhYmxlL3JlZnJlc2guanM/OTI4NSIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvc2Nyb2xsYWJsZS9sb2FkaW5nLWluZGljYXRvci5qcz81NTJmIiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvY29tcG9uZW50cy9zY3JvbGxhYmxlL2luZGV4LmpzPzdiODEiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3NsaWRlci9zbGlkZU1peGluLmpzPzhmNDMiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3NsaWRlci9zbGlkZXIuanM/MTY4NiIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvc2xpZGVyL3NsaWRlci1uZWlnaGJvci5qcz8yMWM0Iiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvY29tcG9uZW50cy9zbGlkZXIvaW5kaWNhdG9yLmpzPzZmMWEiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3NsaWRlci9pbmRleC5qcz9kN2MwIiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvY29tcG9uZW50cy90ZXh0YXJlYS9pbmRleC5qcz80N2YxIiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvY29tcG9uZW50cy92aWRlby5qcz9kMzE3Iiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvY29tcG9uZW50cy93ZWIvaW5kZXguanM/NjE3ZiIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvaW5kZXguanM/N2NkNyIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL21vZHVsZXMvZ2VvbG9jYXRpb24uanM/YzJmYiIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL21vZHVsZXMvc3RvcmFnZS5qcz8yNjQ1Iiwid2VicGFjazovLy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvaHR0cHVybC9idWlsZC9odHRwdXJsLmNvbW1vbi5qcz9lMzc3Iiwid2VicGFjazovLy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3RyaWN0LXVyaS1lbmNvZGUvaW5kZXguanM/ZGYwYiIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanM/M2UxMyIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3F1ZXJ5LXN0cmluZy9pbmRleC5qcz85ZGU3Iiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvbW9kdWxlcy9zdHJlYW0uanM/Njg0NCIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL21vZHVsZXMvY2xpcGJvYXJkLmpzPzU4ODYiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9tb2R1bGVzL2V2ZW50LmpzPzhkOWYiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9tb2R1bGVzL2FuaW1hdGlvbi5qcz82N2UwIiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvbW9kdWxlcy9kb20uanM/ZGEzZSIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL21vZHVsZXMvZ2xvYmFsRXZlbnQuanM/OWMzMCIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL21vZHVsZXMvbW9kYWwvdG9hc3QuanM/MWFlYyIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL21vZHVsZXMvbW9kYWwvbW9kYWwuanM/MjVhZiIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL21vZHVsZXMvbW9kYWwvYWxlcnQuanM/NzVlYyIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL21vZHVsZXMvbW9kYWwvY29uZmlybS5qcz9iZTlkIiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvbW9kdWxlcy9tb2RhbC9wcm9tcHQuanM/OGQ4ZiIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL21vZHVsZXMvbW9kYWwvc3R5bGUuanM/YzNmNyIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL21vZHVsZXMvbW9kYWwvaW5kZXguanM/MWE3YiIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL21vZHVsZXMvbmF2aWdhdG9yLmpzPzdmMjciLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9tb2R1bGVzL3dlYnZpZXcuanM/OTMwMCIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL21vZHVsZXMvd2Vic29ja2V0L3dlYnNvY2tldC5qcz84MzFkIiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvbW9kdWxlcy93ZWJzb2NrZXQvaW5kZXguanM/OWEyNyIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL21vZHVsZXMvbWV0YS5qcz8zNmExIiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvbW9kdWxlcy9pbmRleC5qcz8xY2VhIiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvZGlyZWN0aXZlcy9yZXNpemUuanM/ZDdiMiIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL2RpcmVjdGl2ZXMvaW5kZXguanM/NjlhMSIsIndlYnBhY2s6Ly8vLi4vc3JjL2luZGV4LmpzP2ExNzgiXSwibmFtZXMiOlsiZGVmaW5lZCIsInRvSW50ZWdlciIsImlzT2JqZWN0IiwicmVxdWlyZSQkMCIsImRvY3VtZW50IiwicmVxdWlyZSQkMSIsInJlcXVpcmUkJDIiLCJhbk9iamVjdCIsInRvUHJpbWl0aXZlIiwiSUU4X0RPTV9ERUZJTkUiLCJkUCIsImNyZWF0ZURlc2MiLCJoYXMiLCJoaWRlIiwiZ2xvYmFsIiwiYUZ1bmN0aW9uIiwiY29yZSIsImN0eCIsInJlZGVmaW5lIiwiY29mIiwiSU9iamVjdCIsIm1pbiIsInRvSU9iamVjdCIsInRvTGVuZ3RoIiwidG9BYnNvbHV0ZUluZGV4IiwidWlkIiwiSUVfUFJPVE8iLCIka2V5cyIsImVudW1CdWdLZXlzIiwiZ2V0S2V5cyIsIlBST1RPVFlQRSIsImRQcyIsImNyZWF0ZSIsImRlc2NyaXB0b3IiLCJzZXRUb1N0cmluZ1RhZyIsInRvT2JqZWN0IiwiJGl0ZXJDcmVhdGUiLCJnZXRQcm90b3R5cGVPZiIsIkxJQlJBUlkiLCJJdGVyYXRvcnMiLCIkZXhwb3J0IiwiSVRFUkFUT1IiLCIkZGVmaW5lUHJvcGVydHkiLCJUQUciLCJjbGFzc29mIiwiZ2V0SXRlckZuIiwiaXNBcnJheUl0ZXIiLCJjcmVhdGVQcm9wZXJ0eSIsImNhbGwiLCJnT1BTIiwicElFIiwiYXJndW1lbnRzIiwiQXJyYXlQcm90byIsInN0ZXAiLCJhZGRUb1Vuc2NvcGFibGVzIiwid2tzIiwiJGl0ZXJhdG9ycyIsInByb2Nlc3MiLCJpbnZva2UiLCJjZWwiLCJodG1sIiwiaXNOb2RlIiwibmV3UHJvbWlzZUNhcGFiaWxpdHkiLCJTUEVDSUVTIiwiREVTQ1JJUFRPUlMiLCJUeXBlRXJyb3IiLCJuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSIsInBlcmZvcm0iLCJhbkluc3RhbmNlIiwicmVxdWlyZSQkMyIsInNwZWNpZXNDb25zdHJ1Y3RvciIsInJlcXVpcmUkJDQiLCJyZXF1aXJlJCQ1IiwicmVxdWlyZSQkNiIsInByb21pc2VSZXNvbHZlIiwicmVxdWlyZSQkNyIsImZvck9mIiwiY29uc3QiLCJsaWIiLCJsZXQiLCJlbnYiLCJpIiwidG9TdHJpbmciLCJpbml0IiwiZXh0ZW5kIiwiZXZlbnQiLCJfdWlkIiwiaW5pdFZpZXdwb3J0Iiwid2VleCIsInV0aWxzLmFwcGVuZENzcyIsInRhZ01hcCIsImdldFRyYW5zZm9ybWVyIiwiYmluZGluZ1N0eWxlTmFtZXNGb3JQeDJSZW0iLCJ0aGlzIiwiX2luaXRlZCIsImJhc2UiLCJtYXBGb3JtRXZlbnRzIiwiYXBwZW5kQ3NzIiwicmVjdCIsInNjcm9sbGFibGUiLCJ2bm9kZSIsInRhZyIsImNvbHVtbkRvbSIsImV4dHJhY3RDb21wb25lbnRTdHlsZSIsImdldFJnYiIsImxvb3BBcnJheSIsImdldFN0eWxlU2hlZXRCeUlkIiwicHJvY2Vzc1N0eWxlIiwibG9hZGluZ0luZGljYXRvciIsInNsaWRlciIsImdldENvbXBvbmVudElubGluZVN0eWxlIiwiaW5kaWNhdG9yIiwibWV0YSIsImhhc093blByb3BlcnR5IiwidXRpbHMiLCJxcyIsInF1ZXVlIiwiQ09OVEVOVF9DTEFTUyIsIk1TR19DTEFTUyIsIkJVVFRPTl9HUk9VUF9DTEFTUyIsIkJVVFRPTl9DTEFTUyIsIl9jc3MiLCJpc0FycmF5Iiwid2Vic29ja2V0IiwiZ2VvbG9jYXRpb24iLCJzdG9yYWdlIiwic3RyZWFtIiwiY2xpcGJvYXJkIiwibW9kYWwiLCJhbmltYXRpb24iLCJkb20iLCJnbG9iYWxFdmVudCIsIm5hdmlnYXRvck1vZHVsZSIsIndlYnZpZXciLCJtb2R1bGVzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQSxNQUFJLE9BQU8sS0FBSyxJQUFoQjtBQUNBLE1BQUksUUFBUSxLQUFLLEtBQWpCO0FBQ0EsbUJBQWlCLFNBQWpCLFVBQWlCLENBQVUsRUFBVixFQUFjO0FBQzdCLFdBQU8sTUFBTSxLQUFLLENBQUMsRUFBWixJ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bnRlbnQiOlsiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG4iLCIvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIHBvcykge1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xuICAgIHZhciBpID0gdG9JbnRlZ2VyKHBvcyk7XG4gICAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSBsKSByZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZiAodHlwZW9mIF9fZyA9PSAnbnVtYmVyJykgX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0geyB2ZXJzaW9uOiAnMi41LjInIH07XG5pZiAodHlwZW9mIF9fZSA9PSAnbnVtYmVyJykgX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG4iLCIvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQ7XG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcbnZhciBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcbiIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBTKSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICghUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGRQID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcbiIsInZhciBpZCA9IDA7XG52YXIgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgU1JDID0gcmVxdWlyZSgnLi9fdWlkJykoJ3NyYycpO1xudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgJHRvU3RyaW5nID0gRnVuY3Rpb25bVE9fU1RSSU5HXTtcbnZhciBUUEwgPSAoJycgKyAkdG9TdHJpbmcpLnNwbGl0KFRPX1NUUklORyk7XG5cbnJlcXVpcmUoJy4vX2NvcmUnKS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiAkdG9TdHJpbmcuY2FsbChpdCk7XG59O1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywga2V5LCB2YWwsIHNhZmUpIHtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgdmFsID09ICdmdW5jdGlvbic7XG4gIGlmIChpc0Z1bmN0aW9uKSBoYXModmFsLCAnbmFtZScpIHx8IGhpZGUodmFsLCAnbmFtZScsIGtleSk7XG4gIGlmIChPW2tleV0gPT09IHZhbCkgcmV0dXJuO1xuICBpZiAoaXNGdW5jdGlvbikgaGFzKHZhbCwgU1JDKSB8fCBoaWRlKHZhbCwgU1JDLCBPW2tleV0gPyAnJyArIE9ba2V5XSA6IFRQTC5qb2luKFN0cmluZyhrZXkpKSk7XG4gIGlmIChPID09PSBnbG9iYWwpIHtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSBpZiAoIXNhZmUpIHtcbiAgICBkZWxldGUgT1trZXldO1xuICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICB9IGVsc2UgaWYgKE9ba2V5XSkge1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIHtcbiAgICBoaWRlKE8sIGtleSwgdmFsKTtcbiAgfVxuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG59KShGdW5jdGlvbi5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIHRoaXNbU1JDXSB8fCAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbn0pO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkge1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZiAodGhhdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZm47XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIHNvdXJjZSkge1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRjtcbiAgdmFyIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0Lkc7XG4gIHZhciBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TO1xuICB2YXIgSVNfUFJPVE8gPSB0eXBlICYgJGV4cG9ydC5QO1xuICB2YXIgSVNfQklORCA9IHR5cGUgJiAkZXhwb3J0LkI7XG4gIHZhciB0YXJnZXQgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gfHwgKGdsb2JhbFtuYW1lXSA9IHt9KSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV07XG4gIHZhciBleHBvcnRzID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSk7XG4gIHZhciBleHBQcm90byA9IGV4cG9ydHNbUFJPVE9UWVBFXSB8fCAoZXhwb3J0c1tQUk9UT1RZUEVdID0ge30pO1xuICB2YXIga2V5LCBvd24sIG91dCwgZXhwO1xuICBpZiAoSVNfR0xPQkFMKSBzb3VyY2UgPSBuYW1lO1xuICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gKG93biA/IHRhcmdldCA6IHNvdXJjZSlba2V5XTtcbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIGV4cCA9IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4dGVuZCBnbG9iYWxcbiAgICBpZiAodGFyZ2V0KSByZWRlZmluZSh0YXJnZXQsIGtleSwgb3V0LCB0eXBlICYgJGV4cG9ydC5VKTtcbiAgICAvLyBleHBvcnRcbiAgICBpZiAoZXhwb3J0c1trZXldICE9IG91dCkgaGlkZShleHBvcnRzLCBrZXksIGV4cCk7XG4gICAgaWYgKElTX1BST1RPICYmIGV4cFByb3RvW2tleV0gIT0gb3V0KSBleHBQcm90b1trZXldID0gb3V0O1xuICB9XG59O1xuZ2xvYmFsLmNvcmUgPSBjb3JlO1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7fTtcbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcbiIsIi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG4iLCIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuIiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcbiIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSB7XG4gICAgICBpZiAoT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0ge30pO1xufTtcbiIsInZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgna2V5cycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBzaGFyZWRba2V5XSB8fCAoc2hhcmVkW2tleV0gPSB1aWQoa2V5KSk7XG59O1xuIiwidmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSU9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgaWYgKGtleSAhPSBJRV9QUk9UTykgaGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcbiIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG4iLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdChPKTtcbiAgdmFyIGtleXMgPSBnZXRLZXlzKFByb3BlcnRpZXMpO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpID0gMDtcbiAgdmFyIFA7XG4gIHdoaWxlIChsZW5ndGggPiBpKSBkUC5mKE8sIFAgPSBrZXlzW2krK10sIFByb3BlcnRpZXNbUF0pO1xuICByZXR1cm4gTztcbn07XG4iLCJ2YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbm1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuIiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBkUHMgPSByZXF1aXJlKCcuL19vYmplY3QtZHBzJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgRW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdpZnJhbWUnKTtcbiAgdmFyIGkgPSBlbnVtQnVnS2V5cy5sZW5ndGg7XG4gIHZhciBsdCA9ICc8JztcbiAgdmFyIGd0ID0gJz4nO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICByZXF1aXJlKCcuL19odG1sJykuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxuICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcbiAgd2hpbGUgKGktLSkgZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5KCk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuIiwidmFyIHN0b3JlID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbDtcbnZhciBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuIiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCB0YWcsIHN0YXQpIHtcbiAgaWYgKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpIGRlZihpdCwgVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZyB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGRlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcbiIsIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuIiwiLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKE8pIHtcbiAgTyA9IHRvT2JqZWN0KE8pO1xuICBpZiAoaGFzKE8sIElFX1BST1RPKSkgcmV0dXJuIE9bSUVfUFJPVE9dO1xuICBpZiAodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgJGl0ZXJDcmVhdGUgPSByZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEJVR0dZID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpOyAvLyBTYWZhcmkgaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG52YXIgRkZfSVRFUkFUT1IgPSAnQEBpdGVyYXRvcic7XG52YXIgS0VZUyA9ICdrZXlzJztcbnZhciBWQUxVRVMgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpIHtcbiAgJGl0ZXJDcmVhdGUoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuICB2YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24gKGtpbmQpIHtcbiAgICBpZiAoIUJVR0dZICYmIGtpbmQgaW4gcHJvdG8pIHJldHVybiBwcm90b1traW5kXTtcbiAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICB9O1xuICB2YXIgVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICB2YXIgREVGX1ZBTFVFUyA9IERFRkFVTFQgPT0gVkFMVUVTO1xuICB2YXIgVkFMVUVTX0JVRyA9IGZhbHNlO1xuICB2YXIgcHJvdG8gPSBCYXNlLnByb3RvdHlwZTtcbiAgdmFyICRuYXRpdmUgPSBwcm90b1tJVEVSQVRPUl0gfHwgcHJvdG9bRkZfSVRFUkFUT1JdIHx8IERFRkFVTFQgJiYgcHJvdG9bREVGQVVMVF07XG4gIHZhciAkZGVmYXVsdCA9ICRuYXRpdmUgfHwgZ2V0TWV0aG9kKERFRkFVTFQpO1xuICB2YXIgJGVudHJpZXMgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkO1xuICB2YXIgJGFueU5hdGl2ZSA9IE5BTUUgPT0gJ0FycmF5JyA/IHByb3RvLmVudHJpZXMgfHwgJG5hdGl2ZSA6ICRuYXRpdmU7XG4gIHZhciBtZXRob2RzLCBrZXksIEl0ZXJhdG9yUHJvdG90eXBlO1xuICAvLyBGaXggbmF0aXZlXG4gIGlmICgkYW55TmF0aXZlKSB7XG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZigkYW55TmF0aXZlLmNhbGwobmV3IEJhc2UoKSkpO1xuICAgIGlmIChJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBJdGVyYXRvclByb3RvdHlwZS5uZXh0KSB7XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvclByb3RvdHlwZSwgVEFHLCB0cnVlKTtcbiAgICAgIC8vIGZpeCBmb3Igc29tZSBvbGQgZW5naW5lc1xuICAgICAgaWYgKCFMSUJSQVJZICYmICFoYXMoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SKSkgaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgIH1cbiAgfVxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmIChERUZfVkFMVUVTICYmICRuYXRpdmUgJiYgJG5hdGl2ZS5uYW1lICE9PSBWQUxVRVMpIHtcbiAgICBWQUxVRVNfQlVHID0gdHJ1ZTtcbiAgICAkZGVmYXVsdCA9IGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsgfTtcbiAgfVxuICAvLyBEZWZpbmUgaXRlcmF0b3JcbiAgaWYgKCghTElCUkFSWSB8fCBGT1JDRUQpICYmIChCVUdHWSB8fCBWQUxVRVNfQlVHIHx8ICFwcm90b1tJVEVSQVRPUl0pKSB7XG4gICAgaGlkZShwcm90bywgSVRFUkFUT1IsICRkZWZhdWx0KTtcbiAgfVxuICAvLyBQbHVnIGZvciBsaWJyYXJ5XG4gIEl0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xuICBJdGVyYXRvcnNbVEFHXSA9IHJldHVyblRoaXM7XG4gIGlmIChERUZBVUxUKSB7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiBJU19TRVQgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6ICRlbnRyaWVzXG4gICAgfTtcbiAgICBpZiAoRk9SQ0VEKSBmb3IgKGtleSBpbiBtZXRob2RzKSB7XG4gICAgICBpZiAoIShrZXkgaW4gcHJvdG8pKSByZWRlZmluZShwcm90bywga2V5LCBtZXRob2RzW2tleV0pO1xuICAgIH0gZWxzZSAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChCVUdHWSB8fCBWQUxVRVNfQlVHKSwgTkFNRSwgbWV0aG9kcyk7XG4gIH1cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uIChpdGVyYXRlZCkge1xuICB0aGlzLl90ID0gU3RyaW5nKGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4vLyAyMS4xLjUuMi4xICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGluZGV4ID0gdGhpcy5faTtcbiAgdmFyIHBvaW50O1xuICBpZiAoaW5kZXggPj0gTy5sZW5ndGgpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgcG9pbnQgPSAkYXQoTywgaW5kZXgpO1xuICB0aGlzLl9pICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHsgdmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZSB9O1xufSk7XG4iLCIvLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIGVudHJpZXMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW50cmllcyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIHJldCA9IGl0ZXJhdG9yWydyZXR1cm4nXTtcbiAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIGFuT2JqZWN0KHJldC5jYWxsKGl0ZXJhdG9yKSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTtcbiIsIi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG9bSVRFUkFUT1JdID09PSBpdCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgaW5kZXgsIHZhbHVlKSB7XG4gIGlmIChpbmRleCBpbiBvYmplY3QpICRkZWZpbmVQcm9wZXJ0eS5mKG9iamVjdCwgaW5kZXgsIGNyZWF0ZURlc2MoMCwgdmFsdWUpKTtcbiAgZWxzZSBvYmplY3RbaW5kZXhdID0gdmFsdWU7XG59O1xuIiwiLy8gZ2V0dGluZyB0YWcgZnJvbSAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQVJHID0gY29mKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59O1xuIiwidmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmdldEl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCAhPSB1bmRlZmluZWQpIHJldHVybiBpdFtJVEVSQVRPUl1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG4iLCJ2YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SXSgpO1xuICByaXRlclsncmV0dXJuJ10gPSBmdW5jdGlvbiAoKSB7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uICgpIHsgdGhyb3cgMjsgfSk7XG59IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYywgc2tpcENsb3NpbmcpIHtcbiAgaWYgKCFza2lwQ2xvc2luZyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIHZhciBzYWZlID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IFs3XTtcbiAgICB2YXIgaXRlciA9IGFycltJVEVSQVRPUl0oKTtcbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB7IGRvbmU6IHNhZmUgPSB0cnVlIH07IH07XG4gICAgYXJyW0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXI7IH07XG4gICAgZXhlYyhhcnIpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKTtcbnZhciBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5Jyk7XG52YXIgZ2V0SXRlckZuID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKShmdW5jdGlvbiAoaXRlcikgeyBBcnJheS5mcm9tKGl0ZXIpOyB9KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMSBBcnJheS5mcm9tKGFycmF5TGlrZSwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gIGZyb206IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlIC8qICwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQgKi8pIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KGFycmF5TGlrZSk7XG4gICAgdmFyIEMgPSB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5O1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgbWFwZm4gPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgaXRlckZuID0gZ2V0SXRlckZuKE8pO1xuICAgIHZhciBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYgKG1hcHBpbmcpIG1hcGZuID0gY3R4KG1hcGZuLCBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCwgMik7XG4gICAgLy8gaWYgb2JqZWN0IGlzbid0IGl0ZXJhYmxlIG9yIGl0J3MgYXJyYXkgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yIC0gdXNlIHNpbXBsZSBjYXNlXG4gICAgaWYgKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIShDID09IEFycmF5ICYmIGlzQXJyYXlJdGVyKGl0ZXJGbikpKSB7XG4gICAgICBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHJlc3VsdCA9IG5ldyBDKCk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgaW5kZXgrKykge1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gY2FsbChpdGVyYXRvciwgbWFwZm4sIFtzdGVwLnZhbHVlLCBpbmRleF0sIHRydWUpIDogc3RlcC52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICAgIGZvciAocmVzdWx0ID0gbmV3IEMobGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IG1hcGZuKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5sZW5ndGggPSBpbmRleDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuYXJyYXkuZnJvbScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuQXJyYXkuZnJvbTtcbiIsImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG4iLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcbnZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyICRhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1Zylcbm1vZHVsZS5leHBvcnRzID0gISRhc3NpZ24gfHwgcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHZhciBBID0ge307XG4gIHZhciBCID0ge307XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgUyA9IFN5bWJvbCgpO1xuICB2YXIgSyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbU10gPSA3O1xuICBLLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7IEJba10gPSBrOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IEs7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBUID0gdG9PYmplY3QodGFyZ2V0KTtcbiAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAxO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgdmFyIGlzRW51bSA9IHBJRS5mO1xuICB3aGlsZSAoYUxlbiA+IGluZGV4KSB7XG4gICAgdmFyIFMgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgdmFyIGtleXMgPSBnZXRTeW1ib2xzID8gZ2V0S2V5cyhTKS5jb25jYXQoZ2V0U3ltYm9scyhTKSkgOiBnZXRLZXlzKFMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaikgaWYgKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpIFRba2V5XSA9IFNba2V5XTtcbiAgfSByZXR1cm4gVDtcbn0gOiAkYXNzaWduO1xuIiwiLy8gMTkuMS4zLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GLCAnT2JqZWN0JywgeyBhc3NpZ246IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKSB9KTtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5hc3NpZ247XG4iLCJ2YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0lPYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBnT1BEKE8sIFApO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhcyhPLCBQKSkgcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTtcbiIsIi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgY2hlY2sgPSBmdW5jdGlvbiAoTywgcHJvdG8pIHtcbiAgYW5PYmplY3QoTyk7XG4gIGlmICghaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKSB0aHJvdyBUeXBlRXJyb3IocHJvdG8gKyBcIjogY2FuJ3Qgc2V0IGFzIHByb3RvdHlwZSFcIik7XG59O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBmdW5jdGlvbiAodGVzdCwgYnVnZ3ksIHNldCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0ID0gcmVxdWlyZSgnLi9fY3R4JykoRnVuY3Rpb24uY2FsbCwgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpO1xuICAgICAgICBzZXQodGVzdCwgW10pO1xuICAgICAgICBidWdneSA9ICEodGVzdCBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsgYnVnZ3kgPSB0cnVlOyB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgICBpZiAoYnVnZ3kpIE8uX19wcm90b19fID0gcHJvdG87XG4gICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB9O1xuICAgIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksXG4gIGNoZWNrOiBjaGVja1xufTtcbiIsIi8vIDE5LjEuMy4xOSBPYmplY3Quc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7IHNldFByb3RvdHlwZU9mOiByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXQgfSk7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LnNldFByb3RvdHlwZU9mO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciB0ZXN0ID0ge307XG50ZXN0W3JlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpXSA9ICd6JztcbmlmICh0ZXN0ICsgJycgIT0gJ1tvYmplY3Qgel0nKSB7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoT2JqZWN0LnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdbb2JqZWN0ICcgKyBjbGFzc29mKHRoaXMpICsgJ10nO1xuICB9LCB0cnVlKTtcbn1cbiIsIi8vIDIyLjEuMy4zMSBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbnZhciBVTlNDT1BBQkxFUyA9IHJlcXVpcmUoJy4vX3drcycpKCd1bnNjb3BhYmxlcycpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5pZiAoQXJyYXlQcm90b1tVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSByZXF1aXJlKCcuL19oaWRlJykoQXJyYXlQcm90bywgVU5TQ09QQUJMRVMsIHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb25lLCB2YWx1ZSkge1xuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZSB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJyk7XG52YXIgc3RlcCA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGtpbmQgPSB0aGlzLl9rO1xuICB2YXIgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmICghTyB8fCBpbmRleCA+PSBPLmxlbmd0aCkge1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG4iLCJ2YXIgJGl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG52YXIgSVRFUkFUT1IgPSB3a3MoJ2l0ZXJhdG9yJyk7XG52YXIgVE9fU1RSSU5HX1RBRyA9IHdrcygndG9TdHJpbmdUYWcnKTtcbnZhciBBcnJheVZhbHVlcyA9IEl0ZXJhdG9ycy5BcnJheTtcblxudmFyIERPTUl0ZXJhYmxlcyA9IHtcbiAgQ1NTUnVsZUxpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBDU1NTdHlsZURlY2xhcmF0aW9uOiBmYWxzZSxcbiAgQ1NTVmFsdWVMaXN0OiBmYWxzZSxcbiAgQ2xpZW50UmVjdExpc3Q6IGZhbHNlLFxuICBET01SZWN0TGlzdDogZmFsc2UsXG4gIERPTVN0cmluZ0xpc3Q6IGZhbHNlLFxuICBET01Ub2tlbkxpc3Q6IHRydWUsXG4gIERhdGFUcmFuc2Zlckl0ZW1MaXN0OiBmYWxzZSxcbiAgRmlsZUxpc3Q6IGZhbHNlLFxuICBIVE1MQWxsQ29sbGVjdGlvbjogZmFsc2UsXG4gIEhUTUxDb2xsZWN0aW9uOiBmYWxzZSxcbiAgSFRNTEZvcm1FbGVtZW50OiBmYWxzZSxcbiAgSFRNTFNlbGVjdEVsZW1lbnQ6IGZhbHNlLFxuICBNZWRpYUxpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBNaW1lVHlwZUFycmF5OiBmYWxzZSxcbiAgTmFtZWROb2RlTWFwOiBmYWxzZSxcbiAgTm9kZUxpc3Q6IHRydWUsXG4gIFBhaW50UmVxdWVzdExpc3Q6IGZhbHNlLFxuICBQbHVnaW46IGZhbHNlLFxuICBQbHVnaW5BcnJheTogZmFsc2UsXG4gIFNWR0xlbmd0aExpc3Q6IGZhbHNlLFxuICBTVkdOdW1iZXJMaXN0OiBmYWxzZSxcbiAgU1ZHUGF0aFNlZ0xpc3Q6IGZhbHNlLFxuICBTVkdQb2ludExpc3Q6IGZhbHNlLFxuICBTVkdTdHJpbmdMaXN0OiBmYWxzZSxcbiAgU1ZHVHJhbnNmb3JtTGlzdDogZmFsc2UsXG4gIFNvdXJjZUJ1ZmZlckxpc3Q6IGZhbHNlLFxuICBTdHlsZVNoZWV0TGlzdDogdHJ1ZSwgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIFRleHRUcmFja0N1ZUxpc3Q6IGZhbHNlLFxuICBUZXh0VHJhY2tMaXN0OiBmYWxzZSxcbiAgVG91Y2hMaXN0OiBmYWxzZVxufTtcblxuZm9yICh2YXIgY29sbGVjdGlvbnMgPSBnZXRLZXlzKERPTUl0ZXJhYmxlcyksIGkgPSAwOyBpIDwgY29sbGVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgdmFyIE5BTUUgPSBjb2xsZWN0aW9uc1tpXTtcbiAgdmFyIGV4cGxpY2l0ID0gRE9NSXRlcmFibGVzW05BTUVdO1xuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIHByb3RvID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgdmFyIGtleTtcbiAgaWYgKHByb3RvKSB7XG4gICAgaWYgKCFwcm90b1tJVEVSQVRPUl0pIGhpZGUocHJvdG8sIElURVJBVE9SLCBBcnJheVZhbHVlcyk7XG4gICAgaWYgKCFwcm90b1tUT19TVFJJTkdfVEFHXSkgaGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gICAgSXRlcmF0b3JzW05BTUVdID0gQXJyYXlWYWx1ZXM7XG4gICAgaWYgKGV4cGxpY2l0KSBmb3IgKGtleSBpbiAkaXRlcmF0b3JzKSBpZiAoIXByb3RvW2tleV0pIHJlZGVmaW5lKHByb3RvLCBrZXksICRpdGVyYXRvcnNba2V5XSwgdHJ1ZSk7XG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSwgZm9yYmlkZGVuRmllbGQpIHtcbiAgaWYgKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikgfHwgKGZvcmJpZGRlbkZpZWxkICE9PSB1bmRlZmluZWQgJiYgZm9yYmlkZGVuRmllbGQgaW4gaXQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKG5hbWUgKyAnOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuIiwidmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKTtcbnZhciBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgZ2V0SXRlckZuID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcbnZhciBCUkVBSyA9IHt9O1xudmFyIFJFVFVSTiA9IHt9O1xudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgZW50cmllcywgZm4sIHRoYXQsIElURVJBVE9SKSB7XG4gIHZhciBpdGVyRm4gPSBJVEVSQVRPUiA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXJhYmxlOyB9IDogZ2V0SXRlckZuKGl0ZXJhYmxlKTtcbiAgdmFyIGYgPSBjdHgoZm4sIHRoYXQsIGVudHJpZXMgPyAyIDogMSk7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsZW5ndGgsIHN0ZXAsIGl0ZXJhdG9yLCByZXN1bHQ7XG4gIGlmICh0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdGVyYWJsZSArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICAvLyBmYXN0IGNhc2UgZm9yIGFycmF5cyB3aXRoIGRlZmF1bHQgaXRlcmF0b3JcbiAgaWYgKGlzQXJyYXlJdGVyKGl0ZXJGbikpIGZvciAobGVuZ3RoID0gdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICByZXN1bHQgPSBlbnRyaWVzID8gZihhbk9iamVjdChzdGVwID0gaXRlcmFibGVbaW5kZXhdKVswXSwgc3RlcFsxXSkgOiBmKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pIHJldHVybiByZXN1bHQ7XG4gIH0gZWxzZSBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7KSB7XG4gICAgcmVzdWx0ID0gY2FsbChpdGVyYXRvciwgZiwgc3RlcC52YWx1ZSwgZW50cmllcyk7XG4gICAgaWYgKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5leHBvcnRzLkJSRUFLID0gQlJFQUs7XG5leHBvcnRzLlJFVFVSTiA9IFJFVFVSTjtcbiIsIi8vIDcuMy4yMCBTcGVjaWVzQ29uc3RydWN0b3IoTywgZGVmYXVsdENvbnN0cnVjdG9yKVxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywgRCkge1xuICB2YXIgQyA9IGFuT2JqZWN0KE8pLmNvbnN0cnVjdG9yO1xuICB2YXIgUztcbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IGFuT2JqZWN0KEMpW1NQRUNJRVNdKSA9PSB1bmRlZmluZWQgPyBEIDogYUZ1bmN0aW9uKFMpO1xufTtcbiIsIi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIGFyZ3MsIHRoYXQpIHtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gdW4gPyBmbigpXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQpO1xuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gIH0gcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTtcbiIsInZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBpbnZva2UgPSByZXF1aXJlKCcuL19pbnZva2UnKTtcbnZhciBodG1sID0gcmVxdWlyZSgnLi9faHRtbCcpO1xudmFyIGNlbCA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgc2V0VGFzayA9IGdsb2JhbC5zZXRJbW1lZGlhdGU7XG52YXIgY2xlYXJUYXNrID0gZ2xvYmFsLmNsZWFySW1tZWRpYXRlO1xudmFyIE1lc3NhZ2VDaGFubmVsID0gZ2xvYmFsLk1lc3NhZ2VDaGFubmVsO1xudmFyIERpc3BhdGNoID0gZ2xvYmFsLkRpc3BhdGNoO1xudmFyIGNvdW50ZXIgPSAwO1xudmFyIHF1ZXVlID0ge307XG52YXIgT05SRUFEWVNUQVRFQ0hBTkdFID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSc7XG52YXIgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XG52YXIgcnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaWQgPSArdGhpcztcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICBpZiAocXVldWUuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgdmFyIGZuID0gcXVldWVbaWRdO1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gICAgZm4oKTtcbiAgfVxufTtcbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCkge1xuICBydW4uY2FsbChldmVudC5kYXRhKTtcbn07XG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6XG5pZiAoIXNldFRhc2sgfHwgIWNsZWFyVGFzaykge1xuICBzZXRUYXNrID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGZuKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICB2YXIgaSA9IDE7XG4gICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHF1ZXVlWysrY291bnRlcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgICAgIGludm9rZSh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pLCBhcmdzKTtcbiAgICB9O1xuICAgIGRlZmVyKGNvdW50ZXIpO1xuICAgIHJldHVybiBjb3VudGVyO1xuICB9O1xuICBjbGVhclRhc2sgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCkge1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gIH07XG4gIC8vIE5vZGUuanMgMC44LVxuICBpZiAocmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBTcGhlcmUgKEpTIGdhbWUgZW5naW5lKSBEaXNwYXRjaCBBUElcbiAgfSBlbHNlIGlmIChEaXNwYXRjaCAmJiBEaXNwYXRjaC5ub3cpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgRGlzcGF0Y2gubm93KGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xuICB9IGVsc2UgaWYgKE1lc3NhZ2VDaGFubmVsKSB7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGlzdGVuZXI7XG4gICAgZGVmZXIgPSBjdHgocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCwgMSk7XG4gIC8vIEJyb3dzZXJzIHdpdGggcG9zdE1lc3NhZ2UsIHNraXAgV2ViV29ya2Vyc1xuICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyAnb2JqZWN0J1xuICB9IGVsc2UgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICYmIHR5cGVvZiBwb3N0TWVzc2FnZSA9PSAnZnVuY3Rpb24nICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoaWQgKyAnJywgJyonKTtcbiAgICB9O1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIsIGZhbHNlKTtcbiAgLy8gSUU4LVxuICB9IGVsc2UgaWYgKE9OUkVBRFlTVEFURUNIQU5HRSBpbiBjZWwoJ3NjcmlwdCcpKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoY2VsKCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuLmNhbGwoaWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBzZXRUaW1lb3V0KGN0eChydW4sIGlkLCAxKSwgMCk7XG4gICAgfTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogc2V0VGFzayxcbiAgY2xlYXI6IGNsZWFyVGFza1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBtYWNyb3Rhc2sgPSByZXF1aXJlKCcuL190YXNrJykuc2V0O1xudmFyIE9ic2VydmVyID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIFByb21pc2UgPSBnbG9iYWwuUHJvbWlzZTtcbnZhciBpc05vZGUgPSByZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGVhZCwgbGFzdCwgbm90aWZ5O1xuXG4gIHZhciBmbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyZW50LCBmbjtcbiAgICBpZiAoaXNOb2RlICYmIChwYXJlbnQgPSBwcm9jZXNzLmRvbWFpbikpIHBhcmVudC5leGl0KCk7XG4gICAgd2hpbGUgKGhlYWQpIHtcbiAgICAgIGZuID0gaGVhZC5mbjtcbiAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoaGVhZCkgbm90aWZ5KCk7XG4gICAgICAgIGVsc2UgbGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9IGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHBhcmVudCkgcGFyZW50LmVudGVyKCk7XG4gIH07XG5cbiAgLy8gTm9kZS5qc1xuICBpZiAoaXNOb2RlKSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gICAgfTtcbiAgLy8gYnJvd3NlcnMgd2l0aCBNdXRhdGlvbk9ic2VydmVyLCBleGNlcHQgaU9TIFNhZmFyaSAtIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8zMzlcbiAgfSBlbHNlIGlmIChPYnNlcnZlciAmJiAhKGdsb2JhbC5uYXZpZ2F0b3IgJiYgZ2xvYmFsLm5hdmlnYXRvci5zdGFuZGFsb25lKSkge1xuICAgIHZhciB0b2dnbGUgPSB0cnVlO1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG5ldyBPYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgbm9kZS5kYXRhID0gdG9nZ2xlID0gIXRvZ2dsZTtcbiAgICB9O1xuICAvLyBlbnZpcm9ubWVudHMgd2l0aCBtYXliZSBub24tY29tcGxldGVseSBjb3JyZWN0LCBidXQgZXhpc3RlbnQgUHJvbWlzZVxuICB9IGVsc2UgaWYgKFByb21pc2UgJiYgUHJvbWlzZS5yZXNvbHZlKSB7XG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9taXNlLnRoZW4oZmx1c2gpO1xuICAgIH07XG4gIC8vIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBtYWNyb3Rhc2sgYmFzZWQgb246XG4gIC8vIC0gc2V0SW1tZWRpYXRlXG4gIC8vIC0gTWVzc2FnZUNoYW5uZWxcbiAgLy8gLSB3aW5kb3cucG9zdE1lc3NhZ1xuICAvLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuICAvLyAtIHNldFRpbWVvdXRcbiAgfSBlbHNlIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBzdHJhbmdlIElFICsgd2VicGFjayBkZXYgc2VydmVyIGJ1ZyAtIHVzZSAuY2FsbChnbG9iYWwpXG4gICAgICBtYWNyb3Rhc2suY2FsbChnbG9iYWwsIGZsdXNoKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgIHZhciB0YXNrID0geyBmbjogZm4sIG5leHQ6IHVuZGVmaW5lZCB9O1xuICAgIGlmIChsYXN0KSBsYXN0Lm5leHQgPSB0YXNrO1xuICAgIGlmICghaGVhZCkge1xuICAgICAgaGVhZCA9IHRhc2s7XG4gICAgICBub3RpZnkoKTtcbiAgICB9IGxhc3QgPSB0YXNrO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDI1LjQuMS41IE5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xuXG5mdW5jdGlvbiBQcm9taXNlQ2FwYWJpbGl0eShDKSB7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uICgkJHJlc29sdmUsICQkcmVqZWN0KSB7XG4gICAgaWYgKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCdCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIHJlc29sdmUgPSAkJHJlc29sdmU7XG4gICAgcmVqZWN0ID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhRnVuY3Rpb24ocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ID0gYUZ1bmN0aW9uKHJlamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiAoQykge1xuICByZXR1cm4gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4geyBlOiBmYWxzZSwgdjogZXhlYygpIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4geyBlOiB0cnVlLCB2OiBlIH07XG4gIH1cbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDLCB4KSB7XG4gIGFuT2JqZWN0KEMpO1xuICBpZiAoaXNPYmplY3QoeCkgJiYgeC5jb25zdHJ1Y3RvciA9PT0gQykgcmV0dXJuIHg7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYoQyk7XG4gIHZhciByZXNvbHZlID0gcHJvbWlzZUNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgcmVzb2x2ZSh4KTtcbiAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7XG59O1xuIiwidmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc3JjLCBzYWZlKSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHJlZGVmaW5lKHRhcmdldCwga2V5LCBzcmNba2V5XSwgc2FmZSk7XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVkpIHtcbiAgdmFyIEMgPSBnbG9iYWxbS0VZXTtcbiAgaWYgKERFU0NSSVBUT1JTICYmIEMgJiYgIUNbU1BFQ0lFU10pIGRQLmYoQywgU1BFQ0lFUywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG52YXIgdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXQ7XG52YXIgbWljcm90YXNrID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSA9IHJlcXVpcmUoJy4vX25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcbnZhciBwZXJmb3JtID0gcmVxdWlyZSgnLi9fcGVyZm9ybScpO1xudmFyIHByb21pc2VSZXNvbHZlID0gcmVxdWlyZSgnLi9fcHJvbWlzZS1yZXNvbHZlJyk7XG52YXIgUFJPTUlTRSA9ICdQcm9taXNlJztcbnZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciAkUHJvbWlzZSA9IGdsb2JhbFtQUk9NSVNFXTtcbnZhciBpc05vZGUgPSBjbGFzc29mKHByb2Nlc3MpID09ICdwcm9jZXNzJztcbnZhciBlbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBJbnRlcm5hbCwgbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5LCBPd25Qcm9taXNlQ2FwYWJpbGl0eSwgV3JhcHBlcjtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmY7XG5cbnZhciBVU0VfTkFUSVZFID0gISFmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgLy8gY29ycmVjdCBzdWJjbGFzc2luZyB3aXRoIEBAc3BlY2llcyBzdXBwb3J0XG4gICAgdmFyIHByb21pc2UgPSAkUHJvbWlzZS5yZXNvbHZlKDEpO1xuICAgIHZhciBGYWtlUHJvbWlzZSA9IChwcm9taXNlLmNvbnN0cnVjdG9yID0ge30pW3JlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyldID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgICAgIGV4ZWMoZW1wdHksIGVtcHR5KTtcbiAgICB9O1xuICAgIC8vIHVuaGFuZGxlZCByZWplY3Rpb25zIHRyYWNraW5nIHN1cHBvcnQsIE5vZGVKUyBQcm9taXNlIHdpdGhvdXQgaXQgZmFpbHMgQEBzcGVjaWVzIHRlc3RcbiAgICByZXR1cm4gKGlzTm9kZSB8fCB0eXBlb2YgUHJvbWlzZVJlamVjdGlvbkV2ZW50ID09ICdmdW5jdGlvbicpICYmIHByb21pc2UudGhlbihlbXB0eSkgaW5zdGFuY2VvZiBGYWtlUHJvbWlzZTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59KCk7XG5cbi8vIGhlbHBlcnNcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xudmFyIG5vdGlmeSA9IGZ1bmN0aW9uIChwcm9taXNlLCBpc1JlamVjdCkge1xuICBpZiAocHJvbWlzZS5fbikgcmV0dXJuO1xuICBwcm9taXNlLl9uID0gdHJ1ZTtcbiAgdmFyIGNoYWluID0gcHJvbWlzZS5fYztcbiAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92O1xuICAgIHZhciBvayA9IHByb21pc2UuX3MgPT0gMTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uIChyZWFjdGlvbikge1xuICAgICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbDtcbiAgICAgIHZhciByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZTtcbiAgICAgIHZhciByZWplY3QgPSByZWFjdGlvbi5yZWplY3Q7XG4gICAgICB2YXIgZG9tYWluID0gcmVhY3Rpb24uZG9tYWluO1xuICAgICAgdmFyIHJlc3VsdCwgdGhlbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgaWYgKHByb21pc2UuX2ggPT0gMikgb25IYW5kbGVVbmhhbmRsZWQocHJvbWlzZSk7XG4gICAgICAgICAgICBwcm9taXNlLl9oID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhbmRsZXIgPT09IHRydWUpIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRvbWFpbikgZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChkb21haW4pIGRvbWFpbi5leGl0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2UpIHtcbiAgICAgICAgICAgIHJlamVjdChUeXBlRXJyb3IoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGVuID0gaXNUaGVuYWJsZShyZXN1bHQpKSB7XG4gICAgICAgICAgICB0aGVuLmNhbGwocmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aGlsZSAoY2hhaW4ubGVuZ3RoID4gaSkgcnVuKGNoYWluW2krK10pOyAvLyB2YXJpYWJsZSBsZW5ndGggLSBjYW4ndCB1c2UgZm9yRWFjaFxuICAgIHByb21pc2UuX2MgPSBbXTtcbiAgICBwcm9taXNlLl9uID0gZmFsc2U7XG4gICAgaWYgKGlzUmVqZWN0ICYmICFwcm9taXNlLl9oKSBvblVuaGFuZGxlZChwcm9taXNlKTtcbiAgfSk7XG59O1xudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3Y7XG4gICAgdmFyIHVuaGFuZGxlZCA9IGlzVW5oYW5kbGVkKHByb21pc2UpO1xuICAgIHZhciByZXN1bHQsIGhhbmRsZXIsIGNvbnNvbGU7XG4gICAgaWYgKHVuaGFuZGxlZCkge1xuICAgICAgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChoYW5kbGVyID0gZ2xvYmFsLm9udW5oYW5kbGVkcmVqZWN0aW9uKSB7XG4gICAgICAgICAgaGFuZGxlcih7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogdmFsdWUgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoKGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZSkgJiYgY29uc29sZS5lcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbicsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBCcm93c2VycyBzaG91bGQgbm90IHRyaWdnZXIgYHJlamVjdGlvbkhhbmRsZWRgIGV2ZW50IGlmIGl0IHdhcyBoYW5kbGVkIGhlcmUsIE5vZGVKUyAtIHNob3VsZFxuICAgICAgcHJvbWlzZS5faCA9IGlzTm9kZSB8fCBpc1VuaGFuZGxlZChwcm9taXNlKSA/IDIgOiAxO1xuICAgIH0gcHJvbWlzZS5fYSA9IHVuZGVmaW5lZDtcbiAgICBpZiAodW5oYW5kbGVkICYmIHJlc3VsdC5lKSB0aHJvdyByZXN1bHQudjtcbiAgfSk7XG59O1xudmFyIGlzVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgaWYgKHByb21pc2UuX2ggPT0gMSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9hIHx8IHByb21pc2UuX2M7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlYWN0aW9uO1xuICB3aGlsZSAoY2hhaW4ubGVuZ3RoID4gaSkge1xuICAgIHJlYWN0aW9uID0gY2hhaW5baSsrXTtcbiAgICBpZiAocmVhY3Rpb24uZmFpbCB8fCAhaXNVbmhhbmRsZWQocmVhY3Rpb24ucHJvbWlzZSkpIHJldHVybiBmYWxzZTtcbiAgfSByZXR1cm4gdHJ1ZTtcbn07XG52YXIgb25IYW5kbGVVbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhbmRsZXI7XG4gICAgaWYgKGlzTm9kZSkge1xuICAgICAgcHJvY2Vzcy5lbWl0KCdyZWplY3Rpb25IYW5kbGVkJywgcHJvbWlzZSk7XG4gICAgfSBlbHNlIGlmIChoYW5kbGVyID0gZ2xvYmFsLm9ucmVqZWN0aW9uaGFuZGxlZCkge1xuICAgICAgaGFuZGxlcih7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogcHJvbWlzZS5fdiB9KTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciAkcmVqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBwcm9taXNlID0gdGhpcztcbiAgaWYgKHByb21pc2UuX2QpIHJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICBwcm9taXNlLl92ID0gdmFsdWU7XG4gIHByb21pc2UuX3MgPSAyO1xuICBpZiAoIXByb21pc2UuX2EpIHByb21pc2UuX2EgPSBwcm9taXNlLl9jLnNsaWNlKCk7XG4gIG5vdGlmeShwcm9taXNlLCB0cnVlKTtcbn07XG52YXIgJHJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICB2YXIgdGhlbjtcbiAgaWYgKHByb21pc2UuX2QpIHJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICB0cnkge1xuICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkgdGhyb3cgVHlwZUVycm9yKFwiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGZcIik7XG4gICAgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHZhbHVlKSkge1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSB7IF93OiBwcm9taXNlLCBfZDogZmFsc2UgfTsgLy8gd3JhcFxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoZW4uY2FsbCh2YWx1ZSwgY3R4KCRyZXNvbHZlLCB3cmFwcGVyLCAxKSwgY3R4KCRyZWplY3QsIHdyYXBwZXIsIDEpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICRyZWplY3QuY2FsbCh3cmFwcGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3MgPSAxO1xuICAgICAgbm90aWZ5KHByb21pc2UsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAkcmVqZWN0LmNhbGwoeyBfdzogcHJvbWlzZSwgX2Q6IGZhbHNlIH0sIGUpOyAvLyB3cmFwXG4gIH1cbn07XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZiAoIVVTRV9OQVRJVkUpIHtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgJFByb21pc2UgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkUHJvbWlzZSwgUFJPTUlTRSwgJ19oJyk7XG4gICAgYUZ1bmN0aW9uKGV4ZWN1dG9yKTtcbiAgICBJbnRlcm5hbC5jYWxsKHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihjdHgoJHJlc29sdmUsIHRoaXMsIDEpLCBjdHgoJHJlamVjdCwgdGhpcywgMSkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgJHJlamVjdC5jYWxsKHRoaXMsIGVycik7XG4gICAgfVxuICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgSW50ZXJuYWwgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgdGhpcy5fYyA9IFtdOyAgICAgICAgICAgICAvLyA8LSBhd2FpdGluZyByZWFjdGlvbnNcbiAgICB0aGlzLl9hID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIGNoZWNrZWQgaW4gaXNVbmhhbmRsZWQgcmVhY3Rpb25zXG4gICAgdGhpcy5fcyA9IDA7ICAgICAgICAgICAgICAvLyA8LSBzdGF0ZVxuICAgIHRoaXMuX2QgPSBmYWxzZTsgICAgICAgICAgLy8gPC0gZG9uZVxuICAgIHRoaXMuX3YgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gdmFsdWVcbiAgICB0aGlzLl9oID0gMDsgICAgICAgICAgICAgIC8vIDwtIHJlamVjdGlvbiBzdGF0ZSwgMCAtIGRlZmF1bHQsIDEgLSBoYW5kbGVkLCAyIC0gdW5oYW5kbGVkXG4gICAgdGhpcy5fbiA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBub3RpZnlcbiAgfTtcbiAgSW50ZXJuYWwucHJvdG90eXBlID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJykoJFByb21pc2UucHJvdG90eXBlLCB7XG4gICAgLy8gMjUuNC41LjMgUHJvbWlzZS5wcm90b3R5cGUudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZClcbiAgICB0aGVuOiBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICB2YXIgcmVhY3Rpb24gPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJFByb21pc2UpKTtcbiAgICAgIHJlYWN0aW9uLm9rID0gdHlwZW9mIG9uRnVsZmlsbGVkID09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IHRydWU7XG4gICAgICByZWFjdGlvbi5mYWlsID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVhY3Rpb24uZG9tYWluID0gaXNOb2RlID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9jLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYgKHRoaXMuX2EpIHRoaXMuX2EucHVzaChyZWFjdGlvbik7XG4gICAgICBpZiAodGhpcy5fcykgbm90aWZ5KHRoaXMsIGZhbHNlKTtcbiAgICAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlO1xuICAgIH0sXG4gICAgLy8gMjUuNC41LjEgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2gob25SZWplY3RlZClcbiAgICAnY2F0Y2gnOiBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfSk7XG4gIE93blByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9taXNlID0gbmV3IEludGVybmFsKCk7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBjdHgoJHJlc29sdmUsIHByb21pc2UsIDEpO1xuICAgIHRoaXMucmVqZWN0ID0gY3R4KCRyZWplY3QsIHByb21pc2UsIDEpO1xuICB9O1xuICBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoQykge1xuICAgIHJldHVybiBDID09PSAkUHJvbWlzZSB8fCBDID09PSBXcmFwcGVyXG4gICAgICA/IG5ldyBPd25Qcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgICAgOiBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHsgUHJvbWlzZTogJFByb21pc2UgfSk7XG5yZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpKCRQcm9taXNlLCBQUk9NSVNFKTtcbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoUFJPTUlTRSk7XG5XcmFwcGVyID0gcmVxdWlyZSgnLi9fY29yZScpW1BST01JU0VdO1xuXG4vLyBzdGF0aWNzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpIHtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHRoaXMpO1xuICAgIHZhciAkJHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgICQkcmVqZWN0KHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTElCUkFSWSB8fCAhVVNFX05BVElWRSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCkge1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShMSUJSQVJZICYmIHRoaXMgPT09IFdyYXBwZXIgPyAkUHJvbWlzZSA6IHRoaXMsIHgpO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIShVU0VfTkFUSVZFICYmIHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24gKGl0ZXIpIHtcbiAgJFByb21pc2UuYWxsKGl0ZXIpWydjYXRjaCddKGVtcHR5KTtcbn0pKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuMSBQcm9taXNlLmFsbChpdGVyYWJsZSlcbiAgYWxsOiBmdW5jdGlvbiBhbGwoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgICB2YXIgcmVzb2x2ZSA9IGNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciByZW1haW5pbmcgPSAxO1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICB2YXIgJGluZGV4ID0gaW5kZXgrKztcbiAgICAgICAgdmFyIGFscmVhZHlDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzLnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgcmVtYWluaW5nKys7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChhbHJlYWR5Q2FsbGVkKSByZXR1cm47XG4gICAgICAgICAgYWxyZWFkeUNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgdmFsdWVzWyRpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmUpIHJlamVjdChyZXN1bHQudik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfSxcbiAgLy8gMjUuNC40LjQgUHJvbWlzZS5yYWNlKGl0ZXJhYmxlKVxuICByYWNlOiBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lKSByZWplY3QocmVzdWx0LnYpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuIiwiLypcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGlzSW5pdGlhbGl6ZWQgPSBmYWxzZVxuXG4vLyBtYWpvciBldmVudHMgc3VwcG9ydGVkOlxuLy8gICBwYW5zdGFydFxuLy8gICBwYW5tb3ZlXG4vLyAgIHBhbmVuZFxuLy8gICBzd2lwZVxuLy8gICBsb25ncHJlc3Ncbi8vIGV4dHJhIGV2ZW50cyBzdXBwb3J0ZWQ6XG4vLyAgIGR1YWx0b3VjaHN0YXJ0XG4vLyAgIGR1YWx0b3VjaFxuLy8gICBkdWFsdG91Y2hlbmRcbi8vICAgdGFwXG4vLyAgIGRvdWJsZXRhcFxuLy8gICBwcmVzc2VuZFxuXG52YXIgZG9jID0gd2luZG93LmRvY3VtZW50XG52YXIgZG9jRWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2VcbnZhciBnZXN0dXJlcyA9IHt9XG52YXIgbGFzdFRhcCA9IG51bGxcblxuLyoqXG4gKiBmaW5kIHRoZSBjbG9zZXN0IGNvbW1vbiBhbmNlc3RvclxuICogaWYgdGhlcmUncyBubyBvbmUsIHJldHVybiBudWxsXG4gKlxuICogQHBhcmFtICB7RWxlbWVudH0gZWwxIGZpcnN0IGVsZW1lbnRcbiAqIEBwYXJhbSAge0VsZW1lbnR9IGVsMiBzZWNvbmQgZWxlbWVudFxuICogQHJldHVybiB7RWxlbWVudH0gICAgIGNvbW1vbiBhbmNlc3RvclxuICovXG5mdW5jdGlvbiBnZXRDb21tb25BbmNlc3RvcihlbDEsIGVsMikge1xuICB2YXIgZWwgPSBlbDFcbiAgd2hpbGUgKGVsKSB7XG4gICAgaWYgKGVsLmNvbnRhaW5zKGVsMikgfHwgZWwgPT0gZWwyKSB7XG4gICAgICByZXR1cm4gZWxcbiAgICB9XG4gICAgZWwgPSBlbC5wYXJlbnROb2RlXG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuLyoqXG4gKiBmaXJlIGEgSFRNTEV2ZW50XG4gKlxuICogQHBhcmFtICB7RWxlbWVudH0gZWxlbWVudCB3aGljaCBlbGVtZW50IHRvIGZpcmUgYSBldmVudCBvblxuICogQHBhcmFtICB7c3RyaW5nfSAgdHlwZSAgICB0eXBlIG9mIGV2ZW50XG4gKiBAcGFyYW0gIHtvYmplY3R9ICBleHRyYSAgIGV4dHJhIGRhdGEgZm9yIHRoZSBldmVudCBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZmlyZUV2ZW50KGVsZW1lbnQsIHR5cGUsIGV4dHJhKSB7XG4gIHZhciBldmVudCA9IGRvYy5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpXG4gIGV2ZW50LmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKVxuXG4gIGlmICh0eXBlb2YgZXh0cmEgPT09ICdvYmplY3QnKSB7XG4gICAgZm9yICh2YXIgcCBpbiBleHRyYSkge1xuICAgICAgZXZlbnRbcF0gPSBleHRyYVtwXVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBIGZsYWcgdG8gZGlzdGluZ3Vpc2ggd2l0aCBvdGhlciBldmVudHMgd2l0aCB0aGUgc2FtZSBuYW1lIGdlbmVyYXRlZFxuICAgKiBieSBhbm90aGVyIGxpYnJhcnkgaW4gdGhlIHNhbWUgcGFnZS5cbiAgICovIFxuICBldmVudC5fZm9yID0gJ3dlZXgnXG5cbiAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KVxufVxuXG4vKipcbiAqIGNhbGMgdGhlIHRyYW5zZm9ybVxuICogYXNzdW1lIDQgcG9pbnRzIEFCQ0Qgb24gdGhlIGNvb3JkaW5hdGUgc3lzdGVtXG4gKiA+IHJvdGF0Ze+8mmFuZ2xlIHJvdGF0aW5nIGZyb20gQUIgdG8gQ0RcbiAqID4gc2NhbGXvvJpzY2FsZSByYXRpbyBmcm9tIEFCIHRvIENEXG4gKiA+IHRyYW5zbGF0Ze+8mnRyYW5zbGF0ZSBzaGlmdCBmcm9tIEEgdG8gQ1xuICpcbiAqIEBwYXJhbSAge251bWJlcn0geDEgYWJzY2lzc2Egb2YgQVxuICogQHBhcmFtICB7bnVtYmVyfSB5MSBvcmRpbmF0ZSBvZiBBXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHgyIGFic2Npc3NhIG9mIEJcbiAqIEBwYXJhbSAge251bWJlcn0geTIgb3JkaW5hdGUgb2YgQlxuICogQHBhcmFtICB7bnVtYmVyfSB4MyBhYnNjaXNzYSBvZiBDXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHkzIG9yZGluYXRlIG9mIENcbiAqIEBwYXJhbSAge251bWJlcn0geDQgYWJzY2lzc2Egb2YgRFxuICogQHBhcmFtICB7bnVtYmVyfSB5NCBvcmRpbmF0ZSBvZiBEXG4gKiBAcmV0dXJuIHtvYmplY3R9ICAgIHRyYW5zZm9ybSBvYmplY3QgbGlrZVxuICogICB7cm90YXRlLCBzY2FsZSwgdHJhbnNsYXRlWzJdLCBtYXRyaXhbM11bM119XG4gKi9cbmZ1bmN0aW9uIGNhbGMoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0KSB7XG4gIHZhciByb3RhdGUgPSBNYXRoLmF0YW4yKHk0IC0geTMsIHg0IC0geDMpIC0gTWF0aC5hdGFuMih5MiAtIHkxLCB4MiAtIHgxKVxuICB2YXIgc2NhbGUgPSBNYXRoLnNxcnQoKE1hdGgucG93KHk0IC0geTMsIDIpXG4gICAgKyBNYXRoLnBvdyh4NCAtIHgzLCAyKSkgLyAoTWF0aC5wb3coeTIgLSB5MSwgMilcbiAgICArIE1hdGgucG93KHgyIC0geDEsIDIpKSlcbiAgdmFyIHRyYW5zbGF0ZSA9IFtcbiAgICB4M1xuICAgIC0gc2NhbGUgKiB4MSAqIE1hdGguY29zKHJvdGF0ZSlcbiAgICArIHNjYWxlICogeTEgKiBNYXRoLnNpbihyb3RhdGUpLFxuICAgIHkzXG4gICAgLSBzY2FsZSAqIHkxICogTWF0aC5jb3Mocm90YXRlKVxuICAgIC0gc2NhbGUgKiB4MSAqIE1hdGguc2luKHJvdGF0ZSldXG5cbiAgcmV0dXJuIHtcbiAgICByb3RhdGU6IHJvdGF0ZSxcbiAgICBzY2FsZTogc2NhbGUsXG4gICAgdHJhbnNsYXRlOiB0cmFuc2xhdGUsXG4gICAgbWF0cml4OiBbXG4gICAgICBbc2NhbGUgKiBNYXRoLmNvcyhyb3RhdGUpLCAtc2NhbGUgKiBNYXRoLnNpbihyb3RhdGUpLCB0cmFuc2xhdGVbMF1dLFxuICAgICAgW3NjYWxlICogTWF0aC5zaW4ocm90YXRlKSwgc2NhbGUgKiBNYXRoLmNvcyhyb3RhdGUpLCB0cmFuc2xhdGVbMV1dLFxuICAgICAgWzAsIDAsIDFdXG4gICAgXVxuICB9XG59XG5cbi8qKlxuICogdGFrZSBvdmVyIHRoZSB0b3VjaHN0YXJ0IGV2ZW50cy4gQWRkIG5ldyB0b3VjaGVzIHRvIHRoZSBnZXN0dXJlcy5cbiAqIElmIHRoZXJlIGlzIG5vIHByZXZpb3VzIHJlY29yZHMsIHRoZW4gYmluZCB0b3VjaG1vdmUsIHRvY2hlbmRcbiAqIGFuZCB0b3VjaGNhbmNlbCBldmVudHMuXG4gKiBuZXcgdG91Y2hlcyBpbml0aWFsaXplZCB3aXRoIHN0YXRlICd0YXBwaW5nJywgYW5kIHdpdGhpbiA1MDAgbWlsbGlzZWNvbmRzXG4gKiBpZiB0aGUgc3RhdGUgaXMgc3RpbGwgdGFwcGluZywgdGhlbiB0cmlnZ2VyIGdlc3R1cmUgJ3ByZXNzJy5cbiAqIElmIHRoZXJlIGFyZSB0d28gdG91Y2hlIHBvaW50cywgdGhlbiB0aGUgJ2R1YWx0b3VjaHN0YXJ0JyBpcyB0cmlnZ2VyZC4gVGhlXG4gKiBub2RlIG9mIHRoZSB0b3VjaCBnZXN0dXJlIGlzIHRoZWlyIGNsb2VzdCBjb21tb24gYW5jZXN0b3IuXG4gKlxuICogQGV2ZW50XG4gKiBAcGFyYW0gIHtldmVudH0gZXZlbnRcbiAqL1xuZnVuY3Rpb24gdG91Y2hzdGFydEhhbmRsZXIoZXZlbnQpIHtcblxuICBpZiAoT2JqZWN0LmtleXMoZ2VzdHVyZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgIGRvY0VsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRvdWNobW92ZUhhbmRsZXIsIHRydWUpXG4gICAgZG9jRWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0b3VjaGVuZEhhbmRsZXIsIHRydWUpXG4gICAgZG9jRWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0b3VjaGNhbmNlbEhhbmRsZXIsIHRydWUpXG4gIH1cblxuICAvLyByZWNvcmQgZXZlcnkgdG91Y2hcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzW2ldXG4gICAgdmFyIHRvdWNoUmVjb3JkID0ge31cblxuICAgIGZvciAodmFyIHAgaW4gdG91Y2gpIHtcbiAgICAgIHRvdWNoUmVjb3JkW3BdID0gdG91Y2hbcF1cbiAgICB9XG5cbiAgICB2YXIgZ2VzdHVyZSA9IHtcbiAgICAgIHN0YXJ0VG91Y2g6IHRvdWNoUmVjb3JkLFxuICAgICAgc3RhcnRUaW1lOiBEYXRlLm5vdygpLFxuICAgICAgc3RhdHVzOiAndGFwcGluZycsXG4gICAgICBlbGVtZW50OiBldmVudC5zcmNFbGVtZW50IHx8IGV2ZW50LnRhcmdldCxcbiAgICAgIHByZXNzaW5nSGFuZGxlcjogc2V0VGltZW91dChmdW5jdGlvbiAoZWxlbWVudCwgdG91Y2gpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZ2VzdHVyZS5zdGF0dXMgPT09ICd0YXBwaW5nJykge1xuICAgICAgICAgICAgZ2VzdHVyZS5zdGF0dXMgPSAncHJlc3NpbmcnXG5cbiAgICAgICAgICAgIGZpcmVFdmVudChlbGVtZW50LCAnbG9uZ3ByZXNzJywge1xuICAgICAgICAgICAgICAvLyBhZGQgdG91Y2ggZGF0YSBmb3Igd2VleFxuICAgICAgICAgICAgICB0b3VjaDogdG91Y2gsXG4gICAgICAgICAgICAgIHRvdWNoZXM6IGV2ZW50LnRvdWNoZXMsXG4gICAgICAgICAgICAgIGNoYW5nZWRUb3VjaGVzOiBldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgICAgICAgdG91Y2hFdmVudDogZXZlbnRcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KGdlc3R1cmUucHJlc3NpbmdIYW5kbGVyKVxuICAgICAgICAgIGdlc3R1cmUucHJlc3NpbmdIYW5kbGVyID0gbnVsbFxuICAgICAgICB9XG4gICAgICB9KGV2ZW50LnNyY0VsZW1lbnQgfHwgZXZlbnQudGFyZ2V0LCBldmVudC5jaGFuZ2VkVG91Y2hlc1tpXSksIDUwMClcbiAgICB9XG4gICAgZ2VzdHVyZXNbdG91Y2guaWRlbnRpZmllcl0gPSBnZXN0dXJlXG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXMoZ2VzdHVyZXMpLmxlbmd0aCA9PSAyKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gW11cblxuICAgIGZvciAodmFyIHAgaW4gZ2VzdHVyZXMpIHtcbiAgICAgIGVsZW1lbnRzLnB1c2goZ2VzdHVyZXNbcF0uZWxlbWVudClcbiAgICB9XG5cbiAgICBmaXJlRXZlbnQoZ2V0Q29tbW9uQW5jZXN0b3IoZWxlbWVudHNbMF0sIGVsZW1lbnRzWzFdKSwgJ2R1YWx0b3VjaHN0YXJ0Jywge1xuICAgICAgdG91Y2hlczogc2xpY2UuY2FsbChldmVudC50b3VjaGVzKSxcbiAgICAgIHRvdWNoRXZlbnQ6IGV2ZW50XG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIHRha2Ugb3ZlciB0b3VjaG1vdmUgZXZlbnRzLCBhbmQgaGFuZGxlIHBhbiBhbmQgZHVhbCByZWxhdGVkIGdlc3R1cmVzLlxuICpcbiAqIDEuIHRyYXZlcnNlIGV2ZXJ5IHRvdWNoIHBvaW5077yaXG4gKiA+IGlmICd0YXBwaW5nJyBhbmQgdGhlIHNoaWZ0IGlzIG92ZXIgMTAgcGl4bGVzLCB0aGVuIGl0J3MgYSAncGFubmluZycuXG4gKiAyLiBpZiB0aGVyZSBhcmUgdHdvIHRvdWNoIHBvaW50cywgdGhlbiBjYWxjIHRoZSB0cmFuZm9ybSBhbmQgdHJpZ2dlclxuICogICAnZHVhbHRvdWNoJy5cbiAqXG4gKiBAZXZlbnRcbiAqIEBwYXJhbSAge2V2ZW50fSBldmVudFxuICovXG5mdW5jdGlvbiB0b3VjaG1vdmVIYW5kbGVyKGV2ZW50KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdG91Y2ggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1tpXVxuICAgIHZhciBnZXN0dXJlID0gZ2VzdHVyZXNbdG91Y2guaWRlbnRpZmllcl1cblxuICAgIGlmICghZ2VzdHVyZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCFnZXN0dXJlLmxhc3RUb3VjaCkge1xuICAgICAgZ2VzdHVyZS5sYXN0VG91Y2ggPSBnZXN0dXJlLnN0YXJ0VG91Y2hcbiAgICB9XG4gICAgaWYgKCFnZXN0dXJlLmxhc3RUaW1lKSB7XG4gICAgICBnZXN0dXJlLmxhc3RUaW1lID0gZ2VzdHVyZS5zdGFydFRpbWVcbiAgICB9XG4gICAgaWYgKCFnZXN0dXJlLnZlbG9jaXR5WCkge1xuICAgICAgZ2VzdHVyZS52ZWxvY2l0eVggPSAwXG4gICAgfVxuICAgIGlmICghZ2VzdHVyZS52ZWxvY2l0eVkpIHtcbiAgICAgIGdlc3R1cmUudmVsb2NpdHlZID0gMFxuICAgIH1cbiAgICBpZiAoIWdlc3R1cmUuZHVyYXRpb24pIHtcbiAgICAgIGdlc3R1cmUuZHVyYXRpb24gPSAwXG4gICAgfVxuXG4gICAgdmFyIHRpbWUgPSAgRGF0ZS5ub3coKSAtIGdlc3R1cmUubGFzdFRpbWVcbiAgICB2YXIgdnggPSAodG91Y2guY2xpZW50WCAtIGdlc3R1cmUubGFzdFRvdWNoLmNsaWVudFgpIC8gdGltZVxuICAgIHZhciB2eSA9ICh0b3VjaC5jbGllbnRZIC0gZ2VzdHVyZS5sYXN0VG91Y2guY2xpZW50WSkgLyB0aW1lXG5cbiAgICB2YXIgUkVDT1JEX0RVUkFUSU9OID0gNzBcbiAgICBpZiAodGltZSA+IFJFQ09SRF9EVVJBVElPTikge1xuICAgICAgdGltZSA9IFJFQ09SRF9EVVJBVElPTlxuICAgIH1cbiAgICBpZiAoZ2VzdHVyZS5kdXJhdGlvbiArIHRpbWUgPiBSRUNPUkRfRFVSQVRJT04pIHtcbiAgICAgIGdlc3R1cmUuZHVyYXRpb24gPSBSRUNPUkRfRFVSQVRJT04gLSB0aW1lXG4gICAgfVxuXG4gICAgZ2VzdHVyZS52ZWxvY2l0eVggPSAoZ2VzdHVyZS52ZWxvY2l0eVggKiBnZXN0dXJlLmR1cmF0aW9uICsgdnggKiB0aW1lKVxuICAgICAgLyAoZ2VzdHVyZS5kdXJhdGlvbiArIHRpbWUpXG4gICAgZ2VzdHVyZS52ZWxvY2l0eVkgPSAoZ2VzdHVyZS52ZWxvY2l0eVkgKiBnZXN0dXJlLmR1cmF0aW9uICsgdnkgKiB0aW1lKVxuICAgICAgLyAoZ2VzdHVyZS5kdXJhdGlvbiArIHRpbWUpXG4gICAgZ2VzdHVyZS5kdXJhdGlvbiArPSB0aW1lXG5cbiAgICBnZXN0dXJlLmxhc3RUb3VjaCA9IHt9XG5cbiAgICBmb3IgKHZhciBwIGluIHRvdWNoKSB7XG4gICAgICBnZXN0dXJlLmxhc3RUb3VjaFtwXSA9IHRvdWNoW3BdXG4gICAgfVxuICAgIGdlc3R1cmUubGFzdFRpbWUgPSBEYXRlLm5vdygpXG5cbiAgICB2YXIgZGlzcGxhY2VtZW50WCA9IHRvdWNoLmNsaWVudFggLSBnZXN0dXJlLnN0YXJ0VG91Y2guY2xpZW50WFxuICAgIHZhciBkaXNwbGFjZW1lbnRZID0gdG91Y2guY2xpZW50WSAtIGdlc3R1cmUuc3RhcnRUb3VjaC5jbGllbnRZXG4gICAgdmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KE1hdGgucG93KGRpc3BsYWNlbWVudFgsIDIpXG4gICAgICArIE1hdGgucG93KGRpc3BsYWNlbWVudFksIDIpKVxuICAgIHZhciBpc1ZlcnRpY2FsID0gIShNYXRoLmFicyhkaXNwbGFjZW1lbnRYKSA+IE1hdGguYWJzKGRpc3BsYWNlbWVudFkpKVxuICAgIHZhciBkaXJlY3Rpb24gPSBpc1ZlcnRpY2FsXG4gICAgICA/IGRpc3BsYWNlbWVudFkgPj0gMCA/ICdkb3duJyA6ICd1cCdcbiAgICAgIDogZGlzcGxhY2VtZW50WCA+PSAwID8gJ3JpZ2h0JyA6ICdsZWZ0J1xuXG4gICAgLy8gbWFnaWMgbnVtYmVyIDEwOiBtb3ZpbmcgMTBweCBtZWFucyBwYW4sIG5vdCB0YXBcbiAgICBpZiAoKGdlc3R1cmUuc3RhdHVzID09PSAndGFwcGluZycgfHwgZ2VzdHVyZS5zdGF0dXMgPT09ICdwcmVzc2luZycpXG4gICAgICAgICYmIGRpc3RhbmNlID4gMTApIHtcbiAgICAgIGdlc3R1cmUuc3RhdHVzID0gJ3Bhbm5pbmcnXG4gICAgICBnZXN0dXJlLmlzVmVydGljYWwgPSBpc1ZlcnRpY2FsXG4gICAgICBnZXN0dXJlLmRpcmVjdGlvbiA9IGRpcmVjdGlvblxuXG4gICAgICBmaXJlRXZlbnQoZ2VzdHVyZS5lbGVtZW50LCAncGFuc3RhcnQnLCB7XG4gICAgICAgIHRvdWNoOiB0b3VjaCxcbiAgICAgICAgdG91Y2hlczogZXZlbnQudG91Y2hlcyxcbiAgICAgICAgY2hhbmdlZFRvdWNoZXM6IGV2ZW50LmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICB0b3VjaEV2ZW50OiBldmVudCxcbiAgICAgICAgaXNWZXJ0aWNhbDogZ2VzdHVyZS5pc1ZlcnRpY2FsLFxuICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvblxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoZ2VzdHVyZS5zdGF0dXMgPT09ICdwYW5uaW5nJykge1xuICAgICAgZ2VzdHVyZS5wYW5UaW1lID0gRGF0ZS5ub3coKVxuXG4gICAgICBmaXJlRXZlbnQoZ2VzdHVyZS5lbGVtZW50LCAncGFubW92ZScsIHtcbiAgICAgICAgZGlzcGxhY2VtZW50WDogZGlzcGxhY2VtZW50WCxcbiAgICAgICAgZGlzcGxhY2VtZW50WTogZGlzcGxhY2VtZW50WSxcbiAgICAgICAgdG91Y2g6IHRvdWNoLFxuICAgICAgICB0b3VjaGVzOiBldmVudC50b3VjaGVzLFxuICAgICAgICBjaGFuZ2VkVG91Y2hlczogZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgIHRvdWNoRXZlbnQ6IGV2ZW50LFxuICAgICAgICBpc1ZlcnRpY2FsOiBnZXN0dXJlLmlzVmVydGljYWwsXG4gICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGlmIChPYmplY3Qua2V5cyhnZXN0dXJlcykubGVuZ3RoID09IDIpIHtcbiAgICB2YXIgcG9zaXRpb24gPSBbXVxuICAgIHZhciBjdXJyZW50ID0gW11cbiAgICB2YXIgZWxlbWVudHMgPSBbXVxuICAgIHZhciB0cmFuc2Zvcm1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnQudG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRvdWNoID0gZXZlbnQudG91Y2hlc1tpXVxuICAgICAgdmFyIGdlc3R1cmUgPSBnZXN0dXJlc1t0b3VjaC5pZGVudGlmaWVyXVxuICAgICAgcG9zaXRpb24ucHVzaChbZ2VzdHVyZS5zdGFydFRvdWNoLmNsaWVudFgsIGdlc3R1cmUuc3RhcnRUb3VjaC5jbGllbnRZXSlcbiAgICAgIGN1cnJlbnQucHVzaChbdG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WV0pXG4gICAgfVxuXG4gICAgZm9yICh2YXIgcCBpbiBnZXN0dXJlcykge1xuICAgICAgZWxlbWVudHMucHVzaChnZXN0dXJlc1twXS5lbGVtZW50KVxuICAgIH1cblxuICAgIHRyYW5zZm9ybSA9IGNhbGMoXG4gICAgICBwb3NpdGlvblswXVswXSxcbiAgICAgIHBvc2l0aW9uWzBdWzFdLFxuICAgICAgcG9zaXRpb25bMV1bMF0sXG4gICAgICBwb3NpdGlvblsxXVsxXSxcbiAgICAgIGN1cnJlbnRbMF1bMF0sXG4gICAgICBjdXJyZW50WzBdWzFdLFxuICAgICAgY3VycmVudFsxXVswXSxcbiAgICAgIGN1cnJlbnRbMV1bMV1cbiAgICApXG4gICAgZmlyZUV2ZW50KGdldENvbW1vbkFuY2VzdG9yKGVsZW1lbnRzWzBdLCBlbGVtZW50c1sxXSksICdkdWFsdG91Y2gnLCB7XG4gICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICAgIHRvdWNoZXM6IGV2ZW50LnRvdWNoZXMsXG4gICAgICB0b3VjaEV2ZW50OiBldmVudFxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiBoYW5kbGUgdG91Y2hlbmQgZXZlbnRcbiAqXG4gKiAxLiBpZiB0aGVyZSBhcmUgdG93IHRvdWNoIHBvaW50cywgdGhlbiB0cmlnZ2VyICdkdWFsdG91Y2hlbmQn5aaCXG4gKlxuICogMi4gdHJhdmVyc2UgZXZlcnkgdG91Y2ggcGlvbnTvvJpcbiAqID4gaWYgdGFwcGluZywgdGhlbiB0cmlnZ2VyICd0YXAnLlxuICogSWYgdGhlcmUgaXMgYSB0YXAgMzAwIG1pbGxpc2Vjb25kcyBiZWZvcmUsIHRoZW4gaXQncyBhICdkb3VibGV0YXAnLlxuICogPiBpZiBwYWRkaW5nLCB0aGVuIGRlY2lkZSB0byB0cmlnZ2VyICdwYW5lbmQnIG9yICdzd2lwZSdcbiAqID4gaWYgcHJlc3NpbmcsIHRoZW4gdHJpZ2dlciAncHJlc3NlbmQnLlxuICpcbiAqIDMuIHJlbW92ZSBsaXN0ZW5lcnMuXG4gKlxuICogQGV2ZW50XG4gKiBAcGFyYW0gIHtldmVudH0gZXZlbnRcbiAqL1xuZnVuY3Rpb24gdG91Y2hlbmRIYW5kbGVyKGV2ZW50KSB7XG5cbiAgaWYgKE9iamVjdC5rZXlzKGdlc3R1cmVzKS5sZW5ndGggPT0gMikge1xuICAgIHZhciBlbGVtZW50cyA9IFtdXG4gICAgZm9yICh2YXIgcCBpbiBnZXN0dXJlcykge1xuICAgICAgZWxlbWVudHMucHVzaChnZXN0dXJlc1twXS5lbGVtZW50KVxuICAgIH1cbiAgICBmaXJlRXZlbnQoZ2V0Q29tbW9uQW5jZXN0b3IoZWxlbWVudHNbMF0sIGVsZW1lbnRzWzFdKSwgJ2R1YWx0b3VjaGVuZCcsIHtcbiAgICAgIHRvdWNoZXM6IHNsaWNlLmNhbGwoZXZlbnQudG91Y2hlcyksXG4gICAgICB0b3VjaEV2ZW50OiBldmVudFxuICAgIH0pXG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbaV1cbiAgICB2YXIgaWQgPSB0b3VjaC5pZGVudGlmaWVyXG4gICAgdmFyIGdlc3R1cmUgPSBnZXN0dXJlc1tpZF1cblxuICAgIGlmICghZ2VzdHVyZSkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAoZ2VzdHVyZS5wcmVzc2luZ0hhbmRsZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dChnZXN0dXJlLnByZXNzaW5nSGFuZGxlcilcbiAgICAgIGdlc3R1cmUucHJlc3NpbmdIYW5kbGVyID0gbnVsbFxuICAgIH1cblxuICAgIGlmIChnZXN0dXJlLnN0YXR1cyA9PT0gJ3RhcHBpbmcnKSB7XG4gICAgICBnZXN0dXJlLnRpbWVzdGFtcCA9IERhdGUubm93KClcbiAgICAgIC8vIGZpcmUgY2xpY2ssIG5vdCB0YXAuXG4gICAgICBmaXJlRXZlbnQoZ2VzdHVyZS5lbGVtZW50LCAnd2VleCR0YXAnLCB7XG4gICAgICAgIHRvdWNoOiB0b3VjaCxcbiAgICAgICAgdG91Y2hFdmVudDogZXZlbnRcbiAgICAgIH0pXG5cbiAgICAgIGlmIChsYXN0VGFwICYmIGdlc3R1cmUudGltZXN0YW1wIC0gbGFzdFRhcC50aW1lc3RhbXAgPCAzMDApIHtcbiAgICAgICAgZmlyZUV2ZW50KGdlc3R1cmUuZWxlbWVudCwgJ2RvdWJsZXRhcCcsIHtcbiAgICAgICAgICB0b3VjaDogdG91Y2gsXG4gICAgICAgICAgdG91Y2hFdmVudDogZXZlbnRcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgbGFzdFRhcCA9IGdlc3R1cmVcbiAgICB9XG5cbiAgICBpZiAoZ2VzdHVyZS5zdGF0dXMgPT09ICdwYW5uaW5nJykge1xuICAgICAgdmFyIG5vdyA9IERhdGUubm93KClcbiAgICAgIHZhciBkdXJhdGlvbiA9IG5vdyAtIGdlc3R1cmUuc3RhcnRUaW1lXG4gICAgICB2YXIgZGlzcGxhY2VtZW50WCA9IHRvdWNoLmNsaWVudFggLSBnZXN0dXJlLnN0YXJ0VG91Y2guY2xpZW50WFxuICAgICAgdmFyIGRpc3BsYWNlbWVudFkgPSB0b3VjaC5jbGllbnRZIC0gZ2VzdHVyZS5zdGFydFRvdWNoLmNsaWVudFlcblxuICAgICAgdmFyIHZlbG9jaXR5ID0gTWF0aC5zcXJ0KGdlc3R1cmUudmVsb2NpdHlZICogZ2VzdHVyZS52ZWxvY2l0eVlcbiAgICAgICAgKyBnZXN0dXJlLnZlbG9jaXR5WCAqIGdlc3R1cmUudmVsb2NpdHlYKVxuICAgICAgdmFyIGlzU3dpcGUgPSB2ZWxvY2l0eSA+IDAuNSAmJiAobm93IC0gZ2VzdHVyZS5sYXN0VGltZSkgPCAxMDBcbiAgICAgIHZhciBleHRyYSA9IHtcbiAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICBpc1N3aXBlOiBpc1N3aXBlLFxuICAgICAgICB2ZWxvY2l0eVg6IGdlc3R1cmUudmVsb2NpdHlYLFxuICAgICAgICB2ZWxvY2l0eVk6IGdlc3R1cmUudmVsb2NpdHlZLFxuICAgICAgICBkaXNwbGFjZW1lbnRYOiBkaXNwbGFjZW1lbnRYLFxuICAgICAgICBkaXNwbGFjZW1lbnRZOiBkaXNwbGFjZW1lbnRZLFxuICAgICAgICB0b3VjaDogdG91Y2gsXG4gICAgICAgIHRvdWNoZXM6IGV2ZW50LnRvdWNoZXMsXG4gICAgICAgIGNoYW5nZWRUb3VjaGVzOiBldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgdG91Y2hFdmVudDogZXZlbnQsXG4gICAgICAgIGlzVmVydGljYWw6IGdlc3R1cmUuaXNWZXJ0aWNhbCxcbiAgICAgICAgZGlyZWN0aW9uOiBnZXN0dXJlLmRpcmVjdGlvblxuICAgICAgfVxuXG4gICAgICBmaXJlRXZlbnQoZ2VzdHVyZS5lbGVtZW50LCAncGFuZW5kJywgZXh0cmEpXG4gICAgICBpZiAoaXNTd2lwZSkge1xuICAgICAgICBmaXJlRXZlbnQoZ2VzdHVyZS5lbGVtZW50LCAnc3dpcGUnLCBleHRyYSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZ2VzdHVyZS5zdGF0dXMgPT09ICdwcmVzc2luZycpIHtcbiAgICAgIGZpcmVFdmVudChnZXN0dXJlLmVsZW1lbnQsICdwcmVzc2VuZCcsIHtcbiAgICAgICAgdG91Y2g6IHRvdWNoLFxuICAgICAgICB0b3VjaEV2ZW50OiBldmVudFxuICAgICAgfSlcbiAgICB9XG5cbiAgICBkZWxldGUgZ2VzdHVyZXNbaWRdXG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXMoZ2VzdHVyZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgIGRvY0VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRvdWNobW92ZUhhbmRsZXIsIGZhbHNlKVxuICAgIGRvY0VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdG91Y2hlbmRIYW5kbGVyLCBmYWxzZSlcbiAgICBkb2NFbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRvdWNoY2FuY2VsSGFuZGxlciwgZmFsc2UpXG4gIH1cbn1cblxuLyoqXG4gKiBoYW5kbGUgdG91Y2hjYW5jZWxcbiAqXG4gKiAxLiBpZiB0aGVyZSBhcmUgdHdvIHRvdWNoIHBvaW50cywgdGhlbiB0cmlnZ2VyICdkdWFsdG91Y2hlbmQnXG4gKlxuICogMi4gdHJhdmVyc2UgZXZlcnR5IHRvdWNoIHBvaW50OlxuICogPiBpZiBwYW5ubmlnLCB0aGVuIHRyaWdnZXIgJ3BhbmVuZCdcbiAqID4gaWYgcHJlc3NpbmcsIHRoZW4gdHJpZ2dlciAncHJlc3NlbmQnXG4gKlxuICogMy4gcmVtb3ZlIGxpc3RlbmVyc1xuICpcbiAqIEBldmVudFxuICogQHBhcmFtICB7ZXZlbnR9IGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHRvdWNoY2FuY2VsSGFuZGxlcihldmVudCkge1xuXG4gIGlmIChPYmplY3Qua2V5cyhnZXN0dXJlcykubGVuZ3RoID09IDIpIHtcbiAgICB2YXIgZWxlbWVudHMgPSBbXVxuICAgIGZvciAodmFyIHAgaW4gZ2VzdHVyZXMpIHtcbiAgICAgIGVsZW1lbnRzLnB1c2goZ2VzdHVyZXNbcF0uZWxlbWVudClcbiAgICB9XG4gICAgZmlyZUV2ZW50KGdldENvbW1vbkFuY2VzdG9yKGVsZW1lbnRzWzBdLCBlbGVtZW50c1sxXSksICdkdWFsdG91Y2hlbmQnLCB7XG4gICAgICB0b3VjaGVzOiBzbGljZS5jYWxsKGV2ZW50LnRvdWNoZXMpLFxuICAgICAgdG91Y2hFdmVudDogZXZlbnRcbiAgICB9KVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzW2ldXG4gICAgdmFyIGlkID0gdG91Y2guaWRlbnRpZmllclxuICAgIHZhciBnZXN0dXJlID0gZ2VzdHVyZXNbaWRdXG5cbiAgICBpZiAoIWdlc3R1cmUpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKGdlc3R1cmUucHJlc3NpbmdIYW5kbGVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQoZ2VzdHVyZS5wcmVzc2luZ0hhbmRsZXIpXG4gICAgICBnZXN0dXJlLnByZXNzaW5nSGFuZGxlciA9IG51bGxcbiAgICB9XG5cbiAgICBpZiAoZ2VzdHVyZS5zdGF0dXMgPT09ICdwYW5uaW5nJykge1xuICAgICAgZmlyZUV2ZW50KGdlc3R1cmUuZWxlbWVudCwgJ3BhbmVuZCcsIHtcbiAgICAgICAgdG91Y2g6IHRvdWNoLFxuICAgICAgICB0b3VjaGVzOiBldmVudC50b3VjaGVzLFxuICAgICAgICBjaGFuZ2VkVG91Y2hlczogZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgIHRvdWNoRXZlbnQ6IGV2ZW50XG4gICAgICB9KVxuICAgIH1cbiAgICBpZiAoZ2VzdHVyZS5zdGF0dXMgPT09ICdwcmVzc2luZycpIHtcbiAgICAgIGZpcmVFdmVudChnZXN0dXJlLmVsZW1lbnQsICdwcmVzc2VuZCcsIHtcbiAgICAgICAgdG91Y2g6IHRvdWNoLFxuICAgICAgICB0b3VjaEV2ZW50OiBldmVudFxuICAgICAgfSlcbiAgICB9XG4gICAgZGVsZXRlIGdlc3R1cmVzW2lkXVxuICB9XG5cbiAgaWYgKE9iamVjdC5rZXlzKGdlc3R1cmVzKS5sZW5ndGggPT09IDApIHtcbiAgICBkb2NFbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0b3VjaG1vdmVIYW5kbGVyLCB0cnVlKVxuICAgIGRvY0VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdG91Y2hlbmRIYW5kbGVyLCB0cnVlKVxuICAgIGRvY0VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdG91Y2hjYW5jZWxIYW5kbGVyLCB0cnVlKVxuICB9XG59XG5cbmlmICghaXNJbml0aWFsaXplZCkge1xuICBkb2NFbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdG91Y2hzdGFydEhhbmRsZXIsIHRydWUpXG4gIGlzSW5pdGlhbGl6ZWQgPSB0cnVlXG59XG4iLCJjb25zdCBsaWIgPSB3aW5kb3cubGliIHx8ICh3aW5kb3cubGliID0ge30pXG5cbi8qKlxuICogVmVyc2lvbiBjbGFzcy5cbiAqIEBjbGFzcyBsaWIuZW52flZlcnNpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSB2IC0gdmVyc2lvbiBudW1iZXIuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFZlcnNpb24gKHYpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd2YWwnLCB7XG4gICAgdmFsdWU6IHYudG9TdHJpbmcoKSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0pXG5cbiAgLyoqXG4gICAqIGxhcmdlciB0aGFuXG4gICAqIEBtZXRob2QgZ3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHYgLSB2ZXJzaW9uXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICAgKiBAaW5zdGFuY2VcbiAgICogQG1lbWJlcm9mIFZlcnNpb25cbiAgICovXG4gIHRoaXMuZ3QgPSBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiBWZXJzaW9uLmNvbXBhcmUodGhpcywgdikgPiAwXG4gIH1cblxuICAvKipcbiAgICogbGFyZ2VyIHRoYW4gb3IgZXF1YWwgdG8uXG4gICAqIEBtZXRob2QgZ3RlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2IC0gdmVyc2lvblxuICAgKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAgICogQGluc3RhbmNlXG4gICAqIEBtZW1iZXJvZiBWZXJzaW9uXG4gICAqL1xuICB0aGlzLmd0ZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIFZlcnNpb24uY29tcGFyZSh0aGlzLCB2KSA+PSAwXG4gIH1cblxuICAvKipcbiAgICogbGVzcyB0aGFuLlxuICAgKiBAbWV0aG9kIGx0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2IC0gdmVyc2lvblxuICAgKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAgICogQGluc3RhbmNlXG4gICAqIEBtZW1iZXJvZiBWZXJzaW9uXG4gICAqL1xuICB0aGlzLmx0ID0gZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gVmVyc2lvbi5jb21wYXJlKHRoaXMsIHYpIDwgMFxuICB9XG5cbiAgLyoqXG4gICAqIGxlc3MgdGhhbiBvciBlcXVhbCB0by5cbiAgICogQG1ldGhvZCBsdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHYgLSB2ZXJzaW9uXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICAgKiBAaW5zdGFuY2VcbiAgICogQG1lbWJlcm9mIFZlcnNpb25cbiAgICovXG4gIHRoaXMubHRlID0gZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gVmVyc2lvbi5jb21wYXJlKHRoaXMsIHYpIDw9IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBlcXVhbCB0by5cbiAgICogQG1ldGhvZCBlcVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdiAtIHZlcnNpb25cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gZXF1YWwgdG9cbiAgICogQGluc3RhbmNlXG4gICAqIEBtZW1iZXJvZiBWZXJzaW9uXG4gICAqL1xuICB0aGlzLmVxID0gZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gVmVyc2lvbi5jb21wYXJlKHRoaXMsIHYpID09PSAwXG4gIH1cbn1cblxuLyoqXG4gKiB2ZXJzaW9uIG51bWJlciBzdHJpbmcuXG4gKiBAbWV0aG9kIHRvU3RyaW5nXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGN1cnJlbnQgdmVyc2lvbiBudW1iZXIgc3RyaW5nLlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgVmVyc2lvblxuICovXG5WZXJzaW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudmFsXG59XG5cbi8qKlxuICogcmV0dXJuIGN1cnJlbnQgdmVyc2lvbiBudW1iZXIuXG4gKiBAbWV0aG9kIHZhbHVlT2ZcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHZlcnNpb24gbnVtYmVyXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBWZXJzaW9uXG4gKi9cblZlcnNpb24ucHJvdG90eXBlLnZhbHVlT2YgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IHYgPSB0aGlzLnZhbC5zcGxpdCgnLicpXG4gIGNvbnN0IHIgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHYubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgbiA9IHBhcnNlSW50KHZbaV0sIDEwKVxuICAgIGlmIChpc05hTihuKSkge1xuICAgICAgbiA9IDBcbiAgICB9XG4gICAgbGV0IHMgPSBuLnRvU3RyaW5nKClcbiAgICBpZiAocy5sZW5ndGggPCA1KSB7XG4gICAgICBzID0gQXJyYXkoNiAtIHMubGVuZ3RoKS5qb2luKCcwJykgKyBzXG4gICAgfVxuICAgIHIucHVzaChzKVxuICAgIGlmIChyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgci5wdXNoKCcuJylcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcnNlRmxvYXQoci5qb2luKCcnKSlcbn1cblxuLyoqXG4gKiBjb21wYXJlIHR3byB2ZXJzaW9ucy5cbiAqIEBtZXRob2QgY29tcGFyZVxuICogQHBhcmFtIHtTdHJpbmd9IHYxIC0gdmVyc2lvbjFcbiAqIEBwYXJhbSB7U3RyaW5nfSB2MiAtIHZlcnNpb24yXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IDAgZm9yIGVxdWFsaXR577yMLTEgZm9yIGxlc3MgdGhhbu+8jDEgZm9yIGxhcmdlciB0aGFuLlxuICogQG1lbWJlcm9mIFZlcnNpb25cbiAqL1xuVmVyc2lvbi5jb21wYXJlID0gZnVuY3Rpb24gKHYxLCB2Mikge1xuICB2MSA9IHYxLnRvU3RyaW5nKCkuc3BsaXQoJy4nKVxuICB2MiA9IHYyLnRvU3RyaW5nKCkuc3BsaXQoJy4nKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHYxLmxlbmd0aCB8fCBpIDwgdjIubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgbjEgPSBwYXJzZUludCh2MVtpXSwgMTApXG4gICAgbGV0IG4yID0gcGFyc2VJbnQodjJbaV0sIDEwKVxuICAgIGlmICh3aW5kb3cuaXNOYU4objEpKSB7XG4gICAgICBuMSA9IDBcbiAgICB9XG4gICAgaWYgKHdpbmRvdy5pc05hTihuMikpIHtcbiAgICAgIG4yID0gMFxuICAgIH1cbiAgICBpZiAobjEgPCBuMikge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIGVsc2UgaWYgKG4xID4gbjIpIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuICB9XG4gIHJldHVybiAwXG59XG5cbi8qKlxuICog6Kej5p6Q5ZKM5pON5L2c54mI5pys5Y+3XG4gKiBAbWV0aG9kIHZlcnNpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSB2IC0g6ZyA6KaB6Kej5p6Q55qE54mI5pys5Y+3XG4gKiBAcmV0dXJuIHtsaWIuZW52flZlcnNpb259IFZlcnNvbuWunuS+i1xuICogQG1lbWJlcm9mIGxpYlxuICovXG5saWIudmVyc2lvbiA9IGZ1bmN0aW9uICh2KSB7XG4gIHJldHVybiBuZXcgVmVyc2lvbih2KVxufVxuIiwiY29uc3QgbGliID0gd2luZG93LmxpYiB8fCAod2luZG93LmxpYiA9IHt9KVxuY29uc3QgZW52ID0gbGliLmVudiB8fCAobGliLmVudiA9IHt9KVxuXG5jb25zdCBzZWFyY2ggPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnJlcGxhY2UoL15cXD8vLCAnJylcbmVudi5wYXJhbXMgPSB7fVxuaWYgKHNlYXJjaCkge1xuICBjb25zdCBwYXJhbXMgPSBzZWFyY2guc3BsaXQoJyYnKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgIHBhcmFtc1tpXSA9IHBhcmFtc1tpXS5zcGxpdCgnPScpXG4gICAgdHJ5IHtcbiAgICAgIGVudi5wYXJhbXNbcGFyYW1zW2ldWzBdXSA9IGRlY29kZVVSSUNvbXBvbmVudChwYXJhbXNbaV1bMV0pXG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICBlbnYucGFyYW1zW3BhcmFtc1tpXVswXV0gPSBwYXJhbXNbaV1bMV1cbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCAnLi92ZXJzaW9uJ1xuaW1wb3J0ICcuL3BhcmFtcydcblxuY29uc3QgbGliID0gd2luZG93LmxpYiB8fCAod2luZG93LmxpYiA9IHt9KVxuY29uc3QgZW52ID0gbGliLmVudiB8fCAobGliLmVudiA9IHt9KVxuXG5jb25zdCB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50XG5sZXQgbWF0Y2hcblxuLyoqXG4gKiBvc1xuICovXG5cbm1hdGNoID0gdWEubWF0Y2goL1dpbmRvd3NcXHNQaG9uZVxccyg/Ok9TXFxzKT8oW1xcZC5dKykvKVxuaWYgKG1hdGNoKSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAbWVtYmVyb2YgbGliLmVudlxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gbmFtZSAtIG9zIG5hbWUsIGUuZy4gQW5kcm9pZC9BbmRyb2lkUGFkL2lQaG9uZS9pUG9kL2lQYWQvV2luZG93cyBQaG9uZS91bmtub3duLCBldGMuXG4gICAqIEBwcm9wZXJ0eSB7bGliLmVudn5WZXJzaW9ufSB2ZXJzaW9uIC0gb3MgdmVyc2lvbi5cbiAgICogQHByb3BlcnR5IHtCb29sZWFufSBpc1dpbmRvd3NQaG9uZVxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGlzSVBob25lIC0gaXMgaVBob25lL2lUb3VjaFxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGlzSVBhZFxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGlzSU9TXG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaXNBbmRyb2lkXG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaXNBbmRyb2lkUGFkXG4gICAqL1xuICBlbnYub3MgPSB7XG4gICAgbmFtZTogJ1dpbmRvd3MgUGhvbmUnLFxuICAgIGlzV2luZG93c1Bob25lOiB0cnVlLFxuICAgIHZlcnNpb246IG1hdGNoWzFdXG4gIH1cbn1cbmVsc2UgaWYgKCEhdWEubWF0Y2goL1NhZmFyaS8pICYmIChtYXRjaCA9IHVhLm1hdGNoKC9BbmRyb2lkW1xccy9dKFtcXGQuXSspLykpKSB7XG4gIGVudi5vcyA9IHtcbiAgICB2ZXJzaW9uOiBtYXRjaFsxXVxuICB9XG5cbiAgaWYgKCh1YS5tYXRjaCgvTW9iaWxlXFxzK1NhZmFyaS8pKSkge1xuICAgIGVudi5vcy5uYW1lID0gJ0FuZHJvaWQnXG4gICAgZW52Lm9zLmlzQW5kcm9pZCA9IHRydWVcbiAgfVxuICBlbHNlIHtcbiAgICBlbnYub3MubmFtZSA9ICdBbmRyb2lkUGFkJ1xuICAgIGVudi5vcy5pc0FuZHJvaWRQYWQgPSB0cnVlXG4gIH1cbn1cbmVsc2UgaWYgKChtYXRjaCA9IHVhLm1hdGNoKC8oaVBob25lfGlQYWR8aVBvZCkvKSkpIHtcbiAgY29uc3QgbmFtZSA9IG1hdGNoWzFdXG5cbiAgbWF0Y2ggPSB1YS5tYXRjaCgvT1MgKFtcXGRfLl0rKSBsaWtlIE1hYyBPUyBYLylcblxuICBlbnYub3MgPSB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBpc0lQaG9uZTogKG5hbWUgPT09ICdpUGhvbmUnIHx8IG5hbWUgPT09ICdpUG9kJyksXG4gICAgaXNJUGFkOiBuYW1lID09PSAnaVBhZCcsXG4gICAgaXNJT1M6IHRydWUsXG4gICAgdmVyc2lvbjogbWF0Y2ggJiYgbWF0Y2hbMV0uc3BsaXQoJ18nKS5qb2luKCcuJykgfHwgJydcbiAgfVxufVxuZWxzZSB7XG4gIGVudi5vcyA9IHtcbiAgICBuYW1lOiAndW5rbm93bicsXG4gICAgdmVyc2lvbjogJzAuMC4wJ1xuICB9XG59XG5cbmlmIChsaWIudmVyc2lvbikge1xuICBlbnYub3MudmVyc2lvbiA9IGxpYi52ZXJzaW9uKGVudi5vcy52ZXJzaW9uKVxufVxuXG4vKipcbiAqIGJyb3dzZXJcbiAqL1xuXG5tYXRjaCA9IHVhLm1hdGNoKC8oPzpVQ1dFQnxVQ0Jyb3dzZXJcXC8pKFtcXGQuXSspLylcblxuaWYgKG1hdGNoKSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAbWVtYmVyb2YgZW52XG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBuYW1lIC0gYnJvd3NlciBuYW1l77yMZS5nLiBVQy9RUS9GaXJlZm94L0Nocm9tZS9BbmRyb2lkL1NhZmFyaS9pT1MgV2Vidmlldy9DaHJvbWUgV2Vidmlldy9JRS9JRU1vYmlsZS91bmtub3duLCBldGMuXG4gICAqIEBwcm9wZXJ0eSB7ZW52flZlcnNpb259IHZlcnNpb24gLSBicm93c2VyIHZlcnNpb24uXG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaXNVQ1xuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGlzUVFcbiAgICogQHByb3BlcnR5IHtCb29sZWFufSBpc0lFXG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaXNJRU1vYmlsZVxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGlzSUVMaWtlV2Via2l0XG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaXNDaHJvbWVcbiAgICogQHByb3BlcnR5IHtCb29sZWFufSBpc0FuZHJvaWRcbiAgICogQHByb3BlcnR5IHtCb29sZWFufSBpc1NhZmFyaVxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGlzV2Vidmlld1xuICAgKi9cbiAgZW52LmJyb3dzZXIgPSB7XG4gICAgbmFtZTogJ1VDJyxcbiAgICBpc1VDOiB0cnVlLFxuICAgIHZlcnNpb246IG1hdGNoWzFdXG4gIH1cbn1cbmVsc2UgaWYgKChtYXRjaCA9IHVhLm1hdGNoKC9NUVFCcm93c2VyXFwvKFtcXGQuXSspLykpKSB7XG4gIGVudi5icm93c2VyID0ge1xuICAgIG5hbWU6ICdRUScsXG4gICAgaXNRUTogdHJ1ZSxcbiAgICB2ZXJzaW9uOiBtYXRjaFsxXVxuICB9XG59XG5lbHNlIGlmICgobWF0Y2ggPSB1YS5tYXRjaCgvRmlyZWZveFxcLyhbXFxkLl0rKS8pKSkge1xuICBlbnYuYnJvd3NlciA9IHtcbiAgICBuYW1lOiAnRmlyZWZveCcsXG4gICAgaXNGaXJlZm94OiB0cnVlLFxuICAgIHZlcnNpb246IG1hdGNoWzFdXG4gIH1cbn1cbmVsc2UgaWYgKChtYXRjaCA9IHVhLm1hdGNoKC9NU0lFXFxzKFtcXGQuXSspLykpXG4gIHx8IChtYXRjaCA9IHVhLm1hdGNoKC9JRU1vYmlsZVxcLyhbXFxkLl0rKS8pKSkge1xuICBlbnYuYnJvd3NlciA9IHtcbiAgICB2ZXJzaW9uOiBtYXRjaFsxXVxuICB9XG5cbiAgaWYgKHVhLm1hdGNoKC9JRU1vYmlsZS8pKSB7XG4gICAgZW52LmJyb3dzZXIubmFtZSA9ICdJRU1vYmlsZSdcbiAgICBlbnYuYnJvd3Nlci5pc0lFTW9iaWxlID0gdHJ1ZVxuICB9XG4gIGVsc2Uge1xuICAgIGVudi5icm93c2VyLm5hbWUgPSAnSUUnXG4gICAgZW52LmJyb3dzZXIuaXNJRSA9IHRydWVcbiAgfVxuXG4gIGlmICh1YS5tYXRjaCgvQW5kcm9pZHxpUGhvbmUvKSkge1xuICAgIGVudi5icm93c2VyLmlzSUVMaWtlV2Via2l0ID0gdHJ1ZVxuICB9XG59XG5lbHNlIGlmICgobWF0Y2ggPSB1YS5tYXRjaCgvKD86Q2hyb21lfENyaU9TKVxcLyhbXFxkLl0rKS8pKSkge1xuICBlbnYuYnJvd3NlciA9IHtcbiAgICBuYW1lOiAnQ2hyb21lJyxcbiAgICBpc0Nocm9tZTogdHJ1ZSxcbiAgICB2ZXJzaW9uOiBtYXRjaFsxXVxuICB9XG5cbiAgaWYgKHVhLm1hdGNoKC9WZXJzaW9uXFwvW1xcZCsuXStcXHMqQ2hyb21lLykpIHtcbiAgICBlbnYuYnJvd3Nlci5uYW1lID0gJ0Nocm9tZSBXZWJ2aWV3J1xuICAgIGVudi5icm93c2VyLmlzV2VidmlldyA9IHRydWVcbiAgfVxufVxuZWxzZSBpZiAoISF1YS5tYXRjaCgvU2FmYXJpLykgJiYgKG1hdGNoID0gdWEubWF0Y2goL0FuZHJvaWRbXFxzL10oW1xcZC5dKykvKSkpIHtcbiAgZW52LmJyb3dzZXIgPSB7XG4gICAgbmFtZTogJ0FuZHJvaWQnLFxuICAgIGlzQW5kcm9pZDogdHJ1ZSxcbiAgICB2ZXJzaW9uOiBtYXRjaFsxXVxuICB9XG59XG5lbHNlIGlmICh1YS5tYXRjaCgvaVBob25lfGlQYWR8aVBvZC8pKSB7XG4gIGlmICh1YS5tYXRjaCgvU2FmYXJpLykpIHtcbiAgICBtYXRjaCA9IHVhLm1hdGNoKC9WZXJzaW9uXFwvKFtcXGQuXSspLylcbiAgICBlbnYuYnJvd3NlciA9IHtcbiAgICAgIG5hbWU6ICdTYWZhcmknLFxuICAgICAgaXNTYWZhcmk6IHRydWUsXG4gICAgICB2ZXJzaW9uOiBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJ1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBtYXRjaCA9IHVhLm1hdGNoKC9PUyAoW1xcZF8uXSspIGxpa2UgTWFjIE9TIFgvKVxuICAgIGVudi5icm93c2VyID0ge1xuICAgICAgbmFtZTogJ2lPUyBXZWJ2aWV3JyxcbiAgICAgIGlzV2VidmlldzogdHJ1ZSxcbiAgICAgIHZlcnNpb246IG1hdGNoICYmIG1hdGNoWzFdLnJlcGxhY2UoL18vZywgJy4nKSB8fCAnJ1xuICAgIH1cbiAgfVxufVxuZWxzZSB7XG4gIGVudi5icm93c2VyID0ge1xuICAgIG5hbWU6ICd1bmtub3duJyxcbiAgICB2ZXJzaW9uOiAnMC4wLjAnXG4gIH1cbn1cblxuaWYgKGxpYi52ZXJzaW9uKSB7XG4gIGVudi5icm93c2VyLnZlcnNpb24gPSBsaWIudmVyc2lvbihlbnYuYnJvd3Nlci52ZXJzaW9uKVxufVxuIiwiLypcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmNvbnN0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuXG4vKipcbiAqIFN0cmljdCBvYmplY3QgdHlwZSBjaGVjay4gT25seSByZXR1cm5zIHRydWVcbiAqIGZvciBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmNvbnN0IE9CSkVDVF9TVFJJTkcgPSAnW29iamVjdCBPYmplY3RdJ1xuZXhwb3J0IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QgKG9iaikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSBPQkpFQ1RfU1RSSU5HXG59XG5cbmNvbnN0IEFSUkFZX1NUUklORyA9ICdbb2JqZWN0IEFycmF5XSdcbmV4cG9ydCBmdW5jdGlvbiBpc0FycmF5IChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PT0gQVJSQVlfU1RSSU5HXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1ByaW1pdGl2ZSAodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnXG4gICAgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJ1xuICAgIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCdcbiAgICB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNEZWYgKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgJiYgdmFsICE9PSBudWxsXG59XG4iLCIvKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7XG4gIGlzQXJyYXlcbn0gZnJvbSAnLi90eXBlJ1xuLyoqXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gKiB0aGUgcmlnaHRlc3Qgb2JqZWN0J3MgdmFsdWUgaGFzIHRoZSBoaWdoZXN0IHByaW9yaXR5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kICh0bywgLi4uYXJncykge1xuICBpZiAoIWFyZ3MgfHwgYXJncy5sZW5ndGggPD0gMCkge1xuICAgIHJldHVybiB0b1xuICB9XG4gIGFyZ3MuZm9yRWFjaChmcm9tID0+IHtcbiAgICBpZiAodHlwZW9mIGZyb20gIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZnJvbSkge1xuICAgICAgdG9ba2V5XSA9IGZyb21ba2V5XVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIHRvXG59XG4vKipcbiAqIE1peCB0cnV0aHkgb3IgJycgcHJvcGVydHkgdmFsdWVzIGludG8gdGFyZ2V0IG9iamVjdC5cbiAqIG1vc3RseSBmb3IgbWVyZ2luZyBzdHlsZXMuICh0aGF0J3Mgd2h5ICcnIGlzIGZhbHN5IGJ1dCBzdGlsbCBzaG91bGQgYmUgY291bnRlZCBpbi4pXG4gKiB0aGUgcmlnaHRlc3Qgb2JqZWN0J3MgdmFsdWUgaGFzIHRoZSBoaWdoZXN0IHByaW9yaXR5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kVHJ1dGh5ICh0bywgLi4uYXJncykge1xuICBpZiAoIWFyZ3MgfHwgYXJncy5sZW5ndGggPD0gMCkge1xuICAgIHJldHVybiB0b1xuICB9XG4gIGFyZ3MuZm9yRWFjaChmcm9tID0+IHtcbiAgICBpZiAodHlwZW9mIGZyb20gIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgbGV0IGlcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmcm9tKSB7XG4gICAgICBpZiAoKChpID0gZnJvbVtrZXldKSB8fCBpID09PSAnJyB8fCBpID09PSAwKSAmJiBpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0b1trZXldID0gaVxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIHRvXG59XG4vKipcbiAqIE1peCBzcGVjaWZpZWQgcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmRLZXlzICh0bywgZnJvbSA9IHt9LCBrZXlzKSB7XG4gIChrZXlzIHx8IFtdKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgZnJvbSAmJiAodG9ba2V5XSA9IGZyb21ba2V5XSlcbiAgfSlcbiAgcmV0dXJuIHRvXG59XG4vKipcbiAqIEV4dHJhY3Qgc3BlY2lmaWVkIHByb3BlcnRpZXMgZnJvbSBzcmMgdG8gdGFyZ2V0IG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RLZXlzICh0bywgZnJvbSA9IHt9LCBrZXlzKSB7XG4gIGlmICghZnJvbSkge1xuICAgIHJldHVybiB0b1xuICB9XG4gIChrZXlzIHx8IFtdKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgZnJvbSAmJiAodG9ba2V5XSA9IGZyb21ba2V5XSlcbiAgICBmcm9tICYmIChkZWxldGUgZnJvbVtrZXldKVxuICB9KVxuICByZXR1cm4gdG9cbn1cbi8qKlxuICogU2ltcGxlIGJpbmQsIGZhc3RlciB0aGFuIG5hdGl2ZVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmQgKGZuLCBjdHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgY29uc3QgbCA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICByZXR1cm4gbCA/IGwgPiAxID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpIDogZm4uY2FsbChjdHgsIGEpIDogZm4uY2FsbChjdHgpXG4gIH1cbn1cbi8qKlxuICogT25seSBjYWxsIHRoZSBmdW5jIHRoZSBsYXN0IHRpbWUgYmVmb3JlIGl0J3Mgbm90IHRoYXQgZnJlcXVlbnRseSBjYWxsZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWJvdW5jZSAoZnVuYywgd2FpdCkge1xuICBsZXQgdGltZXJJZFxuICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZXJJZClcbiAgICB0aW1lcklkID0gc2V0VGltZW91dChmdW5jdGlvbiBsYXRlciAoKSB7XG4gICAgICB0aW1lcklkID0gbnVsbFxuICAgICAgZnVuYy5hcHBseShudWxsLCBhcmdzKVxuICAgIH0sIHdhaXQpXG4gIH1cbn1cbi8qKlxuICogT25seSBjYWxsIHRoZSBmdW5jIHRoZSBmaXJzdCB0aW1lIGJlZm9yZSBhIHNlcmllcyBmcmVxdWVudGx5IGZ1bmN0aW9uIGNhbGxzIGhhcHBlbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlcHJlc3MgKGZ1bmMsIHdhaXQpIHtcbiAgbGV0IHRpbWVySWRcblxuICBmdW5jdGlvbiBsYXRlciAoKSB7XG4gICAgdGltZXJJZCA9IG51bGxcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGltZXJJZCkge1xuICAgICAgZnVuYy5hcHBseSgpXG4gICAgfVxuICAgIGNsZWFyVGltZW91dCh0aW1lcklkKVxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KVxuICB9XG59XG4vKipcbiAqIE9ubHkgY2FsbCB0aGUgZnVuYyBldmVyeSB0aW1lIGFmdGVyIGEgd2FpdCBtaWxsaXNlY29uZHMgaWYgaXQncyB0b28gZnJlcXVlbnRseSBjYWxsZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aHJvdHRsZSAoZnVuYywgd2FpdCwgY2FsbExhc3RUaW1lKSB7XG4gIGxldCBsYXN0ID0gMFxuICBsZXQgbGFzdFRpbWVyID0gbnVsbFxuICBjb25zdCBsYXN0VGltZUR1cmF0aW9uID0gd2FpdCArICh3YWl0ID4gMjUgPyB3YWl0IDogMjUpIC8vIHBsdXMgaGFsZiB3YWl0IHRpbWUuXG4gIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzXG4gICAgY29uc3QgdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpXG4gICAgaWYgKHRpbWUgLSBsYXN0ID4gd2FpdCkge1xuICAgICAgaWYgKGNhbGxMYXN0VGltZSkge1xuICAgICAgICBsYXN0VGltZXIgJiYgY2xlYXJUaW1lb3V0KGxhc3RUaW1lcilcbiAgICAgICAgbGFzdFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbGFzdFRpbWVyID0gbnVsbFxuICAgICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncylcbiAgICAgICAgfSwgbGFzdFRpbWVEdXJhdGlvbilcbiAgICAgIH1cbiAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncylcbiAgICAgIGxhc3QgPSB0aW1lXG4gICAgfVxuICB9XG59XG4vLyBkaXJlY3Rpb246ICdsJyB8ICdyJywgZGVmYXVsdCBpcyAncidcbi8vIG51bTogaG93IG1hbnkgdGltZXMgdG8gbG9vcCwgc2hvdWxkIGJlIGEgcG9zaXRpdmUgaW50ZWdlclxuZXhwb3J0IGZ1bmN0aW9uIGxvb3BBcnJheSAoYXJyLCBudW0sIGRpcmVjdGlvbikge1xuICBpZiAoIWlzQXJyYXkoYXJyKSkge1xuICAgIHJldHVyblxuICB9XG4gIGxldCBpc0xlZnQgPSAoZGlyZWN0aW9uICsgJycpLnRvTG93ZXJDYXNlKCkgPT09ICdsJ1xuICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoXG4gIG51bSA9IG51bSAlIGxlblxuICBpZiAobnVtIDwgMCkge1xuICAgIG51bSA9IC1udW1cbiAgICBpc0xlZnQgPSAhaXNMZWZ0XG4gIH1cbiAgaWYgKG51bSA9PT0gMCkge1xuICAgIHJldHVybiBhcnJcbiAgfVxuICBsZXQgbHAsIHJwXG4gIGlmIChpc0xlZnQpIHtcbiAgICBscCA9IGFyci5zbGljZSgwLCBudW0pXG4gICAgcnAgPSBhcnIuc2xpY2UobnVtKVxuICB9XG4gIGVsc2Uge1xuICAgIGxwID0gYXJyLnNsaWNlKDAsIGxlbiAtIG51bSlcbiAgICBycCA9IGFyci5zbGljZShsZW4gLSBudW0pXG4gIH1cbiAgcmV0dXJuIHJwLmNvbmNhdChscClcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjYWNoZWQgdmVyc2lvbiBvZiBhIHB1cmUgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWNoZWQgKGZuKSB7XG4gIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICByZXR1cm4gZnVuY3Rpb24gY2FjaGVkRm4gKHN0cikge1xuICAgIGNvbnN0IGhpdCA9IGNhY2hlW3N0cl1cbiAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSlcbiAgfVxufVxuLyoqXG4gKiBDYW1lbGl6ZSBhIGh5cGhlbi1kZWxtaXRlZCBzdHJpbmcuXG4gKi9cbmNvbnN0IGNhbWVsaXplUkUgPSAvLShcXHcpL2dcbmV4cG9ydCBjb25zdCBjYW1lbGl6ZSA9IGNhY2hlZChzdHIgPT4ge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgKF8sIGMpID0+IGMudG9VcHBlckNhc2UoKSlcbn0pXG5leHBvcnQgZnVuY3Rpb24gY2FtZWxpemVLZXlzIChvYmopIHtcbiAgY29uc3QgcmVzID0ge31cbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgcmVzW2NhbWVsaXplKGtleSldID0gb2JqW2tleV1cbiAgfVxuICByZXR1cm4gcmVzXG59XG4vKipcbiAqIENhcGl0YWxpemUgYSBzdHJpbmcuXG4gKi9cbmV4cG9ydCBjb25zdCBjYXBpdGFsaXplID0gY2FjaGVkKHN0ciA9PiB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcbn0pXG4vKipcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gKi9cbmNvbnN0IGh5cGhlbmF0ZVJFID0gLyhbXi1dKShbQS1aXSkvZ1xuZXhwb3J0IGNvbnN0IGh5cGhlbmF0ZSA9IGNhY2hlZChzdHIgPT4ge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsICckMS0kMicpLnJlcGxhY2UoaHlwaGVuYXRlUkUsICckMS0kMicpLnRvTG93ZXJDYXNlKClcbn0pXG5leHBvcnQgZnVuY3Rpb24gaHlwaGVuYXRlS2V5cyAob2JqKSB7XG4gIGNvbnN0IHJlcyA9IHt9XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIHJlc1toeXBoZW5hdGUoa2V5KV0gPSBvYmpba2V5XVxuICB9XG4gIHJldHVybiByZXNcbn1cbmNvbnN0IHZlbmRvcnNSZWcgPSAvd2Via2l0LXxtb3otfG8tfG1zLS9cbmV4cG9ydCBmdW5jdGlvbiBoeXBoZW5hdGVTdHlsZUtleXMgKG9iaikge1xuICBjb25zdCByZXMgPSB7fVxuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICBjb25zdCBoayA9IGh5cGhlbmF0ZShrZXkpLnJlcGxhY2UodmVuZG9yc1JlZywgZnVuY3Rpb24gKCQwKSB7XG4gICAgICByZXR1cm4gJy0nICsgJDBcbiAgICB9KVxuICAgIHJlc1toa10gPSBvYmpba2V5XVxuICB9XG4gIHJldHVybiByZXNcbn1cbmV4cG9ydCBmdW5jdGlvbiBjYW1lbFRvS2ViYWIgKG5hbWUpIHtcbiAgaWYgKCFuYW1lKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cbiAgcmV0dXJuIG5hbWUucmVwbGFjZSgvKFtBLVpdKS9nLCBmdW5jdGlvbiAoZywgZzEpIHtcbiAgICByZXR1cm4gYC0ke2cxLnRvTG93ZXJDYXNlKCl9YFxuICB9KVxufVxuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZENzcyAoY3NzLCBjc3NJZCwgcmVwbGFjZSkge1xuICBsZXQgc3R5bGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjc3NJZClcbiAgaWYgKHN0eWxlICYmIHJlcGxhY2UpIHtcbiAgICBzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKVxuICAgIHN0eWxlID0gbnVsbFxuICB9XG4gIGlmICghc3R5bGUpIHtcbiAgICBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJylcbiAgICBzdHlsZS50eXBlID0gJ3RleHQvY3NzJ1xuICAgIGNzc0lkICYmIChzdHlsZS5pZCA9IGNzc0lkKVxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoc3R5bGUpXG4gIH1cbiAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSlcbn1cbmV4cG9ydCBmdW5jdGlvbiBuZXh0RnJhbWUgKGNhbGxiYWNrKSB7XG4gIGNvbnN0IHJ1bm5lciA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgIHx8IChjYiA9PiBzZXRUaW1lb3V0KGNiLCAxNikpXG4gIHJ1bm5lcihjYWxsYmFjaylcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b0NTU1RleHQgKG9iamVjdCkge1xuICBpZiAoIW9iamVjdCkge1xuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IG9iaiA9IGh5cGhlbmF0ZVN0eWxlS2V5cyhvYmplY3QpXG4gIGxldCBjc3NUZXh0ID0gJydcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgY3NzVGV4dCArPSBgJHtrZXl9OiR7b2JqW2tleV19O2BcbiAgfVxuICByZXR1cm4gY3NzVGV4dFxufVxuIiwiLypcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJy4uL3V0aWxzL2Z1bmMnXG5cbi8qKlxuICogdmlld3BvcnQgcHJpb3JpdHk6XG4gKlxuICogMS4gbWV0YSB3ZWV4LXZpZXdwb3J0IChkZXZlbG9wZXIgY3VzdG9tKVxuICogMi4gc2V0Vmlld3BvcnQoY29uZmlnKSA6PSBjb25maWcud2lkdGggKHByaXZhdGUgY29kZSkgQGRlcHJlY2F0ZWRcbiAqIDMuIHByb2Nlc3MuZW52LlZJRVdQT1JUX1dJRFRIIChidWlkIHRpbWUpXG4gKlxuICovXG5sZXQgaXNJbml0ZWQgPSBmYWxzZVxuY29uc3QgREVGQVVMVF9WSUVXUE9SVF9XSURUSCA9IDc1MFxuXG4vKipcbiAqIGdldCB2aWV3cG9ydCB3aWR0aCBmcm9tIHdlZXgtdmlld3BvcnQgbWV0YS5cbiAqL1xuY29uc3QgZW52Vmlld3BvcnRXaWR0aCA9IHBhcnNlSW50KHByb2Nlc3MuZW52LlZJRVdQT1JUX1dJRFRIKVxubGV0IHdpZHRoID0gIWlzTmFOKGVudlZpZXdwb3J0V2lkdGgpICYmIGVudlZpZXdwb3J0V2lkdGggPiAwXG4gID8gZW52Vmlld3BvcnRXaWR0aFxuICA6IERFRkFVTFRfVklFV1BPUlRfV0lEVEhcblxubGV0IHd4Vmlld3BvcnRNZXRhID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPVwid2VleC12aWV3cG9ydFwiXScpXG5jb25zdCBtZXRhV2lkdGggPSB3eFZpZXdwb3J0TWV0YSAmJiBwYXJzZUludCh3eFZpZXdwb3J0TWV0YS5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnKSlcbmlmIChtZXRhV2lkdGggJiYgIWlzTmFOKG1ldGFXaWR0aCkgJiYgbWV0YVdpZHRoID4gMCkge1xuICB3aWR0aCA9IG1ldGFXaWR0aFxufVxuXG5sZXQgZHByID0gMFxubGV0IHNjcmVlbldpZHRoID0gMFxubGV0IHNjcmVlbkhlaWdodCA9IDBcblxuY29uc3QgaW5mbyA9IHtcbiAgZHByLFxuICBzY2FsZTogMCxcbiAgcm9vdFZhbHVlOiAwLFxuICByZW06IDAsXG4gIGRldmljZVdpZHRoOiAwLFxuICBkZXZpY2VIZWlnaHQ6IDBcbn1cblxuLyoqXG4gKiBzZXQgcm9vdCBmb250LXNpemUgZm9yIHJlbSB1bml0cy4gSWYgYWxyZWFkeSBiZWVuIHNldCwganVzdCBza2lwIHRoaXMuXG4gKi9cbmZ1bmN0aW9uIHNldFJvb3RGb250ICh3aWR0aCwgdmlld3BvcnRXaWR0aCwgZm9yY2UpIHtcbiAgY29uc3QgZG9jID0gd2luZG93LmRvY3VtZW50XG4gIGNvbnN0IHJlbSA9IHdpZHRoICogNzUwIC8gdmlld3BvcnRXaWR0aCAvIDEwXG4gIGlmICghZG9jLmRvY3VtZW50RWxlbWVudCkgeyByZXR1cm4gfVxuICBjb25zdCByb290Rm9udFNpemUgPSBkb2MuZG9jdW1lbnRFbGVtZW50LnN0eWxlLmZvbnRTaXplXG4gIGlmICghcm9vdEZvbnRTaXplIHx8IGZvcmNlKSB7XG4gICAgZG9jLmRvY3VtZW50RWxlbWVudC5zdHlsZS5mb250U2l6ZSA9IHJlbSArICdweCdcbiAgfVxuICBpbmZvLnJlbSA9IHJlbVxuICBpbmZvLnJvb3RWYWx1ZSA9IHZpZXdwb3J0V2lkdGggLyAxMFxufVxuXG5mdW5jdGlvbiBzZXRNZXRhVmlld3BvcnQgKHdpZHRoKSB7XG4gIGlmICghd3hWaWV3cG9ydE1ldGEpIHtcbiAgICB3eFZpZXdwb3J0TWV0YSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ21ldGEnKVxuICAgIHd4Vmlld3BvcnRNZXRhLnNldEF0dHJpYnV0ZSgnbmFtZScsICd3ZWV4LXZpZXdwb3J0JylcbiAgICBjb25zdCBmaXJzdE1ldGEgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhJylcbiAgICBjb25zdCBoZWFkID0gZmlyc3RNZXRhICYmIGZpcnN0TWV0YS5wYXJlbnRFbGVtZW50XG4gICAgICB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2hpbGRyZW5bMF1cbiAgICBmaXJzdE1ldGFcbiAgICAgID8gaGVhZC5pbnNlcnRCZWZvcmUod3hWaWV3cG9ydE1ldGEsIGZpcnN0TWV0YSlcbiAgICAgIDogaGVhZC5hcHBlbmRDaGlsZCh3eFZpZXdwb3J0TWV0YSlcbiAgfVxuICBlbHNlIHtcbiAgICBjb25zdCBtZXRhV2lkdGggPSBwYXJzZUludCh3eFZpZXdwb3J0TWV0YS5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnKSlcbiAgICBpZiAobWV0YVdpZHRoID09PSB3aWR0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIHd4Vmlld3BvcnRNZXRhLnNldEF0dHJpYnV0ZSgnY29udGVudCcsIHdpZHRoICsgJycpXG59XG5cbi8qKlxuICogZXhwb3J0IHZpZXdwb3J0IGluZm8uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0ICh2aWV3cG9ydFdpZHRoID0gd2lkdGgpIHtcbiAgaWYgKCFpc0luaXRlZCkge1xuICAgIGlzSW5pdGVkID0gdHJ1ZVxuXG4gICAgY29uc3QgZG9jID0gd2luZG93LmRvY3VtZW50XG4gICAgaWYgKCFkb2MpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1t2dWUtcmVuZGVyXSB3aW5kb3cuZG9jdW1lbnQgaXMgdW5kZmluZWQuJylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoIWRvYy5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1t2dWUtcmVuZGVyXSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgaXMgdW5kZmluZWQuJylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGRwciA9IGluZm8uZHByID0gd2luZG93LmRldmljZVBpeGVsUmF0aW9cbiAgICBzY3JlZW5XaWR0aCA9IGRvYy5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGhcbiAgICBzY3JlZW5IZWlnaHQgPSBkb2MuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodFxuXG4gICAgY29uc3QgcmVzZXREZXZpY2VIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzY3JlZW5IZWlnaHQgPSBkb2MuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodFxuICAgICAgY29uc3QgZW52ID0gd2luZG93LndlZXggJiYgd2luZG93LndlZXguY29uZmlnLmVudlxuICAgICAgaW5mby5kZXZpY2VIZWlnaHQgPSBlbnYuZGV2aWNlSGVpZ2h0ID0gc2NyZWVuSGVpZ2h0ICogZHByXG4gICAgfVxuXG4gICAgLy8gc2V0IHJvb3QgZm9udCBmb3IgcmVtLlxuICAgIHNldFJvb3RGb250KHNjcmVlbldpZHRoLCB2aWV3cG9ydFdpZHRoKVxuICAgIHNldE1ldGFWaWV3cG9ydCh2aWV3cG9ydFdpZHRoKVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHJlc2V0RGV2aWNlSGVpZ2h0KVxuXG4gICAgLyoqXG4gICAgICogd2h5IG5vdCB0byB1c2Ugd2luZG93LnNjcmVlbi53aWR0aCB0byBnZXQgc2NyZWVuV2lkdGggPyBCZWNhdXNlIGluIHNvbWVcbiAgICAgKiBvbGQgd2Via2l0IGJyb3dzZXIgb24gYW5kcm9pZCBzeXN0ZW0gaXQgZ2V0IHRoZSBkZXZpY2UgcGl4ZWwgd2lkdGgsIHdoaWNoXG4gICAgICogaXMgdGhlIHNjcmVlbldpZHRoIG11bHRpcGx5IGJ5IHRoZSBkZXZpY2UgcGl4ZWwgcmF0aW8uXG4gICAgICogZS5nLiBpcDYgLT4gZ2V0IDM3NSBmb3IgdmlydHVhbCBzY3JlZW4gd2lkdGguXG4gICAgICovXG4gICAgY29uc3Qgc2NhbGUgPSBzY3JlZW5XaWR0aCAvIHZpZXdwb3J0V2lkdGhcbiAgICAvKipcbiAgICAgKiAxLiBpZiBzZXQgaW5pdGlhbC9tYXhpbXVtL21pbWltdW0tc2NhbGUgc29tZSBob3cgdGhlIHBhZ2Ugd2lsbCBoYXZlIGEgYm91bmNlXG4gICAgICogZWZmZWN0IHdoZW4gdXNlciBkcmFnIHRoZSBwYWdlIHRvd2FyZHMgaG9yaXpvbnRhbCBheGlzLlxuICAgICAqIDIuIER1ZSB0byBjb21wYXRpYmlsaXR5IHJlYXNvbnMsIG5vdCB0byB1c2Ugdmlld3BvcnQgbWV0YSBhbnltb3JlLlxuICAgICAqIDMuIHZpZXdwb3J0IG1ldGEgc2hvdWxkIGFsd2F5cyBiZTpcbiAgICAgKiAgICA8bWV0YSBuYW1lPVwidmlld3BvcnRcIlxuICAgICAqICAgICAgY29udGVudD1cIndpZHRoPWRldmljZS13aWR0aCxcbiAgICAgKiAgICAgIGluaXRpYWwtc2NhbGU9MSxcbiAgICAgKiAgICAgIG1heGltdW0tc2NhbGU9MSxcbiAgICAgKiAgICAgIHVzZXItc2NhbGFibGU9bm9cIiAvPlxuICAgICAqL1xuICAgIGV4dGVuZChpbmZvLCB7XG4gICAgICBzY2FsZSxcbiAgICAgIHJvb3RWYWx1ZTogdmlld3BvcnRXaWR0aCAvIDEwLFxuICAgICAgZGV2aWNlV2lkdGg6IHNjcmVlbldpZHRoICogZHByLFxuICAgICAgZGV2aWNlSGVpZ2h0OiBzY3JlZW5IZWlnaHQgKiBkcHJcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIGluZm9cbn1cblxuLyoqXG4gKiByZXNldCB2aWV3cG9ydCB3aWR0aCBhbmQgc2NhbGUuXG4gKiBAcmV0dXJuIG5ldyBzY2FsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0Vmlld3BvcnQgKHZpZXdwb3J0V2lkdGgpIHtcbiAgc2V0Um9vdEZvbnQoc2NyZWVuV2lkdGgsIHZpZXdwb3J0V2lkdGgsIHRydWUpXG4gIHNldE1ldGFWaWV3cG9ydCh2aWV3cG9ydFdpZHRoKVxuICBjb25zdCBuZXdTY2FsZSA9IHNjcmVlbldpZHRoIC8gdmlld3BvcnRXaWR0aFxuICBpbmZvLnNjYWxlID0gbmV3U2NhbGVcbiAgcmV0dXJuIG5ld1NjYWxlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRWaWV3cG9ydEluZm8gKCkge1xuICByZXR1cm4gaW5mb1xufVxuIiwiLypcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZ1bmN0aW9uIGV4dGVuZCAodG8sIC4uLmFyZ3MpIHtcbiAgaWYgKCFhcmdzIHx8IGFyZ3MubGVuZ3RoIDw9IDApIHsgcmV0dXJuIHRvIH1cbiAgYXJncy5mb3JFYWNoKGZyb20gPT4ge1xuICAgIGlmICh0eXBlb2YgZnJvbSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmcm9tKSB7XG4gICAgICB0b1trZXldID0gZnJvbVtrZXldXG4gICAgfVxuICB9KVxuICByZXR1cm4gdG9cbn1cblxuLy8gaWYgc3VwcG9ydCBwYXNzaXZlIGV2ZW50IGxpc3RlbmVycy5cbmxldCBfc3VwcG9ydHNQYXNzaXZlID0gZmFsc2VcbnRyeSB7XG4gIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBfID0+IHt9LCB7XG4gICAgZ2V0IHBhc3NpdmUgKCkge1xuICAgICAgX3N1cHBvcnRzUGFzc2l2ZSA9IHRydWVcbiAgICB9XG4gIH0pXG59XG5jYXRjaCAoZSkge1xuICAvLyBkbyBub3RoaW5nLlxufVxuZXhwb3J0IGZ1bmN0aW9uIHN1cHBvcnRzUGFzc2l2ZSAoKSB7XG4gIHJldHVybiBfc3VwcG9ydHNQYXNzaXZlXG59XG5cbi8qKlxuICogQ3JlYXRlIEV2ZW50LlxuICogQHBhcmFtIHtET01TdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXZlbnQgKHRhcmdldCwgdHlwZSwgcHJvcHMpIHtcbiAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQodHlwZSwgeyBidWJibGVzOiBmYWxzZSB9KVxuXG4gIGV4dGVuZChldmVudCwgcHJvcHMpXG4gIC8vICBwaGFudG9tanMgZG9uJ3Qgc3VwcG9ydCBjdXN0b21lciBldmVudFxuICBpZiAod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdwaGFudG9tanMnKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gZXZlbnRcbiAgfVxuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShldmVudCwgJ3RhcmdldCcsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogdGFyZ2V0XG4gICAgfSlcbiAgfVxuICBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGV4dGVuZCh7fSwgZXZlbnQsIHsgdGFyZ2V0OiB0YXJnZXQgfSlcbiAgfVxuICByZXR1cm4gZXZlbnRcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBidWJiYWJsZSBFdmVudC5cbiAqIEBwYXJhbSB7RE9NU3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJ1YmJsZXNFdmVudCAodGFyZ2V0LCB0eXBlLCBwcm9wcykge1xuICBjb25zdCBldmVudCA9IG5ldyBFdmVudCh0eXBlLCB7IGJ1YmJsZXM6IHRydWUgfSlcbiAgZXh0ZW5kKGV2ZW50LCBwcm9wcylcbiAgLy8gIHBoYW50b21qcyBkb24ndCBzdXBwb3J0IGN1c3RvbWVyIGV2ZW50XG4gIGlmICh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3BoYW50b21qcycpICE9PSAtMSkge1xuICAgIHJldHVybiBldmVudFxuICB9XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV2ZW50LCAndGFyZ2V0Jywge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiB0YXJnZXRcbiAgICB9KVxuICB9XG4gIGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZXh0ZW5kKHt9LCBldmVudCwgeyB0YXJnZXQ6IHRhcmdldCB9KVxuICB9XG4gIHJldHVybiBldmVudFxufVxuXG4vKipcbiAqIENyZWF0ZSBDdXN0b20gRXZlbnQuXG4gKiBAcGFyYW0ge0RPTVN0cmluZ30gdHlwZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDdXN0b21FdmVudCAodGFyZ2V0LCB0eXBlLCBwcm9wcykge1xuICAvLyBjb21wYXRpYmlsaXR5OiBodHRwOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1jdXN0b21ldmVudFxuICAvLyBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudCh0eXBlKVxuICBjb25zdCBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpXG4gIGV2ZW50LmluaXRDdXN0b21FdmVudCh0eXBlLCBmYWxzZSwgdHJ1ZSwge30pXG4gIC8vIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgLy8gZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcblxuICBleHRlbmQoZXZlbnQsIHByb3BzKVxuXG4gIC8vIGV2ZW50LnRhcmdldCBpcyByZWFkb25seVxuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShldmVudCwgJ3RhcmdldCcsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogdGFyZ2V0IHx8IG51bGxcbiAgICB9KVxuICB9XG4gIGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZXh0ZW5kKHt9LCBldmVudCwgeyB0YXJnZXQ6IHRhcmdldCB8fCBudWxsIH0pXG4gIH1cblxuICByZXR1cm4gZXZlbnRcbn1cblxuLyoqXG4gKiBkaXNwYXRjaCBhIGV2ZW50IG9uIGEgSFRNTCBlbGVtZW50LlxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsbVxuICogQHBhcmFtICB7RXZlbnR9IHR5cGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSAge09iamVjdH0gZGF0YSBleHRyYSBkYXRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzcGF0Y2hOYXRpdmVFdmVudCAoZWxtLCB0eXBlLCBkYXRhKSB7XG4gIGVsbS5kaXNwYXRjaEV2ZW50KGNyZWF0ZUV2ZW50KGVsbSwgdHlwZSwgZGF0YSkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXBGb3JtRXZlbnRzIChjb250ZXh0KSB7XG4gIGNvbnN0IGV2ZW50TWFwID0ge31cbiAgO1snaW5wdXQnLCAnY2hhbmdlJywgJ2ZvY3VzJywgJ2JsdXInLCAncmV0dXJuJ10uZm9yRWFjaCh0eXBlID0+IHtcbiAgICBldmVudE1hcFt0eXBlXSA9IGV2ZW50ID0+IHtcbiAgICAgIGlmIChjb250ZXh0LiRlbCkge1xuICAgICAgICBldmVudC52YWx1ZSA9IGNvbnRleHQuJGVsLnZhbHVlXG4gICAgICAgIC8vIGZvciB0aGUgc2FrZSBvZiB2LW1vZGVsLCBhIGlucHV0IGV2ZW50IG11c3QgYmUgZW1pdHRlZC5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdpbnB1dCcpIHtcbiAgICAgICAgICBjb250ZXh0LiRlbWl0KHR5cGUsIGV2ZW50KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gZXZlbnRNYXBcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBtYXBGb3JtRXZlbnRzXG59XG4iLCIvKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IGh5cGhlbmF0ZSB9IGZyb20gJy4vdXRpbHMnXG5cbmNvbnN0IHNjYWxlU3R5bGVzID0gW1xuICAnd2lkdGgnLFxuICAnaGVpZ2h0JyxcbiAgJ2xlZnQnLFxuICAncmlnaHQnLFxuICAndG9wJyxcbiAgJ2JvdHRvbScsXG4gICdib3JkZXInLFxuICAnYm9yZGVyUmFkaXVzJyxcbiAgJ2JvcmRlcldpZHRoJyxcbiAgJ2JvcmRlckxlZnQnLFxuICAnYm9yZGVyUmlnaHQnLFxuICAnYm9yZGVyVG9wJyxcbiAgJ2JvcmRlckJvdHRvbScsXG4gICdib3JkZXJMZWZ0V2lkdGgnLFxuICAnYm9yZGVyUmlnaHRXaWR0aCcsXG4gICdib3JkZXJUb3BXaWR0aCcsXG4gICdib3JkZXJCb3R0b21XaWR0aCcsXG4gICdtYXJnaW4nLFxuICAnbWFyZ2luTGVmdCcsXG4gICdtYXJnaW5SaWdodCcsXG4gICdtYXJnaW5Ub3AnLFxuICAnbWFyZ2luQm90dG9tJyxcbiAgJ3BhZGRpbmcnLFxuICAncGFkZGluZ0xlZnQnLFxuICAncGFkZGluZ1JpZ2h0JyxcbiAgJ3BhZGRpbmdUb3AnLFxuICAncGFkZGluZ0JvdHRvbScsXG4gICdmb250U2l6ZScsXG4gICdsaW5lSGVpZ2h0JyxcbiAgJ3RyYW5zZm9ybScsXG4gICd3ZWJraXRUcmFuc2Zvcm0nLFxuICAnV2Via2l0VHJhbnNmb3JtJyxcbiAgJ21velRyYW5zZm9ybScsXG4gICdNb3pUcmFuc2Zvcm0nLFxuICAnaXRlbVNpemUnXG5dXG5cbmNvbnN0IHZlbmRvclJlZyA9IC93ZWJraXR8bW96L2lcbmZ1bmN0aW9uIGh5cGhlbiAoa2V5KSB7XG4gIHJldHVybiBoeXBoZW5hdGUoa2V5LnJlcGxhY2UodmVuZG9yUmVnLCBmdW5jdGlvbiAoJDApIHtcbiAgICByZXR1cm4gYC0keyQwLnRvTG93ZXJDYXNlKCl9LWBcbiAgfSkpXG59XG5cbmZ1bmN0aW9uIGdldEFsbFN0eWxlcyAoKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhzY2FsZVN0eWxlcy5yZWR1Y2UoZnVuY3Rpb24gKHByZSwga2V5KSB7XG4gICAgcHJlW2tleV0gPSAxXG4gICAgcHJlW2h5cGhlbihrZXkpXSA9IDFcbiAgICByZXR1cm4gcHJlXG4gIH0sIHt9KSlcbn1cblxuY29uc3QgYWxsU3R5bGVzID0gZ2V0QWxsU3R5bGVzKClcblxuZXhwb3J0IGRlZmF1bHQge1xuICBzY3JvbGxhYmxlVHlwZXM6IFsnc2Nyb2xsZXInLCAnbGlzdCcsICd3YXRlcmZhbGwnXSxcbiAgZ2VzdHVyZUV2ZW50czogW1xuICAgICdwYW5zdGFydCcsXG4gICAgJ3Bhbm1vdmUnLFxuICAgICdwYW5lbmQnLFxuICAgICdzd2lwZScsXG4gICAgJ2xvbmdwcmVzcycsXG4gICAgJ3RhcCdcbiAgXSxcbiAgLy8gdGhlc2UgY29tcG9uZW50cyBzaG91bGQgbm90IGJpbmQgZXZlbnRzIHdpdGggLm5hdGl2ZS5cbiAgd2VleEJ1aWx0SW5Db21wb25lbnRzOiBbXG4gICAgJ2RpdicsXG4gICAgJ2NvbnRhaW5lcicsXG4gICAgJ3RleHQnLFxuICAgICdpbWFnZScsXG4gICAgJ2ltZycsXG4gICAgJ2NlbGwnLFxuICAgICdhJ1xuICBdLFxuICBiaW5kaW5nU3R5bGVOYW1lc0ZvclB4MlJlbTogYWxsU3R5bGVzXG59XG4iLCIvKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IHRocm90dGxlLCBleHRlbmQgfSBmcm9tICcuL2Z1bmMnXG5pbXBvcnQgeyBkaXNwYXRjaE5hdGl2ZUV2ZW50IH0gZnJvbSAnLi9ldmVudCdcbmltcG9ydCBjb25maWcgZnJvbSAnLi4vY29uZmlnJ1xuXG4vKipcbiAqIHdoZXRoZXIgY3QgY29udGFpbnMgZWwuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udGFpbnMgKGNvbnRhaW5lciwgdGFyZ2V0LCBpbmNsdWRlU2VsZikge1xuICBpZiAoaW5jbHVkZVNlbGYgJiYgY29udGFpbmVyID09PSB0YXJnZXQpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBjb250YWluZXIuY29udGFpbnNcbiAgICA/IGNvbnRhaW5lci5jb250YWlucyh0YXJnZXQpICYmIChjb250YWluZXIgIT09IHRhcmdldClcbiAgICA6IGNvbnRhaW5lci5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0YXJnZXQpICYgMTYgIT09IDBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluc2lkZUEgKGVsKSB7XG4gIGlmICh0eXBlb2YgZWwuX2luc2lkZUEgPT09ICdib29sZWFuJykge1xuICAgIHJldHVybiBlbC5faW5zaWRlQVxuICB9XG4gIGxldCBwYXJlbnQgPSBlbC5wYXJlbnRFbGVtZW50XG4gIGNvbnN0IHBhcmVudHMgPSBbXVxuICBjb25zdCBjaGVja1BhcmVudHMgPSBmdW5jdGlvbiAoaW5zaWRlKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBwYXJlbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcGFyZW50c1tpXS5faW5zaWRlQSA9IGluc2lkZVxuICAgIH1cbiAgfVxuICBjb25zdCBjaGVjayA9IGZ1bmN0aW9uIChpbnNpZGUpIHtcbiAgICBlbC5faW5zaWRlQSA9IGluc2lkZVxuICAgIGNoZWNrUGFyZW50cyhpbnNpZGUpXG4gICAgcmV0dXJuIGluc2lkZVxuICB9XG4gIHdoaWxlIChwYXJlbnQgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICBpZiAocGFyZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSB7XG4gICAgICByZXR1cm4gY2hlY2sodHJ1ZSlcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYXJlbnQuX2luc2lkZUEgPT09ICdib29sZWFuJykge1xuICAgICAgcmV0dXJuIGNoZWNrKHBhcmVudC5faW5zaWRlQSlcbiAgICB9XG4gICAgcGFyZW50cy5wdXNoKHBhcmVudClcbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50RWxlbWVudFxuICB9XG4gIHJldHVybiBjaGVjayhmYWxzZSlcbn1cblxuLyoqXG4gKiBnZXQgcGFyZW50IHNjcm9sbGVyIHZDb21wb25lbnQuXG4gKiByZXR1cm4gYSBWdWVDb21wb25lbnQgb3IgbnVsbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBhcmVudFNjcm9sbGVyICh2bSkge1xuICBpZiAoIXZtKSByZXR1cm4gbnVsbFxuICBpZiAodm0uX3BhcmVudFNjcm9sbGVyKSB7XG4gICAgcmV0dXJuIHZtLl9wYXJlbnRTY3JvbGxlclxuICB9XG4gIGZ1bmN0aW9uIF9nZXRQYXJlbnRTY3JvbGxlciAocGFyZW50KSB7XG4gICAgaWYgKCFwYXJlbnQpIHsgcmV0dXJuIH1cbiAgICBpZiAoY29uZmlnLnNjcm9sbGFibGVUeXBlcy5pbmRleE9mKHBhcmVudC53ZWV4VHlwZSkgPiAtMSkge1xuICAgICAgdm0uX3BhcmVudFNjcm9sbGVyID0gcGFyZW50XG4gICAgICByZXR1cm4gcGFyZW50XG4gICAgfVxuICAgIHJldHVybiBfZ2V0UGFyZW50U2Nyb2xsZXIocGFyZW50LiRwYXJlbnQpXG4gIH1cbiAgcmV0dXJuIF9nZXRQYXJlbnRTY3JvbGxlcih2bS4kcGFyZW50KVxufVxuXG4vKipcbiAqIGdldCBzY3JvbGxlcidzIGVsZW1lbnQuXG4gKiBAcGFyYW0gdm0ge0hUTUxFbGVtZW50IHwgVnVlQ09tcG9uZW50fSB2bSBvciBlbGVtZW50LlxuICogcmV0dXJuIHRoZSBlbGVtZW50IG9yIGRvY3VtZW50LmJvZHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXJlbnRTY3JvbGxlckVsZW1lbnQgKHZtKSB7XG4gIGlmICghdm0pIHsgcmV0dXJuIG51bGwgfVxuICBjb25zdCBlbCA9IHZtIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgPyB2bSA6IHZtLiRlbFxuICBpZiAoIWVsIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7IHJldHVybiB9XG4gIGlmICh2bS5fcGFyZW50U2Nyb2xsZXIpIHtcbiAgICByZXR1cm4gdm0uX3BhcmVudFNjcm9sbGVyXG4gIH1cbiAgZnVuY3Rpb24gX2dldFBhcmVudFNjcm9sbGVyIChwYXJlbnQpIHtcbiAgICBpZiAoIXBhcmVudCkgeyByZXR1cm4gfVxuICAgIGNvbnN0IHRhZ05hbWUgPSBwYXJlbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKHRhZ05hbWUgPT09ICdib2R5J1xuICAgICAgfHwgKHRhZ05hbWUgPT09ICdtYWluJ1xuICAgICAgJiYgY29uZmlnLnNjcm9sbGFibGVUeXBlcy5pbmRleE9mKHBhcmVudC5nZXRBdHRyaWJ1dGUoJ3dlZXgtdHlwZScpKSA+IC0xKVxuICAgICkge1xuICAgICAgdm0uX3BhcmVudFNjcm9sbGVyID0gcGFyZW50XG4gICAgICByZXR1cm4gcGFyZW50XG4gICAgfVxuICAgIHJldHVybiBfZ2V0UGFyZW50U2Nyb2xsZXIocGFyZW50LnBhcmVudEVsZW1lbnQpXG4gIH1cbiAgcmV0dXJuIF9nZXRQYXJlbnRTY3JvbGxlcihlbClcbn1cblxuZnVuY3Rpb24gaG9yaXpvbnRhbEJhbGFuY2UgKHJlY3QsIGN0UmVjdCkge1xuICByZXR1cm4gcmVjdC5sZWZ0IDwgY3RSZWN0LnJpZ2h0ICYmIHJlY3QucmlnaHQgPiBjdFJlY3QubGVmdFxufVxuXG5mdW5jdGlvbiB2ZXJ0aWNhbEJhbGFuY2UgKHJlY3QsIGN0UmVjdCkge1xuICByZXR1cm4gcmVjdC50b3AgPCBjdFJlY3QuYm90dG9tICYmIHJlY3QuYm90dG9tID4gY3RSZWN0LnRvcFxufVxuXG4vKipcbiAqIHJldHVybiBhIGRhdGEgYXJyYXkgd2l0aCB0d28gYm9vbGVhbiB2YWx1ZSwgd2hpY2ggYXJlOlxuICogMS4gdmlzaWJsZSBpbiBjdXJyZW50IGN0J3Mgdmlld3BvcnQuXG4gKiAyLiB2aXNpYmxlIHdpdGggb2Zmc2V0IGluIGN1cnJlbnQgY3QncyB2aWV3cG9ydC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc0ludGVyc2VjdGlvbiAocmVjdCwgY3RSZWN0LCBkaXIsIG9mZnNldCkge1xuICBkaXIgPSBkaXIgfHwgJ3VwJ1xuICBjb25zdCBpc0hvcml6b250YWwgPSBkaXIgPT09ICdsZWZ0JyB8fCBkaXIgPT09ICdyaWdodCdcbiAgY29uc3QgaXNWZXJ0aWNhbCA9IGRpciA9PT0gJ3VwJyB8fCBkaXIgPT09ICdkb3duJ1xuICBpZiAoaXNIb3Jpem9udGFsICYmICF2ZXJ0aWNhbEJhbGFuY2UocmVjdCwgY3RSZWN0KSkge1xuICAgIHJldHVybiBbZmFsc2UsIGZhbHNlXVxuICB9XG4gIGlmIChpc1ZlcnRpY2FsICYmICFob3Jpem9udGFsQmFsYW5jZShyZWN0LCBjdFJlY3QpKSB7XG4gICAgcmV0dXJuIFtmYWxzZSwgZmFsc2VdXG4gIH1cbiAgb2Zmc2V0ID0gb2Zmc2V0ID8gcGFyc2VJbnQob2Zmc2V0KSAqIHdlZXguY29uZmlnLmVudi5zY2FsZSA6IDBcbiAgc3dpdGNoIChkaXIpIHtcbiAgICBjYXNlICd1cCc6XG4gICAgICByZXR1cm4gW1xuICAgICAgICByZWN0LnRvcCA8IGN0UmVjdC5ib3R0b20gJiYgcmVjdC5ib3R0b20gPiBjdFJlY3QudG9wLFxuICAgICAgICByZWN0LnRvcCA8IGN0UmVjdC5ib3R0b20gKyBvZmZzZXQgJiYgcmVjdC5ib3R0b20gPiBjdFJlY3QudG9wIC0gb2Zmc2V0XG4gICAgICBdXG4gICAgY2FzZSAnZG93bic6XG4gICAgICByZXR1cm4gW1xuICAgICAgICByZWN0LmJvdHRvbSA+IGN0UmVjdC50b3AgJiYgcmVjdC50b3AgPCBjdFJlY3QuYm90dG9tLFxuICAgICAgICByZWN0LmJvdHRvbSA+IGN0UmVjdC50b3AgLSBvZmZzZXQgJiYgcmVjdC50b3AgPCBjdFJlY3QuYm90dG9tICsgb2Zmc2V0XG4gICAgICBdXG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICByZXR1cm4gW1xuICAgICAgICByZWN0LmxlZnQgPCBjdFJlY3QucmlnaHQgJiYgcmVjdC5yaWdodCA+IGN0UmVjdC5sZWZ0LFxuICAgICAgICByZWN0LmxlZnQgPCBjdFJlY3QucmlnaHQgKyBvZmZzZXQgJiYgcmVjdC5yaWdodCA+IGN0UmVjdC5sZWZ0IC0gb2Zmc2V0XG4gICAgICBdXG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgcmVjdC5yaWdodCA+IGN0UmVjdC5sZWZ0ICYmIHJlY3QubGVmdCA8IGN0UmVjdC5yaWdodCxcbiAgICAgICAgcmVjdC5yaWdodCA+IGN0UmVjdC5sZWZ0IC0gb2Zmc2V0ICYmIHJlY3QubGVmdCA8IGN0UmVjdC5yaWdodCArIG9mZnNldFxuICAgICAgXVxuICB9XG59XG5cbi8qKlxuICogaXNFbGVtZW50VmlzaWJsZVxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9ICBlbCAgICBhIGRvbSBlbGVtZW50LlxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9ICBjb250YWluZXIgIG9wdGlvbmFsLCB0aGUgY29udGFpbmVyIG9mIHRoaXMgZWwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VsZW1lbnRWaXNpYmxlIChlbCwgY29udGFpbmVyLCBkaXIsIG9mZnNldCkge1xuICBpZiAoIWVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCkgeyByZXR1cm4gZmFsc2UgfVxuICBjb25zdCBib2R5UmVjdCA9IHtcbiAgICB0b3A6IDAsXG4gICAgbGVmdDogMCxcbiAgICBib3R0b206IHdpbmRvdy5pbm5lckhlaWdodCxcbiAgICByaWdodDogd2luZG93LmlubmVyV2lkdGhcbiAgfVxuICBjb25zdCBjdFJlY3QgPSAoY29udGFpbmVyID09PSB3aW5kb3cgfHwgY29udGFpbmVyID09PSBkb2N1bWVudC5ib2R5KVxuICAgID8gYm9keVJlY3QgOiBjb250YWluZXJcbiAgICAgID8gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogYm9keVJlY3RcbiAgcmV0dXJuIGhhc0ludGVyc2VjdGlvbihlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgY3RSZWN0LCBkaXIsIG9mZnNldClcbn1cblxuLy8gdG8gdHJpZ2dlciB0aGUgYXBwZWFyL2Rpc2FwcGVhciBldmVudC5cbmZ1bmN0aW9uIHRyaWdnZXJBcHBlYXJFdmVudCAoZWxtLCBldnQsIGRpcikge1xuICBkaXNwYXRjaE5hdGl2ZUV2ZW50KGVsbSwgZXZ0LCB7XG4gICAgZGlyZWN0aW9uOiBkaXJcbiAgfSlcbn1cblxuLyoqXG4gKiBnZXQgYWxsIGV2ZW50IGxpc3RlbmVycy4gaW5jbHVkaW5nIGJvdW5kIGhhbmRsZXJzIGluIGFsbCBwYXJlbnQgdm5vZGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXZlbnRIYW5kbGVycyAoY29udGV4dCkge1xuICBsZXQgdm5vZGUgPSBjb250ZXh0LiR2bm9kZVxuICBjb25zdCBoYW5kbGVycyA9IHt9XG4gIGNvbnN0IGF0dGFjaGVkVm5vZGVzID0gW11cbiAgd2hpbGUgKHZub2RlKSB7XG4gICAgYXR0YWNoZWRWbm9kZXMucHVzaCh2bm9kZSlcbiAgICB2bm9kZSA9IHZub2RlLnBhcmVudFxuICB9XG4gIGF0dGFjaGVkVm5vZGVzLmZvckVhY2goZnVuY3Rpb24gKHZub2RlKSB7XG4gICAgY29uc3QgcGFyZW50TGlzdGVuZXJzID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucyAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zLmxpc3RlbmVyc1xuICAgIGNvbnN0IGRhdGFPbiA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5vblxuICAgIGV4dGVuZChoYW5kbGVycywgcGFyZW50TGlzdGVuZXJzLCBkYXRhT24pXG4gIH0pXG4gIHJldHVybiBoYW5kbGVyc1xufVxuXG5mdW5jdGlvbiBnZXRBcHBlYXJPZmZzZXQgKGVsKSB7XG4gIHJldHVybiBlbCAmJiBlbC5nZXRBdHRyaWJ1dGUoJ2FwcGVhci1vZmZzZXQnKVxufVxuXG5mdW5jdGlvbiB1cGRhdGVXYXRjaEFwcGVhckxpc3QgKGNvbnRhaW5lcikge1xuICBjb250YWluZXIuX3dhdGNoQXBwZWFyTGlzdCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKFxuICAgIGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCdbd2VleC1hcHBlYXJdJykpXG59XG5cbi8qKlxuICogaW5qZWN0IHJlbW92ZUNoaWxkIGZ1bmN0aW9uIHRvIHdhdGNoIGRpc2FwcGVhciBhbmQgb2Zmc2V0RGlzYXBwZWFyIGV2ZW50cy5cbiAqL1xuaWYgKCF3aW5kb3cuX3JtSW5qZWN0ZWQpIHtcbiAgd2luZG93Ll9ybUluamVjdGVkID0gdHJ1ZVxuICBjb25zdCBuYXRpdmVSZW1vdmUgPSBIVE1MRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlQ2hpbGRcbiAgSFRNTEVsZW1lbnQucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgZWwuX3Zpc2libGUgJiYgdHJpZ2dlckFwcGVhckV2ZW50KGVsLCAnZGlzYXBwZWFyJywgbnVsbClcbiAgICBlbC5fb2Zmc2V0VmlzaWJsZSAmJiB0cmlnZ2VyQXBwZWFyRXZlbnQoZWwsICdvZmZzZXREaXNhcHBlYXInLCBudWxsKVxuICAgIG5hdGl2ZVJlbW92ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIH1cbn1cblxuLyoqXG4gKiBXYXRjaCBlbGVtZW50J3MgdmlzaWJpbGl0eSB0byB0ZWxsIHdoZXRoZXIgc2hvdWxkIHRyaWdnZXIgYSBhcHBlYXIvZGlzYXBwZWFyXG4gKiBldmVudCBpbiBzY3JvbGwgaGFuZGxlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdhdGNoQXBwZWFyIChjb250ZXh0LCBmaXJlTm93KSB7XG4gIGNvbnN0IGVsID0gY29udGV4dCAmJiBjb250ZXh0LiRlbFxuICBpZiAoIWVsIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7IHJldHVybiB9XG5cbiAgbGV0IGlzV2luZG93ID0gZmFsc2VcbiAgY29uc3QgY29udGFpbmVyID0gZ2V0UGFyZW50U2Nyb2xsZXJFbGVtZW50KGNvbnRleHQpXG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKGNvbnRhaW5lciA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgIGlzV2luZG93ID0gdHJ1ZVxuICB9XG4gIC8qKlxuICAgKiBDb2RlIGJlbG93IHdpbGwgb25seSBleGVjIG9uY2UgZm9yIGJpbmRpbmcgc2Nyb2xsIGhhbmRsZXIgZm9yIHBhcmVudCBjb250YWluZXIuXG4gICAqL1xuICBsZXQgc2Nyb2xsSGFuZGxlciA9IGNvbnRhaW5lci5fc2Nyb2xsSGFuZGxlclxuICBpZiAoIXNjcm9sbEhhbmRsZXIpIHtcbiAgICBzY3JvbGxIYW5kbGVyID0gY29udGFpbmVyLl9zY3JvbGxIYW5kbGVyID0gZXZlbnQgPT4ge1xuICAgICAgdXBkYXRlV2F0Y2hBcHBlYXJMaXN0KGNvbnRhaW5lcilcbiAgICAgIC8qKlxuICAgICAgICogZGV0ZWN0IHNjcm9sbGluZyBkaXJlY3Rpb24uXG4gICAgICAgKiBkaXJlY3Rpb24gb25seSBzdXBwb3J0IHVwICYgZG93biB5ZXQuXG4gICAgICAgKiBUT0RPOiBkaXJlY3Rpb24gc3VwcG9ydCBsZWZ0ICYgcmlnaHQuXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IHNjcm9sbFRvcCA9IGlzV2luZG93ID8gd2luZG93LnBhZ2VZT2Zmc2V0IDogY29udGFpbmVyLnNjcm9sbFRvcFxuICAgICAgY29uc3QgcHJlVG9wID0gY29udGFpbmVyLl9sYXN0U2Nyb2xsVG9wXG4gICAgICBjb250YWluZXIuX2xhc3RTY3JvbGxUb3AgPSBzY3JvbGxUb3BcbiAgICAgIGNvbnN0IGRpciA9IChzY3JvbGxUb3AgPCBwcmVUb3BcbiAgICAgICAgPyAnZG93bicgOiBzY3JvbGxUb3AgPiBwcmVUb3BcbiAgICAgICAgICA/ICd1cCcgOiBjb250YWluZXIuX3ByZXZEaXJlY3Rpb24pIHx8IG51bGxcbiAgICAgIGNvbnRhaW5lci5fcHJldkRpcmVjdGlvbiA9IGRpclxuICAgICAgY29uc3Qgd2F0Y2hBcHBlYXJMaXN0ID0gY29udGFpbmVyLl93YXRjaEFwcGVhckxpc3QgfHwgW11cbiAgICAgIGNvbnN0IGxlbiA9IHdhdGNoQXBwZWFyTGlzdC5sZW5ndGhcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgZWwgPSB3YXRjaEFwcGVhckxpc3RbaV1cbiAgICAgICAgY29uc3QgYXBwZWFyT2Zmc2V0ID0gZ2V0QXBwZWFyT2Zmc2V0KGVsKVxuICAgICAgICBjb25zdCB2aXNpYmxlRGF0YSA9IGlzRWxlbWVudFZpc2libGUoZWwsIGNvbnRhaW5lciwgZGlyLCBhcHBlYXJPZmZzZXQpXG4gICAgICAgIGRldGVjdEFwcGVhcihlbCwgdmlzaWJsZURhdGEsIGRpcilcbiAgICAgIH1cbiAgICB9XG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRocm90dGxlKHNjcm9sbEhhbmRsZXIsIDEwMCwgdHJ1ZSkpXG4gIH1cbiAgaWYgKGZpcmVOb3cpIHtcbiAgICBjb250ZXh0LiRuZXh0VGljayhzY3JvbGxIYW5kbGVyKVxuICB9XG59XG5cbi8qKlxuICogZGVjaWRlIHdoZXRoZXIgdG8gdHJpZ2dlciBhIGFwcGVhci9kaXNhcHBlYXIgZXZlbnQuXG4gKiBAcGFyYW0ge1Z1ZUNvbXBvbmVudH0gY29udGV4dFxuICogQHBhcmFtIHtib29sZWFufSB2aXNpYmxlXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRlY3RBcHBlYXIgKGVsLCB2aXNpYmxlRGF0YSwgZGlyID0gbnVsbCwgYXBwZWFyT2Zmc2V0KSB7XG4gIGlmICghZWwpIHsgcmV0dXJuIH1cbiAgY29uc3QgW3Zpc2libGUsIG9mZnNldFZpc2libGVdID0gdmlzaWJsZURhdGFcbiAgLyoqXG4gICAqIE5vIG1hdHRlciBpdCdzIGJpbmRpbmcgYXBwZWFyL2Rpc2FwcGVhciBvciBib3RoIG9mIHRoZW0uIEFsd2F5c1xuICAgKiBzaG91bGQgdGVzdCBpdCdzIHZpc2liaWxpdHkgYW5kIGNoYW5nZSB0aGUgZWwuX3Zpc2libGUuXG4gICAqIElmIG5laWdoZXIgaGFzIGJlZW4gYm91bmQsIHRoZW4gaWdub3JlIGl0LlxuICAgKi9cbiAgLyoqXG4gICAqIGlmIHRoZSBjb21wb25lbnQgaGFzbid0IGFwcGVhcmVkIGZvciBvbmNlIHlldCwgdGhlbiBpdCBzaG91bGRuJ3QgdHJpZ2dlclxuICAgKiBhIGRpc2FwcGVhciBldmVudCBhdCBhbGwuXG4gICAqL1xuICBpZiAoZWwuX2FwcGVhcmVkT25jZSB8fCB2aXNpYmxlKSB7XG4gICAgaWYgKGVsLl92aXNpYmxlICE9PSB2aXNpYmxlKSB7XG4gICAgICBlbC5fdmlzaWJsZSA9IHZpc2libGVcbiAgICAgIGlmICh2aXNpYmxlICYmICFlbC5fYXBwZWFyZWRPbmNlKSB7XG4gICAgICAgIGVsLl9hcHBlYXJlZE9uY2UgPSB0cnVlXG4gICAgICB9XG4gICAgICBjb25zdCBldnROYW1lID0gdmlzaWJsZSA/ICdhcHBlYXInIDogJ2Rpc2FwcGVhcidcbiAgICAgIGlmIChlbC5nZXRBdHRyaWJ1dGUoYGRhdGEtZXZ0LSR7ZXZ0TmFtZX1gKSA9PT0gJycpIHtcbiAgICAgICAgdHJpZ2dlckFwcGVhckV2ZW50KGVsLCBldnROYW1lLCBkaXIpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChlbC5fb2Zmc2V0QXBwZWFyZWRPbmNlIHx8IG9mZnNldFZpc2libGUpIHtcbiAgICBpZiAoZWwuX29mZnNldFZpc2libGUgIT09IG9mZnNldFZpc2libGUpIHtcbiAgICAgIGVsLl9vZmZzZXRWaXNpYmxlID0gb2Zmc2V0VmlzaWJsZVxuICAgICAgaWYgKG9mZnNldFZpc2libGUgJiYgIWVsLl9vZmZzZXRBcHBlYXJlZE9uY2UpIHtcbiAgICAgICAgZWwuX29mZnNldEFwcGVhcmVkT25jZSA9IHRydWVcbiAgICAgIH1cbiAgICAgIGNvbnN0IGV2dCA9IG9mZnNldFZpc2libGUgPyBbJ29mZnNldC1hcHBlYXInLCAnb2Zmc2V0QXBwZWFyJ10gOiBbJ29mZnNldC1kaXNhcHBlYXInLCAnb2Zmc2V0RGlzYXBwZWFyJ11cbiAgICAgIGlmIChlbC5nZXRBdHRyaWJ1dGUoYGRhdGEtZXZ0LSR7ZXZ0WzBdfWApID09PSAnJykge1xuICAgICAgICB0cmlnZ2VyQXBwZWFyRXZlbnQoZWwsIGV2dFsxXSwgZGlyKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IGlzRWxlbWVudFZpc2libGUgfSBmcm9tICcuL2NvbXBvbmVudCdcbmltcG9ydCB7IGRpc3BhdGNoTmF0aXZlRXZlbnQgfSBmcm9tICcuL2V2ZW50J1xuaW1wb3J0IHsgdGhyb3R0bGUgfSBmcm9tICcuL2Z1bmMnXG5cbmNvbnN0IGxhenlsb2FkQXR0ciA9ICdkYXRhLWltZy1zcmMnXG5jb25zdCBwbGFjZWhvbGRlckF0dHIgPSAncGxhY2Vob2xkZXInXG5cbmZ1bmN0aW9uIHByZUxvYWRJbWcgKHNyYyxcbiAgbG9hZENhbGxiYWNrLFxuICBlcnJvckNhbGxiYWNrKSB7XG4gIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpXG4gIGltZy5vbmxvYWQgPSBsb2FkQ2FsbGJhY2sgPyBsb2FkQ2FsbGJhY2suYmluZChpbWcpIDogbnVsbFxuICBpbWcub25lcnJvciA9IGVycm9yQ2FsbGJhY2sgPyBlcnJvckNhbGxiYWNrLmJpbmQoaW1nKSA6IG51bGxcbiAgaW1nLnNyYyA9IHNyY1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlTcmMgKGl0ZW0sIHNyYywgcGxhY2Vob2xkZXJTcmMpIHtcbiAgaWYgKCFzcmMpIHsgcmV0dXJuIH1cbiAgZnVuY3Rpb24gZmluYWxsQ2IgKCkge1xuICAgIGRlbGV0ZSBpdGVtLl9zcmNfbG9hZGluZ1xuICB9XG5cbiAgaWYgKHdpbmRvdy5fcHJvY2Vzc0ltZ1NyYykge1xuICAgIHNyYyA9IHdpbmRvdy5fcHJvY2Vzc0ltZ1NyYyhzcmMsIGl0ZW0pXG4gICAgaWYgKHBsYWNlaG9sZGVyU3JjKSB7XG4gICAgICBwbGFjZWhvbGRlclNyYyA9IHdpbmRvdy5fcHJvY2Vzc0ltZ1NyYyhwbGFjZWhvbGRlclNyYywgaXRlbSlcbiAgICB9XG4gIH1cblxuICBpZiAoaXRlbS5fc3JjX2xvYWRpbmcgPT09IHNyYykge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyoqXG4gICAqIDEuIGFwcGx5IHNyYyBpbW1lZGlhdGVseSBpbiBjYXNlIGphdnNjcmlwdCBibG9ja3MgdGhlIGltYWdlIGxvYWRpbmdcbiAgICogIGJlZm9yZSBuZXh0IHRpY2suXG4gICAqL1xuICBpdGVtLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGB1cmwoJHtzcmMgfHwgJyd9KWBcbiAgaXRlbS5yZW1vdmVBdHRyaWJ1dGUobGF6eWxvYWRBdHRyKVxuICAvKipcbiAgICogMi4gdGhlbiBsb2FkIHRoZSBpbWcgc3JjIHdpdGggSW1hZ2UgY29uc3RydWN0b3IgKGJ1dCB3b3VsZCBub3QgcG9zdFxuICAgKiAgYSByZXF1ZXN0IGFnYWluKSwganVzdCB0byB0cmlnZ2VyIHRoZSBsb2FkIGV2ZW50LlxuICAgKi9cbiAgaXRlbS5fc3JjX2xvYWRpbmcgPSBzcmNcbiAgcHJlTG9hZEltZyhzcmMsIGZ1bmN0aW9uIChldnQpIHtcbiAgICBpdGVtLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGB1cmwoJHtzcmMgfHwgJyd9KWBcbiAgICBjb25zdCB7IHdpZHRoOiBuYXR1cmFsV2lkdGgsIGhlaWdodDogbmF0dXJhbEhlaWdodCB9ID0gdGhpc1xuICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBzaXplOiB7IG5hdHVyYWxXaWR0aCwgbmF0dXJhbEhlaWdodCB9XG4gICAgfVxuICAgIGRpc3BhdGNoTmF0aXZlRXZlbnQoaXRlbSwgJ2xvYWQnLCBwYXJhbXMpXG4gICAgZmluYWxsQ2IoKVxuICB9LCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBzaXplOiB7IG5hdHVyYWxXaWR0aDogMCwgbmF0dXJhbEhlaWdodDogMCB9XG4gICAgfVxuICAgIGRpc3BhdGNoTmF0aXZlRXZlbnQoaXRlbSwgJ2xvYWQnLCBwYXJhbXMpXG4gICAgaWYgKHBsYWNlaG9sZGVyU3JjKSB7XG4gICAgICBwcmVMb2FkSW1nKHBsYWNlaG9sZGVyU3JjLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGl0ZW0uc3R5bGUuYmFja2dyb3VuZEltYWdlID0gYHVybCgke3BsYWNlaG9sZGVyU3JjIHx8ICcnfSlgXG4gICAgICB9KVxuICAgIH1cbiAgICBmaW5hbGxDYigpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGdldEN0U2Nyb2xsZXIgKGVsKSB7XG4gIGlmICghZWwpIHsgcmV0dXJuIH1cbiAgbGV0IHNjcm9sbGVyID0gZWwuX3B0U2Nyb2xsZXJcbiAgaWYgKCFzY3JvbGxlcikge1xuICAgIGxldCBwdCA9IGVsLnBhcmVudEVsZW1lbnRcbiAgICB3aGlsZSAocHQgJiYgcHQgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgIGlmICgocHQuY2xhc3NOYW1lICsgJycgfHwgJycpLm1hdGNoKC93ZWV4LWxpc3R8d2VleC1zY3JvbGxlcnx3ZWV4LXdhdGVyZmFsbC8pKSB7XG4gICAgICAgIHNjcm9sbGVyID0gcHRcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHB0ID0gcHQucGFyZW50RWxlbWVudFxuICAgIH1cbiAgICBzY3JvbGxlciA9IHB0XG4gICAgZWwuX3B0U2Nyb2xsZXIgPSBwdFxuICB9XG4gIHJldHVybiBzY3JvbGxlclxufVxuXG5leHBvcnQgZnVuY3Rpb24gZmlyZUxhenlsb2FkIChlbCwgaWdub3JlVmlzaWJpbGl0eSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShlbCkpIHtcbiAgICByZXR1cm4gZWwuZm9yRWFjaChjdCA9PiBmaXJlTGF6eWxvYWQoY3QpKVxuICB9XG4gIGVsID0gZWwgfHwgZG9jdW1lbnQuYm9keVxuICBpZiAoIWVsKSB7IHJldHVybiB9XG4gIGxldCBpbWdzID0gKGVsIHx8IGRvY3VtZW50LmJvZHkpLnF1ZXJ5U2VsZWN0b3JBbGwoYFske2xhenlsb2FkQXR0cn1dYClcbiAgaWYgKGVsLmdldEF0dHJpYnV0ZShsYXp5bG9hZEF0dHIpKSB7IGltZ3MgPSBbZWxdIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgaW1nID0gaW1nc1tpXVxuICAgIGlmICh0eXBlb2YgaWdub3JlVmlzaWJpbGl0eSA9PT0gJ2Jvb2xlYW4nICYmIGlnbm9yZVZpc2liaWxpdHkpIHtcbiAgICAgIGFwcGx5U3JjKGltZywgaW1nLmdldEF0dHJpYnV0ZShsYXp5bG9hZEF0dHIpLCBpbWcuZ2V0QXR0cmlidXRlKHBsYWNlaG9sZGVyQXR0cikpXG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRWxlbWVudFZpc2libGUoaW1nLCBnZXRDdFNjcm9sbGVyKGVsKSlbMF0pIHtcbiAgICAgIGFwcGx5U3JjKGltZywgaW1nLmdldEF0dHJpYnV0ZShsYXp5bG9hZEF0dHIpLCBpbWcuZ2V0QXR0cmlidXRlKHBsYWNlaG9sZGVyQXR0cikpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogY2FjaGUgYSB0aHJvdHRsZSBsYXp5bG9hZCBmdW5jdGlvbiBmb3IgZXZlcnkgY29udGFpbmVyIGVsZW1lbnRcbiAqIG9uY2UgZm9yIGRpZmZlcmVudCB3YWl0IHRpbWVzIHNlcGFyYXRlLlxuICogICB0aGUgYXJjaGl0ZWN0dXJlIG9mIHRoaXMgY2FjaGU6XG4gKiAgICAgIGNhY2hlOiB7XG4gKiAgICAgICAgZWwuaWQ6IHtcbiAqICAgICAgICAgIHdhaXQ6IHRocm90dGxlZEZ1bmN0aW9uICgpIHsgLi4uIH1cbiAqICAgICAgICB9XG4gKiAgICAgIH1cbiAqL1xuY29uc3QgY2FjaGUgPSB7fVxubGV0IF91aWQgPSAxXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGhyb3R0bGVMYXp5bG9hZCAod2FpdCA9IDE2LCBlbCA9IGRvY3VtZW50LmJvZHkpIHtcbiAgbGV0IGlkID0gKyhlbCAmJiBlbC5kYXRhc2V0LnRocm90dGxlSWQpXG4gIGlmIChpc05hTihpZCkgfHwgaWQgPD0gMCkge1xuICAgIGlkID0gX3VpZCsrXG4gICAgZWwgJiYgZWwuc2V0QXR0cmlidXRlKCdkYXRhLXRocm90dGxlLWlkJywgaWQgKyAnJylcbiAgfVxuXG4gICFjYWNoZVtpZF0gJiYgKGNhY2hlW2lkXSA9IHt9KVxuICBjb25zdCB0aHJvdHRsZWQgPSBjYWNoZVtpZF1bd2FpdF0gfHxcbiAgICAoY2FjaGVbaWRdW3dhaXRdID0gdGhyb3R0bGUoXG4gICAgICBmaXJlTGF6eWxvYWQuYmluZCh0aGlzLCBlbCksXG4gICAgICBwYXJzZUZsb2F0KHdhaXQpLFxuICAgICAgLy8gdHJ1ZSBmb3IgY2FsbExhc3RUaW1lLlxuICAgICAgLy8gdG8gdHJpZ2dlciBvbmNlIG1vcmUgdGltZSBhZnRlciB0aGUgbGFzdCB0aHJvdHRsZWQgZnVuY3Rpb24gY2FsbGVkIHdpdGggYSBsaXR0bGUgbW9yZSBkZWxheS5cbiAgICAgIHRydWUpXG4gICAgKVxuICByZXR1cm4gdGhyb3R0bGVkXG59XG4iLCIvKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IGNvbmZpZyBmcm9tICcuLi9jb25maWcnXG5pbXBvcnQgeyBjYW1lbGl6ZSB9IGZyb20gJy4vZnVuYydcbmNvbnN0IHsgYmluZGluZ1N0eWxlTmFtZXNGb3JQeDJSZW0gfSA9IGNvbmZpZ1xuXG4vLyB3aGV0aGVyIHRvIHN1cHBvcnQgdXNpbmcgMC41cHggdG8gcGFpbnQgMXB4IHdpZHRoIGJvcmRlci5cbmxldCBfc3VwcG9ydEhhaXJsaW5lc1xuZXhwb3J0IGZ1bmN0aW9uIHN1cHBvcnRIYWlybGluZXMgKCkge1xuICBpZiAodHlwZW9mIF9zdXBwb3J0SGFpcmxpbmVzID09PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnN0IGRwciA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvXG4gICAgaWYgKGRwciAmJiBkcHIgPj0gMiAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IGRvY0VsbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFxuICAgICAgY29uc3QgdGVzdEVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICBjb25zdCBmYWtlQm9keSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2JvZHknKVxuICAgICAgY29uc3QgYmVmb3JlTm9kZSA9IGRvY0VsbS5maXJzdEVsZW1lbnRDaGlsZCB8fCBkb2NFbG0uZmlyc3RDaGlsZFxuICAgICAgdGVzdEVsbS5zdHlsZS5ib3JkZXIgPSAnMC41cHggc29saWQgdHJhbnNwYXJlbnQnXG4gICAgICBmYWtlQm9keS5hcHBlbmRDaGlsZCh0ZXN0RWxtKVxuICAgICAgZG9jRWxtLmluc2VydEJlZm9yZShmYWtlQm9keSwgYmVmb3JlTm9kZSlcbiAgICAgIF9zdXBwb3J0SGFpcmxpbmVzID0gdGVzdEVsbS5vZmZzZXRIZWlnaHQgPT09IDFcbiAgICAgIGRvY0VsbS5yZW1vdmVDaGlsZChmYWtlQm9keSlcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBfc3VwcG9ydEhhaXJsaW5lcyA9IGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiBfc3VwcG9ydEhhaXJsaW5lc1xufVxuXG5sZXQgc3VwcG9ydCA9IG51bGxcblxuZXhwb3J0IGZ1bmN0aW9uIHN1cHBvcnRTdGlja3kgKCkge1xuICBpZiAoc3VwcG9ydCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBzdXBwb3J0XG4gIH1cbiAgY29uc3QgZWxlbWVudCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBjb25zdCBlbGVtZW50U3R5bGUgPSBlbGVtZW50LnN0eWxlXG4gIGVsZW1lbnRTdHlsZS5jc3NUZXh0ID0gJ3Bvc2l0aW9uOi13ZWJraXQtc3RpY2t5O3Bvc2l0aW9uOnN0aWNreTsnXG4gIHN1cHBvcnQgPSBlbGVtZW50U3R5bGUucG9zaXRpb24uaW5kZXhPZignc3RpY2t5JykgIT09IC0xXG4gIHJldHVybiBzdXBwb3J0XG59XG5cbi8qKlxuICogZ2V0IHRyYW5zZm9ybU9ialxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJhbnNmb3JtT2JqIChlbG0pIHtcbiAgbGV0IHN0eWxlT2JqID0ge31cbiAgaWYgKCFlbG0pIHsgcmV0dXJuIHN0eWxlT2JqIH1cbiAgY29uc3QgdHJhbnNmb3JtU3RyID0gZWxtLnN0eWxlLndlYmtpdFRyYW5zZm9ybVxuICAgIHx8IGVsbS5zdHlsZS5tb3pUcmFuc2Zvcm1cbiAgICB8fCBlbG0uc3R5bGUudHJhbnNmb3JtXG4gIGlmICh0cmFuc2Zvcm1TdHIgJiYgdHJhbnNmb3JtU3RyLm1hdGNoKC8oPzogKig/OnRyYW5zbGF0ZXxyb3RhdGV8c2NhbGUpW14oXSpcXChbXihdK1xcKSkrL2kpKSB7XG4gICAgc3R5bGVPYmogPSB0cmFuc2Zvcm1TdHIudHJpbSgpLnJlcGxhY2UoLywgKy9nLCAnLCcpLnNwbGl0KCcgJykucmVkdWNlKGZ1bmN0aW9uIChwcmUsIHN0cikge1xuICAgICAgWyd0cmFuc2xhdGUnLCAnc2NhbGUnLCAncm90YXRlJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAobmV3IFJlZ0V4cChuYW1lLCAnaScpLnRlc3Qoc3RyKSkge1xuICAgICAgICAgIHByZVtuYW1lXSA9IHN0clxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgcmV0dXJuIHByZVxuICAgIH0sIHt9KVxuICB9XG4gIHJldHVybiBzdHlsZU9ialxufVxuXG4vKipcbiAqIHRyYW5zbGF0ZSBhIHRyYW5zZm9ybSBzdHJpbmcgZnJvbSBhIHRyYW5zZm9ybU9iai5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRyYW5zZm9ybVN0ciAob2JqKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLnJlZHVjZShmdW5jdGlvbiAocHJlLCBrZXkpIHtcbiAgICByZXR1cm4gcHJlICsgb2JqW2tleV0gKyAnICdcbiAgfSwgJycpXG59XG5cbi8qKlxuICogYWRkIHRyYW5zZm9ybSBzdHlsZSB0byBlbGVtZW50LlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxtXG4gKiBAcGFyYW0ge29iamVjdH0gc3R5bGU6IHRyYW5zZm9ybSBvYmplY3QsIGZvcm1hdCBpcyBsaWtlIHRoaXM6XG4gKiAgIHtcbiAqICAgICB0cmFuc2xhdGU6ICd0cmFuc2xhdGUzZCgycHgsIDJweCwgMnB4KScsXG4gKiAgICAgc2NhbGU6ICdzY2FsZSgwLjIpJyxcbiAqICAgICByb3RhdGU6ICdyb3RhdGUoMzBkZWcpJ1xuICogICB9XG4gKiBAcGFyYW0ge2Jvb2xlYW59IHJlcGxhY2U6IHdoZXRoZXIgdG8gcmVwbGFjZSBhbGwgdHJhbnNmb3JtIHByb3BlcnRpZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRUcmFuc2Zvcm0gKGVsbSwgc3R5bGUsIHJlcGxhY2UpIHtcbiAgaWYgKCFzdHlsZSkgeyByZXR1cm4gfVxuICBsZXQgc3R5bGVPYmogPSB7fVxuICBpZiAoIXJlcGxhY2UpIHtcbiAgICBzdHlsZU9iaiA9IGdldFRyYW5zZm9ybU9iaihlbG0pXG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gc3R5bGUpIHtcbiAgICBjb25zdCB2YWwgPSBzdHlsZVtrZXldXG4gICAgaWYgKHZhbCkge1xuICAgICAgc3R5bGVPYmpba2V5XSA9IHZhbFxuICAgIH1cbiAgfVxuICBjb25zdCByZXNTdHIgPSBnZXRUcmFuc2Zvcm1TdHIoc3R5bGVPYmopXG4gIGVsbS5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSByZXNTdHJcbiAgZWxtLnN0eWxlLm1velRyYW5zZm9ybSA9IHJlc1N0clxuICBlbG0uc3R5bGUudHJhbnNmb3JtID0gcmVzU3RyXG59XG5cbi8qKlxuICogY29weSBhIHRyYW5zZm9ybSBiZWhhdmlvdXIgZnJvbSBvbmUgZWxlbWVudCB0byBhbm90aGVyLlxuICoga2V5IGNvdWxkIGJlOiAndHJhbnNsYXRlJyB8ICdzY2FsZScgfCAncm90YXRlJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gY29weVRyYW5zZm9ybSAoZnJvbSwgdG8sIGtleSkge1xuICBsZXQgc3RyXG4gIGlmICgha2V5KSB7XG4gICAgc3RyID0gZnJvbS5zdHlsZS53ZWJraXRUcmFuc2Zvcm1cbiAgICAgIHx8IGZyb20uc3R5bGUubW96VHJhbnNmb3JtXG4gICAgICB8fCBmcm9tLnN0eWxlLnRyYW5zZm9ybVxuICB9XG4gIGVsc2Uge1xuICAgIGNvbnN0IGZyb21PYmogPSBnZXRUcmFuc2Zvcm1PYmooZnJvbSlcbiAgICBpZiAoIWZyb21PYmpba2V5XSkgeyByZXR1cm4gfVxuICAgIGNvbnN0IHRvT2JqID0gZ2V0VHJhbnNmb3JtT2JqKHRvKVxuICAgIHRvT2JqW2tleV0gPSBmcm9tT2JqW2tleV1cbiAgICBzdHIgPSBnZXRUcmFuc2Zvcm1TdHIodG9PYmopXG4gIH1cbiAgdG8uc3R5bGUud2Via2l0VHJhbnNmb3JtID0gc3RyXG4gIHRvLnN0eWxlLm1velRyYW5zZm9ybSA9IHN0clxuICB0by5zdHlsZS50cmFuc2Zvcm0gPSBzdHJcbn1cblxuLyoqXG4gKiBnZXQgY29sb3IncyByLCBnLCBiIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIHN1cHBvcnQgYWxsIGtpbmRzIG9mIHZhbHVlIG9mIGNvbG9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmdiIChjb2xvcikge1xuICBjb25zdCBoYXhSZWcgPSAvIyhbXFxkYS1mQS1GXXsyfSkoW1xcZGEtZkEtRl17Mn0pKFtcXGRhLWZBLUZdezJ9KS9cbiAgY29uc3QgcmdiUmVnID0gL3JnYlxcKChcXGQrKSxcXHMqKFxcZCspLFxccyooXFxkKylcXCkvXG4gIGNvbnN0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJylcbiAgY29uc3QgYm9keSA9IGRvY3VtZW50LmJvZHlcbiAgc3Bhbi5zdHlsZS5jc3NUZXh0ID0gYGNvbG9yOiAke2NvbG9yfTsgd2lkdGg6IDBweDsgaGVpZ2h0OiAwcHg7YFxuICBib2R5ICYmIGJvZHkuYXBwZW5kQ2hpbGQoc3BhbilcbiAgY29sb3IgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzcGFuKS5jb2xvciArICcnXG4gIGJvZHkgJiYgYm9keS5yZW1vdmVDaGlsZChzcGFuKVxuXG4gIGxldCBtYXRjaFxuICBtYXRjaCA9IGNvbG9yLm1hdGNoKGhheFJlZylcbiAgaWYgKG1hdGNoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHI6IHBhcnNlSW50KG1hdGNoWzFdLCAxNiksXG4gICAgICBnOiBwYXJzZUludChtYXRjaFsyXSwgMTYpLFxuICAgICAgYjogcGFyc2VJbnQobWF0Y2hbM10sIDE2KVxuICAgIH1cbiAgfVxuICBtYXRjaCA9IGNvbG9yLm1hdGNoKHJnYlJlZylcbiAgaWYgKG1hdGNoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHI6IHBhcnNlSW50KG1hdGNoWzFdKSxcbiAgICAgIGc6IHBhcnNlSW50KG1hdGNoWzJdKSxcbiAgICAgIGI6IHBhcnNlSW50KG1hdGNoWzNdKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIGdldCBzdHlsZSBzaGVldCB3aXRoIG93bmVyIG5vZGUncyBpZFxuICogQHBhcmFtIHtzdHJpbmd9IGlkIG93bmVyIG5vZGUgaWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdHlsZVNoZWV0QnlJZCAoaWQpIHtcbiAgaWYgKCFpZCkgeyByZXR1cm4gfVxuICBjb25zdCBzdHlsZVNoZWV0cyA9IGRvY3VtZW50LnN0eWxlU2hlZXRzXG4gIGNvbnN0IGxlbiA9IHN0eWxlU2hlZXRzLmxlbmd0aFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3Qgc3R5bGVTaGVldCA9IHN0eWxlU2hlZXRzW2ldXG4gICAgaWYgKHN0eWxlU2hlZXQub3duZXJOb2RlLmlkID09PSBpZCkge1xuICAgICAgcmV0dXJuIHN0eWxlU2hlZXRcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Q2hpbGRyZW5Ub3RhbFdpZHRoIChjaGlsZHJlbikge1xuICBjb25zdCBsZW4gPSBjaGlsZHJlbi5sZW5ndGhcbiAgbGV0IHRvdGFsID0gMFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdG90YWwgKz0gY2hpbGRyZW5baV0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGhcbiAgfVxuICByZXR1cm4gdG90YWxcbn1cbi8qKlxuICogZ2V0IHRvdGFsIGNvbnRlbnQgd2lkdGggb2YgdGhlIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbG1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJhbmdlV2lkdGggKGVsbSkge1xuICBjb25zdCBjaGlsZHJlbiA9IGVsbS5jaGlsZHJlblxuICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIGVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aFxuICB9XG4gIGlmICghUmFuZ2UpIHtcbiAgICByZXR1cm4gZ2V0Q2hpbGRyZW5Ub3RhbFdpZHRoKGNoaWxkcmVuKVxuICB9XG4gIGNvbnN0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKVxuICBpZiAoIXJhbmdlLnNlbGVjdE5vZGVDb250ZW50cykge1xuICAgIHJldHVybiBnZXRDaGlsZHJlblRvdGFsV2lkdGgoY2hpbGRyZW4pXG4gIH1cbiAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKGVsbSlcbiAgcmV0dXJuIHJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoXG59XG5cbi8qKlxuICogcHgycmVtIGFuZCBjYW1lbGl6ZSBrZXlzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3R5bGVPYmplY3QycmVtIChzdHlsZSwgcm9vdFZhbHVlKSB7XG4gIGNvbnN0IG9iaiA9IHt9XG4gIGZvciAoY29uc3QgayBpbiBzdHlsZSkge1xuICAgIGNvbnN0IGNhbUsgPSBjYW1lbGl6ZShrKVxuICAgIGlmIChiaW5kaW5nU3R5bGVOYW1lc0ZvclB4MlJlbS5pbmRleE9mKGNhbUspID4gLTEpIHtcbiAgICAgIG9ialtjYW1LXSA9IHB4MnJlbShzdHlsZVtrXSArICcnLCByb290VmFsdWUpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgb2JqW2NhbUtdID0gc3R5bGVba11cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9ialxufVxuXG5leHBvcnQgZnVuY3Rpb24gcHgycmVtIChweCwgcm9vdFZhbHVlKSB7XG4gIHJldHVybiBweC5yZXBsYWNlKC8oWystXT9cXGQrKD86LlxcZCopPykoW3B8d114KS9nLCBmdW5jdGlvbiAoJDAsICQxLCAkMikge1xuICAgIGlmICgkMiA9PT0gJ3d4JykgeyAvLyAnd3gnIC0+IHB4XG4gICAgICByZXR1cm4gJDEgKyAncHgnXG4gICAgfVxuICAgIGVsc2UgeyAgLy8gJ3B4JyAtPiByZW1cbiAgICAgIGNvbnN0IHB4VmFsID0gcGFyc2VGbG9hdCgkMSlcbiAgICAgIGNvbnN0IHNpZ24gPSBweFZhbCA+IDBcbiAgICAgICAgPyAxIDogcHhWYWwgPCAwID9cbiAgICAgICAgICAtMSA6IDBcbiAgICAgIGlmIChNYXRoLmFicyhweFZhbCkgPD0gMSkge1xuICAgICAgICByZXR1cm4gc3VwcG9ydEhhaXJsaW5lcygpXG4gICAgICAgICAgPyBgJHtzaWduICogMC41fXB4YFxuICAgICAgICAgIDogYCR7c2lnbiAqIDF9cHhgXG4gICAgICB9XG4gICAgICByZXR1cm4gcHhWYWxcbiAgICAgICAgLyAocm9vdFZhbHVlIHx8IHdpbmRvdy53ZWV4LmNvbmZpZy5lbnYucmVtKVxuICAgICAgICArICdyZW0nXG4gICAgfVxuICB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtMnB4IChyZW0sIHJvb3RWYWx1ZSkge1xuICByZXR1cm4gcmVtLnJlcGxhY2UoLyhbKy1dP1xcZCsoPzouXFxkKik/KXJlbS9nLCBmdW5jdGlvbiAoJDAsICQxKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoJDEpXG4gICAgICAqIChyb290VmFsdWUgfHwgd2luZG93LndlZXguY29uZmlnLmVudi5yZW0pXG4gICAgICArICdweCdcbiAgfSlcbn1cbiIsIi8qXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZXhwb3J0ICogZnJvbSAnLi9mdW5jJ1xuZXhwb3J0ICogZnJvbSAnLi9ldmVudCdcbmV4cG9ydCAqIGZyb20gJy4vY29tcG9uZW50J1xuZXhwb3J0ICogZnJvbSAnLi9sYXp5bG9hZCdcbmV4cG9ydCAqIGZyb20gJy4vc3R5bGUnXG5leHBvcnQgKiBmcm9tICcuL3R5cGUnXG4iLCIvKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCAnLi4vbGliL2VudmQnXG5cbmltcG9ydCB7IGluaXQgYXMgaW5pdFZpZXdwb3J0IH0gZnJvbSAnLi92aWV3cG9ydCdcbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJy4uL3V0aWxzJ1xuXG4vKipcbiAqIGdldCBXWEVudmlyb25tZW50IGluZm8uXG4gKiBAcGFyYW0gIHtvYmplY3R9IHZpZXdwb3J0SW5mbzogaW5mbyBhYm91dCB2aWV3cG9ydC5cbiAqIEBwYXJhbSAge29iamVjdH0gZW52SW5mbzogaW5mbyBwYXJzZWQgZnJvbSBsaWIuZW52LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdEVudiAodmlld3BvcnRJbmZvLCBlbnZJbmZvKSB7XG4gIGNvbnN0IGJyb3dzZXJOYW1lID0gZW52SW5mby5icm93c2VyID8gZW52SW5mby5icm93c2VyLm5hbWUgOiBuYXZpZ2F0b3IuYXBwTmFtZVxuICBjb25zdCBicm93c2VyVmVyc2lvbiA9IGVudkluZm8uYnJvd3NlciA/IGVudkluZm8uYnJvd3Nlci52ZXJzaW9uLnZhbCA6IG51bGxcbiAgbGV0IG9zTmFtZSA9IGVudkluZm8ub3MubmFtZVxuICBpZiAob3NOYW1lLm1hdGNoKC8oaVBob25lfGlQYWR8aVBvZCkvaSkpIHtcbiAgICBvc05hbWUgPSAnaU9TJ1xuICB9XG4gIGVsc2UgaWYgKG9zTmFtZS5tYXRjaCgvQW5kcm9pZC9pKSkge1xuICAgIG9zTmFtZSA9ICdhbmRyb2lkJ1xuICB9XG4gIGNvbnN0IG9zVmVyc2lvbiA9IGVudkluZm8ub3MudmVyc2lvbi52YWxcbiAgY29uc3QgZW52ID0ge1xuICAgIHBsYXRmb3JtOiAnV2ViJyxcbiAgICB3ZWV4VmVyc2lvbjogJ3Byb2Nlc3MuZW52LldFRVhfVkVSU0lPTicsXG4gICAgdXNlckFnZW50OiBuYXZpZ2F0b3IudXNlckFnZW50LFxuICAgIGFwcE5hbWU6IGJyb3dzZXJOYW1lLFxuICAgIGFwcFZlcnNpb246IGJyb3dzZXJWZXJzaW9uLFxuICAgIG9zTmFtZSxcbiAgICBvc1ZlcnNpb24sXG4gICAgZGV2aWNlTW9kZWw6IGVudkluZm8ub3MubmFtZSB8fCBudWxsXG4gIH1cbiAgLyoqXG4gICAqIHZpZXdwb3J0SW5mbzogc2NhbGUsIGRldmljZVdpZHRoLCBkZXZpY2VIZWlnaHQuIGRwclxuICAgKi9cbiAgcmV0dXJuIGV4dGVuZCh2aWV3cG9ydEluZm8sIGVudilcbn1cblxuLy8gY29uc3Qgdmlld3BvcnRJbmZvID0gaW5pdFZpZXdwb3J0KClcblxuLy8gNzUwIGJ5IGRlZmF1bHQgY3VycmVudGx5XG4vLyBjb25zdCBzY2FsZSA9IHZpZXdwb3J0SW5mby5zY2FsZVxuXG4vLyBjb25zdCB1bml0cyA9IHtcbi8vICAgUkVNOiAxMiAqIHNjYWxlLFxuLy8gICBWVzogdmlld3BvcnRJbmZvLmRldmljZVdpZHRoIC8gMTAwLFxuLy8gICBWSDogdmlld3BvcnRJbmZvLmRldmljZUhlaWdodCAvIDEwMCxcbi8vICAgVk1JTjogTWF0aC5taW4odmlld3BvcnRJbmZvLmRldmljZVdpZHRoLCB2aWV3cG9ydEluZm8uZGV2aWNlSGVpZ2h0KSAvIDEwMCxcbi8vICAgVk1BWDogTWF0aC5tYXgodmlld3BvcnRJbmZvLmRldmljZVdpZHRoLCB2aWV3cG9ydEluZm8uZGV2aWNlSGVpZ2h0KSAvIDEwMCxcbi8vICAgQ006IDk2IC8gMi41NCAqIHNjYWxlLFxuLy8gICBNTTogOTYgLyAyNS40ICogc2NhbGUsXG4vLyAgIFE6IDk2IC8gMjUuNCAvIDQgKiBzY2FsZSxcbi8vICAgSU46IDk2ICogc2NhbGUsXG4vLyAgIFBUOiA5NiAvIDcyICogc2NhbGUsXG4vLyAgIFBDOiA5NiAvIDYgKiBzY2FsZSxcbi8vICAgUFg6IHNjYWxlXG4vLyB9XG5cbi8vIE9iamVjdC5mcmVlemUodW5pdHMpXG4vLyBPYmplY3QuZnJlZXplKGVudilcblxuLy8gd2luZG93LkNTU19VTklUID0gdW5pdHNcbndpbmRvdy5XWEVudmlyb25tZW50ID0gaW5pdEVudihpbml0Vmlld3BvcnQoKSwgd2luZG93LmxpYi5lbnYpXG4iLCIvKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qIGdsb2JhbCBWdWUgKi9cblxuaW1wb3J0ICcuL3d4LWVudidcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uL3V0aWxzJ1xuXG5jb25zdCB3ZWV4TW9kdWxlcyA9IHt9XG5jb25zdCBfcm9vdHMgPSBbXVxuXG5jb25zdCB3ZWV4ID0ge1xuICBfX3Z1ZV9fOiBudWxsLFxuICB1dGlscyxcbiAgLy8gdW5pdHM6IHdpbmRvdy5DU1NfVU5JVCxcbiAgY29uZmlnOiB7XG4gICAgZW52OiB3aW5kb3cuV1hFbnZpcm9ubWVudCxcbiAgICBidW5kbGVVcmw6IGxvY2F0aW9uLmhyZWZcbiAgfSxcblxuICBfY29tcG9uZW50czoge30sXG4gIF9tb2R1bGVzOiB3ZWV4TW9kdWxlcyxcblxuICBfbWV0YToge1xuICAgIG1vdW50ZWQ6IHt9LFxuICAgIHVwZGF0ZWQ6IHt9LFxuICAgIGRlc3Ryb3llZDoge30sXG4gICAgcmVxdWlyZWRNb2R1bGVzOiB7fSxcbiAgICBhcGlDYWxsZWQ6IHt9LFxuICAgIHBlcmY6IHt9XG4gIH0sXG5cbiAgZG9jdW1lbnQ6IHtcbiAgICBib2R5OiB7fVxuICB9LFxuXG4gIHJlcXVpcmVNb2R1bGUgKG1vZHVsZU5hbWUpIHtcbiAgICBjb25zdCBtZXRhTW9kID0gd2VleC5fbWV0YS5yZXF1aXJlZE1vZHVsZXNcbiAgICBpZiAoIW1ldGFNb2RbbW9kdWxlTmFtZV0pIHtcbiAgICAgIG1ldGFNb2RbbW9kdWxlTmFtZV0gPSAwXG4gICAgfVxuICAgIG1ldGFNb2RbbW9kdWxlTmFtZV0rK1xuICAgIHJldHVybiB3ZWV4TW9kdWxlc1ttb2R1bGVOYW1lXVxuICB9LFxuXG4gIHJlZ2lzdGVyTW9kdWxlICguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJBcGlNb2R1bGUoLi4uYXJncylcbiAgfSxcblxuICBzdXBwb3J0IChmZWF0dXJlID0gJycpIHtcbiAgICBjb25zdCBtYXRjaCA9IChmZWF0dXJlICsgJycpLm1hdGNoKC9AKGNvbXBvbmVudHxtb2R1bGUpXFwvKFxcdyspKC5cXHcrKT8vKVxuICAgIGlmIChtYXRjaCkge1xuICAgICAgY29uc3QgdHlwZSA9IG1hdGNoWzFdXG4gICAgICBjb25zdCBtb2QgPSBtYXRjaFsyXVxuICAgICAgbGV0IG1ldGhvZCA9IG1hdGNoWzNdXG4gICAgICBtZXRob2QgPSBtZXRob2QgJiYgbWV0aG9kLnJlcGxhY2UoL15cXC4vLCAnJylcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdjb21wb25lbnQnOlxuICAgICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5fY29tcG9uZW50c1ttb2RdICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICBjYXNlICdtb2R1bGUnOlxuICAgICAgICAgIGNvbnN0IG1vZHVsZSA9IHdlZXhNb2R1bGVzW21vZF1cbiAgICAgICAgICByZXR1cm4gbW9kdWxlICYmIG1ldGhvZCA/ICEhbW9kdWxlW21ldGhvZF0gOiAhIW1vZHVsZVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihgW3Z1ZS1yZW5kZXJdIGludmFsaWQgYXJndW1lbnQgZm9yIHdlZXguc3VwcG9ydDogJHtmZWF0dXJlfWApXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBuZXcgdnVlIGluc3RhbmNlIGluIHRoaXMgd2VleCBpbnN0YW5jZS4gUHV0IGl0cyByb290IGVsZW1lbnQgaW50byB3ZWV4LmRvY3VtZW50LmJvZHkuY2hpbGRyZW4sIHNvXG4gICAqIHRoYXQgdXNlciBjYW4gdXNlIHdlZXguZG9jdW1lbnQuYm9keSB0byB3YWxrIHRocm91Z2ggYWxsIGRvbSBzdHJ1Y3R1cmVzIGluIGFsbCB2dWUgaW5zdGFuY2VzIGluIHRoZSBwYWdlLlxuICAgKi9cbiAgcmVnaXN0ZXJWdWVJbnN0YW5jZSAoaW5zdGFuY2UpIHtcbiAgICBpZiAoIWluc3RhbmNlIGluc3RhbmNlb2YgVnVlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgW3Z1ZS1yZW5kZXJdIHJlZ2lzdGVyVnVlSW5zdGFuY2U6IGludmFsaWQgaW5zdGFuY2UsIG5vdCBhIHZ1ZSBpbnN0YW5jZS5gKVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbnN0IHJvb3QgPSBpbnN0YW5jZS4kcm9vdFxuICAgIGlmICghcm9vdCB8fCAhcm9vdC4kZWwpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBbdnVlLXJlbmRlcl0gcmVnaXN0ZXJWdWVJbnN0YW5jZTogaW5zdGFuY2UgaGFzIG5vIHJvb3QuYClcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0aGlzLmRvY3VtZW50LmJvZHkuY2hpbGRyZW4ucHVzaChyb290LiRlbClcbiAgfSxcblxuICAvLyBAZGVwcmVjYXRlZFxuICByZXF1aXJlICguLi5hcmdzKSB7XG4gICAgY29uc29sZS5sb2coYFtWdWUgUmVuZGVyXSBcIndlZXgucmVxdWlyZVwiIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgXCJ3ZWV4LnJlcXVpcmVNb2R1bGVcIiBpbnN0ZWFkLmApXG4gICAgcmV0dXJuIHRoaXMucmVxdWlyZU1vZHVsZSguLi5hcmdzKVxuICB9LFxuXG4gIC8vIEBkZXByZWNhdGVkXG4gIC8vIFRPRE86IHJlbmFtZSB0byByZWdpc3Rlck1vZHVsZVxuICByZWdpc3RlckFwaU1vZHVsZSAobmFtZSwgbW9kdWxlLCBtZXRhKSB7XG4gICAgaWYgKCF3ZWV4TW9kdWxlc1tuYW1lXSkge1xuICAgICAgd2VleE1vZHVsZXNbbmFtZV0gPSB7fVxuICAgIH1cbiAgICBpZiAoISFtZXRhICYmIG1ldGEucmVnaXN0ZXJUeXBlID09PSAnYXNzaWdubWVudCcpIHtcbiAgICAgIHdlZXhNb2R1bGVzW25hbWVdID0gbW9kdWxlXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gbW9kdWxlKSB7XG4gICAgICAgIGlmIChtb2R1bGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIHdlZXhNb2R1bGVzW25hbWVdW2tleV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsZWQgPSB3ZWV4Ll9tZXRhLmFwaUNhbGxlZFxuICAgICAgICAgICAgaWYgKCFjYWxsZWRbbmFtZV0pIHtcbiAgICAgICAgICAgICAgY2FsbGVkW25hbWVdID0ge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhbGxlZE1vZCA9IGNhbGxlZFtuYW1lXVxuICAgICAgICAgICAgaWYgKCFjYWxsZWRNb2Rba2V5XSkge1xuICAgICAgICAgICAgICBjYWxsZWRNb2Rba2V5XSA9IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxlZE1vZFtrZXldKytcbiAgICAgICAgICAgIHJldHVybiBtb2R1bGVba2V5XS5hcHBseSh3ZWV4LCBhcmd1bWVudHMpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHJlZ2lzdGVyQ29tcG9uZW50IChuYW1lLCBjb21wb25lbnQpIHtcbiAgICBpZiAoIXRoaXMuX192dWVfXykge1xuICAgICAgcmV0dXJuIGNvbnNvbGUubG9nKCdbVnVlIFJlbmRlcl0gVnVlIGlzIG5vdCBmb3VuZC4gUGxlYXNlIGltcG9ydCBWdWUuanMgYmVmb3JlIHJlZ2lzdGVyIGEgY29tcG9uZW50LicpXG4gICAgfVxuICAgIHRoaXMuX2NvbXBvbmVudHNbbmFtZV0gPSAwXG4gICAgaWYgKGNvbXBvbmVudC5fY3NzKSB7XG4gICAgICBjb25zdCBjc3MgPSBjb21wb25lbnQuX2Nzcy5yZXBsYWNlKC9cXGJbKy1dP1tcXGQuXStyZW07P1xcYi9nLCBmdW5jdGlvbiAobSkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChtKSAqIDc1ICogd2VleC5jb25maWcuZW52LnNjYWxlICsgJ3B4J1xuICAgICAgfSlcbiAgICAgIHV0aWxzLmFwcGVuZENzcyhjc3MsIGB3ZWV4LWNtcC0ke25hbWV9YClcbiAgICAgIGRlbGV0ZSBjb21wb25lbnQuX2Nzc1xuICAgIH1cbiAgICB0aGlzLl9fdnVlX18uY29tcG9uZW50KG5hbWUsIGNvbXBvbmVudClcbiAgfSxcblxuICAvLyBAZGVwcmVjYXRlZFxuICBnZXRSb290ICgpIHt9LFxuXG4gIC8vIEBkZXByZWNhdGVkXG4gIHNlbmRlcjoge1xuICAgIHBlcmZvcm1DYWxsYmFjayAoY2FsbGJhY2ssIGRhdGEsIGtlZXBBbGl2ZSkge1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZGF0YSlcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9LFxuXG4gIC8vIEBkZXByZWNhdGVkXG4gIGluc3RhbGwgKG1vZHVsZSkge1xuICAgIG1vZHVsZS5pbml0KHRoaXMpXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHdlZXguZG9jdW1lbnQuYm9keSwgJ2NoaWxkcmVuJywge1xuICBnZXQgKCkgeyByZXR1cm4gX3Jvb3RzIH1cbn0pXG5cbjsgWydvbicsICdvbmNlJywgJ29mZicsICdlbWl0J10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIHdlZXhbbWV0aG9kXSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgaWYgKCF0aGlzLl92dWUpIHtcbiAgICAgIHRoaXMuX3Z1ZSA9IG5ldyB0aGlzLl9fdnVlX18oKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdnVlW2AkJHttZXRob2R9YF0oLi4uYXJncylcbiAgfVxufSlcblxuZXhwb3J0IGRlZmF1bHQgd2VleFxuIiwiLypcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQge1xuICAvLyBjYW1lbGl6ZUtleXMsXG4gIC8vIGh5cGhlbmF0ZUtleXMsXG4gIGV4dGVuZCxcbiAgZXh0ZW5kVHJ1dGh5XG4gIC8vIHRyaW1Db21tZW50LFxuICAvLyBub3JtYWxpemVTdHlsZSxcbiAgLy8gYXV0b1ByZWZpeCxcbiAgLy8gaXNBcnJheSxcbiAgLy8gZ2V0UGFyZW50U2Nyb2xsZXIsXG4gIC8vIHN1cHBvcnRTdGlja3ksXG4gIC8vIGFwcGVuZENzc1xufSBmcm9tICcuLi91dGlscydcblxuZnVuY3Rpb24gZ2V0SW5saW5lU3R5bGUgKHZub2RlKSB7XG4gIGNvbnN0IGRhdGEgPSB2bm9kZS5kYXRhIHx8IHt9XG4gIHJldHVybiBleHRlbmRUcnV0aHkoe30sIGRhdGEuc3RhdGljU3R5bGUsIGRhdGEuc3R5bGUpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0Q29tcG9uZW50U3R5bGUgKGNvbnRleHQpIHtcbiAgcmV0dXJuIGdldENvbXBvbmVudElubGluZVN0eWxlKGNvbnRleHQpXG4gIC8vIHJldHVybiBnZXRDb21wb25lbnRTdHlsZShjb250ZXh0LCB0cnVlKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29tcG9uZW50SW5saW5lU3R5bGUgKGNvbnRleHQpIHtcbiAgbGV0IHZub2RlID0gY29udGV4dCAmJiBjb250ZXh0LiR2bm9kZVxuICBpZiAoIXZub2RlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcignW3Z1ZS1yZW5kZXJdIGdldENvbXBvbmVudFN0eWxlIGZhaWxlZDogbm8gJHZub2RlIGluIGNvbnRleHQuJylcbiAgICB9XG4gICAgcmV0dXJuIHt9XG4gIH1cbiAgY29uc3Qgc3R5bGUgPSB7fVxuICB3aGlsZSAodm5vZGUpIHtcbiAgICBleHRlbmQoc3R5bGUsIGdldElubGluZVN0eWxlKHZub2RlKSlcbiAgICB2bm9kZSA9IHZub2RlLnBhcmVudFxuICB9XG4gIHJldHVybiBzdHlsZVxufVxuXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgdHJhbnNmb3JtIChzdHlsZSkge1xuICAgIGNvbnN0IGxpbmVzID0gc3R5bGUubGluZXNcbiAgICBpZiAobGluZXMgPiAwKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihzdHlsZSwge1xuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgIHRleHRPdmVyZmxvdzogJ2VsbGlwc2lzJyxcbiAgICAgICAgV2Via2l0TGluZUNsYW1wOiBsaW5lc1xuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlXG4gIH1cbn1cbiIsImNvbnN0IHRhZ01hcCA9IHtcbiAgdGV4dDogcmVxdWlyZSgnLi90ZXh0Jylcbn1cblxuZXhwb3J0cy5nZXRUcmFuc2Zvcm1lciA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgcmV0dXJuIHRhZ01hcFt0YWddXG59XG4iLCJjb25zdCB7IGdldENvbXBpbGVyIH0gPSByZXF1aXJlKCcuL2NvbXBpbGVyJylcbmNvbnN0IHsgZ2V0VHJhbnNmb3JtZXIgfSA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtZXInKVxuXG5leHBvcnRzLmdldENvbXBpbGVyID0gZ2V0Q29tcGlsZXJcbmV4cG9ydHMuZ2V0VHJhbnNmb3JtZXIgPSBnZXRUcmFuc2Zvcm1lclxuIiwiLypcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBnZXRUcmFuc2Zvcm1lciB9IGZyb20gJ3d4di10cmFuc2Zvcm1lcidcbmltcG9ydCB7XG4gIGlzQXJyYXksXG4gIGlzRGVmLFxuICBpc1ByaW1pdGl2ZSxcbiAgZGlzcGF0Y2hOYXRpdmVFdmVudFxufSBmcm9tICcuLi91dGlscydcbmltcG9ydCBjb25maWcgZnJvbSAnLi4vY29uZmlnJ1xuXG5jb25zdCB7XG4gIHdlZXhCdWlsdEluQ29tcG9uZW50c1xufSA9IGNvbmZpZ1xuXG5jb25zdCBhcHBlYXJFdmVudHNNYXAgPSB7XG4gIGFwcGVhcjogJ2FwcGVhcicsXG4gIGRpc2FwcGVhcjogJ2Rpc2FwcGVhcicsXG4gIG9mZnNldEFwcGVhcjogJ29mZnNldC1hcHBlYXInLFxuICBvZmZzZXREaXNhcHBlYXI6ICdvZmZzZXQtZGlzYXBwZWFyJ1xufVxuXG4vKipcbiAqIHJlbW92ZSB0ZXh0IG5vZGVzIGluIHRoZSBub2RlcyBhcnJheS5cbiAqIEBwYXJhbSAge0FycmF5fSBub2Rlc1xuICogQHJldHVybiB7QXJyYXl9IG5vZGVzIHdpdGhvdXQgdGV4dCBub2Rlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyaW1UZXh0Vk5vZGVzICh2bm9kZXMpIHtcbiAgaWYgKGlzQXJyYXkodm5vZGVzKSkge1xuICAgIHJldHVybiB2bm9kZXMuZmlsdGVyKHZub2RlID0+ICEhdm5vZGUudGFnKVxuICB9XG4gIHJldHVybiB2bm9kZXNcbn1cblxuLyoqXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogbWV0aG9kIHRvIHRyYW5zZm9ybSBhcmdzIHBhc3NlZCB0byBjcmVhdGVFbGVtZW50XG4gKiBmb3IgcmVuZGVyIGZ1bmN0aW9uLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vLyBzaG91bGQgc2hhcmUgd2l0aCBwcmVjb21waWxlci5cbmNvbnN0IG1ldGFNYXAgPSB7XG4gIGZpZ3VyZTogWydpbWcnLCAnaW1hZ2UnLCAnZmlndXJlJ10sXG4gIHA6IFsndGV4dCcsICdwJ10sXG4gIGRpdjogWydjb250YWluZXInLCAnZGl2J10sXG4gIHNlY3Rpb246IFsnY2VsbCddXG59XG5cbmNvbnN0IGNoZWNrTWFwID0gT2JqZWN0LmtleXMobWV0YU1hcCkucmVkdWNlKGZ1bmN0aW9uIChwcmUsIHRhcmdldFRhZykge1xuICBjb25zdCB0YWdBcnIgPSBtZXRhTWFwW3RhcmdldFRhZ11cbiAgdGFnQXJyLmZvckVhY2goZnVuY3Rpb24gKGZyb21UYWcpIHtcbiAgICBwcmVbZnJvbVRhZ10gPSB0YXJnZXRUYWdcbiAgfSlcbiAgcmV0dXJuIHByZVxufSwge30pXG5cbmNvbnN0IF9zdGRUYWdNYXAgPSB7XG4gIHA6ICd0ZXh0JyxcbiAgZmlndXJlOiAnaW1hZ2UnLFxuICBzZWN0aW9uOiAnY2VsbCdcbn1cbmZ1bmN0aW9uIGdldFN0ZFRhZyAodGFnKSB7XG4gIGNvbnN0IHN0ZFRhZyA9IF9zdGRUYWdNYXBbdGFnXVxuICByZXR1cm4gc3RkVGFnIHx8IHRhZ1xufVxuXG5jb25zdCBwcmVjb21waWxlZENsYXNzTWFwID0ge1xuICBkaXY6IHtcbiAgICAnd2VleC1jdCc6IHRydWUsXG4gICAgJ3dlZXgtZGl2JzogdHJ1ZVxuICB9LFxuICBpbWFnZToge1xuICAgICd3ZWV4LWVsJzogdHJ1ZSxcbiAgICAnd2VleC1pbWFnZSc6IHRydWVcbiAgfSxcbiAgdGV4dDoge1xuICAgICd3ZWV4LWVsJzogdHJ1ZSxcbiAgICAnd2VleC10ZXh0JzogdHJ1ZVxuICB9LFxuICBjZWxsOiB7XG4gICAgJ3dlZXgtY3QnOiB0cnVlLFxuICAgICd3ZWV4LWNlbGwnOiB0cnVlXG4gIH0sXG4gIGE6IHtcbiAgICAnd2VleC1jdCc6IHRydWUsXG4gICAgJ3dlZXgtYSc6IHRydWVcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ByZWNvbXBpbGVkICh0YWcpIHtcbiAgcmV0dXJuIGNvbmZpZy53ZWV4QnVpbHRJbkNvbXBvbmVudHMuaW5kZXhPZih0YWcpID4gLTFcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVJlbmRlciAoY3R4LCBoKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoXG4gICAgdGFnLFxuICAgIGRhdGEsXG4gICAgY2hpbGRyZW4sXG4gICAgbm9ybWFsaXphdGlvblR5cGUsXG4gICAgYWx3YXlzTm9ybWFsaXplXG4gICkge1xuICAgIGlmIChpc0FycmF5KGRhdGEpIHx8IGlzUHJpbWl0aXZlKGRhdGEpKSB7XG4gICAgICBub3JtYWxpemF0aW9uVHlwZSA9IGNoaWxkcmVuXG4gICAgICBjaGlsZHJlbiA9IGRhdGFcbiAgICAgIGRhdGEgPSB7fVxuICAgIH1cbiAgICBpZiAoIWlzRGVmKGRhdGEpKSB7XG4gICAgICBkYXRhID0ge31cbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEuaXMpKSB7XG4gICAgICB0YWcgPSBkYXRhLmlzXG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGFnID09PSAnc3RyaW5nJykge1xuICAgICAgZGF0YSA9IHRyYW5zZm9ybURhdGEodGhpcywgZGF0YSwgdGFnKVxuICAgICAgdGFnID0gdHJhbnNmb3JtVGFnKHRoaXMsIHRhZylcbiAgICB9XG4gICAgZWxzZSB7ICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgICAgZGF0YSA9IHRyYW5zZm9ybURhdGEodGhpcywgZGF0YSwgdW5kZWZpbmVkKVxuICAgIH1cbiAgICByZXR1cm4gaC5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgIHRhZyxcbiAgICAgIGRhdGEsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIG5vcm1hbGl6YXRpb25UeXBlLFxuICAgICAgYWx3YXlzTm9ybWFsaXplXG4gICAgKVxuICB9LmJpbmQoY3R4KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtVGFnIChjdHgsIHRhZykge1xuICBjb25zdCBlbGVtZW50VGFnID0gY2hlY2tNYXBbdGFnXVxuICByZXR1cm4gZWxlbWVudFRhZyB8fCB0YWdcbn1cblxuLyoqXG4gKiBUZWxsIHdoZXRoZXIgYSBlbGVtZW50IGlzIGNvbnRhaW5lZCBpbiBhIGVsZW1lbnQgd2hvIGhhc1xuICogYSBhdHRyaWJ1dGUgJ2J1YmJsZSc9dHJ1ZS5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXG4gKi9cbi8vIGZ1bmN0aW9uIGluQnViYmxlIChlbCkge1xuLy8gICBpZiAodHlwZW9mIGVsLl9pbkJ1YmJsZSA9PT0gJ2Jvb2xlYW4nKSB7XG4vLyAgICAgcmV0dXJuIGVsLl9pbkJ1YmJsZVxuLy8gICB9XG4vLyAgIGNvbnN0IHBhcmVudHMgPSBbXVxuLy8gICBsZXQgcGFyZW50ID0gZWwucGFyZW50RWxlbWVudFxuLy8gICBsZXQgaW5CdWJibGVcbi8vICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQgIT09IGRvY3VtZW50LmJvZHkpIHtcbi8vICAgICBpZiAodHlwZW9mIHBhcmVudC5faW5CdWJibGUgPT09ICdib29sZWFuJykge1xuLy8gICAgICAgaW5CdWJibGUgPSBwYXJlbnQuX2luQnViYmxlXG4vLyAgICAgICBicmVha1xuLy8gICAgIH1cbi8vICAgICBjb25zdCBhdHRyID0gcGFyZW50LmdldEF0dHJpYnV0ZSgnYnViYmxlJylcbi8vICAgICBpZiAoYXR0ciAhPT0gJycpIHtcbi8vICAgICAgIGluQnViYmxlID0gYXR0ciA9PT0gdHJ1ZSB8fCBhdHRyID09PSAndHJ1ZSdcbi8vICAgICAgIGJyZWFrXG4vLyAgICAgfVxuLy8gICAgIHBhcmVudHMucHVzaChwYXJlbnQpXG4vLyAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudEVsZW1lbnRcbi8vICAgfVxuLy8gICBlbC5faW5CdWJibGUgPSBpbkJ1YmJsZVxuLy8gICBmb3IgKGxldCBpID0gMCwgbCA9IHBhcmVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4vLyAgICAgcGFyZW50c1tpXS5faW5CdWJibGUgPSBpbkJ1YmJsZVxuLy8gICB9XG4vLyAgIHJldHVybiBpbkJ1YmJsZVxuLy8gfVxuXG5mdW5jdGlvbiBiaW5kRXZlbnRzIChjdHgsIGV2dHMsIGF0dHJzLCB0YWcsIGFwcGVhckF0dGFjaGVkKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIGV2dHMpIHtcbiAgICBjb25zdCBhcHBlYXJFdnROYW1lID0gYXBwZWFyRXZlbnRzTWFwW2tleV1cbiAgICBpZiAoYXBwZWFyRXZ0TmFtZSkge1xuICAgICAgYXR0cnNbYGRhdGEtZXZ0LSR7YXBwZWFyRXZ0TmFtZX1gXSA9ICcnXG4gICAgICBpZiAoIWFwcGVhckF0dGFjaGVkLnZhbHVlKSB7XG4gICAgICAgIGFwcGVhckF0dGFjaGVkLnZhbHVlID0gdHJ1ZVxuICAgICAgICBhdHRyc1snd2VleC1hcHBlYXInXSA9ICcnXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYXR0cnNbYGRhdGEtZXZ0LSR7a2V5fWBdID0gJydcbiAgICAgIGlmIChrZXkgIT09ICdjbGljaycpIHtcbiAgICAgICAgLy8gc2hvdWxkIHN0b3AgcHJvcGFnYXRpb24gYnkgZGVmYXVsdC5cbiAgICAgICAgLy8gVE9ETzogc2hvdWxkIHRlc3QgaW5CdWJibGUgZmlyc3QuXG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBldnRzW2tleV1cbiAgICAgICAgaWYgKGlzQXJyYXkoZXZ0c1trZXldKSkge1xuICAgICAgICAgIGhhbmRsZXIudW5zaGlmdChjdHguJHN0b3BQcm9wYWdhdGlvbilcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBldnRzW2tleV0gPSBbY3R4LiRzdG9wUHJvcGFnYXRpb24sIGhhbmRsZXJdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGV2dHMuY2xpY2spIHtcbiAgICBldnRzLndlZXgkdGFwID0gZXZ0cy5jbGlja1xuICAgIGV2dHMuY2xpY2sgPSBjdHguJHN0b3BPdXRlckFcbiAgfVxuICBpZiAoZXZ0cy5zY3JvbGwpIHtcbiAgICBldnRzLndlZXgkc2Nyb2xsID0gZXZ0cy5zY3JvbGxcbiAgICBkZWxldGUgZXZ0cy5zY3JvbGxcbiAgfVxufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1PbiAoY3R4LCBkYXRhLCB0YWcpIHtcbiAgbGV0IHsgb24sIG5hdGl2ZU9uIH0gPSBkYXRhXG4gIGlmICh3ZWV4QnVpbHRJbkNvbXBvbmVudHMuaW5kZXhPZih0YWcpID4gLTEpIHtcbiAgICAvKipcbiAgICAgKiBmb3IgZGl2LCBpbWFnZSwgdGV4dCwgY2VsbCwgYSwgLi4uXG4gICAgICogdXNlciBzaG91bGQgYmluZCBhbGwgZXZlbnRzIHdpdGhvdXQgLm5hdGl2ZS5cbiAgICAgKi9cbiAgICBuYXRpdmVPbiA9IG51bGxcbiAgICBkZWxldGUgZGF0YS5uYXRpdmVPblxuICB9XG4gIGlmIChpc0RlZih3ZWV4Ll9jb21wb25lbnRzW3RhZ10pKSB7XG4gICAgLyoqXG4gICAgICogZm9yIHNsaWRlciwgbGlzdCwgLi4uXG4gICAgICogdXNlciBzaG91bGQgYmluZCBldmVudHMgd2l0aG91dCAubmF0aXZlLlxuICAgICAqIGluIG91ciBldmVudHMgaGFuZGxpbmcsIGFsbCBldmVudHMgc2hvdWxkIHRyYW5zZmVyIHRvXG4gICAgICogLm5hdGl2ZSBiaW5kaW5nLlxuICAgICAqL1xuICAgIGRlbGV0ZSBkYXRhLm5hdGl2ZU9uXG4gICAgbmF0aXZlT24gPSBudWxsXG4gICAgaWYgKG9uKSB7XG4gICAgICBuYXRpdmVPbiA9IGRhdGEubmF0aXZlT24gPSBvblxuICAgIH1cbiAgICBvbiA9IG51bGxcbiAgICBkZWxldGUgZGF0YS5vblxuICB9XG5cbiAgbGV0IGF0dHJzID0gZGF0YS5hdHRyc1xuICBpZiAoIWF0dHJzKSB7XG4gICAgYXR0cnMgPSBkYXRhLmF0dHJzID0ge31cbiAgfVxuXG4gIGNvbnN0IGFwcGVhckF0dGFjaGVkID0ge1xuICAgIHZhbHVlOiBmYWxzZVxuICB9XG4gIGlmIChvbikge1xuICAgIGJpbmRFdmVudHMoY3R4LCBvbiwgYXR0cnMsIHRhZywgYXBwZWFyQXR0YWNoZWQpXG4gIH1cbiAgaWYgKG5hdGl2ZU9uKSB7XG4gICAgYmluZEV2ZW50cyhjdHgsIG5hdGl2ZU9uLCBhdHRycywgdGFnLCBhcHBlYXJBdHRhY2hlZClcbiAgfVxuXG4gIC8qKlxuICAgKiBiaW5kaW5nIGEgd2VleCR0YXAgdG8gPGE+IGVsZW1lbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBpZiB0aGVyZVxuICAgKiBpcyBubyBidWJibGVzPXRydWUgZmxhZyBzaG93aW5nIG9uIHBhcmVudHMuXG4gICAqL1xuICBpZiAodGFnID09PSAnYScpIHtcbiAgICBpZiAoIW9uKSB7XG4gICAgICBvbiA9IGRhdGEub24gPSB7fVxuICAgIH1cbiAgICAvLyBpZiAoIWNoZWNrQnViYmxlKGVsKSkge1xuICAgIGxldCBldnQgPSBvblsnd2VleCR0YXAnXVxuICAgIGlmICghZXZ0KSB7XG4gICAgICBvblsnd2VleCR0YXAnXSA9IGN0eC4kc3RvcFByb3BhZ2F0aW9uXG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZXZ0KSkge1xuICAgICAgZXZ0LnVuc2hpZnQoY3R4LiRzdG9wUHJvcGFnYXRpb24pXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZXZ0ID0gW2N0eC4kc3RvcFByb3BhZ2F0aW9uLCBldnRdXG4gICAgfVxuICAgIC8vIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1DbGFzcyAoZGF0YSwgdGFnKSB7XG4gIGxldCB7IGNsYXNzOiBjbGFzc0RhdGEgfSA9IGRhdGFcbiAgY29uc3QgdGFnQ2xhc3NPYmogPSBwcmVjb21waWxlZENsYXNzTWFwW3RhZ11cbiAgaWYgKCFjbGFzc0RhdGEpIHtcbiAgICBjbGFzc0RhdGEgPSBkYXRhLmNsYXNzID0gW11cbiAgfVxuICBpZiAoY2xhc3NEYXRhICYmIGlzQXJyYXkoY2xhc3NEYXRhKSkge1xuICAgIGRhdGEuY2xhc3MgPSBjbGFzc0RhdGEuY29uY2F0KE9iamVjdC5rZXlzKHRhZ0NsYXNzT2JqKSlcbiAgfVxuICBlbHNlIGlmICh0eXBlb2YgY2xhc3NEYXRhID09PSAnb2JqZWN0Jykge1xuICAgIE9iamVjdC5hc3NpZ24oY2xhc3NEYXRhLCB0YWdDbGFzc09iailcbiAgfVxufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdHlsZSAoY3R4LCBkYXRhLCB0YWcpIHtcbiAgY29uc3QgeyBzdHlsZSB9ID0gZGF0YVxuICBpZiAoIXN0eWxlKSB7IHJldHVybiB9XG4gIGNvbnN0IHRyYW5zZm9ybWVyID0gZ2V0VHJhbnNmb3JtZXIoZ2V0U3RkVGFnKHRhZykpXG4gIGlmICh0cmFuc2Zvcm1lcikge1xuICAgIGRhdGEuc3R5bGUgPSBjdHguX3B4MnJlbSh0cmFuc2Zvcm1lci50cmFuc2Zvcm0oc3R5bGUpLCA3NSlcbiAgfVxuICBlbHNlIHtcbiAgICBkYXRhLnN0eWxlID0gY3R4Ll9weDJyZW0oc3R5bGUsIDc1KVxuICB9XG59XG5cbi8qKlxuICogdHJhbnNmb3JtQXR0cnM6XG4gKiAgLSBhZGQgd2VleC10eXBlIGF0dHJzIGZvciBwcmVjb21waWxlZFRhZ3MuXG4gKiAgLSBpbWFnZS5yZXNpemU6IHRyYW5zZm9ybSB0byBkaXJlY3RpdmUgd2VleC1yZXNpemUuXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybUF0dHJzIChkYXRhLCB0YWcpIHtcbiAgbGV0IHsgYXR0cnMsIGRpcmVjdGl2ZXMgfSA9IGRhdGFcbiAgaWYgKCFhdHRycykge1xuICAgIGF0dHJzID0gZGF0YS5hdHRycyA9IHt9XG4gIH1cbiAgYXR0cnNbJ3dlZXgtdHlwZSddID0gdGFnXG4gIGlmICh0YWcgPT09ICdpbWFnZScpIHtcbiAgICBjb25zdCB7IHNyYywgcmVzaXplIH0gPSBhdHRyc1xuICAgIGlmIChzcmMpIHtcbiAgICAgIGF0dHJzWydkYXRhLWltZy1zcmMnXSA9IHNyY1xuICAgIH1cbiAgICBpZiAocmVzaXplKSB7XG4gICAgICBpZiAoIWRpcmVjdGl2ZXMpIHtcbiAgICAgICAgZGlyZWN0aXZlcyA9IGRhdGEuZGlyZWN0aXZlcyA9IFtdXG4gICAgICB9XG4gICAgICBkaXJlY3RpdmVzLnB1c2goe1xuICAgICAgICBuYW1lOiAnd2VleC1yZXNpemUnLFxuICAgICAgICB2YWx1ZTogYXR0cnMucmVzaXplXG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtRGF0YSAoY3R4LCBkYXRhLCB0YWcpIHtcbiAgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICAvLyBwYXJhbWV0ZXIgZGF0YSBpcyBvbW1pdGVkLlxuICAgIHJldHVybiBkYXRhXG4gIH1cbiAgY29uc3QgaXNQID0gaXNQcmVjb21waWxlZCh0YWcpXG4gIC8vIGNsYXNzXG4gIGlzUCAmJiB0cmFuc2Zvcm1DbGFzcyhkYXRhLCB0YWcpXG4gIC8vIHN0eWxlXG4gIHRyYW5zZm9ybVN0eWxlKGN0eCwgZGF0YSwgdGFnKVxuICAvLyBhdHRyc1xuICBpc1AgJiYgdHJhbnNmb3JtQXR0cnMoZGF0YSwgdGFnKVxuICAvLyBvblxuICB0cmFuc2Zvcm1PbihjdHgsIGRhdGEsIHRhZylcbiAgcmV0dXJuIGRhdGFcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hcE5hdGl2ZUV2ZW50cyAoY3R4LCBtYXApIHtcbiAgY29uc3QgZXZlbnRNYXAgPSB7fVxuICBmb3IgKGNvbnN0IG9yaWdFdmVudCBpbiBtYXApIHtcbiAgICBldmVudE1hcFtvcmlnRXZlbnRdID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgY29uc3QgZWwgPSBldnQudGFyZ2V0XG4gICAgICBkaXNwYXRjaE5hdGl2ZUV2ZW50KGVsLCBtYXBbb3JpZ0V2ZW50XSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGV2ZW50TWFwXG59XG4iLCIvKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmV4cG9ydCAqIGZyb20gJy4vc3R5bGUnXG5leHBvcnQgKiBmcm9tICcuL25vZGUnXG4iLCIvKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7XG4gIGdldFRocm90dGxlTGF6eWxvYWQsXG4gIHdhdGNoQXBwZWFyLFxuICBkZWJvdW5jZVxufSBmcm9tICcuLi91dGlscydcblxuaW1wb3J0IGNvbmZpZyBmcm9tICcuLi9jb25maWcnXG5jb25zdCBzY3JvbGxhYmxlVHlwZXMgPSBjb25maWcuc2Nyb2xsYWJsZVR5cGVzXG5cbmxldCBsYXp5bG9hZFdhdGNoZWQgPSBmYWxzZVxuZnVuY3Rpb24gd2F0Y2hMYXp5bG9hZCAoKSB7XG4gIGxhenlsb2FkV2F0Y2hlZCA9IHRydWVcbiAgOyBbXG4gICAgJ3Njcm9sbCcsXG4gICAgLy8gJ3RyYW5zaXRpb25lbmQnLFxuICAgIC8vICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcbiAgICAvLyAnYW5pbWF0aW9uZW5kJyxcbiAgICAvLyAnd2Via2l0QW5pbWF0aW9uRW5kJyxcbiAgICAncmVzaXplJ1xuICBdLmZvckVhY2goZXZ0ID0+IHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldnQsIGdldFRocm90dGxlTGF6eWxvYWQoMjUsIGRvY3VtZW50LmJvZHkpKVxuICB9KVxuICAvKipcbiAgICogSW4gY2FzZSB0aGUgdXNlcnMgdXNlIHRoZSBib2R5J3Mgb3ZlcmZsb3cgdG8gc2Nyb2xsLiBUaGVuIHRoZSBzY3JvbGxcbiAgICogZXZlbnQgd291bGQgbm90IGJlIHRyaWdnZXJlZCBvbiB0aGUgd2luZG93IG9iamVjdCBidXQgb24gdGhlIGJvZHkuXG4gICAqL1xuICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGdldFRocm90dGxlTGF6eWxvYWQoMjUsIGRvY3VtZW50LmJvZHkpKVxufVxuXG5sZXQgaWRDbnQgPSAwXG5sZXQgYXBwZWFyV2F0Y2hlZCA9IGZhbHNlXG5cbi8qKlxuICogZHVyaW5nIHVwZGF0aW5nLCB0aGUgYXBwZWFyIHdhdGNoZXIgYmluZGluZyBvbiB0aGUgYXBwZWFyV2F0Y2hlZCBjb250ZXh0XG4gKiBzaG91bGQgYmUgdHJpZ2dlcmVkIHdpdGhpbiBhIGRlYm91bmNlZCB3cmFwcGVyLlxuICogSWYgdGhlIHVwZGF0aW5nIGludGVydmFsIGlzIHNob3J0ZXIgdGhlbiA1MCBtcywgdGhlbiB0aGUgYXBwZWFyIGV2ZW50cyB3aWxsXG4gKiBpZ25vcmUgdGhlIGNoYW5nZSBpbiB0aGUgcHJldmlvdXMgNTAgbXMgZHVlIHRvIHRoZSBkZWJvdW5jZSB3cmFwcGVyLlxuICovXG5jb25zdCBkZWJvdW5jZWRXYXRjaEFwcGVhciA9IGRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgd2F0Y2hBcHBlYXIoYXBwZWFyV2F0Y2hlZCwgdHJ1ZSlcbn0sIDUwKVxuXG4vKipcbiAqIGlmIGl0J3MgYSBzY3JvbGxhYmxlIHRhZywgdGhlbiB3YXRjaCBhcHBlYXIgZXZlbnRzIGZvciBpdC5cbiAqL1xuZnVuY3Rpb24gd2F0Y2hBcHBlYXJGb3JTY3JvbGxhYmxlcyAodGFnTmFtZSwgY29udGV4dCkge1xuICAvLyB3aGVuIHRoaXMgaXMgYSBzY3JvbGxlci9saXN0L3dhdGVyZmFsbFxuICBpZiAoc2Nyb2xsYWJsZVR5cGVzLmluZGV4T2YodGFnTmFtZSkgPiAtMSkge1xuICAgIGNvbnN0IHNkID0gY29udGV4dC5zY3JvbGxEaXJlY3Rpb25cbiAgICBpZiAoIXNkIHx8IHNkICE9PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgIGFwcGVhcldhdGNoZWQgPSBjb250ZXh0XG4gICAgICB3YXRjaEFwcGVhcihjb250ZXh0LCB0cnVlKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGJlZm9yZUNyZWF0ZSAoKSB7XG4gICAgaWYgKCFsYXp5bG9hZFdhdGNoZWQpIHtcbiAgICAgIHdhdGNoTGF6eWxvYWQoKVxuICAgIH1cbiAgfSxcblxuICB1cGRhdGVkICgpIHtcbiAgICBjb25zdCBlbCA9IHRoaXMuJGVsXG4gICAgaWYgKCFlbCB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICh0aGlzLl9yb290SWQpIHtcbiAgICAgIGlmIChlbC5jbGFzc05hbWUuaW5kZXhPZignd2VleC1yb290JykgPD0gLTEpIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnd2VleC1yb290JylcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnd2VleC1jdCcpXG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnZGF0YS13eC1yb290LWlkJywgdGhpcy5fcm9vdElkKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHRhZ05hbWUgPSB0aGlzLiRvcHRpb25zICYmIHRoaXMuJG9wdGlvbnMuX2NvbXBvbmVudFRhZ1xuICAgIGNvbnN0IG1ldGFVcCA9IHdlZXguX21ldGEudXBkYXRlZFxuICAgIGlmICghbWV0YVVwW3RhZ05hbWVdKSB7XG4gICAgICBtZXRhVXBbdGFnTmFtZV0gPSAwXG4gICAgfVxuICAgIG1ldGFVcFt0YWdOYW1lXSsrXG4gICAgLy8gd2lsbCBjaGVjayBhcHBlYXJpbmcgd2hlbiBubyBvdGhlciBjaGFuZ2VzIGluIGxhdGVzdCA1MG1zLlxuICAgIGRlYm91bmNlZFdhdGNoQXBwZWFyKClcbiAgICAvKipcbiAgICAgKiBzaW5jZSB0aGUgdXBkYXRpbmcgb2YgY29tcG9uZW50IG1heSBhZmZlY3QgdGhlIGxheW91dCwgdGhlIGxhenlsb2FkaW5nIHNob3VsZFxuICAgICAqIGJlIGZpcmVkLlxuICAgICAqL1xuICAgIHRoaXMuX2ZpcmVMYXp5bG9hZCgpXG4gIH0sXG5cbiAgbW91bnRlZCAoKSB7XG4gICAgY29uc3QgdGFnTmFtZSA9IHRoaXMuJG9wdGlvbnMgJiYgdGhpcy4kb3B0aW9ucy5fY29tcG9uZW50VGFnXG4gICAgY29uc3QgZWwgPSB0aGlzLiRlbFxuICAgIGlmICghZWwgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAodHlwZW9mIHdlZXguX2NvbXBvbmVudHNbdGFnTmFtZV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB3ZWV4Ll9jb21wb25lbnRzW3RhZ05hbWVdKytcbiAgICB9XG4gICAgY29uc3QgbWV0YU10ID0gd2VleC5fbWV0YS5tb3VudGVkXG4gICAgaWYgKCFtZXRhTXRbdGFnTmFtZV0pIHtcbiAgICAgIG1ldGFNdFt0YWdOYW1lXSA9IDBcbiAgICB9XG4gICAgbWV0YU10W3RhZ05hbWVdKytcblxuICAgIHdhdGNoQXBwZWFyRm9yU2Nyb2xsYWJsZXModGFnTmFtZSwgdGhpcylcblxuICAgIC8vIHdoZW4gdGhpcyBpcyB0aGUgcm9vdCBlbGVtZW50IG9mIFZ1ZSBpbnN0YW5jZS5cbiAgICBpZiAodGhpcyA9PT0gdGhpcy4kcm9vdCkge1xuICAgICAgY29uc3Qgcm9vdElkID0gYHd4LXJvb3QtJHtpZENudCsrfWBcbiAgICAgIGlmICghd2VleC5fcm9vdCkge1xuICAgICAgICB3ZWV4Ll9yb290ID0ge31cbiAgICAgIH1cbiAgICAgIHdlZXguX3Jvb3Rbcm9vdElkXSA9IHRoaXNcbiAgICAgIHRoaXMuX3Jvb3RJZCA9IHJvb3RJZFxuICAgICAgaWYgKGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnd2VleC1yb290JylcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ3dlZXgtY3QnKVxuICAgICAgZWwuc2V0QXR0cmlidXRlKCdkYXRhLXd4LXJvb3QtaWQnLCByb290SWQpXG5cbiAgICAgIC8qKlxuICAgICAgICogdGhlcmUncyBubyBzY3JvbGxhYmxlIGNvbXBvbmVudCBpbiB0aGlzIHBhZ2UuIFRoYXQgaXMgdG8gc2F5LFxuICAgICAgICogdGhlIHBhZ2UgaXMgdXNpbmcgYm9keSBzY3JvbGxpbmcgaW5zdGVhZCBvZiBzY3JvbGxhYmUgY29tcG9uZW50cy5cbiAgICAgICAqIFRoZW4gdGhlIGFwcGVhciB3YXRjaGVyIHNob3VsZCBiZSBhdHRhY2hlZCBvbiB0aGUgYm9keS5cbiAgICAgICAqL1xuICAgICAgaWYgKCFhcHBlYXJXYXRjaGVkKSB7XG4gICAgICAgIGFwcGVhcldhdGNoZWQgPSB0aGlzXG4gICAgICAgIHdhdGNoQXBwZWFyKHRoaXMsIHRydWUpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2ZpcmVMYXp5bG9hZChlbClcbiAgICB9XG5cbiAgICAvLyBnaXZlIHdhcm5pbmcgZm9yIG5vdCB1c2luZyAkcHJvY2Vzc1N0eWxlIGluIHZ1ZS1sb2FkZXIgY29uZmlnLlxuICAgIC8vIGlmICghd2FybmVkICYmICF3aW5kb3cuX3N0eWxlX3Byb2Nlc3NpbmdfYWRkZWQpIHtcbiAgICAvLyAgIHdhcm5Qcm9jZXNzU3R5bGUoKVxuICAgIC8vIH1cbiAgfSxcblxuICBkZXN0cm95ZWQgKCkge1xuICAgIGNvbnN0IGVsID0gdGhpcy4kZWxcbiAgICBpZiAoIWVsIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLyoqXG4gICAgICogaWYgdGhlIGRlc3Ryb3llZCBlbGVtZW50IGlzIGFib3ZlIGFub3RoZXIgcGFuZWwgd2l0aCBpbWFnZXMgaW5zaWRlLCBhbmQgdGhlIGltYWdlc1xuICAgICAqIG1vdmVkIGludG8gdGhlIHZpZXdwb3J0LCB0aGVuIHRoZSBsYXp5bG9hZGluZyBzaG91bGQgYmUgdHJpZ2dlcmVkLlxuICAgICAqL1xuICAgIGlmICh0aGlzLl9yb290SWQpIHtcbiAgICAgIGRlbGV0ZSB3ZWV4Ll9yb290W3RoaXMuX3Jvb3RJZF1cbiAgICAgIGRlbGV0ZSB0aGlzLl9yb290SWRcbiAgICB9XG4gICAgY29uc3QgdGFnTmFtZSA9IHRoaXMuJG9wdGlvbnMgJiYgdGhpcy4kb3B0aW9ucy5fY29tcG9uZW50VGFnXG4gICAgaWYgKHR5cGVvZiB3ZWV4Ll9jb21wb25lbnRzW3RhZ05hbWVdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgd2VleC5fY29tcG9uZW50c1t0YWdOYW1lXS0tXG4gICAgfVxuICAgIGNvbnN0IG1ldGFEcyA9IHdlZXguX21ldGEuZGVzdHJveWVkXG4gICAgaWYgKCFtZXRhRHNbdGFnTmFtZV0pIHtcbiAgICAgIG1ldGFEc1t0YWdOYW1lXSA9IDBcbiAgICB9XG4gICAgbWV0YURzW3RhZ05hbWVdKytcbiAgICB0aGlzLl9maXJlTGF6eWxvYWQoKVxuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBfZmlyZUxhenlsb2FkIChlbCkge1xuICAgICAgZ2V0VGhyb3R0bGVMYXp5bG9hZCgyNSwgZWwgfHwgZG9jdW1lbnQuYm9keSkoKVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgaW5zaWRlQSB9IGZyb20gJy4uL3V0aWxzJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG1ldGhvZHM6IHtcbiAgICAvLyBkZXByZWNhdGVkLlxuICAgICRzdG9wT3V0dGVyQSAoZSkge1xuICAgICAgcmV0dXJuIHRoaXMuJHN0b3BPdXRlckEoZSlcbiAgICB9LFxuXG4gICAgJHN0b3BPdXRlckEgKGUpIHtcbiAgICAgIGlmIChlICYmIGUucHJldmVudERlZmF1bHQgJiYgZS50YXJnZXQpIHtcbiAgICAgICAgaWYgKGluc2lkZUEoZS50YXJnZXQpKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgJHN0b3BQcm9wYWdhdGlvbiAoZSkge1xuICAgICAgaWYgKGUgJiYgZS5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IGdldFRyYW5zZm9ybWVyIH0gZnJvbSAnd3h2LXRyYW5zZm9ybWVyJ1xuaW1wb3J0IHsgaXNBcnJheSwgaXNQbGFpbk9iamVjdCB9IGZyb20gJy4uL3V0aWxzJ1xuaW1wb3J0IGNvbmZpZyBmcm9tICcuLi9jb25maWcnXG5jb25zdCB7IGJpbmRpbmdTdHlsZU5hbWVzRm9yUHgyUmVtIH0gPSBjb25maWdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBtZXRob2RzOiB7XG4gICAgX3B4MnJlbSAodmFsdWUsIHJvb3RWYWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSArICcnKS5yZXBsYWNlKC9bKy1dP1xcZCsoPzouXFxkKik/W3B3XXgvZ2ksIGZ1bmN0aW9uICgkMCkge1xuICAgICAgICAgIHJldHVybiB3ZWV4LnV0aWxzLnB4MnJlbSgkMCwgcm9vdFZhbHVlKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHdlZXgudXRpbHMucHgycmVtKHZhbHVlICsgJycsIHJvb3RWYWx1ZSlcbiAgICAgIH1cbiAgICAgIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB2YWx1ZS5oYXNPd25Qcm9wZXJ0eShrKVxuICAgICAgICAgICAgJiYgYmluZGluZ1N0eWxlTmFtZXNGb3JQeDJSZW0uaW5kZXhPZihrKSA+IC0xXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YWx1ZVtrXSA9IHdlZXgudXRpbHMucHgycmVtKHZhbHVlW2tdICsgJycsIHJvb3RWYWx1ZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB0aGlzLl9weDJyZW0odmFsdWVbaV0sIHJvb3RWYWx1ZSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX3Byb2Nlc3NFeGNsdXNpdmVTdHlsZSAoc3R5bGVPYmosIHJvb3RWYWx1ZSwgdGFnTmFtZSkge1xuICAgICAgY29uc3QgdHJhbnNmb3JtZXIgPSBnZXRUcmFuc2Zvcm1lcih0YWdOYW1lKVxuICAgICAgcmV0dXJuIHRoaXMuX3B4MnJlbShcbiAgICAgICAgdHJhbnNmb3JtZXIudHJhbnNmb3JtKHN0eWxlT2JqKSxcbiAgICAgICAgcm9vdFZhbHVlXG4gICAgICApXG4gICAgfSxcblxuICAgIF9nZXRQYXJlbnRSZWN0ICgpIHtcbiAgICAgIGNvbnN0IGVsID0gdGhpcy4kZWxcbiAgICAgIGNvbnN0IHBhcmVudCA9IGVsICYmIGVsLnBhcmVudEVsZW1lbnRcbiAgICAgIHJldHVybiBwYXJlbnQgJiYgcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLy8gaW5wdXQgYW5kIHRleHRhcmUgaGFzIHNvbWUgY29tbW9uIGFwaSBhbmQgZXZlbnRcbmltcG9ydCB7IGV4dGVuZCwgZGlzcGF0Y2hOYXRpdmVFdmVudCB9IGZyb20gJy4uL3V0aWxzJ1xuXG5jb25zdCBmaW5kRW50ZXJLZXlUeXBlID0gZnVuY3Rpb24gKGtleSkge1xuICBjb25zdCBrZXlzID0gWydkZWZhdWx0JywgJ2dvJywgJ25leHQnLCAnc2VhcmNoJywgJ3NlbmQnXVxuICBpZiAoa2V5cy5pbmRleE9mKGtleSkgPiAtMSkge1xuICAgIHJldHVybiBrZXlcbiAgfVxuICByZXR1cm4gJ2RvbmUnXG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbWV0aG9kczoge1xuICAgIGZvY3VzICgpIHtcbiAgICAgIHRoaXMuJGVsICYmIHRoaXMuJGVsLmZvY3VzKClcbiAgICB9LFxuICAgIGJsdXIgKCkge1xuICAgICAgdGhpcy4kZWwgJiYgdGhpcy4kZWwuYmx1cigpXG4gICAgfSxcblxuICAgIHNldFNlbGVjdGlvblJhbmdlIChzdGFydCwgZW5kKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLiRlbC5zZXRTZWxlY3Rpb25SYW5nZShzdGFydCwgZW5kKVxuICAgICAgfVxuICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBbdnVlLXJlbmRlcl0gc2V0U2VsZWN0aW9uUmFuZ2UgaXMgbm90IHN1cHBvcnRlZC5gKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGdldFNlbGVjdGlvblJhbmdlIChjYWxsYmFjaykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpXG4gICAgICAgIGNvbnN0IHN0ciA9IHNlbGVjdGlvbi50b1N0cmluZygpXG4gICAgICAgIGNvbnN0IHNlbGVjdGlvblN0YXJ0ID0gdGhpcy4kZWwudmFsdWUuaW5kZXhPZihzdHIpXG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbkVuZCA9IHNlbGVjdGlvblN0YXJ0ID09PSAtMSA/IHNlbGVjdGlvblN0YXJ0IDogc2VsZWN0aW9uU3RhcnQgKyBzdHIubGVuZ3RoXG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHtcbiAgICAgICAgICBzZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICBzZWxlY3Rpb25FbmRcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKG5ldyBFcnJvcignW3Z1ZS1yZW5kZXJdIGdldFNlbGVjdGlvbiBpcyBub3Qgc3VwcG9ydGVkLicpKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRFZGl0U2VsZWN0aW9uUmFuZ2UgKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmdldFNlbGVjdGlvblJhbmdlKGNhbGxiYWNrKVxuICAgIH0sXG5cbiAgICAvLyBzdXBwb3J0IGVudGVyIGtleSBldmVudFxuICAgIGNyZWF0ZUtleWJvYXJkRXZlbnQgKGV2ZW50cykge1xuICAgICAgY29uc3QgY3VzdG9tS2V5VHlwZSA9IHRoaXMucmV0dXJuS2V5VHlwZVxuICAgICAgaWYgKGN1c3RvbUtleVR5cGUpIHtcbiAgICAgICAgY29uc3Qga2V5Ym9hcmRFdmVudHMgPSB7XG4gICAgICAgICAgJ2tleXVwJzogZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBjb25zdCBjb2RlID0gZXYua2V5Q29kZVxuICAgICAgICAgICAgbGV0IGtleSA9IGV2LmtleVxuICAgICAgICAgICAgaWYgKGNvZGUgPT09IDEzKSB7XG4gICAgICAgICAgICAgIGlmICgha2V5IHx8IGtleS50b0xvd2VyQ2FzZSgpID09PSAndGFiJykge1xuICAgICAgICAgICAgICAgIGtleSA9ICduZXh0J1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRpc3BhdGNoTmF0aXZlRXZlbnQoZXYudGFyZ2V0LCAncmV0dXJuJywge1xuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICByZXR1cm5LZXlUeXBlOiBmaW5kRW50ZXJLZXlUeXBlKGN1c3RvbUtleVR5cGUpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBldi50YXJnZXQudmFsdWVcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnRzID0gZXh0ZW5kKGV2ZW50cywga2V5Ym9hcmRFdmVudHMpXG4gICAgICB9XG4gICAgICByZXR1cm4gZXZlbnRzXG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7XG4gIGdldFBhcmVudFNjcm9sbGVyXG59IGZyb20gJy4uL3V0aWxzJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRlc3Ryb3llZCAoKSB7XG4gICAgaWYgKCF0aGlzLl9zdGlja3lBZGRlZCkgeyByZXR1cm4gfVxuICAgIGNvbnN0IHNjcm9sbGVyID0gZ2V0UGFyZW50U2Nyb2xsZXIodGhpcylcbiAgICBpZiAoIXNjcm9sbGVyKSB7IHJldHVybiB9XG4gICAgZGVsZXRlIHNjcm9sbGVyLl9zdGlja3lDaGlsZHJlblt0aGlzLl91aWRdXG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIF9hZGRTdGlja3kgKCkge1xuICAgICAgY29uc3QgZWwgPSB0aGlzLiRlbFxuICAgICAgaWYgKCFlbCB8fCBlbC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBbdnVlLXJlbmRlcl0gJGVsIGRvZXNuJ3QgZXhpc3QgdG8gYWRkIHN0aWNreS5gKVxuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnc3RpY2t5JylcbiAgICAgIGlmICghdGhpcy5fcGxhY2Vob2xkZXIpIHtcbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXIgPSBlbC5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgIH1cbiAgICAgIHRoaXMuX3BsYWNlaG9sZGVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snXG4gICAgICB0aGlzLl9wbGFjZWhvbGRlci5zdHlsZS53aWR0aCA9IHRoaXMuJGVsLm9mZnNldFdpZHRoICsgJ3B4J1xuICAgICAgdGhpcy5fcGxhY2Vob2xkZXIuc3R5bGUuaGVpZ2h0ID0gdGhpcy4kZWwub2Zmc2V0SGVpZ2h0ICsgJ3B4J1xuICAgICAgZWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5fcGxhY2Vob2xkZXIsIHRoaXMuJGVsKVxuICAgIH0sXG5cbiAgICBfcmVtb3ZlU3RpY2t5ICgpIHtcbiAgICAgIGNvbnN0IGVsID0gdGhpcy4kZWxcbiAgICAgIGlmICghZWwgfHwgZWwubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgW3Z1ZS1yZW5kZXJdICRlbCBkb2Vzbid0IGV4aXN0IHRvIHJlbW92ZSBzdGlja3kuYClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ3N0aWNreScpXG4gICAgICBpZiAodGhpcy5fcGxhY2Vob2xkZXIpIHtcbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9wbGFjZWhvbGRlcilcbiAgICAgIH1cbiAgICAgIHRoaXMuX3BsYWNlaG9sZGVyID0gbnVsbFxuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgYmFzZSBmcm9tICcuL2Jhc2UnXG5pbXBvcnQgZXZlbnQgZnJvbSAnLi9ldmVudCdcbmltcG9ydCBzdHlsZSBmcm9tICcuL3N0eWxlJ1xuaW1wb3J0IGlucHV0Q29tbW9uIGZyb20gJy4vaW5wdXQtY29tbW9uJ1xuaW1wb3J0IHN0aWNreSBmcm9tICcuL3N0aWNreSdcblxuZXhwb3J0IHtcbiAgYmFzZSxcbiAgZXZlbnQsXG4gIHN0eWxlLFxuICBpbnB1dENvbW1vbixcbiAgc3RpY2t5XG59XG4iLCIvKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB3ZWV4IGZyb20gJy4vaW5zdGFuY2UnXG5pbXBvcnQgKiBhcyBjb3JlIGZyb20gJy4uL2NvcmUnXG5cbmltcG9ydCB7IGlucHV0Q29tbW9uIH0gZnJvbSAnLi4vbWl4aW5zJ1xuXG53aW5kb3cuZ2xvYmFsID0gd2luZG93XG53aW5kb3cud2VleCA9IHdlZXhcblxud2VleC5fc3R5bGVNYXAgPSB7fVxuXG47IFsnZ2V0Q29tcG9uZW50SW5saW5lU3R5bGUnLFxuICAnZXh0cmFjdENvbXBvbmVudFN0eWxlJyxcbiAgJ21hcE5hdGl2ZUV2ZW50cycsXG4gICd0cmltVGV4dFZOb2RlcyddXG4gIC5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICB3ZWV4W21ldGhvZF0gPSBjb3JlW21ldGhvZF0uYmluZCh3ZWV4KVxuICB9KVxuXG53ZWV4Lm1peGlucyA9IHtcbiAgaW5wdXRDb21tb25cbn1cbiIsIi8qXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHtcbiAgdHJhbnNmb3JtUmVuZGVyXG59IGZyb20gJy4uL2NvcmUvbm9kZSdcbmltcG9ydCB7IGlzRGVmIH0gZnJvbSAnLi4vdXRpbHMnXG5cbmxldCBfaW5pdGVkID0gZmFsc2VcblxuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0ICh3ZWV4KSB7XG4gICAgaWYgKF9pbml0ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBfaW5pdGVkID0gdHJ1ZVxuICAgIGNvbnN0IFZ1ZSA9IHdlZXguX192dWVfX1xuICAgIGNvbnN0IF9yZW5kZXIgPSBWdWUucHJvdG90eXBlLl9yZW5kZXJcbiAgICBWdWUucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBsZXQgd2VleFJlbmRlciA9IHRoaXMuX3dlZXhSZW5kZXJcbiAgICAgIGNvbnN0IHRhZyA9IHRoaXMuJG9wdGlvbnMgJiYgdGhpcy4kb3B0aW9ucy5fY29tcG9uZW50VGFnXG4gICAgICBpZiAoXG4gICAgICAgICF3ZWV4UmVuZGVyXG4gICAgICAgICYmICFpc0RlZih3ZWV4Ll9jb21wb25lbnRzW3RhZ10pXG4gICAgICApIHtcbiAgICAgICAgY29uc3Qgb3JpZ1JlbmRlciA9IHRoaXMuJG9wdGlvbnMucmVuZGVyXG4gICAgICAgIHdlZXhSZW5kZXIgPSB0aGlzLl93ZWV4UmVuZGVyID0gZnVuY3Rpb24gKGgsIC4uLmFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gb3JpZ1JlbmRlci5jYWxsKHRoaXMsIHRyYW5zZm9ybVJlbmRlcih0aGlzLCBoKSwgLi4uYXJncylcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRvcHRpb25zLnJlbmRlciA9IHdlZXhSZW5kZXJcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVuZGVyLmNhbGwodGhpcylcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0ICcuLi9zdHlsZXMvcmVzZXQuY3NzJ1xuaW1wb3J0ICcuLi9zdHlsZXMvYmFzZS5jc3MnXG5cbmltcG9ydCAnY29yZS1qcy9mbi9hcnJheS9mcm9tJ1xuaW1wb3J0ICdjb3JlLWpzL2ZuL29iamVjdC9hc3NpZ24nXG5pbXBvcnQgJ2NvcmUtanMvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2YnXG5pbXBvcnQgJ2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZydcbmltcG9ydCAnY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InXG5pbXBvcnQgJ2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJ1xuaW1wb3J0ICdjb3JlLWpzL21vZHVsZXMvZXM2LnByb21pc2UnXG5cbmltcG9ydCAnLi4vbGliL2dlc3R1cmUnXG5pbXBvcnQgJy4vZ2xvYmFsJ1xuaW1wb3J0IHJlbmRlckZ1bmN0aW9uUGx1Z2luIGZyb20gJy4vcmVuZGVyLWZ1bmN0aW9uJ1xuXG5pZiAoZ2xvYmFsLlZ1ZSkge1xuICBzZXRWdWUoZ2xvYmFsLlZ1ZSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldFZ1ZSAodnVlKSB7XG4gIGlmICghdnVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbVnVlIFJlbmRlcl0gVnVlIG5vdCBmb3VuZC4gUGxlYXNlIG1ha2Ugc3VyZSB2dWUgMi54IHJ1bnRpbWUgaXMgaW1wb3J0ZWQuJylcbiAgfVxuICBpZiAoZ2xvYmFsLndlZXguX192dWVfXykge1xuICAgIHJldHVyblxuICB9XG4gIGdsb2JhbC53ZWV4Ll9fdnVlX18gPSB2dWVcbiAgd2VleC5pbnN0YWxsKHJlbmRlckZ1bmN0aW9uUGx1Z2luKVxuICBjb25zb2xlLmxvZyhgW1Z1ZSBSZW5kZXJdIGluc3RhbGwgVnVlICR7dnVlLnZlcnNpb259LmApXG59XG5cbmV4cG9ydCBkZWZhdWx0IHdlZXhcbiIsIi8qXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHdlZXggZnJvbSAnLi93ZWV4J1xuaW1wb3J0IHsgc2V0VnVlIH0gZnJvbSAnLi93ZWV4J1xuaW1wb3J0IHsgYmFzZSwgZXZlbnQsIHN0eWxlLCBzdGlja3kgfSBmcm9tICcuL21peGlucydcblxuLyoqXG4gKiBpbml0IHdlZXguXG4gKiBAcGFyYW0gIHtWdWUkMn0gVnVlOiBWdWUgQ29uc3RydWN0b3IuXG4gKiBAcGFyYW0gIHtvYmplY3R9IG9wdGlvbnM6IGV4dGVuZCB3ZWV4IHBsdWdpbnMuXG4gKiAgICAgICAgIC0gY29tcG9uZW50cy5cbiAqICAgICAgICAgLSBtb2R1bGVzLlxuICovXG5sZXQgX2luaXRlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbml0IChWdWUvKiwgb3B0aW9ucyA9IHt9Ki8pIHtcbiAgaWYgKF9pbml0ZWQpIHsgcmV0dXJuIH1cbiAgX2luaXRlZCA9IHRydWVcblxuICBzZXRWdWUoVnVlKVxuXG4gIFZ1ZS5wcm90b3R5cGUuJGdldENvbmZpZyA9ICgpID0+IHtcbiAgICBjb25zb2xlLndhcm4oJ1tWdWUgUmVuZGVyXSBcInRoaXMuJGdldENvbmZpZ1wiIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgXCJ3ZWV4LmNvbmZpZ1wiIGluc3RlYWQuJylcbiAgICByZXR1cm4gd2VleC5jb25maWdcbiAgfVxuXG4gIGNvbnN0IGh0bWxSZWdleCA9IC9eaHRtbDovaVxuICBWdWUuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSB0YWcgPT4gaHRtbFJlZ2V4LnRlc3QodGFnKVxuICBWdWUuY29uZmlnLnBhcnNlUGxhdGZvcm1UYWdOYW1lID0gdGFnID0+IHRhZy5yZXBsYWNlKGh0bWxSZWdleCwgJycpXG5cbiAgZnVuY3Rpb24gaXNXZWV4VGFnICh0YWcpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdlZXguX2NvbXBvbmVudHNbdGFnXSAhPT0gJ3VuZGVmaW5lZCdcbiAgfVxuICBjb25zdCBvbGRHZXRUYWdOYW1lc3BhY2UgPSBWdWUuY29uZmlnLmdldFRhZ05hbWVzcGFjZVxuICBWdWUuY29uZmlnLmdldFRhZ05hbWVzcGFjZSA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgICBpZiAoaXNXZWV4VGFnKHRhZykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICByZXR1cm4gb2xkR2V0VGFnTmFtZXNwYWNlKHRhZylcbiAgfVxuXG4gIFZ1ZS5taXhpbihiYXNlKVxuICBWdWUubWl4aW4oZXZlbnQpXG4gIFZ1ZS5taXhpbihzdHlsZSlcbiAgVnVlLm1peGluKHN0aWNreSlcbn1cblxuLy8gYXV0byBpbml0IGluIGRpc3QgbW9kZS5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuVnVlKSB7XG4gIGluaXQod2luZG93LlZ1ZSlcbn1cblxud2VleC5pbml0ID0gaW5pdFxuXG5leHBvcnQgZGVmYXVsdCB3ZWV4XG4iLCIvKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IElucHV0IGNvbXBvbmVudC5cbiAqIFN1cHBvcnQgdi1tb2RlbCBvbmx5IGlmIHZ1ZSB2ZXJzaW9uIGlzIGxhcmdlciB0aGFuIDIuMi4wXG4gKi9cbmltcG9ydCB7IGdldENvbXBvbmVudElubGluZVN0eWxlIH0gZnJvbSAnLi4vLi4vY29yZSdcblxubGV0IG1hcEZvcm1FdmVudHMsIGFwcGVuZENzc1xuXG5jb25zdCBJRF9QUkVGSVhfUExBQ0VIT0xERVJfQ09MT1IgPSAnd2lwdF9wbGNfJ1xuY29uc3QgSURfUFJFRklYX0lOUFVUID0gJ3dpcHRfJ1xubGV0IGlkQ291bnQgPSAwXG5cbmZ1bmN0aW9uIHNldFBsYWNlaG9sZGVyQ29sb3IgKGlucHV0Vm0sIHBsYWNlaG9sZGVyQ29sb3IpIHtcbiAgaWYgKCFwbGFjZWhvbGRlckNvbG9yKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3QgdmVuZG9ycyA9IFtcbiAgICAnOjotd2Via2l0LWlucHV0LXBsYWNlaG9sZGVyJyxcbiAgICAnOi1tb3otcGxhY2Vob2xkZXInLFxuICAgICc6Oi1tb3otcGxhY2Vob2xkZXInLFxuICAgICc6LW1zLWlucHV0LXBsYWNlaG9sZGVyJyxcbiAgICAnOnBsYWNlaG9sZGVyLXNob3duJ1xuICBdXG4gIGNvbnN0IGlkID0gaW5wdXRWbS5faWRcbiAgYXBwZW5kQ3NzKFxuICAgIHZlbmRvcnMubWFwKGZ1bmN0aW9uICh2ZW5kb3IsIGlkeCkge1xuICAgICAgcmV0dXJuIGAjJHtJRF9QUkVGSVhfSU5QVVR9JHtpZH0ke3ZlbmRvcnNbaWR4XX17Y29sb3I6JHtwbGFjZWhvbGRlckNvbG9yfTt9YFxuICAgIH0pLmpvaW4oJycpLFxuICAgIGAke0lEX1BSRUZJWF9QTEFDRUhPTERFUl9DT0xPUn0ke2lkfWAsXG4gICAgdHJ1ZSlcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1N0eWxlICh2bSkge1xuICBjb25zdCBzdHlsZXMgPSBnZXRDb21wb25lbnRJbmxpbmVTdHlsZSh2bSlcbiAgY29uc3QgcGhDb2xvciA9IHN0eWxlcy5wbGFjZWhvbGRlckNvbG9yIHx8IHN0eWxlc1sncGxhY2Vob2xkZXItY29sb3InXVxuICBpZiAocGhDb2xvcikge1xuICAgIHNldFBsYWNlaG9sZGVyQ29sb3Iodm0sIHBoQ29sb3IpXG4gIH1cbiAgcmV0dXJuIHN0eWxlc1xufVxuXG5mdW5jdGlvbiBnZXRJbnB1dCAod2VleCkge1xuICBjb25zdCB7IGlucHV0Q29tbW9uIH0gPSB3ZWV4Lm1peGluc1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ3dlZXgtaW5wdXQnLFxuICAgIG1peGluczogW2lucHV0Q29tbW9uXSxcbiAgICBwcm9wczoge1xuICAgICAgdHlwZToge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6ICd0ZXh0JyxcbiAgICAgICAgdmFsaWRhdG9yICh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAnZW1haWwnLCAnbnVtYmVyJywgJ3Bhc3N3b3JkJywgJ3NlYXJjaCcsICd0ZWwnLCAndGV4dCcsICd1cmwnLCAnZGF0ZScsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnLCAndGltZSdcbiAgICAgICAgICAgIC8vIHVuc3VwcG9ydGVkIHR5cGU6XG4gICAgICAgICAgICAvLyBidXR0b24sIGNoZWNrYm94LCBjb2xvciwgZmlsZSwgaGlkZGVuLCBpbWFnZSxcbiAgICAgICAgICAgIC8vIG1vbnRoLCByYWRpbywgcmFuZ2UsIHJlc2V0LCBzdWJtaXQsIHdlZWssXG4gICAgICAgICAgXS5pbmRleE9mKHZhbHVlKSAhPT0gLTFcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHZhbHVlOiBTdHJpbmcsXG4gICAgICBwbGFjZWhvbGRlcjogU3RyaW5nLFxuICAgICAgZGlzYWJsZWQ6IHtcbiAgICAgICAgdHlwZTogW1N0cmluZywgQm9vbGVhbl0sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgYXV0b2ZvY3VzOiB7XG4gICAgICAgIHR5cGU6IFtTdHJpbmcsIEJvb2xlYW5dLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIG1heGxlbmd0aDogW1N0cmluZywgTnVtYmVyXSxcbiAgICAgIHJldHVybktleVR5cGU6IFN0cmluZ1xuICAgIH0sXG5cbiAgICByZW5kZXIgKGNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIGlmICghdGhpcy5faWQpIHtcbiAgICAgICAgdGhpcy5faWQgPSBpZENvdW50KytcbiAgICAgIH1cbiAgICAgIGNvbnN0IGV2ZW50cyA9IG1hcEZvcm1FdmVudHModGhpcylcbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdodG1sOmlucHV0Jywge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgICd3ZWV4LXR5cGUnOiAnaW5wdXQnLFxuICAgICAgICAgIGlkOiBgJHtJRF9QUkVGSVhfSU5QVVR9JHt0aGlzLl9pZH1gLFxuICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZSxcbiAgICAgICAgICBkaXNhYmxlZDogKHRoaXMuZGlzYWJsZWQgIT09ICdmYWxzZScgJiYgdGhpcy5kaXNhYmxlZCAhPT0gZmFsc2UpLFxuICAgICAgICAgIGF1dG9mb2N1czogKHRoaXMuYXV0b2ZvY3VzICE9PSAnZmFsc2UnICYmIHRoaXMuYXV0b2ZvY3VzICE9PSBmYWxzZSksXG4gICAgICAgICAgcGxhY2Vob2xkZXI6IHRoaXMucGxhY2Vob2xkZXIsXG4gICAgICAgICAgbWF4bGVuZ3RoOiB0aGlzLm1heGxlbmd0aCxcbiAgICAgICAgICAncmV0dXJuS2V5VHlwZSc6IHRoaXMucmV0dXJuS2V5VHlwZVxuICAgICAgICB9LFxuICAgICAgICBkb21Qcm9wczoge1xuICAgICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlXG4gICAgICAgIH0sXG4gICAgICAgIG9uOiB0aGlzLmNyZWF0ZUtleWJvYXJkRXZlbnQoZXZlbnRzKSxcbiAgICAgICAgc3RhdGljQ2xhc3M6ICd3ZWV4LWlucHV0IHdlZXgtZWwnLFxuICAgICAgICBzdGF0aWNTdHlsZTogcHJvY2Vzc1N0eWxlKHRoaXMpXG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQgKHdlZXgpIHtcbiAgICBtYXBGb3JtRXZlbnRzID0gd2VleC51dGlscy5tYXBGb3JtRXZlbnRzXG4gICAgYXBwZW5kQ3NzID0gd2VleC51dGlscy5hcHBlbmRDc3NcblxuICAgIHdlZXgucmVnaXN0ZXJDb21wb25lbnQoJ2lucHV0JywgZ2V0SW5wdXQod2VleCkpXG4gIH1cbn1cbiIsIi8qXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0ICcuL3N0eWxlLmNzcydcblxuZnVuY3Rpb24gZ2V0U3dpdGNoICh3ZWV4KSB7XG4gIGNvbnN0IHsgZXh0cmFjdENvbXBvbmVudFN0eWxlIH0gPSB3ZWV4XG4gIGNvbnN0IHsgZGlzcGF0Y2hOYXRpdmVFdmVudCB9ID0gd2VleC51dGlsc1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ3dlZXgtc3dpdGNoJyxcbiAgICBwcm9wczoge1xuICAgICAgY2hlY2tlZDoge1xuICAgICAgICB0eXBlOiBbQm9vbGVhbiwgU3RyaW5nXSxcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBkaXNhYmxlZDoge1xuICAgICAgICB0eXBlOiBbQm9vbGVhbiwgU3RyaW5nXSxcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICAvLyBCb3JkZXIgY29sb3IgIHdoZW4gdGhlIHN3aXRjaCBpcyB0dXJuZWQgb2ZmXG4gICAgICB0aW50Q29sb3I6IFN0cmluZyxcbiAgICAgIC8vIEJhY2tncm91bmQgY29sb3Igd2hlbiB0aGUgc3dpdGNoIGlzIHR1cm5lZCBvbi5cbiAgICAgIG9uVGludENvbG9yOiBTdHJpbmcsXG4gICAgICAvLyBDb2xvciBvZiB0aGUgZm9yZWdyb3VuZCBzd2l0Y2ggZ3JpcC5cbiAgICAgIHRodW1iVGludENvbG9yOiBTdHJpbmdcbiAgICB9LFxuICAgIGRhdGEgKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNDaGVja2VkOiAodGhpcy5jaGVja2VkICE9PSAnZmFsc2UnICYmIHRoaXMuY2hlY2tlZCAhPT0gZmFsc2UpLFxuICAgICAgICBpc0Rpc2FibGVkOiAodGhpcy5kaXNhYmxlZCAhPT0gJ2ZhbHNlJyAmJiB0aGlzLmRpc2FibGVkICE9PSBmYWxzZSlcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICB3cmFwcGVyQ2xhc3MgKCkge1xuICAgICAgICBjb25zdCBjbGFzc0FycmF5ID0gWyd3ZWV4LWVsJywgJ3dlZXgtc3dpdGNoJ11cbiAgICAgICAgdGhpcy5pc0NoZWNrZWQgJiYgY2xhc3NBcnJheS5wdXNoKCd3ZWV4LXN3aXRjaC1jaGVja2VkJylcbiAgICAgICAgdGhpcy5pc0Rpc2FibGVkICYmIGNsYXNzQXJyYXkucHVzaCgnd2VleC1zd2l0Y2gtZGlzYWJsZWQnKVxuICAgICAgICByZXR1cm4gY2xhc3NBcnJheS5qb2luKCcgJylcbiAgICAgIH0sXG4gICAgICBtZXJnZVN0eWxlICgpIHtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBleHRyYWN0Q29tcG9uZW50U3R5bGUodGhpcylcbiAgICAgICAgY29uc3QgeyB0aW50Q29sb3IsIG9uVGludENvbG9yLCBpc0NoZWNrZWQsIGlzRGlzYWJsZWQgfSA9IHRoaXNcblxuICAgICAgICBpZiAoIWlzQ2hlY2tlZCAmJiB0aW50Q29sb3IpIHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHN0eWxlLCB7XG4gICAgICAgICAgICBib3JkZXJDb2xvcjogdGludENvbG9yLFxuICAgICAgICAgICAgYm94U2hhZG93OiBgJHt0aW50Q29sb3J9IDAgMCAwIDAgaW5zZXRgXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0NoZWNrZWQgJiYgb25UaW50Q29sb3IpIHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHN0eWxlLCB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IG9uVGludENvbG9yLFxuICAgICAgICAgICAgY29sb3I6IG9uVGludENvbG9yLFxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IG9uVGludENvbG9yLFxuICAgICAgICAgICAgYm94U2hhZG93OiBgJHtvblRpbnRDb2xvcn0gMCAwIDAgMC41MzMzMzNyZW0gaW5zZXRgXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlzRGlzYWJsZWQgJiYgT2JqZWN0LmFzc2lnbihzdHlsZSwge1xuICAgICAgICAgIG9wYWNpdHk6IDAuM1xuICAgICAgICB9KVxuXG4gICAgICAgIHJldHVybiBzdHlsZVxuICAgICAgfSxcbiAgICAgIHNtYWxsU3R5bGUgKCkge1xuICAgICAgICBjb25zdCB7IHRodW1iVGludENvbG9yIH0gPSB0aGlzXG4gICAgICAgIGxldCBzbWFsbFN0eWxlID0ge31cblxuICAgICAgICBpZiAodGh1bWJUaW50Q29sb3IpIHtcbiAgICAgICAgICBzbWFsbFN0eWxlID0ge1xuICAgICAgICAgICAgYmFja2dyb3VuZDogdGh1bWJUaW50Q29sb3JcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNtYWxsU3R5bGVcbiAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIHRvZ2dsZSAoKSB7XG4gICAgICAgIC8vIFRPRE86IGhhbmRsZSB0aGUgZXZlbnRzXG4gICAgICAgIGlmICghdGhpcy5pc0Rpc2FibGVkKSB7XG4gICAgICAgICAgdGhpcy5pc0NoZWNrZWQgPSAhdGhpcy5pc0NoZWNrZWRcbiAgICAgICAgICBkaXNwYXRjaE5hdGl2ZUV2ZW50KHRoaXMuJGVsLCAnY2hhbmdlJywgeyB2YWx1ZTogdGhpcy5pc0NoZWNrZWQgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBtb3VudGVkICgpIHtcbiAgICAgIGNvbnN0IGVsID0gdGhpcy4kZWxcbiAgICAgIGlmIChlbCAmJiBlbC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICBpZiAoIXRoaXMuX3JlbW92ZUNsaWNrSGFuZGxlcikge1xuICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSBldnQgPT4ge1xuICAgICAgICAgICAgdGhpcy50b2dnbGUoKVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9yZW1vdmVDbGlja0hhbmRsZXIgPSBlbC5yZW1vdmVFdmVudExpc3RlbmVyLmJpbmQoZWwsICd3ZWV4JHRhcCcsIGhhbmRsZXIpXG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignd2VleCR0YXAnLCBoYW5kbGVyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGJlZm9yZURlc3Ryb3kgKCkge1xuICAgICAgY29uc3Qgcm0gPSB0aGlzLl9yZW1vdmVDbGlja0hhbmRsZXJcbiAgICAgIGlmIChybSkge1xuICAgICAgICBybSgpXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9yZW1vdmVDbGlja0hhbmRsZXJcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVuZGVyIChjcmVhdGVFbGVtZW50KSB7XG4gICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgnc3BhbicsIHtcbiAgICAgICAgYXR0cnM6IHsgJ3dlZXgtdHlwZSc6ICdzd2l0Y2gnIH0sXG4gICAgICAgIHN0YXRpY0NsYXNzOiB0aGlzLndyYXBwZXJDbGFzcyxcbiAgICAgICAgc3RhdGljU3R5bGU6IHRoaXMubWVyZ2VTdHlsZVxuICAgICAgfSwgW2NyZWF0ZUVsZW1lbnQoJ3NtYWxsJywge1xuICAgICAgICBzdGF0aWNDbGFzczogJ3dlZXgtc3dpdGNoLWlubmVyJyxcbiAgICAgICAgc3RhdGljU3R5bGU6IHRoaXMuc21hbGxTdHlsZVxuICAgICAgfSldKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQgKHdlZXgpIHtcbiAgICB3ZWV4LnJlZ2lzdGVyQ29tcG9uZW50KCdzd2l0Y2gnLCBnZXRTd2l0Y2god2VleCkpXG4gIH1cbn1cbiIsIi8qXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5jb25zdCBERUZBVUxUX09GRlNFVF9BQ0NVUkFDWSA9IDEwXG5jb25zdCBERUZBVUxUX0xPQURNT1JFX09GRlNFVCA9IDBcblxuZnVuY3Rpb24gZ2V0VGhyb3R0bGVkU2Nyb2xsIChjb250ZXh0KSB7XG4gIGNvbnN0IHNjYWxlID0gd2VleC5jb25maWcuZW52LnNjYWxlXG4gIGlmICghY29udGV4dC5fdGhyb3R0bGVTY3JvbGwpIHtcbiAgICBjb25zdCB3cmFwcGVyID0gY29udGV4dC4kcmVmcy53cmFwcGVyXG4gICAgY29uc3QgaW5uZXIgPSBjb250ZXh0LiRyZWZzLmlubmVyXG4gICAgbGV0IHByZU9mZnNldCA9IChjb250ZXh0LnNjcm9sbERpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnXG4gICAgICA/IHdyYXBwZXIuc2Nyb2xsTGVmdFxuICAgICAgOiB3cmFwcGVyLnNjcm9sbFRvcClcbiAgICAgIHx8IDBcbiAgICBjb250ZXh0Ll90aHJvdHRsZVNjcm9sbCA9IHdlZXgudXRpbHMudGhyb3R0bGUoZnVuY3Rpb24gKGV2dCkge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gY29udGV4dC5zY3JvbGxEaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJ1xuICAgICAgICA/IHdyYXBwZXIuc2Nyb2xsTGVmdFxuICAgICAgICA6IHdyYXBwZXIuc2Nyb2xsVG9wXG4gICAgICBjb25zdCBpbmRlbnQgPSBwYXJzZUludChjb250ZXh0Lm9mZnNldEFjY3VyYWN5KSAqIHNjYWxlXG4gICAgICBmdW5jdGlvbiB0cmlnZ2VyU2Nyb2xsICgpIHtcbiAgICAgICAgY29uc3QgcmVjdCA9IGlubmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgIGNvbnN0IGV2dE9iaiA9IHtcbiAgICAgICAgICBjb250ZW50U2l6ZTogeyB3aWR0aDogcmVjdC53aWR0aCwgaGVpZ2h0OiByZWN0LmhlaWdodCB9LFxuICAgICAgICAgIGNvbnRlbnRPZmZzZXQ6IHtcbiAgICAgICAgICAgIHg6IHdyYXBwZXIuc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogcG9zaXRpdmUgZGlyZWNpdG9uIGZvciB5LWF4aXMgaXMgZG93bi5cbiAgICAgICAgICAgICAqIHNvIHNob3VsZCB1c2UgbmVnYXRpdmUgb3BlcmF0aW9uIG9uIHNjcm9sbFRvcC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgKDAsMCktLS0tLS0tLS0tLS0tLS0+IHhcbiAgICAgICAgICAgICAqICAgICAgIHxcbiAgICAgICAgICAgICAqICAgICAgIHxcbiAgICAgICAgICAgICAqICAgICAgIHxcbiAgICAgICAgICAgICAqICAgICAgIHxcbiAgICAgICAgICAgICAqICAgICAgIHYgeVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgeTogLXdyYXBwZXIuc2Nyb2xsVG9wXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZXh0LiRlbCkge1xuICAgICAgICAgIHdlZXgudXRpbHMuZGlzcGF0Y2hOYXRpdmVFdmVudChjb250ZXh0LiRlbCwgJ3dlZXgkc2Nyb2xsJywgZXZ0T2JqKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoTWF0aC5hYnMob2Zmc2V0IC0gcHJlT2Zmc2V0KSA+PSBpbmRlbnQpIHtcbiAgICAgICAgdHJpZ2dlclNjcm9sbCgpXG4gICAgICAgIHByZU9mZnNldCA9IG9mZnNldFxuICAgICAgfVxuICAgIH0sIDE2LCB0cnVlKVxuICB9XG4gIHJldHVybiBjb250ZXh0Ll90aHJvdHRsZVNjcm9sbFxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHByb3BzOiB7XG4gICAgbG9hZG1vcmVvZmZzZXQ6IHtcbiAgICAgIHR5cGU6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgICBkZWZhdWx0OiBERUZBVUxUX0xPQURNT1JFX09GRlNFVCxcbiAgICAgIHZhbGlkYXRvciAodmFsdWUpIHtcbiAgICAgICAgY29uc3QgdmFsID0gcGFyc2VJbnQodmFsdWUpXG4gICAgICAgIHJldHVybiAhaXNOYU4odmFsKSAmJiB2YWwgPj0gREVGQVVMVF9MT0FETU9SRV9PRkZTRVRcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgb2Zmc2V0QWNjdXJhY3k6IHtcbiAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICBkZWZhdWx0OiBERUZBVUxUX09GRlNFVF9BQ0NVUkFDWSxcbiAgICAgIHZhbGlkYXRvciAodmFsdWUpIHtcbiAgICAgICAgY29uc3QgdmFsID0gcGFyc2VJbnQodmFsdWUpXG4gICAgICAgIHJldHVybiAhaXNOYU4odmFsKSAmJiB2YWwgPj0gREVGQVVMVF9PRkZTRVRfQUNDVVJBQ1lcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgY3JlYXRlZCAoKSB7XG4gICAgLy8gc2hvdWxkIGNhbGwgcmVzZXRMb2FkbW9yZSgpIHRvIGVuYWJsZSBsb2FkbW9yZSBldmVudC5cbiAgICB0aGlzLl9sb2FkbW9yZVJlc2V0ID0gdHJ1ZVxuICB9LFxuXG4gIG1vdW50ZWQgKCkge1xuICAgIHRoaXMucmVsb2FkU3RpY2t5Q2hpbGRyZW4oKVxuICB9LFxuXG4gIHVwZGF0ZWQgKCkge1xuICAgIHRoaXMucmVsb2FkU3RpY2t5Q2hpbGRyZW4oKVxuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICB1cGRhdGVMYXlvdXQgKCkge1xuICAgICAgY29uc3Qgd3JhcHBlciA9IHRoaXMuJHJlZnMud3JhcHBlclxuICAgICAgaWYgKHdyYXBwZXIpIHtcbiAgICAgICAgY29uc3QgcmVjdCA9IHdyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgICAgdGhpcy5fd3JhcHBlcldpZHRoID0gcmVjdC53aWR0aFxuICAgICAgICB0aGlzLl93cmFwcGVySGVpZ2h0ID0gcmVjdC5oZWlnaHRcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlubmVyID0gdGhpcy4kcmVmcy5pbm5lclxuICAgICAgY29uc3QgY2hpbGRyZW4gPSBpbm5lciAmJiBpbm5lci5jaGlsZHJlblxuICAgICAgaWYgKGlubmVyKSB7XG4gICAgICAgIGNvbnN0IHJlY3QgPSBpbm5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICB0aGlzLl9pbm5lcldpZHRoID0gcmVjdC53aWR0aFxuICAgICAgICB0aGlzLl9pbm5lckhlaWdodCA9IHJlY3QuaGVpZ2h0XG4gICAgICB9XG4gICAgICBjb25zdCBsb2FkaW5nRWwgPSB0aGlzLl9sb2FkaW5nICYmIHRoaXMuX2xvYWRpbmcuJGVsXG4gICAgICBjb25zdCByZWZyZXNoRWwgPSB0aGlzLl9yZWZyZXNoICYmIHRoaXMuX3JlZnJlc2guJGVsXG4gICAgICBpZiAobG9hZGluZ0VsKSB7XG4gICAgICAgIHRoaXMuX2lubmVySGVpZ2h0IC09IGxvYWRpbmdFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHRcbiAgICAgIH1cbiAgICAgIGlmIChyZWZyZXNoRWwpIHtcbiAgICAgICAgdGhpcy5faW5uZXJIZWlnaHQgLT0gcmVmcmVzaEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodFxuICAgICAgfVxuICAgICAgLy8gaW5uZXIgd2lkdGggaXMgYWx3YXlzIHRoZSB2aWV3cG9ydCB3aWR0aCBzb21laG93IGluIGhvcml6b250YWxcbiAgICAgIC8vIHNjb2xsZXIsIHRoZXJlZm9yZSB0aGUgaW5uZXIgd2lkdGggc2hvdWxkIGJlIHJlY2xhY3VsYXRlZC5cbiAgICAgIGlmICh0aGlzLnNjcm9sbERpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnICYmIGNoaWxkcmVuKSB7XG4gICAgICAgIHRoaXMuX2lubmVyV2lkdGggPSB3ZWV4LnV0aWxzLmdldFJhbmdlV2lkdGgoaW5uZXIpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHJlc2V0TG9hZG1vcmUgKCkge1xuICAgICAgdGhpcy5fbG9hZG1vcmVSZXNldCA9IHRydWVcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcHJvY2VzcyBzdGlja3kgY2hpbGRyZW4gaW4gc2Nyb2xsYWJsZSBjb21wb25lbnRzLlxuICAgICAqIGN1cnJlbnQgb25seSBzdXBwb3J0IGxpc3QgYW5kIHZlcnRpY2FsIHNjcm9sbGVyLlxuICAgICAqL1xuICAgIHByb2Nlc3NTdGlja3kgKCkge1xuICAgICAgLyoqXG4gICAgICAgKiBjdXJyZW50IGJyb3dzZXIgc3VwcG9ydCAnc3RpY2t5JyBvciAnLXdlYmtpdC1zdGlja3knLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgICAgICAqIHRvIGRvIGZ1cnRoZXIgbW9yZS5cbiAgICAgICAqL1xuICAgICAgY29uc3Qgc3RpY2t5Q2hpbGRyZW4gPSB0aGlzLl9zdGlja3lDaGlsZHJlblxuICAgICAgY29uc3QgbGVuID0gc3RpY2t5Q2hpbGRyZW4gJiYgc3RpY2t5Q2hpbGRyZW4ubGVuZ3RoIHx8IDBcbiAgICAgIGlmIChsZW4gPD0gMCkgeyByZXR1cm4gfVxuXG4gICAgICBjb25zdCBvcmlnU3RpY2t5ID0gd2VleC51dGlscy5zdXBwb3J0U3RpY2t5KClcbiAgICAgIC8vIGN1cnJlbnQgb25seSBzdXBwb3J0IGxpc3QgYW5kIHZlcnRpY2FsIHNjcm9sbGVyLlxuICAgICAgaWYgKHRoaXMuc2Nyb2xsRGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuJGVsXG4gICAgICBpZiAoIWNvbnRhaW5lcikgeyByZXR1cm4gfVxuICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gY29udGFpbmVyLnNjcm9sbFRvcFxuXG4gICAgICBsZXQgc3RpY2t5Q2hpbGRcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgc3RpY2t5Q2hpbGQgPSBzdGlja3lDaGlsZHJlbltpXVxuICAgICAgICBpZiAob3JpZ1N0aWNreSkge1xuICAgICAgICAgIHRoaXMuYWRkU3RpY2t5KHN0aWNreUNoaWxkLCBvcmlnU3RpY2t5KVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0aWNreUNoaWxkLl9pbml0T2Zmc2V0VG9wIDwgc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgdGhpcy5hZGRTdGlja3koc3RpY2t5Q2hpbGQpXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVTdGlja3koc3RpY2t5Q2hpbGQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWRkU3RpY2t5IChlbCwgc3VwcG9ydFN0aWNreSkge1xuICAgICAgaWYgKHN1cHBvcnRTdGlja3kpIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnd2VleC1pb3Mtc3RpY2t5JylcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoZWwuX3N0aWNreSA9PT0gdHJ1ZSkgcmV0dXJuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFt2dWUtcmVuZGVyXSBoZWFkZXIgYWRkIHN0aWNreWAsIGVsKVxuICAgICAgICB9XG4gICAgICAgIGVsLl9zdGlja3kgPSB0cnVlXG4gICAgICAgIGlmICghZWwuX3BsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSBlbC5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgICBwbGFjZWhvbGRlci5fb3JpZ05vZGUgPSBlbFxuICAgICAgICAgIHBsYWNlaG9sZGVyLmNsYXNzTGlzdC5hZGQoJ3dlZXgtc3RpY2t5LXBsYWNlaG9sZGVyJylcbiAgICAgICAgICBlbC5fcGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlclxuICAgICAgICB9XG4gICAgICAgIGVsLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsLl9wbGFjZWhvbGRlciwgZWwpXG4gICAgICAgIGVsLnN0eWxlLndpZHRoID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpLndpZHRoXG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ3dlZXgtc3RpY2t5JylcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVtb3ZlU3RpY2t5IChlbCkge1xuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgZWwuX3N0aWNreSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgfHwgZWwuX3N0aWNreSA9PT0gZmFsc2VcbiAgICAgICkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbdnVlLXJlbmRlcl0gaGVhZGVyIHJlbW92ZSBzdGlja3lgLCBlbClcbiAgICAgIH1cbiAgICAgIGVsLl9zdGlja3kgPSBmYWxzZVxuICAgICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbC5fcGxhY2Vob2xkZXIpXG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCd3ZWV4LXN0aWNreScpXG4gICAgfSxcblxuICAgIHJlbG9hZFN0aWNreUNoaWxkcmVuICgpIHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuJGVsXG4gICAgICBpZiAoIWNvbnRhaW5lcikgcmV0dXJuXG4gICAgICBjb25zdCBzdGlja3lDaGlsZHJlbiA9IFtdXG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCdbc3RpY2t5XScpXG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldXG4gICAgICAgIGlmICgvd2VleC1zdGlja3ktcGxhY2Vob2xkZXIvLnRlc3QoY2hpbGQuY2xhc3NOYW1lKSkgeyAgLy8gaXMgYSBwbGFjZWhvbGRlci5cbiAgICAgICAgICBjb25zdCBvcmlnTm9kZSA9IGNoaWxkLl9vcmlnTm9kZVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFvcmlnTm9kZVxuICAgICAgICAgICAgfHwgIW9yaWdOb2RlLnBhcmVudE5vZGVcbiAgICAgICAgICAgIHx8IG9yaWdOb2RlLnBhcmVudE5vZGUgIT09IGNoaWxkLnBhcmVudE5vZGVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAgLy8gaXMgYSBzdGlja3kgbm9kZS5cbiAgICAgICAgICBzdGlja3lDaGlsZHJlbi5wdXNoKGNoaWxkKVxuICAgICAgICAgIGlmICghY2hpbGQuX3N0aWNreSkge1xuICAgICAgICAgICAgY2hpbGQuX2luaXRPZmZzZXRUb3AgPSBjaGlsZC5vZmZzZXRUb3BcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX3N0aWNreUNoaWxkcmVuID0gc3RpY2t5Q2hpbGRyZW5cbiAgICB9LFxuXG4gICAgaGFuZGxlU2Nyb2xsIChldmVudCkge1xuICAgICAgd2VleC51dGlscy5nZXRUaHJvdHRsZUxhenlsb2FkKDI1LCB0aGlzLiRlbCwgJ3Njcm9sbCcpKClcbiAgICAgIGdldFRocm90dGxlZFNjcm9sbCh0aGlzKShldmVudClcblxuICAgICAgdGhpcy5wcm9jZXNzU3RpY2t5KClcblxuICAgICAgLy8gZmlyZSBsb2FkbW9yZSBldmVudC5cbiAgICAgIGNvbnN0IGlubmVyID0gdGhpcy4kcmVmcy5pbm5lclxuICAgICAgaWYgKGlubmVyKSB7XG4gICAgICAgIGNvbnN0IGlubmVyTGVuZ3RoID0gdGhpcy5zY3JvbGxEaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJ1xuICAgICAgICAgID8gdGhpcy5faW5uZXJXaWR0aFxuICAgICAgICAgIDogdGhpcy5faW5uZXJIZWlnaHRcbiAgICAgICAgaWYgKCF0aGlzLl9pbm5lckxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuX2lubmVyTGVuZ3RoID0gaW5uZXJMZW5ndGhcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW5uZXJMZW5ndGggIT09IGlubmVyTGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5faW5uZXJMZW5ndGggPSBpbm5lckxlbmd0aFxuICAgICAgICAgIHRoaXMuX2xvYWRtb3JlUmVzZXQgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2xvYWRtb3JlUmVzZXQgJiYgdGhpcy5yZWFjaEJvdHRvbSh0aGlzLmxvYWRtb3Jlb2Zmc2V0KSkge1xuICAgICAgICAgIHRoaXMuX2xvYWRtb3JlUmVzZXQgPSBmYWxzZVxuICAgICAgICAgIGNvbnN0IGVsID0gdGhpcy4kZWxcbiAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgIHdlZXgudXRpbHMuZGlzcGF0Y2hOYXRpdmVFdmVudChlbCwgJ2xvYWRtb3JlJylcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVhY2hUb3AgKCkge1xuICAgICAgY29uc3Qgd3JhcHBlciA9IHRoaXMuJHJlZnMud3JhcHBlclxuICAgICAgcmV0dXJuICghIXdyYXBwZXIpICYmICh3cmFwcGVyLnNjcm9sbFRvcCA8PSAwKVxuICAgIH0sXG5cbiAgICByZWFjaEJvdHRvbSAob2Zmc2V0KSB7XG4gICAgICBjb25zdCB3cmFwcGVyID0gdGhpcy4kcmVmcy53cmFwcGVyXG4gICAgICBjb25zdCBpbm5lciA9IHRoaXMuJHJlZnMuaW5uZXJcbiAgICAgIG9mZnNldCA9IHBhcnNlSW50KG9mZnNldCB8fCAwKSAqIHdlZXguY29uZmlnLmVudi5zY2FsZVxuXG4gICAgICBpZiAod3JhcHBlciAmJiBpbm5lcikge1xuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLnNjcm9sbERpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnXG4gICAgICAgICAgPyAnd2lkdGgnXG4gICAgICAgICAgOiAnaGVpZ2h0J1xuICAgICAgICBjb25zdCBpbm5lckxlbmd0aCA9IHRoaXNbYF9pbm5lciR7a2V5WzBdLnRvVXBwZXJDYXNlKCl9JHtrZXkuc3Vic3RyKDEpfWBdXG4gICAgICAgIGNvbnN0IHdyYXBwZXJMZW5ndGggPSB0aGlzW2Bfd3JhcHBlciR7a2V5WzBdLnRvVXBwZXJDYXNlKCl9JHtrZXkuc3Vic3RyKDEpfWBdXG4gICAgICAgIGNvbnN0IHNjcm9sbE9mZnNldCA9IHRoaXMuc2Nyb2xsRGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCdcbiAgICAgICAgICA/IHdyYXBwZXIuc2Nyb2xsTGVmdFxuICAgICAgICAgIDogd3JhcHBlci5zY3JvbGxUb3BcbiAgICAgICAgcmV0dXJuIHNjcm9sbE9mZnNldCA+PSBpbm5lckxlbmd0aCAtIHdyYXBwZXJMZW5ndGggLSBvZmZzZXRcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0sXG5cbiAgICBoYW5kbGVUb3VjaFN0YXJ0IChldmVudCkge1xuICAgICAgaWYgKHRoaXMuX2xvYWRpbmcgfHwgdGhpcy5fcmVmcmVzaCkge1xuICAgICAgICBjb25zdCB0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdXG4gICAgICAgIHRoaXMuX3RvdWNoUGFyYW1zID0ge1xuICAgICAgICAgIHJlYWNoVG9wOiB0aGlzLnJlYWNoVG9wKCksXG4gICAgICAgICAgcmVhY2hCb3R0b206IHRoaXMucmVhY2hCb3R0b20oKSxcbiAgICAgICAgICBzdGFydFRvdWNoRXZlbnQ6IHRvdWNoLFxuICAgICAgICAgIHN0YXJ0WDogdG91Y2gucGFnZVgsXG4gICAgICAgICAgc3RhcnRZOiB0b3VjaC5wYWdlWSxcbiAgICAgICAgICB0aW1lU3RhbXA6IGV2ZW50LnRpbWVTdGFtcFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGhhbmRsZVRvdWNoTW92ZSAoZXZlbnQpIHtcbiAgICAgIGlmICghdGhpcy5fdG91Y2hQYXJhbXMgfHwgIXRoaXMuX3JlZnJlc2ggJiYgIXRoaXMuX2xvYWRpbmcpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBjb25zdCBpbm5lciA9IHRoaXMuJHJlZnMuaW5uZXJcbiAgICAgIGNvbnN0IHsgc3RhcnRZLCByZWFjaFRvcCwgcmVhY2hCb3R0b20gfSA9IHRoaXMuX3RvdWNoUGFyYW1zXG4gICAgICBpZiAoaW5uZXIpIHtcbiAgICAgICAgY29uc3QgdG91Y2ggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXVxuICAgICAgICBjb25zdCBvZmZzZXRZID0gdG91Y2gucGFnZVkgLSBzdGFydFlcbiAgICAgICAgY29uc3QgZGlyID0gb2Zmc2V0WSA+IDAgPyAnZG93bicgOiAndXAnXG4gICAgICAgIHRoaXMuX3RvdWNoUGFyYW1zLm9mZnNldFkgPSBvZmZzZXRZXG4gICAgICAgIGlmICh0aGlzLl9yZWZyZXNoICYmIChkaXIgPT09ICdkb3duJykgJiYgcmVhY2hUb3ApIHtcbiAgICAgICAgICB0aGlzLl9yZWZyZXNoLnB1bGxpbmdEb3duKG9mZnNldFkpXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fbG9hZGluZyAmJiAoZGlyID09PSAndXAnKSAmJiByZWFjaEJvdHRvbSkge1xuICAgICAgICAgIHRoaXMuX2xvYWRpbmcucHVsbGluZ1VwKC1vZmZzZXRZKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGhhbmRsZVRvdWNoRW5kIChldmVudCkge1xuICAgICAgaWYgKCF0aGlzLl90b3VjaFBhcmFtcyB8fCAhdGhpcy5fcmVmcmVzaCAmJiAhdGhpcy5fbG9hZGluZykge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGNvbnN0IGlubmVyID0gdGhpcy4kcmVmcy5pbm5lclxuICAgICAgY29uc3QgeyBzdGFydFksIHJlYWNoVG9wLCByZWFjaEJvdHRvbSB9ID0gdGhpcy5fdG91Y2hQYXJhbXNcbiAgICAgIGlmIChpbm5lcikge1xuICAgICAgICBjb25zdCB0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdXG4gICAgICAgIGNvbnN0IG9mZnNldFkgPSB0b3VjaC5wYWdlWSAtIHN0YXJ0WVxuICAgICAgICBjb25zdCBkaXIgPSBvZmZzZXRZID4gMCA/ICdkb3duJyA6ICd1cCdcbiAgICAgICAgdGhpcy5fdG91Y2hQYXJhbXMub2Zmc2V0WSA9IG9mZnNldFlcbiAgICAgICAgaWYgKHRoaXMuX3JlZnJlc2ggJiYgKGRpciA9PT0gJ2Rvd24nKSAmJiByZWFjaFRvcCkge1xuICAgICAgICAgIHRoaXMuX3JlZnJlc2gucHVsbGluZ0VuZCgpXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fbG9hZGluZyAmJiAoZGlyID09PSAndXAnKSAmJiByZWFjaEJvdHRvbSkge1xuICAgICAgICAgIHRoaXMuX2xvYWRpbmcucHVsbGluZ0VuZCgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0aGlzLl90b3VjaFBhcmFtc1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBzY3JvbGxhYmxlIGZyb20gJy4vc2Nyb2xsYWJsZSdcblxuZXhwb3J0IHtcbiAgc2Nyb2xsYWJsZVxufVxuIiwiLypcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBzY3JvbGxhYmxlIH0gZnJvbSAnLi9taXhpbnMnXG5cbmZ1bmN0aW9uIGdldExpc3QgKHdlZXgpIHtcbiAgY29uc3Qge1xuICAgIGV4dHJhY3RDb21wb25lbnRTdHlsZVxuICB9ID0gd2VleFxuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ3dlZXgtbGlzdCcsXG4gICAgbWl4aW5zOiBbc2Nyb2xsYWJsZV0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIHdyYXBwZXJDbGFzcyAoKSB7XG4gICAgICAgIGNvbnN0IGNsYXNzQXJyYXkgPSBbJ3dlZXgtbGlzdCcsICd3ZWV4LWxpc3Qtd3JhcHBlcicsICd3ZWV4LWN0J11cbiAgICAgICAgdGhpcy5fcmVmcmVzaCAmJiBjbGFzc0FycmF5LnB1c2goJ3dpdGgtcmVmcmVzaCcpXG4gICAgICAgIHRoaXMuX2xvYWRpbmcgJiYgY2xhc3NBcnJheS5wdXNoKCd3aXRoLWxvYWRpbmcnKVxuICAgICAgICByZXR1cm4gY2xhc3NBcnJheS5qb2luKCcgJylcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuICAgICAgY3JlYXRlQ2hpbGRyZW4gKGgpIHtcbiAgICAgICAgY29uc3Qgc2xvdHMgPSB0aGlzLiRzbG90cy5kZWZhdWx0IHx8IFtdXG4gICAgICAgIHRoaXMuX2NlbGxzID0gc2xvdHMuZmlsdGVyKHZub2RlID0+IHtcbiAgICAgICAgICBpZiAoIXZub2RlLnRhZyAmJiAhdm5vZGUuY29tcG9uZW50T3B0aW9ucykgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBoKCdhcnRpY2xlJywge1xuICAgICAgICAgICAgcmVmOiAnaW5uZXInLFxuICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd3ZWV4LWxpc3QtaW5uZXIgd2VleC1jdCdcbiAgICAgICAgICB9LCB0aGlzLl9jZWxscylcbiAgICAgICAgXVxuICAgICAgfVxuICAgIH0sXG5cbiAgICByZW5kZXIgKGNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIHRoaXMud2VleFR5cGUgPSAnbGlzdCdcblxuICAgICAgdGhpcy4kbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZUxheW91dCgpXG4gICAgICB9KVxuXG4gICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgnbWFpbicsIHtcbiAgICAgICAgcmVmOiAnd3JhcHBlcicsXG4gICAgICAgIGF0dHJzOiB7ICd3ZWV4LXR5cGUnOiAnbGlzdCcgfSxcbiAgICAgICAgc3RhdGljQ2xhc3M6IHRoaXMud3JhcHBlckNsYXNzLFxuICAgICAgICBvbjoge1xuICAgICAgICAgIHNjcm9sbDogdGhpcy5oYW5kbGVTY3JvbGwsXG4gICAgICAgICAgdG91Y2hzdGFydDogdGhpcy5oYW5kbGVUb3VjaFN0YXJ0LFxuICAgICAgICAgIHRvdWNobW92ZTogdGhpcy5oYW5kbGVUb3VjaE1vdmUsXG4gICAgICAgICAgdG91Y2hlbmQ6IHRoaXMuaGFuZGxlVG91Y2hFbmRcbiAgICAgICAgfSxcbiAgICAgICAgc3RhdGljU3R5bGU6IGV4dHJhY3RDb21wb25lbnRTdHlsZSh0aGlzKVxuICAgICAgfSwgdGhpcy5jcmVhdGVDaGlsZHJlbihjcmVhdGVFbGVtZW50KSlcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0ICh3ZWV4KSB7XG4gICAgd2VleC5yZWdpc3RlckNvbXBvbmVudCgnbGlzdCcsIGdldExpc3Qod2VleCkpXG4gIH1cbn1cbiIsIi8qXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBzY3JvbGxhYmxlIH0gZnJvbSAnLi9taXhpbnMnXG5cbmZ1bmN0aW9uIGdldFNjcm9sbGVyICh3ZWV4KSB7XG4gIGNvbnN0IHtcbiAgICBleHRyYWN0Q29tcG9uZW50U3R5bGVcbiAgfSA9IHdlZXhcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICd3ZWV4LXNjcm9sbGVyJyxcbiAgICBtaXhpbnM6IFtzY3JvbGxhYmxlXSxcbiAgICBwcm9wczoge1xuICAgICAgc2Nyb2xsRGlyZWN0aW9uOiB7XG4gICAgICAgIHR5cGU6IFtTdHJpbmddLFxuICAgICAgICBkZWZhdWx0OiAndmVydGljYWwnLFxuICAgICAgICB2YWxpZGF0b3IgKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIFsnaG9yaXpvbnRhbCcsICd2ZXJ0aWNhbCddLmluZGV4T2YodmFsdWUpICE9PSAtMVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2Nyb2xsYWJsZToge1xuICAgICAgICB0eXBlOiBbQm9vbGVhbl0sXG4gICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICB3cmFwcGVyQ2xhc3MgKCkge1xuICAgICAgICBjb25zdCBjbGFzc0FycmF5ID0gWyd3ZWV4LXNjcm9sbGVyJywgJ3dlZXgtc2Nyb2xsZXItd3JhcHBlcicsICd3ZWV4LWN0J11cbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsRGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICBjbGFzc0FycmF5LnB1c2goJ3dlZXgtc2Nyb2xsZXItaG9yaXpvbnRhbCcpXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY2xhc3NBcnJheS5wdXNoKCd3ZWV4LXNjcm9sbGVyLXZlcnRpY2FsJylcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuc2Nyb2xsYWJsZSkge1xuICAgICAgICAgIGNsYXNzQXJyYXkucHVzaCgnd2VleC1zY3JvbGxlci1kaXNhYmxlZCcpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsYXNzQXJyYXkuam9pbignICcpXG4gICAgICB9XG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcbiAgICAgIGNyZWF0ZUNoaWxkcmVuIChoKSB7XG4gICAgICAgIGNvbnN0IHNsb3RzID0gdGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXVxuICAgICAgICB0aGlzLl9jZWxscyA9IHNsb3RzLmZpbHRlcih2bm9kZSA9PiB7XG4gICAgICAgICAgaWYgKCF2bm9kZS50YWcgJiYgIXZub2RlLmNvbXBvbmVudE9wdGlvbnMpIHJldHVybiBmYWxzZVxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgaCgnYXJ0aWNsZScsIHtcbiAgICAgICAgICAgIHJlZjogJ2lubmVyJyxcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiAnd2VleC1zY3JvbGxlci1pbm5lciB3ZWV4LWN0J1xuICAgICAgICAgIH0sIHRoaXMuX2NlbGxzKVxuICAgICAgICBdXG4gICAgICB9XG4gICAgfSxcblxuICAgIHJlbmRlciAoY3JlYXRlRWxlbWVudCkge1xuICAgICAgdGhpcy53ZWV4VHlwZSA9ICdzY3JvbGxlcidcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIC8vIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgLy8gICB2YWxpZGF0ZVN0eWxlcygnc2Nyb2xsZXInLCB0aGlzLiR2bm9kZS5kYXRhICYmIHRoaXMuJHZub2RlLmRhdGEuc3RhdGljU3R5bGUpXG4gICAgICAvLyB9XG5cbiAgICAgIHRoaXMuX2NlbGxzID0gdGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXVxuICAgICAgdGhpcy4kbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZUxheW91dCgpXG4gICAgICB9KVxuXG4gICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgnbWFpbicsIHtcbiAgICAgICAgcmVmOiAnd3JhcHBlcicsXG4gICAgICAgIGF0dHJzOiB7ICd3ZWV4LXR5cGUnOiAnc2Nyb2xsZXInIH0sXG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgc2Nyb2xsOiB0aGlzLmhhbmRsZVNjcm9sbCxcbiAgICAgICAgICB0b3VjaHN0YXJ0OiB0aGlzLmhhbmRsZVRvdWNoU3RhcnQsXG4gICAgICAgICAgdG91Y2htb3ZlOiB0aGlzLmhhbmRsZVRvdWNoTW92ZSxcbiAgICAgICAgICB0b3VjaGVuZDogdGhpcy5oYW5kbGVUb3VjaEVuZFxuICAgICAgICB9LFxuICAgICAgICBzdGF0aWNDbGFzczogdGhpcy53cmFwcGVyQ2xhc3MsXG4gICAgICAgIHN0YXRpY1N0eWxlOiBleHRyYWN0Q29tcG9uZW50U3R5bGUodGhpcylcbiAgICAgIH0sIHRoaXMuY3JlYXRlQ2hpbGRyZW4oY3JlYXRlRWxlbWVudCkpXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdCAod2VleCkge1xuICAgIHdlZXgucmVnaXN0ZXJDb21wb25lbnQoJ3Njcm9sbGVyJywgZ2V0U2Nyb2xsZXIod2VleCkpXG4gIH1cbn1cbiIsIi8qXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IHdhdGVyZmFsbFxuICogTk9URTogb25seSBzdXBwb3J0IGZ1bGwgc2NyZWVuIHdpZHRoIHdhdGVyZmFsbC5cbiAqL1xuXG5pbXBvcnQgeyBzY3JvbGxhYmxlIH0gZnJvbSAnLi9taXhpbnMnXG5cbmNvbnN0IE5PUk1BTF9HQVBfU0laRSA9IDMyXG5jb25zdCBERUZBVUxUX0NPTFVNTl9DT1VOVCA9IDFcblxuZnVuY3Rpb24gZ2V0V2F0ZXJmYWxsICh3ZWV4KSB7XG4gIGNvbnN0IHtcbiAgICBleHRyYWN0Q29tcG9uZW50U3R5bGVcbiAgfSA9IHdlZXhcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICd3ZWV4LXdhdGVyZmFsbCcsXG4gICAgbWl4aW5zOiBbc2Nyb2xsYWJsZV0sXG4gICAgcHJvcHM6IHtcbiAgICAgIC8qKlxuICAgICAgICogc3BlY2lmaWVkIGdhcCBzaXplLlxuICAgICAgICogdmFsdWUgY2FuIGJlIG51bWJlciBvciAnbm9ybWFsJy4gJ25vcm1hbCcgKDMycHgpIGJ5IGRlZmF1bHQuXG4gICAgICAgKi9cbiAgICAgIGNvbHVtbkdhcDoge1xuICAgICAgICB0eXBlOiBbU3RyaW5nLCBOdW1iZXJdLFxuICAgICAgICBkZWZhdWx0OiAnbm9ybWFsJyxcbiAgICAgICAgdmFsaWRhdG9yICh2YWwpIHtcbiAgICAgICAgICBpZiAoIXZhbCB8fCB2YWwgPT09ICdub3JtYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YWwgPSBwYXJzZUludCh2YWwpXG4gICAgICAgICAgcmV0dXJuICFpc05hTih2YWwpICYmIHZhbCA+IDBcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogdGhlIG1heGltdW0gY29sdW1uIGNvdW50cy5cbiAgICAgICAqIHZhbHVlIGNhbiBiZSBudW1iZXIgb3IgJ2F1dG8nLiAxIGJ5IGRlZmF1bHQuXG4gICAgICAgKi9cbiAgICAgIGNvbHVtbkNvdW50OiB7XG4gICAgICAgIHR5cGU6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgICAgIGRlZmF1bHQ6IERFRkFVTFRfQ09MVU1OX0NPVU5ULFxuICAgICAgICB2YWxpZGF0b3IgKHZhbCkge1xuICAgICAgICAgIHZhbCA9IHBhcnNlSW50KHZhbClcbiAgICAgICAgICByZXR1cm4gIWlzTmFOKHZhbCkgJiYgdmFsID4gMFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiB0aGUgbWltaW11bSBjb2x1bW4gd2lkdGguXG4gICAgICAgKiB2YWx1ZSBjYW4gYmUgbnVtYmVyIG9yICdhdXRvJy4gJ2F1dG8nIGJ5IGRlZmF1bHQuXG4gICAgICAgKi9cbiAgICAgIGNvbHVtbldpZHRoOiB7XG4gICAgICAgIHR5cGU6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgICAgIGRlZmF1bHQ6ICdhdXRvJyxcbiAgICAgICAgdmFsaWRhdG9yICh2YWwpIHtcbiAgICAgICAgICBpZiAoIXZhbCB8fCB2YWwgPT09ICdhdXRvJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsID0gcGFyc2VJbnQodmFsKVxuICAgICAgICAgIHJldHVybiAhaXNOYU4odmFsKSAmJiB2YWwgPiAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbW91bnRlZCAoKSB7XG4gICAgICB0aGlzLl9uZXh0VGljaygpXG4gICAgfSxcblxuICAgIHVwZGF0ZWQgKCkge1xuICAgICAgdGhpcy4kbmV4dFRpY2sodGhpcy5fbmV4dFRpY2soKSlcbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuICAgICAgX2NyZWF0ZUNoaWxkcmVuIChoLCByb290U3R5bGUpIHtcbiAgICAgICAgY29uc3Qgc2xvdHMgPSAodGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXSkuc2xpY2UoKVxuICAgICAgICB0aGlzLl9oZWFkZXJzID0gW11cbiAgICAgICAgdGhpcy5fZm9vdGVycyA9IFtdXG4gICAgICAgIHRoaXMuX290aGVycyA9IFtdXG4gICAgICAgIGNvbnN0IGxlbiA9IHNsb3RzLmxlbmd0aFxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjb25zdCB2bm9kZSA9IHNsb3RzW2ldXG4gICAgICAgICAgY29uc3QgdGFnID1cbiAgICAgICAgICAgIHZub2RlLmNvbXBvbmVudE9wdGlvbnNcbiAgICAgICAgICAgICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnMudGFnXG4gICAgICAgICAgICB8fCB2bm9kZS50YWdcbiAgICAgICAgICBpZiAodGFnID09PSAncmVmcmVzaCcgfHwgdGFnID09PSAnbG9hZGluZycpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0YWcgPT09ICdzZWN0aW9uJykgeyAgLy8gY2VsbFxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRhZyA9PT0gJ2hlYWRlcicpIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlcnMucHVzaCh2bm9kZSlcbiAgICAgICAgICAgIHNsb3RzW2ldID0gbnVsbCAvLyBzaG91bGQgbm90IGluY2x1ZGVkIGluIGZvb3Rlci5cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjb25zdCB2bm9kZSA9IHNsb3RzW2ldXG4gICAgICAgICAgaWYgKCF2bm9kZSkgeyBjb250aW51ZSB9ICAvLyBhbHJlYWR5IHRha2VuIGJ5IGhlYWRlci5cbiAgICAgICAgICBjb25zdCB0YWcgPVxuICAgICAgICAgICAgdm5vZGUuY29tcG9uZW50T3B0aW9uc1xuICAgICAgICAgICAgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucy50YWdcbiAgICAgICAgICAgIHx8IHZub2RlLnRhZ1xuICAgICAgICAgIGlmICh0YWcgPT09ICdyZWZyZXNoJyB8fCB0YWcgPT09ICdsb2FkaW5nJykge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRhZyA9PT0gJ3NlY3Rpb24nKSB7IC8vIGNlbGxcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0YWcgPT09ICdoZWFkZXInKSB7XG4gICAgICAgICAgICB0aGlzLl9mb290ZXJzLnB1c2godm5vZGUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2VsbHMgPSBzbG90cy5maWx0ZXIodm5vZGUgPT4ge1xuICAgICAgICAgIGlmICghdm5vZGUpIHJldHVybiBmYWxzZVxuICAgICAgICAgIGNvbnN0IGNtcE9wdHMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zXG4gICAgICAgICAgaWYgKCF2bm9kZS50YWcgJiYgIWNtcE9wdHMpIHJldHVybiBmYWxzZVxuICAgICAgICAgIGNvbnN0IHRhZyA9IGNtcE9wdHMgJiYgY21wT3B0cy50YWcgfHwgdm5vZGUudGFnXG4gICAgICAgICAgaWYgKHRhZyA9PT0gJ3JlZnJlc2gnIHx8IHRhZyA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgICAgICAgICB0aGlzW2BfJHt0YWd9YF0gPSB2bm9kZVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0YWcgIT09ICdzZWN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5fb3RoZXJzLnB1c2godm5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLl9yZUNhbGMocm9vdFN0eWxlKVxuICAgICAgICB0aGlzLl9nZW5Db2x1bW5zKGgpXG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdXG4gICAgICAgIHRoaXMuX3JlZnJlc2ggJiYgY2hpbGRyZW4ucHVzaCh0aGlzLl9yZWZyZXNoKVxuICAgICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmNvbmNhdCh0aGlzLl9oZWFkZXJzKVxuICAgICAgICAvLyAuY29uY2F0KHRoaXMuX290aGVycylcbiAgICAgICAgY2hpbGRyZW4ucHVzaChoKCdodG1sOmRpdicsIHtcbiAgICAgICAgICByZWY6ICdjb2x1bW5zJyxcbiAgICAgICAgICBzdGF0aWNDbGFzczogJ3dlZXgtd2F0ZXJmYWxsLWlubmVyLWNvbHVtbnMgd2VleC1jdCdcbiAgICAgICAgfSwgdGhpcy5fY29sdW1ucykpXG4gICAgICAgIGNoaWxkcmVuLnB1c2goaCgnaHRtbDpkaXYnLCB7XG4gICAgICAgICAgcmVmOiAnZm9vdGVycycsXG4gICAgICAgICAgc3RhdGljQ2xhc3M6ICd3ZWV4LXdhdGVyZmFsbC1mb290ZXJzIHdlZXgtY3QnXG4gICAgICAgIH0sIHRoaXMuX2Zvb3RlcnMpKVxuICAgICAgICB0aGlzLl9sb2FkaW5nICYmIGNoaWxkcmVuLnB1c2godGhpcy5fbG9hZGluZylcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBoKCdhcnRpY2xlJywge1xuICAgICAgICAgICAgcmVmOiAnaW5uZXInLFxuICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd3ZWV4LXdhdGVyZmFsbC1pbm5lciB3ZWV4LWN0J1xuICAgICAgICAgIH0sIGNoaWxkcmVuKVxuICAgICAgICBdXG4gICAgICB9LFxuXG4gICAgICBfcmVDYWxjIChyb290U3R5bGUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5PVEU6IGNvbHVtbkdhcCBhbmQgY29sdW1uV2lkdGggY2FuJ3QgYm90aCBiZSBhdXRvLlxuICAgICAgICAgKiBOT1RFOiB0aGUgZm9ybXVsYTpcbiAgICAgICAgICogIHRvdGFsV2lkdGggPSBuICogdyArIChuIC0gMSkgKiBnYXBcbiAgICAgICAgICogMS4gaWYgY29sdW1uQ291bnQgPSBuIHRoZW4gY2FsYyB3XG4gICAgICAgICAqIDIuIGlmIGNvbHVtbldpZHRoID0gdyB0aGVuIGNhbGMgblxuICAgICAgICAgKiAzLiBpZiBjb2x1bW5XaWR0aCA9IHcgYW5kIGNvbHVtbkNvdW50ID0gbiB0aGVuIGNhbGMgdG90YWxXaWR0aFxuICAgICAgICAgKiAgICAzLjEgaWYgdG90YWxXaWR0aCA8IGN0V2lkdGggdGhlbiBpbmNyZWFzZSBjb2x1bW5XaWR0aFxuICAgICAgICAgKiAgICAzLjIgaWYgdG90YWxXaWR0aCA+IGN0V2lkdGggdGhlbiBkZWNyZWFzZSBjb2x1bW5Db3VudFxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IHdpZHRoLCBnYXAsIGNudCwgY3RXaWR0aFxuICAgICAgICBjb25zdCBzY2FsZSA9IHdlZXguY29uZmlnLmVudi5zY2FsZVxuICAgICAgICBjb25zdCBlbCA9IHRoaXMuJGVsXG4gICAgICAgIGZ1bmN0aW9uIGdldEN0V2lkdGggKHdpZHRoLCBzdHlsZSkge1xuICAgICAgICAgIGNvbnN0IHBhZGRpbmcgPSBzdHlsZS5wYWRkaW5nXG4gICAgICAgICAgICA/IHBhcnNlSW50KHN0eWxlLnBhZGRpbmcpICogMlxuICAgICAgICAgICAgOiBwYXJzZUludChzdHlsZS5wYWRkaW5nTGVmdCB8fCAwKSArIHBhcnNlSW50KHN0eWxlLnBhZGRpbmdSaWdodCB8fCAwKVxuICAgICAgICAgIHJldHVybiB3aWR0aCAtIHBhZGRpbmdcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWwgJiYgZWwubm9kZVR5cGUgPT09IDEpIHsgLy8gYWxyZWFkeSBtb3VudGVkXG4gICAgICAgICAgY29uc3QgY3N0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpXG4gICAgICAgICAgY3RXaWR0aCA9IGdldEN0V2lkdGgoZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgsIGNzdHlsZSlcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gbm90IG1vdW50ZWQuXG4gICAgICAgICAgLy8gb25seSBzdXBwb3J0IGZ1bGwgc2NyZWVuIHdpZHRoIGZvciB3YXRlcmZhbGwgY29tcG9uZW50LlxuICAgICAgICAgIGN0V2lkdGggPSBnZXRDdFdpZHRoKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCwgcm9vdFN0eWxlKVxuICAgICAgICB9XG5cbiAgICAgICAgZ2FwID0gdGhpcy5jb2x1bW5HYXBcbiAgICAgICAgaWYgKGdhcCAmJiBnYXAgIT09ICdub3JtYWwnKSB7XG4gICAgICAgICAgZ2FwID0gcGFyc2VJbnQoZ2FwKVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGdhcCA9IE5PUk1BTF9HQVBfU0laRVxuICAgICAgICB9XG4gICAgICAgIGdhcCA9IGdhcCAqIHNjYWxlXG5cbiAgICAgICAgd2lkdGggPSB0aGlzLmNvbHVtbldpZHRoXG4gICAgICAgIGNudCA9IHRoaXMuY29sdW1uQ291bnRcbiAgICAgICAgaWYgKHdpZHRoICYmIHdpZHRoICE9PSAnYXV0bycpIHtcbiAgICAgICAgICB3aWR0aCA9IHBhcnNlSW50KHdpZHRoKSAqIHNjYWxlXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNudCAmJiBjbnQgIT09ICdhdXRvJykge1xuICAgICAgICAgIGNudCA9IHBhcnNlSW50KGNudClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDAuIGlmICFjb2x1bW5Db3VudCAmJiAhY29sdW1uV2lkdGhcbiAgICAgICAgaWYgKGNudCA9PT0gJ2F1dG8nICYmIHdpZHRoID09PSAnYXV0bycpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgW3Z1ZS1yZW5kZXJdIHdhdGVyZmFsbCdzIGNvbHVtbldpZHRoIGFuZCBjb2x1bW5Db3VudCBzaG91bGRuJ3RgXG4gICAgICAgICAgICArIGAgYm90aCBiZSBhdXRvIGF0IHRoZSBzYW1lIHRpbWUuYClcbiAgICAgICAgICAgIGNudCA9IERFRkFVTFRfQ09MVU1OX0NPVU5UXG4gICAgICAgICAgICB3aWR0aCA9IGN0V2lkdGhcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gMS4gaWYgY29sdW1uQ291bnQgPSBuIHRoZW4gY2FsYyB3LlxuICAgICAgICBlbHNlIGlmIChjbnQgIT09ICdhdXRvJyAmJiB3aWR0aCA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgd2lkdGggPSAoY3RXaWR0aCAtIChjbnQgLSAxKSAqIGdhcCkgLyBjbnRcbiAgICAgICAgfVxuICAgICAgICAvLyAyLiBpZiBjb2x1bW5XaWR0aCA9IHcgdGhlbiBjYWxjIG4uXG4gICAgICAgIGVsc2UgaWYgKGNudCA9PT0gJ2F1dG8nICYmIHdpZHRoICE9PSAnYXV0bycpIHtcbiAgICAgICAgICBjbnQgPSAoY3RXaWR0aCArIGdhcCkgLyAod2lkdGggKyBnYXApXG4gICAgICAgIH1cbiAgICAgICAgLy8gMy4gaWYgY29sdW1uV2lkdGggPSB3IGFuZCBjb2x1bW5Db3VudCA9IG4gdGhlbiBjYWxjIHRvdGFsV2lkdGhcbiAgICAgICAgZWxzZSBpZiAoY250ICE9PSAnYXV0bycgJiYgd2lkdGggIT09ICdhdXRvJykge1xuICAgICAgICAgIGxldCB0b3RhbFdpZHRoXG4gICAgICAgICAgY29uc3QgYWRqdXN0Q291bnRBbmRXaWR0aCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRvdGFsV2lkdGggPSBjbnQgKiB3aWR0aCArIChjbnQgLSAxKSAqIGdhcFxuICAgICAgICAgICAgaWYgKHRvdGFsV2lkdGggPCBjdFdpZHRoKSB7XG4gICAgICAgICAgICAgIHdpZHRoICs9IChjdFdpZHRoIC0gdG90YWxXaWR0aCkgLyBjbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRvdGFsV2lkdGggPiBjdFdpZHRoICYmIGNudCA+IDEpIHtcbiAgICAgICAgICAgICAgY250LS1cbiAgICAgICAgICAgICAgYWRqdXN0Q291bnRBbmRXaWR0aCgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b3RhbFdpZHRoID4gY3RXaWR0aCkgeyAgLy8gY250ID09PSAxXG4gICAgICAgICAgICAgIHdpZHRoID0gY3RXaWR0aFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBhZGp1c3RDb3VudEFuZFdpZHRoKClcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb2x1bW5Db3VudCA9IGNudFxuICAgICAgICB0aGlzLl9jb2x1bW5XaWR0aCA9IHdpZHRoXG4gICAgICAgIHRoaXMuX2NvbHVtbkdhcCA9IGdhcFxuICAgICAgfSxcblxuICAgICAgX2dlbkNvbHVtbnMgKGNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5fY29sdW1ucyA9IFtdXG4gICAgICAgIGNvbnN0IGNlbGxzID0gdGhpcy5fY2VsbHNcbiAgICAgICAgY29uc3QgY29sdW1uQ250ID0gdGhpcy5fY29sdW1uQ291bnRcbiAgICAgICAgY29uc3QgbGVuID0gY2VsbHMubGVuZ3RoXG4gICAgICAgIGNvbnN0IGNvbHVtbkNlbGxzID0gdGhpcy5fY29sdW1uQ2VsbHMgPSBBcnJheShjb2x1bW5DbnQpLmpvaW4oJy4nKS5zcGxpdCgnLicpLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBbXSB9KVxuICAgICAgICAvLyBzcHJlYWQgY2VsbHMgdG8gdGhlIGNvbHVtbnMgdXNpbmcgc2ltcG9sZSBwb2xsaW5nIGFsZ29yaXRobS5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIChjZWxsc1tpXS5kYXRhLmF0dHJzIHx8IChjZWxsc1tpXS5kYXRhLmF0dHJzID0ge30pKVsnZGF0YS1jZWxsJ10gPSBpXG4gICAgICAgICAgY29sdW1uQ2VsbHNbaSAlIGNvbHVtbkNudF0ucHVzaChjZWxsc1tpXSlcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbkNudDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5fY29sdW1ucy5wdXNoKGNyZWF0ZUVsZW1lbnQoJ2h0bWw6ZGl2Jywge1xuICAgICAgICAgICAgcmVmOiBgY29sdW1uJHtpfWAsXG4gICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAnZGF0YS1jb2x1bW4nOiBpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd3ZWV4LWN0JyxcbiAgICAgICAgICAgIHN0YXRpY1N0eWxlOiB7XG4gICAgICAgICAgICAgIHdpZHRoOiB0aGlzLl9jb2x1bW5XaWR0aCArICdweCcsXG4gICAgICAgICAgICAgIG1hcmdpbkxlZnQ6IGkgPT09IDAgPyAwIDogdGhpcy5fY29sdW1uR2FwICsgJ3B4J1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIGNvbHVtbkNlbGxzW2ldKSlcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX25leHRUaWNrICgpIHtcbiAgICAgICAgdGhpcy5fcmVMYXlvdXRDaGlsZHJlbigpXG4gICAgICB9LFxuXG4gICAgICBfcmVMYXlvdXRDaGlsZHJlbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0cmVhdCB0aGUgc2hvcnRlc3QgY29sdW1uIGJvdHRvbSBhcyB0aGUgbWF0Y2ggc3RhbmRhcmQuXG4gICAgICAgICAqIHdoaWNoZXZlciBjZWxsIGV4Y2VlZGVkIGl0IHdvdWxkIGJlIHJlYXJyYW5nZWQuXG4gICAgICAgICAqIDEuIG0gPSBzaG9ydGVzdCBjb2x1bW4gYm90dG9tLlxuICAgICAgICAgKiAyLiBnZXQgYWxsIGNlbGwgaWRzIHdobyBpcyBiZWxvdyBtLlxuICAgICAgICAgKiAzLiBjYWxjdWxhdGUgd2hpY2ggY2VsbCBzaG91bGQgYmUgaW4gd2hpY2ggY29sdW1uLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgY29sdW1uQ250ID0gdGhpcy5fY29sdW1uQ291bnRcbiAgICAgICAgY29uc3QgY29sdW1uRG9tcyA9IFtdXG4gICAgICAgIGNvbnN0IGNvbHVtbkFwcGVuZEZyYWdtZW50cyA9IFtdXG4gICAgICAgIGNvbnN0IGNvbHVtbkJvdHRvbXMgPSBbXVxuICAgICAgICBsZXQgbWluQm90dG9tID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbiAgICAgICAgbGV0IG1pbkJvdHRvbUNvbHVtbkluZGV4ID0gMFxuXG4gICAgICAgIC8vIDEuIGZpbmQgdGhlIHNob3J0ZXN0IGNvbHVtbiBib3R0b20uXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1uQ250OyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjb2x1bW5Eb20gPSB0aGlzLl9jb2x1bW5zW2ldLmVsbVxuICAgICAgICAgIGNvbnN0IGxhc3RDaGlsZCA9IGNvbHVtbkRvbS5sYXN0RWxlbWVudENoaWxkXG4gICAgICAgICAgY29uc3QgYm90dG9tID0gbGFzdENoaWxkID8gbGFzdENoaWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSA6IDBcbiAgICAgICAgICBjb2x1bW5Eb21zLnB1c2goY29sdW1uRG9tKVxuICAgICAgICAgIGNvbHVtbkJvdHRvbXNbaV0gPSBib3R0b21cbiAgICAgICAgICBjb2x1bW5BcHBlbmRGcmFnbWVudHMucHVzaChkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCkpXG4gICAgICAgICAgaWYgKGJvdHRvbSA8IG1pbkJvdHRvbSkge1xuICAgICAgICAgICAgbWluQm90dG9tID0gYm90dG9tXG4gICAgICAgICAgICBtaW5Cb3R0b21Db2x1bW5JbmRleCA9IGlcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyAyLiBnZXQgYWxsIGNlbGwgaWRzIHdobyBpcyBiZWxvdyBtLlxuICAgICAgICBjb25zdCBiZWxvd0NlbGxJZHMgPSBbXVxuICAgICAgICBjb25zdCBiZWxvd0NlbGxzID0ge31cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5DbnQ7IGkrKykge1xuICAgICAgICAgIGlmIChpID09PSBtaW5Cb3R0b21Db2x1bW5JbmRleCkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY29sdW1uRG9tID0gY29sdW1uRG9tc1tpXVxuICAgICAgICAgIGNvbnN0IGNlbGxzSW5Db2x1bW4gPSBjb2x1bW5Eb20ucXVlcnlTZWxlY3RvckFsbCgnc2VjdGlvbi53ZWV4LWNlbGwnKVxuICAgICAgICAgIGNvbnN0IGxlbiA9IGNlbGxzSW5Db2x1bW4ubGVuZ3RoXG4gICAgICAgICAgZm9yIChsZXQgaiA9IGxlbiAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICBjb25zdCBjZWxsRG9tID0gY2VsbHNJbkNvbHVtbltqXVxuICAgICAgICAgICAgY29uc3QgY2VsbFJlY3QgPSBjZWxsRG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgICAgICBpZiAoY2VsbFJlY3QudG9wID4gbWluQm90dG9tKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGlkID0gfn5jZWxsRG9tLmdldEF0dHJpYnV0ZSgnZGF0YS1jZWxsJylcbiAgICAgICAgICAgICAgYmVsb3dDZWxsSWRzLnB1c2goaWQpXG4gICAgICAgICAgICAgIGJlbG93Q2VsbHNbaWRdID0geyBlbG06IGNlbGxEb20sIGhlaWdodDogY2VsbFJlY3QuaGVpZ2h0IH1cbiAgICAgICAgICAgICAgY29sdW1uQm90dG9tc1tpXSAtPSBjZWxsUmVjdC5oZWlnaHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyAzLiBjYWxjdWxhdGUgd2hpY2ggY2VsbCBzaG91bGQgYmUgaW4gd2hpY2ggY29sdW1uIGFuZCByZWFycmFuZ2UgdGhlbVxuICAgICAgICAvLyAgaW4gdGhlIGRvbSB0cmVlLlxuICAgICAgICBiZWxvd0NlbGxJZHMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSA+IGIgfSlcbiAgICAgICAgY29uc3QgY2VsbElkc0xlbiA9IGJlbG93Q2VsbElkcy5sZW5ndGhcbiAgICAgICAgZnVuY3Rpb24gYWRkVG9TaG9ydGVzdENvbHVtbiAoYmVsb3dDZWxsKSB7XG4gICAgICAgICAgLy8gZmluZCBzaG9ydGVzdCBib3R0b20uXG4gICAgICAgICAgbWluQm90dG9tID0gTWF0aC5taW4oLi4uY29sdW1uQm90dG9tcylcbiAgICAgICAgICBtaW5Cb3R0b21Db2x1bW5JbmRleCA9IGNvbHVtbkJvdHRvbXMuaW5kZXhPZihtaW5Cb3R0b20pXG4gICAgICAgICAgY29uc3QgeyBlbG06IGNlbGxFbG0sIGhlaWdodDogY2VsbEhlaWdodCB9ID0gYmVsb3dDZWxsXG4gICAgICAgICAgY29sdW1uQXBwZW5kRnJhZ21lbnRzW21pbkJvdHRvbUNvbHVtbkluZGV4XS5hcHBlbmRDaGlsZChjZWxsRWxtKVxuICAgICAgICAgIGNvbHVtbkJvdHRvbXNbbWluQm90dG9tQ29sdW1uSW5kZXhdICs9IGNlbGxIZWlnaHRcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNlbGxJZHNMZW47IGkrKykge1xuICAgICAgICAgIGFkZFRvU2hvcnRlc3RDb2x1bW4oYmVsb3dDZWxsc1tiZWxvd0NlbGxJZHNbaV1dKVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1uQ250OyBpKyspIHtcbiAgICAgICAgICBjb2x1bW5Eb21zW2ldLmFwcGVuZENoaWxkKGNvbHVtbkFwcGVuZEZyYWdtZW50c1tpXSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICByZW5kZXIgKGNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIHRoaXMud2VleFR5cGUgPSAnd2F0ZXJmYWxsJ1xuICAgICAgdGhpcy5fY2VsbHMgPSB0aGlzLiRzbG90cy5kZWZhdWx0IHx8IFtdXG4gICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7XG4gICAgICAgIHRoaXMudXBkYXRlTGF5b3V0KClcbiAgICAgIH0pXG4gICAgICBjb25zdCBtZXJnZWRTdHlsZSA9IGV4dHJhY3RDb21wb25lbnRTdHlsZSh0aGlzKVxuICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ21haW4nLCB7XG4gICAgICAgIHJlZjogJ3dyYXBwZXInLFxuICAgICAgICBhdHRyczogeyAnd2VleC10eXBlJzogJ3dhdGVyZmFsbCcgfSxcbiAgICAgICAgb246IHtcbiAgICAgICAgICBzY3JvbGw6IHRoaXMuaGFuZGxlU2Nyb2xsLFxuICAgICAgICAgIHRvdWNoc3RhcnQ6IHRoaXMuaGFuZGxlVG91Y2hTdGFydCxcbiAgICAgICAgICB0b3VjaG1vdmU6IHRoaXMuaGFuZGxlVG91Y2hNb3ZlLFxuICAgICAgICAgIHRvdWNoZW5kOiB0aGlzLmhhbmRsZVRvdWNoRW5kXG4gICAgICAgIH0sXG4gICAgICAgIHN0YXRpY0NsYXNzOiAnd2VleC13YXRlcmZhbGwgd2VleC13YXRlcmZhbGwtd3JhcHBlciB3ZWV4LWN0JyxcbiAgICAgICAgc3RhdGljU3R5bGU6IG1lcmdlZFN0eWxlXG4gICAgICB9LCB0aGlzLl9jcmVhdGVDaGlsZHJlbihjcmVhdGVFbGVtZW50LCBtZXJnZWRTdHlsZSkpXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdCAod2VleCkge1xuICAgIHdlZXgucmVnaXN0ZXJDb21wb25lbnQoJ3dhdGVyZmFsbCcsIGdldFdhdGVyZmFsbCh3ZWV4KSlcbiAgfVxufVxuIiwiLypcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZ1bmN0aW9uIGdldEhlYWRlciAod2VleCkge1xuICBjb25zdCB7IGV4dHJhY3RDb21wb25lbnRTdHlsZSB9ID0gd2VleFxuXG4gIHJldHVybiB7XG4gICAgcmVuZGVyIChjcmVhdGVFbGVtZW50KSB7XG4gICAgICBjb25zdCBhdHRycyA9IHRoaXMuJHZub2RlLmRhdGEuYXR0cnNcbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdodG1sOmhlYWRlcicsIHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAnd2VleC10eXBlJzogJ2hlYWRlcicsXG4gICAgICAgICAgc3RpY2t5OiAoXG4gICAgICAgICAgICB0aGlzLiRwYXJlbnQud2VleFR5cGUgPT09ICd3YXRlcmZhbGwnXG4gICAgICAgICAgICAmJiB0eXBlb2YgYXR0cnMuc3RpY2t5ID09PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICkgPyB1bmRlZmluZWQgOiAnJ1xuICAgICAgICB9LFxuICAgICAgICByZWY6ICdoZWFkZXInLFxuICAgICAgICBzdGF0aWNDbGFzczogJ3dlZXgtaGVhZGVyIHdlZXgtY3QnLFxuICAgICAgICBzdGF0aWNTdHlsZTogZXh0cmFjdENvbXBvbmVudFN0eWxlKHRoaXMpXG4gICAgICB9LCB0aGlzLiRzbG90cy5kZWZhdWx0KVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQgKHdlZXgpIHtcbiAgICB3ZWV4LnJlZ2lzdGVyQ29tcG9uZW50KCdoZWFkZXInLCBnZXRIZWFkZXIod2VleCkpXG4gIH1cbn1cbiIsIi8qXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mdW5jdGlvbiBnZXRMb2FkaW5nICgpIHtcbiAgY29uc3QgeyBleHRyYWN0Q29tcG9uZW50U3R5bGUgfSA9IHdlZXhcbiAgY29uc3QgeyBkaXNwYXRjaE5hdGl2ZUV2ZW50IH0gPSB3ZWV4LnV0aWxzXG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnd2VleC1sb2FkaW5nJyxcbiAgICBwcm9wczoge1xuICAgICAgZGlzcGxheToge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6ICdzaG93JyxcbiAgICAgICAgdmFsaWRhdG9yICh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBbJ3Nob3cnLCAnaGlkZSddLmluZGV4T2YodmFsdWUpICE9PSAtMVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkYXRhICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhlaWdodDogLTEsXG4gICAgICAgIHZpZXdIZWlnaHQ6IDBcbiAgICAgIH1cbiAgICB9LFxuICAgIG1vdW50ZWQgKCkge1xuICAgICAgdGhpcy52aWV3SGVpZ2h0ID0gdGhpcy4kZWwub2Zmc2V0SGVpZ2h0XG4gICAgICBpZiAodGhpcy5kaXNwbGF5ID09PSAnaGlkZScpIHtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAwXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLnZpZXdIZWlnaHRcbiAgICAgIH1cbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICBoZWlnaHQgKHZhbCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBgJHt2YWx9cHhgXG4gICAgICAgIHRoaXMuJGVsLnN0eWxlLmhlaWdodCA9IG9mZnNldFxuICAgICAgICB0aGlzLiRlbC5zdHlsZS5ib3R0b20gPSBvZmZzZXRcbiAgICAgIH0sXG4gICAgICBkaXNwbGF5ICh2YWwpIHtcbiAgICAgICAgaWYgKHZhbCA9PT0gJ2hpZGUnKSB7XG4gICAgICAgICAgdGhpcy5oZWlnaHQgPSAwXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLnZpZXdIZWlnaHRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgcHVsbGluZyAob2Zmc2V0WSA9IDApIHtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBvZmZzZXRZXG4gICAgICB9LFxuICAgICAgcHVsbGluZ1VwIChvZmZzZXRZKSB7XG4gICAgICAgIHRoaXMuJGVsLnN0eWxlLnRyYW5zaXRpb24gPSBgaGVpZ2h0IDBzYFxuICAgICAgICB0aGlzLnB1bGxpbmcob2Zmc2V0WSlcbiAgICAgIH0sXG4gICAgICBwdWxsaW5nRW5kICgpIHtcbiAgICAgICAgdGhpcy4kZWwgJiYgKHRoaXMuJGVsLnN0eWxlLnRyYW5zaXRpb24gPSBgaGVpZ2h0IC4yc2ApXG4gICAgICAgIGlmICh0aGlzLmhlaWdodCA+PSB0aGlzLnZpZXdIZWlnaHQpIHtcbiAgICAgICAgICB0aGlzLnB1bGxpbmcodGhpcy52aWV3SGVpZ2h0KVxuICAgICAgICAgIGlmICh0aGlzLiRlbCkge1xuICAgICAgICAgICAgZGlzcGF0Y2hOYXRpdmVFdmVudCh0aGlzLiRlbCwgJ2xvYWRpbmcnKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLnB1bGxpbmcoMClcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdldENoaWxkcmVuICgpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0IHx8IFtdXG4gICAgICAgIGlmICh0aGlzLmRpc3BsYXkgPT09ICdzaG93Jykge1xuICAgICAgICAgIHJldHVybiBjaGlsZHJlblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZHJlbi5maWx0ZXIodm5vZGUgPT4ge1xuICAgICAgICAgIHJldHVybiB2bm9kZS5jb21wb25lbnRPcHRpb25zXG4gICAgICAgICAgICAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zLnRhZyAhPT0gJ2xvYWRpbmctaW5kaWNhdG9yJ1xuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyIChjcmVhdGVFbGVtZW50KSB7XG4gICAgICB0aGlzLiRwYXJlbnQuX2xvYWRpbmcgPSB0aGlzXG4gICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgnYXNpZGUnLCB7XG4gICAgICAgIHJlZjogJ2xvYWRpbmcnLFxuICAgICAgICBhdHRyczogeyAnd2VleC10eXBlJzogJ2xvYWRpbmcnIH0sXG4gICAgICAgIHN0YXRpY0NsYXNzOiAnd2VleC1sb2FkaW5nIHdlZXgtY3QnLFxuICAgICAgICBzdGF0aWNTdHlsZTogZXh0cmFjdENvbXBvbmVudFN0eWxlKHRoaXMpXG4gICAgICB9LCB0aGlzLmdldENoaWxkcmVuKCkpXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdCAod2VleCkge1xuICAgIHdlZXgucmVnaXN0ZXJDb21wb25lbnQoJ2xvYWRpbmcnLCBnZXRMb2FkaW5nKHdlZXgpKVxuICB9XG59XG4iLCIvKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZnVuY3Rpb24gZ2V0UmVmcmVzaCAod2VleCkge1xuICBjb25zdCB7IGV4dHJhY3RDb21wb25lbnRTdHlsZSB9ID0gd2VleFxuICBjb25zdCB7IGRpc3BhdGNoTmF0aXZlRXZlbnQgfSA9IHdlZXgudXRpbHNcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICd3ZWV4LXJlZnJlc2gnLFxuICAgIHByb3BzOiB7XG4gICAgICBkaXNwbGF5OiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogJ3Nob3cnLFxuICAgICAgICB2YWxpZGF0b3IgKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIFsnc2hvdycsICdoaWRlJ10uaW5kZXhPZih2YWx1ZSkgIT09IC0xXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRhdGEgKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGFzdER5OiAwLFxuICAgICAgICB2aWV3SGVpZ2h0OiAwLFxuICAgICAgICBoZWlnaHQ6IC0xXG4gICAgICB9XG4gICAgfSxcbiAgICBtb3VudGVkICgpIHtcbiAgICAgIHRoaXMudmlld0hlaWdodCA9IHRoaXMuJGVsLm9mZnNldEhlaWdodFxuICAgICAgaWYgKHRoaXMuZGlzcGxheSA9PT0gJ2hpZGUnKSB7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMFxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy52aWV3SGVpZ2h0XG4gICAgICB9XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgaGVpZ2h0ICh2YWwpIHtcbiAgICAgICAgdGhpcy4kZWwuc3R5bGUuaGVpZ2h0ID0gYCR7dmFsfXB4YFxuICAgICAgfSxcbiAgICAgIGRpc3BsYXkgKHZhbCkge1xuICAgICAgICBpZiAodmFsID09PSAnaGlkZScpIHtcbiAgICAgICAgICB0aGlzLmhlaWdodCA9IDBcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMudmlld0hlaWdodFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICBwdWxsaW5nIChvZmZzZXRZID0gMCkge1xuICAgICAgICB0aGlzLmhlaWdodCA9IG9mZnNldFlcbiAgICAgICAgaWYgKHRoaXMuJGVsKSB7XG4gICAgICAgICAgZGlzcGF0Y2hOYXRpdmVFdmVudCh0aGlzLiRlbCwgJ3B1bGxpbmdkb3duJywge1xuICAgICAgICAgICAgZHk6IG9mZnNldFkgLSB0aGlzLmxhc3REeSxcbiAgICAgICAgICAgIHB1bGxpbmdEaXN0YW5jZTogb2Zmc2V0WSxcbiAgICAgICAgICAgIHZpZXdIZWlnaHQ6IHRoaXMudmlld0hlaWdodFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0RHkgPSBvZmZzZXRZXG4gICAgICB9LFxuICAgICAgcHVsbGluZ0Rvd24gKG9mZnNldFkpIHtcbiAgICAgICAgdGhpcy4kZWwuc3R5bGUudHJhbnNpdGlvbiA9IGBoZWlnaHQgMHNgXG4gICAgICAgIHRoaXMucHVsbGluZyhvZmZzZXRZKVxuICAgICAgfSxcbiAgICAgIHB1bGxpbmdFbmQgKCkge1xuICAgICAgICB0aGlzLiRlbCAmJiAodGhpcy4kZWwuc3R5bGUudHJhbnNpdGlvbiA9IGBoZWlnaHQgLjJzYClcbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0ID49IHRoaXMudmlld0hlaWdodCkge1xuICAgICAgICAgIHRoaXMucHVsbGluZyh0aGlzLnZpZXdIZWlnaHQpXG4gICAgICAgICAgaWYgKHRoaXMuJGVsKSB7XG4gICAgICAgICAgICBkaXNwYXRjaE5hdGl2ZUV2ZW50KHRoaXMuJGVsLCAncmVmcmVzaCcpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRoaXMucHVsbGluZygwKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZ2V0Q2hpbGRyZW4gKCkge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW11cbiAgICAgICAgaWYgKHRoaXMuZGlzcGxheSA9PT0gJ3Nob3cnKSB7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkcmVuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuLmZpbHRlcih2bm9kZSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHZub2RlLmNvbXBvbmVudE9wdGlvbnNcbiAgICAgICAgICAgICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnMudGFnICE9PSAnbG9hZGluZy1pbmRpY2F0b3InXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSxcbiAgICByZW5kZXIgKGNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIHRoaXMuJHBhcmVudC5fcmVmcmVzaCA9IHRoaXNcbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdhc2lkZScsIHtcbiAgICAgICAgcmVmOiAncmVmcmVzaCcsXG4gICAgICAgIGF0dHJzOiB7ICd3ZWV4LXR5cGUnOiAncmVmcmVzaCcgfSxcbiAgICAgICAgc3RhdGljQ2xhc3M6ICd3ZWV4LXJlZnJlc2ggd2VleC1jdCcsXG4gICAgICAgIHN0YXRpY1N0eWxlOiBleHRyYWN0Q29tcG9uZW50U3R5bGUodGhpcylcbiAgICAgIH0sIHRoaXMuZ2V0Q2hpbGRyZW4oKSlcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0ICh3ZWV4KSB7XG4gICAgd2VleC5yZWdpc3RlckNvbXBvbmVudCgncmVmcmVzaCcsIGdldFJlZnJlc2god2VleCkpXG4gIH1cbn1cbiIsIi8qXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xubGV0IGV4dHJhY3RDb21wb25lbnRTdHlsZSwgZ2V0UmdiLCBsb29wQXJyYXksIGdldFN0eWxlU2hlZXRCeUlkXG5cbmNvbnN0IF9jc3MgPSBgXG4ud2VleC1yZWZyZXNoLWluZGljYXRvcixcbi53ZWV4LWxvYWRpbmctaW5kaWNhdG9yIHtcbiAgd2lkdGg6IDFyZW0gIWltcG9ydGFudDtcbiAgaGVpZ2h0OiAxcmVtICFpbXBvcnRhbnQ7XG4gIC13ZWJraXQtYm94LWFsaWduOiBjZW50ZXI7XG4gIC1tb3otYm94LWFsaWduOiBjZW50ZXI7XG4gIC13ZWJraXQtYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgLW1zLWZsZXgtYWxpZ246IGNlbnRlcjtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgLXdlYmtpdC1ib3gtcGFjazogY2VudGVyO1xuICAtbW96LWJveC1wYWNrOiBjZW50ZXI7XG4gIC13ZWJraXQtanVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIC1tcy1mbGV4LXBhY2s6IGNlbnRlcjtcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIG92ZXJmbG93OiB2aXNpYmxlO1xuICBiYWNrZ3JvdW5kOiBub25lO1xufVxuLndlZXgtcmVmcmVzaC1pbmRpY2F0b3I6YmVmb3JlLFxuLndlZXgtbG9hZGluZy1pbmRpY2F0b3I6YmVmb3JlIHtcbiAgZGlzcGxheTogYmxvY2s7XG4gIGNvbnRlbnQ6ICcnO1xuICBmb250LXNpemU6IDAuMTZyZW07XG4gIHdpZHRoOiAwLjVlbTtcbiAgaGVpZ2h0OiAwLjVlbTtcbiAgbGVmdDogMDtcbiAgdG9wOiAwO1xuICBib3JkZXItcmFkaXVzOiA1MCU7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgdGV4dC1pbmRlbnQ6IC05OTk5ZW07XG4gIC13ZWJraXQtYW5pbWF0aW9uOiB3ZWV4LXNwaW5uZXIgMS4xcyBpbmZpbml0ZSBlYXNlO1xuICAtbW96LWFuaW1hdGlvbjogd2VleC1zcGlubmVyIDEuMXMgaW5maW5pdGUgZWFzZTtcbiAgYW5pbWF0aW9uOiB3ZWV4LXNwaW5uZXIgMS4xcyBpbmZpbml0ZSBlYXNlO1xufVxuXG5ALXdlYmtpdC1rZXlmcmFtZXMgd2VleC1zcGlubmVyIHtcbiAgMCUsXG4gIDEwMCUge1xuICAgIGJveC1zaGFkb3c6IDBlbSAtMS4zZW0gMGVtIDBlbSAjZmZmZmZmLCAwLjllbSAtMC45ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAxLjI1ZW0gMGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMC44NzVlbSAwLjg3NWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMGVtIDEuMjVlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0wLjllbSAwLjllbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0xLjNlbSAwZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpLCAtMC45ZW0gLTAuOWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC43KTtcbiAgfVxuICAxMS4yNSUge1xuICAgIGJveC1zaGFkb3c6IDBlbSAtMS4zZW0gMGVtIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyksIDAuOWVtIC0wLjllbSAwIDBlbSAjZmZmZmZmLCAxLjI1ZW0gMGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMC44NzVlbSAwLjg3NWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMGVtIDEuMjVlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0wLjllbSAwLjllbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0xLjNlbSAwZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAtMC45ZW0gLTAuOWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KTtcbiAgfVxuICAyNSUge1xuICAgIGJveC1zaGFkb3c6IDBlbSAtMS4zZW0gMGVtIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSksIDAuOWVtIC0wLjllbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyksIDEuMjVlbSAwZW0gMCAwZW0gI2ZmZmZmZiwgMC44NzVlbSAwLjg3NWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMGVtIDEuMjVlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0wLjllbSAwLjllbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0xLjNlbSAwZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAtMC45ZW0gLTAuOWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKTtcbiAgfVxuICAzNy41JSB7XG4gICAgYm94LXNoYWRvdzogMGVtIC0xLjNlbSAwZW0gMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMC45ZW0gLTAuOWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KSwgMS4yNWVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyksIDAuODc1ZW0gMC44NzVlbSAwIDBlbSAjZmZmZmZmLCAwZW0gMS4yNWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTAuOWVtIDAuOWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTEuM2VtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0wLjllbSAtMC45ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xuICB9XG4gIDUwJSB7XG4gICAgYm94LXNoYWRvdzogMGVtIC0xLjNlbSAwZW0gMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMC45ZW0gLTAuOWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMS4yNWVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSksIDAuODc1ZW0gMC44NzVlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyksIDBlbSAxLjI1ZW0gMCAwZW0gI2ZmZmZmZiwgLTAuOWVtIDAuOWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTEuM2VtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0wLjllbSAtMC45ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xuICB9XG4gIDYxLjI1JSB7XG4gICAgYm94LXNoYWRvdzogMGVtIC0xLjNlbSAwZW0gMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMC45ZW0gLTAuOWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMS4yNWVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDAuODc1ZW0gMC44NzVlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSksIDBlbSAxLjI1ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpLCAtMC45ZW0gMC45ZW0gMCAwZW0gI2ZmZmZmZiwgLTEuM2VtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0wLjllbSAtMC45ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xuICB9XG4gIDc1JSB7XG4gICAgYm94LXNoYWRvdzogMGVtIC0xLjNlbSAwZW0gMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMC45ZW0gLTAuOWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMS4yNWVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDAuODc1ZW0gMC44NzVlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDBlbSAxLjI1ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpLCAtMC45ZW0gMC45ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpLCAtMS4zZW0gMGVtIDAgMGVtICNmZmZmZmYsIC0wLjllbSAtMC45ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xuICB9XG4gIDg3LjUlIHtcbiAgICBib3gtc2hhZG93OiAwZW0gLTEuM2VtIDBlbSAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAwLjllbSAtMC45ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAxLjI1ZW0gMGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMC44NzVlbSAwLjg3NWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMGVtIDEuMjVlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0wLjllbSAwLjllbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSksIC0xLjNlbSAwZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpLCAtMC45ZW0gLTAuOWVtIDAgMGVtICNmZmZmZmY7XG4gIH1cbn1cblxuQGtleWZyYW1lcyB3ZWV4LXNwaW5uZXIge1xuICAwJSxcbiAgMTAwJSB7XG4gICAgYm94LXNoYWRvdzogMGVtIC0xLjNlbSAwZW0gMGVtICNmZmZmZmYsIDAuOWVtIC0wLjllbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDEuMjVlbSAwZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAwLjg3NWVtIDAuODc1ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAwZW0gMS4yNWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTAuOWVtIDAuOWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTEuM2VtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSksIC0wLjllbSAtMC45ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpO1xuICB9XG4gIDExLjI1JSB7XG4gICAgYm94LXNoYWRvdzogMGVtIC0xLjNlbSAwZW0gMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC43KSwgMC45ZW0gLTAuOWVtIDAgMGVtICNmZmZmZmYsIDEuMjVlbSAwZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAwLjg3NWVtIDAuODc1ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAwZW0gMS4yNWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTAuOWVtIDAuOWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTEuM2VtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0wLjllbSAtMC45ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpO1xuICB9XG4gIDI1JSB7XG4gICAgYm94LXNoYWRvdzogMGVtIC0xLjNlbSAwZW0gMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KSwgMC45ZW0gLTAuOWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC43KSwgMS4yNWVtIDBlbSAwIDBlbSAjZmZmZmZmLCAwLjg3NWVtIDAuODc1ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAwZW0gMS4yNWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTAuOWVtIDAuOWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTEuM2VtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0wLjllbSAtMC45ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xuICB9XG4gIDM3LjUlIHtcbiAgICBib3gtc2hhZG93OiAwZW0gLTEuM2VtIDBlbSAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAwLjllbSAtMC45ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpLCAxLjI1ZW0gMGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC43KSwgMC44NzVlbSAwLjg3NWVtIDAgMGVtICNmZmZmZmYsIDBlbSAxLjI1ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAtMC45ZW0gMC45ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAtMS4zZW0gMGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTAuOWVtIC0wLjllbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMik7XG4gIH1cbiAgNTAlIHtcbiAgICBib3gtc2hhZG93OiAwZW0gLTEuM2VtIDBlbSAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAwLjllbSAtMC45ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAxLjI1ZW0gMGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KSwgMC44NzVlbSAwLjg3NWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC43KSwgMGVtIDEuMjVlbSAwIDBlbSAjZmZmZmZmLCAtMC45ZW0gMC45ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAtMS4zZW0gMGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTAuOWVtIC0wLjllbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMik7XG4gIH1cbiAgNjEuMjUlIHtcbiAgICBib3gtc2hhZG93OiAwZW0gLTEuM2VtIDBlbSAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAwLjllbSAtMC45ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAxLjI1ZW0gMGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMC44NzVlbSAwLjg3NWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KSwgMGVtIDEuMjVlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyksIC0wLjllbSAwLjllbSAwIDBlbSAjZmZmZmZmLCAtMS4zZW0gMGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTAuOWVtIC0wLjllbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMik7XG4gIH1cbiAgNzUlIHtcbiAgICBib3gtc2hhZG93OiAwZW0gLTEuM2VtIDBlbSAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAwLjllbSAtMC45ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAxLjI1ZW0gMGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMC44NzVlbSAwLjg3NWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMGVtIDEuMjVlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSksIC0wLjllbSAwLjllbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyksIC0xLjNlbSAwZW0gMCAwZW0gI2ZmZmZmZiwgLTAuOWVtIC0wLjllbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMik7XG4gIH1cbiAgODcuNSUge1xuICAgIGJveC1zaGFkb3c6IDBlbSAtMS4zZW0gMGVtIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDAuOWVtIC0wLjllbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDEuMjVlbSAwZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAwLjg3NWVtIDAuODc1ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAwZW0gMS4yNWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTAuOWVtIDAuOWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KSwgLTEuM2VtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyksIC0wLjllbSAtMC45ZW0gMCAwZW0gI2ZmZmZmZjtcbiAgfVxufVxuYFxuXG5mdW5jdGlvbiBnZXRTdHlsZVNoZWV0IChzcGlubmVyVm0pIHtcbiAgaWYgKHNwaW5uZXJWbS5fc3R5bGVTaGVldCkge1xuICAgIHJldHVyblxuICB9XG4gIHNwaW5uZXJWbS5fc3R5bGVTaGVldCA9IGdldFN0eWxlU2hlZXRCeUlkKCd3ZWV4LWNtcC1sb2FkaW5nLWluZGljYXRvcicpXG59XG5cbmZ1bmN0aW9uIHNldEtleWZyYW1lQ29sb3IgKHNwaW5uZXJWbSwgdmFsKSB7XG4gIGdldFN0eWxlU2hlZXQoc3Bpbm5lclZtKVxuICBjb25zdCBrZXlmcmFtZVJ1bGVzID0gY29tcHV0ZUtleUZyYW1lUnVsZXModmFsKVxuICBjb25zdCBydWxlcyA9IHNwaW5uZXJWbS5fc3R5bGVTaGVldC5ydWxlcyB8fCBzcGlubmVyVm0uX3N0eWxlU2hlZXQuY3NzUnVsZXNcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBydWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBpdGVtID0gcnVsZXMuaXRlbShpKVxuICAgIGlmICgoaXRlbS50eXBlID09PSBDU1NSdWxlLktFWUZSQU1FU19SVUxFXG4gICAgICAgICAgfHwgaXRlbS50eXBlID09PSBDU1NSdWxlLldFQktJVF9LRVlGUkFNRVNfUlVMRSlcbiAgICAgICAgJiYgaXRlbS5uYW1lID09PSAnd2VleC1zcGlubmVyJykge1xuICAgICAgY29uc3QgY3NzUnVsZXMgPSBpdGVtLmNzc1J1bGVzXG4gICAgICBmb3IgKGxldCBqID0gMCwgbSA9IGNzc1J1bGVzLmxlbmd0aDsgaiA8IG07IGorKykge1xuICAgICAgICBjb25zdCBrZXlmcmFtZSA9IGNzc1J1bGVzW2pdXG4gICAgICAgIGlmIChrZXlmcmFtZS50eXBlID09PSBDU1NSdWxlLktFWUZSQU1FX1JVTEVcbiAgICAgICAgICB8fCBrZXlmcmFtZS50eXBlID09PSBDU1NSdWxlLldFQktJVF9LRVlGUkFNRV9SVUxFKSB7XG4gICAgICAgICAga2V5ZnJhbWUuc3R5bGUuYm94U2hhZG93ID0ga2V5ZnJhbWVSdWxlc1tqXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVLZXlGcmFtZVJ1bGVzIChyZ2IpIHtcbiAgaWYgKCFyZ2IpIHtcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCBzY2FsZUFyciA9IFtcbiAgICAnMGVtIC0xLjNlbSAwZW0gMGVtJyxcbiAgICAnMC45ZW0gLTAuOWVtIDAgMGVtJyxcbiAgICAnMS4yNWVtIDBlbSAwIDBlbScsXG4gICAgJzAuODc1ZW0gMC44NzVlbSAwIDBlbScsXG4gICAgJzBlbSAxLjI1ZW0gMCAwZW0nLFxuICAgICctMC45ZW0gMC45ZW0gMCAwZW0nLFxuICAgICctMS4zZW0gMGVtIDAgMGVtJyxcbiAgICAnLTAuOWVtIC0wLjllbSAwIDBlbSddXG4gIGNvbnN0IGNvbG9yQXJyID0gW1xuICAgICcxJyxcbiAgICAnMC4yJyxcbiAgICAnMC4yJyxcbiAgICAnMC4yJyxcbiAgICAnMC4yJyxcbiAgICAnMC4yJyxcbiAgICAnMC41JyxcbiAgICAnMC43J11cbiAgICAubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gJ3JnYmEoJyArIHJnYi5yICsgJywnICsgcmdiLmcgKyAnLCcgKyByZ2IuYiArICcsJyArIGUgKyAnKSdcbiAgICB9KVxuICBjb25zdCBydWxlcyA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2NhbGVBcnIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0bXBDb2xvckFyciA9IGxvb3BBcnJheShjb2xvckFyciwgaSwgJ3InKVxuICAgIHJ1bGVzLnB1c2goc2NhbGVBcnIubWFwKGZ1bmN0aW9uIChzY2FsZVN0ciwgaSkge1xuICAgICAgcmV0dXJuIHNjYWxlU3RyICsgJyAnICsgdG1wQ29sb3JBcnJbaV1cbiAgICB9KS5qb2luKCcsICcpKVxuICB9XG4gIHJldHVybiBydWxlc1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzU3R5bGUgKHZtKSB7XG4gIGNvbnN0IHN0eWxlID0gZXh0cmFjdENvbXBvbmVudFN0eWxlKHZtKVxuICBjb25zdCBjb2xvciA9IHN0eWxlLmNvbG9yXG4gIGNvbnN0IHJnYiA9IGNvbG9yICYmIGdldFJnYihjb2xvcilcbiAgaWYgKHJnYikge1xuICAgIHNldEtleWZyYW1lQ29sb3Iodm0sIHJnYilcbiAgfVxuICByZXR1cm4gc3R5bGVcbn1cblxuY29uc3QgbG9hZGluZ0luZGljYXRvciA9IHtcbiAgbmFtZTogJ3dlZXgtbG9hZGluZy1pbmRpY2F0b3InLFxuICByZW5kZXIgKGNyZWF0ZUVsZW1lbnQpIHtcbiAgICB0aGlzLndlZXhUeXBlID0gJ2xvYWRpbmctaW5kaWNhdG9yJ1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdtYXJrJywge1xuICAgICAgYXR0cnM6IHsgJ3dlZXgtdHlwZSc6ICdsb2FkaW5nLWluZGljYXRvcicgfSxcbiAgICAgIHN0YXRpY0NsYXNzOiAnd2VleC1sb2FkaW5nLWluZGljYXRvciB3ZWV4LWN0JyxcbiAgICAgIHN0YXRpY1N0eWxlOiBwcm9jZXNzU3R5bGUodGhpcylcbiAgICB9KVxuICB9LFxuICBfY3NzXG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdCAod2VleCkge1xuICAgIGV4dHJhY3RDb21wb25lbnRTdHlsZSA9IHdlZXguZXh0cmFjdENvbXBvbmVudFN0eWxlXG4gICAgZ2V0UmdiID0gd2VleC51dGlscy5nZXRSZ2JcbiAgICBsb29wQXJyYXkgPSB3ZWV4LnV0aWxzLmxvb3BBcnJheVxuICAgIGdldFN0eWxlU2hlZXRCeUlkID0gd2VleC51dGlscy5nZXRTdHlsZVNoZWV0QnlJZFxuICAgIHdlZXgucmVnaXN0ZXJDb21wb25lbnQoJ2xvYWRpbmctaW5kaWNhdG9yJywgbG9hZGluZ0luZGljYXRvcilcbiAgfVxufVxuIiwiLypcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBsaXN0IGZyb20gJy4vbGlzdCdcbmltcG9ydCBzY3JvbGxlciBmcm9tICcuL3Njcm9sbGVyJ1xuaW1wb3J0IHdhdGVyZmFsbCBmcm9tICcuL3dhdGVyZmFsbCdcbi8vIGltcG9ydCBjZWxsIGZyb20gJy4vY2VsbCdcbmltcG9ydCBoZWFkZXIgZnJvbSAnLi9oZWFkZXInXG5pbXBvcnQgbG9hZGluZyBmcm9tICcuL2xvYWRpbmcnXG5pbXBvcnQgcmVmcmVzaCBmcm9tICcuL3JlZnJlc2gnXG5pbXBvcnQgbG9hZGluZ0luZGljYXRvciBmcm9tICcuL2xvYWRpbmctaW5kaWNhdG9yJ1xuXG5pbXBvcnQgJy4vc3R5bGUuY3NzJ1xuXG5jb25zdCBtb2R1bGVzID0gW1xuICBsaXN0LFxuICBzY3JvbGxlcixcbiAgd2F0ZXJmYWxsLFxuICAvLyBjZWxsLFxuICBoZWFkZXIsXG4gIGxvYWRpbmcsXG4gIHJlZnJlc2gsXG4gIGxvYWRpbmdJbmRpY2F0b3Jcbl1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0ICh3ZWV4KSB7XG4gICAgbW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgIHdlZXguaW5zdGFsbChtb2QpXG4gICAgfSlcbiAgfVxufVxuIiwiLypcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBUUkFOU0lUSU9OX1RJTUUgPSA0MDBcbmNvbnN0IE5FSUdIQk9SX1NDQUxFX1RJTUUgPSAxMDBcbmNvbnN0IE1BSU5fU0xJREVfT1BBQ0lUWSA9IDFcbmNvbnN0IFRIUk9UVExFX1NDUk9MTF9USU1FID0gMjVcbmNvbnN0IElOVEVSVkFMX01JTklNVU0gPSAyMDBcblxuZXhwb3J0IGRlZmF1bHQge1xuICBjcmVhdGVkICgpIHtcbiAgICB0aGlzLl9jbG9uZXMgPSBbXVxuICAgIHRoaXMuaW5uZXJPZmZzZXQgPSAwXG4gICAgdGhpcy5faW5kaWNhdG9yID0gbnVsbFxuICB9LFxuXG4gIGJlZm9yZVVwZGF0ZSAoKSB7XG4gICAgdGhpcy5fZ2V0V3JhcHBlclNpemUoKVxuICB9LFxuXG4gIHVwZGF0ZWQgKCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy4kY2hpbGRyZW5cbiAgICBjb25zdCBsZW4gPSBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGhcbiAgICBpZiAoY2hpbGRyZW4gJiYgbGVuID4gMCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCB2bSA9IGNoaWxkcmVuW2ldXG4gICAgICAgIGlmICh2bS4kb3B0aW9ucy5fY29tcG9uZW50VGFnID09PSAnaW5kaWNhdG9yJ1xuICAgICAgICAgIHx8IHZtLiR2bm9kZS5kYXRhLnJlZiA9PT0gJ2luZGljYXRvcicpIHtcbiAgICAgICAgICB2bS5fd2F0Y2hlci5nZXQoKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBmcmFtZUNvdW50ID0gdGhpcy5mcmFtZUNvdW50XG4gICAgaWYgKCF0aGlzLl9wcmVGcmFtZUNvdW50KSB7XG4gICAgICB0aGlzLl9wcmVGcmFtZUNvdW50ID0gZnJhbWVDb3VudFxuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLl9wcmVGcmFtZUNvdW50ICE9PSBmcmFtZUNvdW50KSB7XG4gICAgICB0aGlzLl9yZXNldE5vZGVzKClcbiAgICAgIHRoaXMuX3ByZUZyYW1lQ291bnQgPSBmcmFtZUNvdW50XG4gICAgICBjb25zdCByZXNldEJsYW5rRnJhbWUgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRJbmRleCA+PSBmcmFtZUNvdW50KSB7XG4gICAgICAgICAgLy8gcmVzZXQgYmxhbmsgcGFnZS5cbiAgICAgICAgICB0aGlzLl9zdG9wQXV0b1BsYXkoKVxuICAgICAgICAgIHRoaXMuX3NsaWRlVG8oMClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3NsaWRpbmcpIHtcbiAgICAgICAgLy8gSWYgaXQncyBzbGlkaW5nLCB0aGVuIHRoZSBjdXJyZW50SW5kZXggaXMgdGhlIGxhc3QgZnJhbWUuIFRoZSBhY3R1YWwgY3VycmVudEluZGV4XG4gICAgICAgIC8vIHNob3VsZCBiZSB0aGUgbmV4dCBpbmRleC5cbiAgICAgICAgLy8gVGhhdCBpcyB0byBzYXksIHRoaXMgdXBkYXRpbmcgaGFwcGVucyBCZXR3ZWVuIF9wYXJlcGFyZU5vZGVzIGFuZCBfcmVhcnJhbmdlTm9kZXMsXG4gICAgICAgIC8vIGFuZCB0aGUgc2xpZGluZyBpcyBub3QgeWV0IGZpbmlzaGVkLCBhbmQgdGhlIHN0YXRlIGlzIG5vdCB1cGRhdGVkIHlldC5cbiAgICAgICAgc2V0VGltZW91dChyZXNldEJsYW5rRnJhbWUsIFRSQU5TSVRJT05fVElNRSArIE5FSUdIQk9SX1NDQUxFX1RJTUUpXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzZXRCbGFua0ZyYW1lKClcbiAgICAgIH1cbiAgICB9XG4gICAgd2VleC51dGlscy5maXJlTGF6eWxvYWQodGhpcy4kZWwsIHRydWUpXG4gICAgaWYgKHRoaXMuX3ByZUluZGV4ICE9PSB0aGlzLmN1cnJlbnRJbmRleCkge1xuICAgICAgdGhpcy5fc2xpZGVUbyh0aGlzLmN1cnJlbnRJbmRleClcbiAgICB9XG4gIH0sXG5cbiAgbW91bnRlZCAoKSB7XG4gICAgdGhpcy5fZ2V0V3JhcHBlclNpemUoKVxuICAgIHRoaXMuX3NsaWRlVG8odGhpcy5jdXJyZW50SW5kZXgpXG4gICAgd2VleC51dGlscy5maXJlTGF6eWxvYWQodGhpcy4kZWwsIHRydWUpXG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIF9nZXRXcmFwcGVyU2l6ZSAoKSB7XG4gICAgICBjb25zdCB3cmFwcGVyID0gdGhpcy4kcmVmcy53cmFwcGVyXG4gICAgICBpZiAod3JhcHBlcikge1xuICAgICAgICBjb25zdCByZWN0ID0gd3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICB0aGlzLl93cmFwcGVyV2lkdGggPSByZWN0LndpZHRoXG4gICAgICAgIHRoaXMuX3dyYXBwZXJIZWlnaHQgPSByZWN0LmhlaWdodFxuICAgICAgfVxuICAgIH0sXG5cbiAgICBfZm9ybWF0Q2hpbGRyZW4gKGNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXVxuICAgICAgbGV0IGluZGljYXRvclZub2RlXG4gICAgICBjb25zdCBjZWxscyA9IGNoaWxkcmVuLmZpbHRlcih2bm9kZSA9PiB7XG4gICAgICAgIGlmICghdm5vZGUudGFnKSByZXR1cm4gZmFsc2VcbiAgICAgICAgaWYgKHZub2RlLmNvbXBvbmVudE9wdGlvbnMgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucy50YWcgPT09ICdpbmRpY2F0b3InKSB7XG4gICAgICAgICAgaW5kaWNhdG9yVm5vZGUgPSB2bm9kZVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9KS5tYXAodm5vZGUgPT4ge1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgnbGknLCB7XG4gICAgICAgICAgcmVmOiAnY2VsbHMnLFxuICAgICAgICAgIHN0YXRpY0NsYXNzOiBgd2VleC1zbGlkZXItY2VsbCB3ZWV4LWN0JHt0aGlzLmlzTmVpZ2hib3IgPyAnIG5laWdoYm9yLWNlbGwnIDogJyd9YFxuICAgICAgICB9LCBbdm5vZGVdKVxuICAgICAgfSlcbiAgICAgIGlmIChpbmRpY2F0b3JWbm9kZSkge1xuICAgICAgICBpbmRpY2F0b3JWbm9kZS5kYXRhLmF0dHJzID0gaW5kaWNhdG9yVm5vZGUuZGF0YS5hdHRycyB8fCB7fVxuICAgICAgICBpbmRpY2F0b3JWbm9kZS5kYXRhLmF0dHJzLmNvdW50ID0gY2VsbHMubGVuZ3RoXG4gICAgICAgIGluZGljYXRvclZub2RlLmRhdGEuYXR0cnMuYWN0aXZlID0gdGhpcy5jdXJyZW50SW5kZXhcbiAgICAgICAgdGhpcy5faW5kaWNhdG9yID0gaW5kaWNhdG9yVm5vZGVcbiAgICAgIH1cbiAgICAgIHJldHVybiBjZWxsc1xuICAgIH0sXG5cbiAgICBfcmVuZGVyU2xpZGVzIChjcmVhdGVFbGVtZW50KSB7XG4gICAgICB0aGlzLl9jZWxscyA9IHRoaXMuX2Zvcm1hdENoaWxkcmVuKGNyZWF0ZUVsZW1lbnQpXG4gICAgICB0aGlzLmZyYW1lQ291bnQgPSB0aGlzLl9jZWxscy5sZW5ndGhcbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KFxuICAgICAgICAnbmF2JyxcbiAgICAgICAge1xuICAgICAgICAgIHJlZjogJ3dyYXBwZXInLFxuICAgICAgICAgIGF0dHJzOiB7ICd3ZWV4LXR5cGUnOiB0aGlzLmlzTmVpZ2hib3IgPyAnc2xpZGVyLW5laWdoYm9yJyA6ICdzbGlkZXInIH0sXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIHRvdWNoc3RhcnQ6IHRoaXMuX2hhbmRsZVRvdWNoU3RhcnQsXG4gICAgICAgICAgICB0b3VjaG1vdmU6IHdlZXgudXRpbHMudGhyb3R0bGUod2VleC51dGlscy5iaW5kKHRoaXMuX2hhbmRsZVRvdWNoTW92ZSwgdGhpcyksIDI1KSxcbiAgICAgICAgICAgIHRvdWNoZW5kOiB0aGlzLl9oYW5kbGVUb3VjaEVuZCxcbiAgICAgICAgICAgIHRvdWNoY2FuY2VsOiB0aGlzLl9oYW5kbGVUb3VjaENhbmNlbFxuICAgICAgICAgIH0sXG4gICAgICAgICAgc3RhdGljQ2xhc3M6ICd3ZWV4LXNsaWRlciB3ZWV4LXNsaWRlci13cmFwcGVyIHdlZXgtY3QnLFxuICAgICAgICAgIHN0YXRpY1N0eWxlOiB3ZWV4LmV4dHJhY3RDb21wb25lbnRTdHlsZSh0aGlzKVxuICAgICAgICB9LFxuICAgICAgICBbXG4gICAgICAgICAgY3JlYXRlRWxlbWVudCgndWwnLCB7XG4gICAgICAgICAgICByZWY6ICdpbm5lcicsXG4gICAgICAgICAgICBzdGF0aWNDbGFzczogJ3dlZXgtc2xpZGVyLWlubmVyIHdlZXgtY3QnXG4gICAgICAgICAgfSwgdGhpcy5fY2VsbHMpLFxuICAgICAgICAgIHRoaXMuX2luZGljYXRvclxuICAgICAgICBdXG4gICAgICApXG4gICAgfSxcblxuICAgIC8vIGdldCBzdGFuZGFyZCBpbmRleFxuICAgIF9ub3JtYWxpemVJbmRleCAoaW5kZXgpIHtcbiAgICAgIGNvbnN0IG5ld0luZGV4ID0gKGluZGV4ICsgdGhpcy5mcmFtZUNvdW50KSAlIHRoaXMuZnJhbWVDb3VudFxuICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG5ld0luZGV4LCAwKSwgdGhpcy5mcmFtZUNvdW50IC0gMSlcbiAgICB9LFxuXG4gICAgX3N0YXJ0QXV0b1BsYXkgKCkge1xuICAgICAgaWYgKCF0aGlzLmF1dG9QbGF5IHx8IHRoaXMuYXV0b1BsYXkgPT09ICdmYWxzZScpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fYXV0b1BsYXlUaW1lcikge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fYXV0b1BsYXlUaW1lcilcbiAgICAgICAgdGhpcy5fYXV0b1BsYXlUaW1lciA9IG51bGxcbiAgICAgIH1cbiAgICAgIGxldCBpbnRlcnZhbCA9IHBhcnNlSW50KHRoaXMuaW50ZXJ2YWwgLSBUUkFOU0lUSU9OX1RJTUUgLSBORUlHSEJPUl9TQ0FMRV9USU1FKVxuICAgICAgaW50ZXJ2YWwgPSBpbnRlcnZhbCA+IElOVEVSVkFMX01JTklNVU0gPyBpbnRlcnZhbCA6IElOVEVSVkFMX01JTklNVU1cbiAgICAgIHRoaXMuX2F1dG9QbGF5VGltZXIgPSBzZXRUaW1lb3V0KHdlZXgudXRpbHMuYmluZCh0aGlzLl9uZXh0LCB0aGlzKSwgaW50ZXJ2YWwpXG4gICAgfSxcblxuICAgIF9zdG9wQXV0b1BsYXkgKCkge1xuICAgICAgaWYgKHRoaXMuX2F1dG9QbGF5VGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2F1dG9QbGF5VGltZXIpXG4gICAgICAgIHRoaXMuX2F1dG9QbGF5VGltZXIgPSBudWxsXG4gICAgICB9XG4gICAgfSxcblxuICAgIF9zbGlkZVRvIChpbmRleCwgaXNUb3VjaFNjcm9sbCkge1xuICAgICAgaWYgKHRoaXMuZnJhbWVDb3VudCA8PSAwKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmluZmluaXRlIHx8IHRoaXMuaW5maW5pdGUgPT09ICdmYWxzZScpIHtcbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSB8fCBpbmRleCA+ICh0aGlzLmZyYW1lQ291bnQgLSAxKSkge1xuICAgICAgICAgIHRoaXMuX3NsaWRlVG8odGhpcy5jdXJyZW50SW5kZXgpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fcHJlSW5kZXggJiYgdGhpcy5fcHJlSW5kZXggIT09IDApIHtcbiAgICAgICAgaWYgKHRoaXMuX3Nob3dOb2RlcyAmJiB0aGlzLl9zaG93Tm9kZXNbMF0pIHtcbiAgICAgICAgICB0aGlzLl9wcmVJbmRleCA9IHRoaXMuX3Nob3dOb2Rlc1swXS5pbmRleFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3ByZUluZGV4ID0gdGhpcy5jdXJyZW50SW5kZXhcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fc2xpZGluZykge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHRoaXMuX3NsaWRpbmcgPSB0cnVlXG5cbiAgICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5fbm9ybWFsaXplSW5kZXgoaW5kZXgpXG4gICAgICBjb25zdCBpbm5lciA9IHRoaXMuJHJlZnMuaW5uZXJcbiAgICAgIGNvbnN0IHN0ZXAgPSB0aGlzLl9zdGVwID0gdGhpcy5mcmFtZUNvdW50IDw9IDEgPyAwIDogdGhpcy5fcHJlSW5kZXggLSBpbmRleFxuXG4gICAgICBpZiAoaW5uZXIpIHtcbiAgICAgICAgdGhpcy5fcHJlcGFyZU5vZGVzKClcbiAgICAgICAgY29uc3QgdHJhbnNsYXRlID0gd2VleC51dGlscy5nZXRUcmFuc2Zvcm1PYmooaW5uZXIpLnRyYW5zbGF0ZVxuICAgICAgICBjb25zdCBtYXRjaCA9IHRyYW5zbGF0ZSAmJiB0cmFuc2xhdGUubWF0Y2goL3RyYW5zbGF0ZVteKF0rXFwoKFsrLVxcZC5dKykvKVxuICAgICAgICBjb25zdCBpbm5lclggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAwXG4gICAgICAgIGNvbnN0IGRpc3QgPSBpbm5lclggLSB0aGlzLmlubmVyT2Zmc2V0XG4gICAgICAgIHRoaXMuaW5uZXJPZmZzZXQgKz0gc3RlcCAqIHRoaXMuX3dyYXBwZXJXaWR0aFxuICAgICAgICAvLyB0cmFuc2Zvcm0gdGhlIHdob2xlIHNsaWRlcyBncm91cC5cbiAgICAgICAgaW5uZXIuc3R5bGUud2Via2l0VHJhbnNpdGlvbiA9IGAtd2Via2l0LXRyYW5zZm9ybSAke1RSQU5TSVRJT05fVElNRSAvIDEwMDB9cyBlYXNlLWluLW91dGBcbiAgICAgICAgaW5uZXIuc3R5bGUubW96VHJhbnNpdGlvbiA9IGB0cmFuc2Zvcm0gJHtUUkFOU0lUSU9OX1RJTUUgLyAxMDAwfXMgZWFzZS1pbi1vdXRgXG4gICAgICAgIGlubmVyLnN0eWxlLnRyYW5zaXRpb24gPSBgdHJhbnNmb3JtICR7VFJBTlNJVElPTl9USU1FIC8gMTAwMH1zIGVhc2UtaW4tb3V0YFxuICAgICAgICBpbm5lci5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHt0aGlzLmlubmVyT2Zmc2V0fXB4LCAwLCAwKWBcbiAgICAgICAgaW5uZXIuc3R5bGUubW96VHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7dGhpcy5pbm5lck9mZnNldH1weCwgMCwgMClgXG4gICAgICAgIGlubmVyLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke3RoaXMuaW5uZXJPZmZzZXR9cHgsIDAsIDApYFxuXG4gICAgICAgIC8vIGVtaXQgc2Nyb2xsIGV2ZW50cy5cbiAgICAgICAgaWYgKCFpc1RvdWNoU2Nyb2xsKSB7XG4gICAgICAgICAgdGhpcy5fZW1pdFNjcm9sbEV2ZW50KCdzY3JvbGxzdGFydCcpXG4gICAgICAgIH1cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fdGhyb3R0bGVFbWl0U2Nyb2xsKGRpc3QsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXRTY3JvbGxFdmVudCgnc2Nyb2xsZW5kJylcbiAgICAgICAgICB9KVxuICAgICAgICB9LCBUSFJPVFRMRV9TQ1JPTExfVElNRSlcblxuICAgICAgICB0aGlzLl9sb29wU2hvd05vZGVzKHN0ZXApXG5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNOZWlnaGJvcikge1xuICAgICAgICAgICAgdGhpcy5fc2V0TmVpZ2hib3JzKClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlubmVyLnN0eWxlLndlYmtpdFRyYW5zaXRpb24gPSAnJ1xuICAgICAgICAgICAgaW5uZXIuc3R5bGUubW96VHJhbnNpdGlvbiA9ICcnXG4gICAgICAgICAgICBpbm5lci5zdHlsZS50cmFuc2l0aW9uID0gJydcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9zaG93U3RhcnRJZHg7IGkgPD0gdGhpcy5fc2hvd0VuZElkeDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9zaG93Tm9kZXNbaV1cbiAgICAgICAgICAgICAgaWYgKCFub2RlKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgICAgICAgY29uc3QgZWxtID0gbm9kZS5maXJzdEVsZW1lbnRDaGlsZFxuICAgICAgICAgICAgICBlbG0uc3R5bGUud2Via2l0VHJhbnNpdGlvbiA9ICcnXG4gICAgICAgICAgICAgIGVsbS5zdHlsZS5tb3pUcmFuc2l0aW9uID0gJydcbiAgICAgICAgICAgICAgZWxtLnN0eWxlLnRyYW5zaXRpb24gPSAnJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2xlYW4gY2xvbmVkIG5vZGVzIGFuZCByZWFycmFuZ2Ugc2xpZGUgY2VsbHMuXG4gICAgICAgICAgICB0aGlzLl9yZWFycmFuZ2VOb2RlcyhuZXdJbmRleClcbiAgICAgICAgICB9LCBORUlHSEJPUl9TQ0FMRV9USU1FKVxuICAgICAgICB9LCBUUkFOU0lUSU9OX1RJTUUpXG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdJbmRleCAhPT0gdGhpcy5fcHJlSW5kZXgpIHtcbiAgICAgICAgd2VleC51dGlscy5kaXNwYXRjaE5hdGl2ZUV2ZW50KHRoaXMuJGVsLCAnY2hhbmdlJywge1xuICAgICAgICAgIGluZGV4OiBuZXdJbmRleFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBfY2xlYXJOb2Rlc09mZnNldCAoKSB7XG4gICAgICBjb25zdCBlbmQgPSB0aGlzLl9zaG93RW5kSWR4XG4gICAgICBmb3IgKGxldCBpID0gdGhpcy5fc2hvd1N0YXJ0SWR4OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5fc2hvd05vZGVzW2ldXG4gICAgICAgIG5vZGUgPSBub2RlICYmIG5vZGUuZmlyc3RFbGVtZW50Q2hpbGRcbiAgICAgICAgaWYgKCFub2RlKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgd2VleC51dGlscy5hZGRUcmFuc2Zvcm0odGhpcy5fc2hvd05vZGVzW2ldLmZpcnN0RWxlbWVudENoaWxkLCB7XG4gICAgICAgICAgdHJhbnNsYXRlOiAndHJhbnNsYXRlM2QoMHB4LCAwcHgsIDBweCknXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSxcblxuICAgIF9sb29wU2hvd05vZGVzIChzdGVwKSB7XG4gICAgICBpZiAoIXN0ZXAgfHwgdGhpcy5mcmFtZUNvdW50IDw9IDEpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBjb25zdCBzaWduID0gc3RlcCA+IDAgPyAxIDogLTFcbiAgICAgIGxldCBpID0gc3RlcCA8PSAwID8gdGhpcy5fc2hvd1N0YXJ0SWR4IDogdGhpcy5fc2hvd0VuZElkeFxuICAgICAgY29uc3QgZW5kID0gc3RlcCA8PSAwID8gdGhpcy5fc2hvd0VuZElkeCA6IHRoaXMuX3Nob3dTdGFydElkeFxuICAgICAgZm9yICg7IGkgIT09IGVuZCAtIHNpZ247IGkgLT0gc2lnbikge1xuICAgICAgICBjb25zdCBuZXh0SWR4ID0gaSArIHN0ZXBcbiAgICAgICAgdGhpcy5fc2hvd05vZGVzW25leHRJZHhdID0gdGhpcy5fc2hvd05vZGVzW2ldXG4gICAgICAgIHRoaXMuX3Nob3dOb2Rlc1tuZXh0SWR4XS5fc2hvd0luZGV4ID0gbmV4dElkeFxuICAgICAgICBkZWxldGUgdGhpcy5fc2hvd05vZGVzW2ldXG4gICAgICB9XG4gICAgICB0aGlzLl9zaG93U3RhcnRJZHggKz0gc3RlcFxuICAgICAgdGhpcy5fc2hvd0VuZElkeCArPSBzdGVwXG4gICAgfSxcblxuICAgIF9wcmVwYXJlTm9kZXMgKCkge1xuICAgICAgLy8gdGVzdCBpZiB0aGUgbmV4dCBzbGlkZSB0b3dhcmRzIHRoZSBkaXJlY3Rpb24gZXhpc3RzLlxuICAgICAgLy8gZS5nLiBjdXJyZW50SW5kZXggMCAtPiAxOiBzaG91bGQgcHJlcGFyZSA0IHNsaWRlczogLTEsIDAsIDEsIDJcbiAgICAgIC8vIGlmIG5vdCwgdHJhbnNsYXRlIGEgbm9kZSB0byBoZXJlLCBvciBqdXN0IGNsb25lIGl0LlxuICAgICAgY29uc3Qgc3RlcCA9IHRoaXMuX3N0ZXBcbiAgICAgIGlmICghdGhpcy5faW5pdGVkKSB7XG4gICAgICAgIHRoaXMuX2luaXROb2RlcygpXG4gICAgICAgIHRoaXMuX2luaXRlZCA9IHRydWVcbiAgICAgICAgdGhpcy5fc2hvd05vZGVzID0ge31cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmZyYW1lQ291bnQgPD0gMSkge1xuICAgICAgICB0aGlzLl9zaG93U3RhcnRJZHggPSB0aGlzLl9zaG93RW5kSWR4ID0gMFxuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5fY2VsbHNbMF0uZWxtXG4gICAgICAgIG5vZGUuc3R5bGUub3BhY2l0eSA9IDFcbiAgICAgICAgbm9kZS5zdHlsZS56SW5kZXggPSA5OVxuICAgICAgICBub2RlLmluZGV4ID0gMFxuICAgICAgICB0aGlzLl9zaG93Tm9kZXNbMF0gPSBub2RlXG4gICAgICAgIG5vZGUuX2luU2hvdyA9IHRydWVcbiAgICAgICAgbm9kZS5fc2hvd0luZGV4ID0gMFxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2hvd0NvdW50ID0gdGhpcy5fc2hvd0NvdW50ID0gTWF0aC5hYnMoc3RlcCkgKyAzXG4gICAgICB0aGlzLl9zaG93U3RhcnRJZHggPSBzdGVwIDw9IDAgPyAtMSA6IDIgLSBzaG93Q291bnRcbiAgICAgIHRoaXMuX3Nob3dFbmRJZHggPSBzdGVwIDw9IDAgPyBzaG93Q291bnQgLSAyIDogMVxuICAgICAgdGhpcy5fY2xlYXJOb2Rlc09mZnNldCgpXG4gICAgICB0aGlzLl9wb3NpdGlvbk5vZGVzKHRoaXMuX3Nob3dTdGFydElkeCwgdGhpcy5fc2hvd0VuZElkeCwgc3RlcClcbiAgICB9LFxuXG4gICAgX2NsZWFyQ2xvbmVzICgpIHtcbiAgICAgIC8vIGNsZWFyIGFsbCBjbG9uZXMuXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLl9jbG9uZXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgdGhpcy5fY2xvbmVzW2tleV0uZm9yRWFjaChjbG9uZU5vZGUgPT4ge1xuICAgICAgICAgIGNsb25lTm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNsb25lTm9kZSlcbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy5fY2xvbmVzW2tleV0gPSBbXVxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgLy8gcmVzZXQgbm9kZXMnIGluZGV4IGFuZCBfaW5TaG93IHN0YXRlLiBCdXQgbGVhdmUgdGhlIHN0eWxlc1xuICAgIC8vIGFzIHRoZXkgYXJlIHRvIHByZXZlbnQgZG9tIHJlcmVuZGVyaW5nLlxuICAgIF9yZXNldE5vZGVzICgpIHtcbiAgICAgIHRoaXMuX2NsZWFyQ2xvbmVzKClcbiAgICAgIC8vIHJlc2V0IHN0YXR1cy5cbiAgICAgIHRoaXMuX2NlbGxzLmZvckVhY2goKGNlbGwsIGlkeCkgPT4ge1xuICAgICAgICBjb25zdCBlbG0gPSBjZWxsLmVsbVxuICAgICAgICBlbG0uaW5kZXggPSBpZHhcbiAgICAgICAgZWxtLl9pblNob3cgPSBmYWxzZVxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgX2luaXROb2RlcyAoKSB7XG4gICAgICB0aGlzLl9jZWxscy5mb3JFYWNoKChjZWxsLCBpZHgpID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGNlbGwuZWxtXG4gICAgICAgIG5vZGUuaW5kZXggPSBpZHhcbiAgICAgICAgbm9kZS5faW5TaG93ID0gZmFsc2VcbiAgICAgICAgbm9kZS5zdHlsZS56SW5kZXggPSAwXG4gICAgICAgIG5vZGUuc3R5bGUub3BhY2l0eSA9IDBcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIF9wb3NpdGlvbk5vZGVzIChiZWdpbiwgZW5kLCBzdGVwLCBhbmltKSB7XG4gICAgICBjb25zdCBjZWxscyA9IHRoaXMuX2NlbGxzXG4gICAgICBjb25zdCBzdGFydCA9IHN0ZXAgPD0gMCA/IGJlZ2luIDogZW5kXG4gICAgICBjb25zdCBzdG9wID0gc3RlcCA8PSAwID8gZW5kIDogYmVnaW5cbiAgICAgIGNvbnN0IHNpZ24gPSBzdGVwIDw9IDAgPyAtMSA6IDFcbiAgICAgIGxldCBjZWxsSW5kZXggPSB0aGlzLl9wcmVJbmRleCArIHNpZ25cbiAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSAhPT0gc3RvcCAtIHNpZ247IGkgPSBpIC0gc2lnbikge1xuICAgICAgICBjb25zdCBub2RlID0gY2VsbHNbdGhpcy5fbm9ybWFsaXplSW5kZXgoY2VsbEluZGV4KV0uZWxtXG4gICAgICAgIGNlbGxJbmRleCA9IGNlbGxJbmRleCAtIHNpZ25cbiAgICAgICAgdGhpcy5fcG9zaXRpb25Ob2RlKG5vZGUsIGkpXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGluZGV4OiBwb3NpdGlvbiBpbmRleCBpbiB0aGUgc2hvd2luZyBjZWxscycgdmlldy5cbiAgICAgKi9cbiAgICBfcG9zaXRpb25Ob2RlIChub2RlLCBpbmRleCkge1xuICAgICAgY29uc3QgaG9sZGVyID0gdGhpcy5fc2hvd05vZGVzW2luZGV4XVxuICAgICAgaWYgKG5vZGUuX2luU2hvdyAmJiAoaG9sZGVyICE9PSBub2RlIHx8IGhvbGRlci5fc2hvd0luZGV4ICE9PSBpbmRleCkpIHtcbiAgICAgICAgaWYgKGhvbGRlciAmJiBob2xkZXIuX2lzQ2xvbmUpIHsgdGhpcy5fcmVtb3ZlQ2xvbmUoaG9sZGVyKSB9XG4gICAgICAgIG5vZGUgPSB0aGlzLl9nZXRDbG9uZShub2RlLmluZGV4KVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAobm9kZS5faW5TaG93KSB7ICAvLyBob2xkZXIgPT09IG5vZGVcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIG5vZGUuX2luU2hvdyA9IHRydWVcbiAgICAgIGNvbnN0IHRyYW5zbGF0ZVggPSBpbmRleCAqIHRoaXMuX3dyYXBwZXJXaWR0aCAtIHRoaXMuaW5uZXJPZmZzZXRcbiAgICAgIHdlZXgudXRpbHMuYWRkVHJhbnNmb3JtKG5vZGUsIHtcbiAgICAgICAgdHJhbnNsYXRlOiBgdHJhbnNsYXRlM2QoJHt0cmFuc2xhdGVYfXB4LCAwcHgsIDBweClgXG4gICAgICB9KVxuICAgICAgbm9kZS5zdHlsZS56SW5kZXggPSA5OSAtIE1hdGguYWJzKGluZGV4KVxuICAgICAgbm9kZS5zdHlsZS5vcGFjaXR5ID0gMVxuICAgICAgbm9kZS5fc2hvd0luZGV4ID0gaW5kZXhcbiAgICAgIHRoaXMuX3Nob3dOb2Rlc1tpbmRleF0gPSBub2RlXG4gICAgfSxcblxuICAgIF9nZXRDbG9uZSAoaW5kZXgpIHtcbiAgICAgIGNvbnN0IGFyciA9IHRoaXMuX2Nsb25lc1tpbmRleF0gfHwgKHRoaXMuX2Nsb25lc1tpbmRleF0gPSBbXSlcbiAgICAgIGNvbnN0IG9yaWdOb2RlID0gdGhpcy5fY2VsbHNbaW5kZXhdLmVsbVxuICAgICAgY29uc3QgY2xvbmUgPSBvcmlnTm9kZS5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgIGNsb25lLl9pc0Nsb25lID0gdHJ1ZVxuICAgICAgY2xvbmUuX2luU2hvdyA9IHRydWVcbiAgICAgIC8vIGNsb25lLl9pblNob3cgPSBvcmlnTm9kZS5faW5TaG93XG4gICAgICBjbG9uZS5pbmRleCA9IG9yaWdOb2RlLmluZGV4XG4gICAgICBjbG9uZS5zdHlsZS5vcGFjaXR5ID0gMFxuICAgICAgY2xvbmUuc3R5bGUuekluZGV4ID0gMFxuICAgICAgdGhpcy4kcmVmcy5pbm5lci5hcHBlbmRDaGlsZChjbG9uZSlcbiAgICAgIGFyci5wdXNoKGNsb25lKVxuICAgICAgcmV0dXJuIGNsb25lXG4gICAgICAvLyB0cnkge1xuICAgICAgLy8gICBsZXQgYXJyID0gdGhpcy5fY2xvbmVzW2luZGV4XVxuICAgICAgLy8gICBpZiAoIWFycikge1xuICAgICAgLy8gICAgIHRoaXMuX2Nsb25lc1tpbmRleF0gPSBhcnIgPSBbXVxuICAgICAgLy8gICB9XG4gICAgICAvLyAgIGlmIChhcnIubGVuZ3RoIDw9IDApIHtcblxuICAgICAgLy8gICB9XG4gICAgICAvLyAgIHJldHVybiBhcnIucG9wKClcbiAgICAgIC8vIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gICBjb25zb2xlLmVycm9yKCd0aGlzLl9jZWxscyAtPiAnLCB0aGlzLl9jZWxscylcbiAgICAgIC8vIH1cbiAgICB9LFxuXG4gICAgX3JlbW92ZUNsb25lIChub2RlKSB7XG4gICAgICBjb25zdCBjbG9uZUFyciA9IHRoaXMuX2Nsb25lc1tub2RlLmluZGV4XVxuICAgICAgbGV0IGlcbiAgICAgIGlmIChjbG9uZUFyciAmJiAoaSA9IGNsb25lQXJyLmluZGV4T2Yobm9kZSkpID4gLTEpIHtcbiAgICAgICAgY2xvbmVBcnIuc3BsaWNlKGksIDEpXG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSlcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gbWF5YmUgY2VsbHMgaGFzIGJlZW4gdXBkYXRlZCBhbmQgdGhpcyBjbG9uZSBub2RlIGlzIGFscmVhZHkgcmVtb3ZlZCBmcm9tIHRoZSBkb20gdHJlZVxuICAgICAgICAvLyB0aHJvdWdodCBfY2xlYXJDbG9uZXMgbWV0aG9kLlxuICAgICAgfVxuICAgICAgLy8gY29uc3QgaWR4ID0gbm9kZS5pbmRleFxuICAgICAgLy8gdGhpcy5faGlkZU5vZGUobm9kZSlcbiAgICAgIC8vIGNvbnN0IGFyciA9IHRoaXMuX2Nsb25lc1tpZHhdXG4gICAgICAvLyBhcnIucHVzaChub2RlKVxuICAgIH0sXG5cbiAgICBfaGlkZU5vZGUgKG5vZGUpIHtcbiAgICAgIG5vZGUuX2luU2hvdyA9IGZhbHNlXG4gICAgICBub2RlLnN0eWxlLm9wYWNpdHkgPSAwXG4gICAgICBub2RlLnN0eWxlLnpJbmRleCA9IDBcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogaGlkZSBub2RlcyBmcm9tIGJlZ2luIHRvIGVuZCBpbiBzaG93QXJyYXkuXG4gICAgICogaWYgaXQgaXMgY2xvbmUgbm9kZSwganVzdCBtb3ZlIHRoZSBjbG9uZSBub2RlIHRvIHRoZSBidWZmZXIuXG4gICAgICovXG4gICAgX2NsZWFyTm9kZXMgKGJlZ2luLCBlbmQpIHtcbiAgICAgIGZvciAobGV0IGkgPSBiZWdpbjsgaSA8PSBlbmQ7IGkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5fc2hvd05vZGVzW2ldXG4gICAgICAgIGlmICghbm9kZSkgeyByZXR1cm4gfVxuICAgICAgICBpZiAobm9kZS5faXNDbG9uZSkge1xuICAgICAgICAgIHRoaXMuX3JlbW92ZUNsb25lKG5vZGUpXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIW5vZGUuX2luU2hvdykge1xuICAgICAgICAgIHRoaXMuX2hpZGVOb2RlKG5vZGUpXG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMuX3Nob3dOb2Rlc1tpXVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjb3B5IG5vZGUgc3R5bGUgcHJvcHMgKG9wYWNpdHkgYW5kIHpJbmRleCkgYW5kIHRyYW5zZm9ybSBzdGF0dXMgZnJvbVxuICAgICAqIG9uZSBlbGVtZW50IHRvIGFub3RoZXIuXG4gICAgICovXG4gICAgX2NvcHlTdHlsZSAoZnJvbSwgdG8sIHN0eWxlcyA9IFsnb3BhY2l0eScsICd6SW5kZXgnXSwgdHJhbnNmb3JtRXh0cmEgPSB7fSkge1xuICAgICAgd2VleC51dGlscy5leHRlbmRLZXlzKHRvLnN0eWxlLCBmcm9tLnN0eWxlLCBzdHlsZXMpXG4gICAgICBjb25zdCB0cmFuc09iaiA9IHdlZXgudXRpbHMuZ2V0VHJhbnNmb3JtT2JqKGZyb20pXG4gICAgICBmb3IgKGNvbnN0IGsgaW4gdHJhbnNmb3JtRXh0cmEpIHtcbiAgICAgICAgdHJhbnNPYmpba10gPSB0cmFuc2Zvcm1FeHRyYVtrXVxuICAgICAgfVxuICAgICAgd2VleC51dGlscy5hZGRUcmFuc2Zvcm0odG8sIHRyYW5zT2JqKVxuICAgICAgY29uc3QgZnJvbUlubmVyID0gZnJvbS5maXJzdEVsZW1lbnRDaGlsZFxuICAgICAgY29uc3QgdG9Jbm5lciA9IHRvLmZpcnN0RWxlbWVudENoaWxkXG4gICAgICB0b0lubmVyLnN0eWxlLm9wYWNpdHkgPSBmcm9tSW5uZXIuc3R5bGUub3BhY2l0eVxuICAgICAgd2VleC51dGlscy5jb3B5VHJhbnNmb3JtKGZyb21Jbm5lciwgdG9Jbm5lcilcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVwbGFjZSBhIGNsb25lIG5vZGUgd2l0aCB0aGUgb3JpZ2luYWwgbm9kZSBpZiBpdCdzIG5vdCBpbiB1c2UuXG4gICAgICovXG4gICAgX3JlcGxhY2VDbG9uZSAoY2xvbmUsIHBvcykge1xuICAgICAgY29uc3Qgb3JpZ0NlbGwgPSB0aGlzLl9jZWxsc1tjbG9uZS5pbmRleF1cbiAgICAgIGlmICghb3JpZ0NlbGwpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBjb25zdCBvcmlnTm9kZSA9IG9yaWdDZWxsLmVsbVxuICAgICAgaWYgKG9yaWdOb2RlLl9pblNob3cpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBjb25zdCBvcmlnU2hvd0luZGV4ID0gb3JpZ05vZGUuX3Nob3dJbmRleFxuICAgICAgY29uc3Qgc3R5bGVQcm9wcyA9IFsnb3BhY2l0eScsICd6SW5kZXgnXVxuICAgICAgbGV0IGNsXG4gICAgICBpZiAoTWF0aC5hYnMob3JpZ1Nob3dJbmRleCkgPD0gMSkge1xuICAgICAgICAvLyBsZWF2ZSBhIGNsb25lIHRvIHJlcGxhY2UgdGhlIG9yaWdOb2RlIGluIHRoZSBzaG93IHpvbmUoLTEgfiAxKS5cbiAgICAgICAgY2wgPSB0aGlzLl9nZXRDbG9uZShvcmlnTm9kZS5pbmRleClcbiAgICAgICAgdGhpcy5fY29weVN0eWxlKG9yaWdOb2RlLCBjbClcbiAgICAgICAgdGhpcy5fc2hvd05vZGVzW29yaWdTaG93SW5kZXhdID0gY2xcbiAgICAgIH1cbiAgICAgIG9yaWdOb2RlLl9pblNob3cgPSB0cnVlXG4gICAgICBjb25zdCB0cmFuc09iaiA9IHdlZXgudXRpbHMuZ2V0VHJhbnNmb3JtT2JqKGNsb25lKVxuICAgICAgdHJhbnNPYmoudHJhbnNsYXRlID0gdHJhbnNPYmoudHJhbnNsYXRlLnJlcGxhY2UoL1srLVxcZC5dK1twd114LywgKCQwKSA9PiB7XG4gICAgICAgIHJldHVybiBwb3MgKiB0aGlzLl93cmFwcGVyV2lkdGggLSB0aGlzLmlubmVyT2Zmc2V0ICsgJ3B4J1xuICAgICAgfSlcbiAgICAgIHRoaXMuX2NvcHlTdHlsZShjbG9uZSwgb3JpZ05vZGUsIHN0eWxlUHJvcHMsIHRyYW5zT2JqKVxuICAgICAgdGhpcy5fcmVtb3ZlQ2xvbmUoY2xvbmUpXG4gICAgICBpZiAoIWNsKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zaG93Tm9kZXNbb3JpZ1Nob3dJbmRleF1cbiAgICAgIH1cbiAgICAgIHRoaXMuX3Nob3dOb2Rlc1twb3NdID0gb3JpZ05vZGVcbiAgICAgIG9yaWdOb2RlLl9zaG93SW5kZXggPSBwb3NcbiAgICB9LFxuXG4gICAgX3JlYXJyYW5nZU5vZGVzIChuZXdJbmRleCkge1xuICAgICAgaWYgKHRoaXMuZnJhbWVDb3VudCA8PSAxKSB7XG4gICAgICAgIHRoaXMuX3NsaWRpbmcgPSBmYWxzZVxuICAgICAgICB0aGlzLmN1cnJlbnRJbmRleCA9IDBcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIGNsZWFyIGF1dG9QbGF5IHRpbWVyIChhbmQgcmVzdGFydCBhZnRlciB1cGRhdGVkIGhvb2spLlxuICAgICAgdGhpcy5fc3RhcnRBdXRvUGxheSgpXG5cbiAgICAgIC8qKlxuICAgICAgICogY2xlYW4gbm9kZXMuIHJlcGxhY2UgY3VycmVudCBub2RlIHdpdGggbm9uLWNsb25lZCBub2RlLlxuICAgICAgICogc2V0IGN1cnJlbnQgaW5kZXggdG8gdGhlIG5ldyBpbmRleC5cbiAgICAgICAqL1xuICAgICAgY29uc3Qgc2hvd3MgPSB0aGlzLl9zaG93Tm9kZXNcbiAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9zaG93U3RhcnRJZHg7IGkgPD0gdGhpcy5fc2hvd0VuZElkeDsgaSsrKSB7XG4gICAgICAgIHNob3dzW2ldLl9pblNob3cgPSBmYWxzZVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IC0xOyBpIDw9IDE7IGkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gc2hvd3NbaV1cbiAgICAgICAgaWYgKCFub2RlLl9pc0Nsb25lKSB7XG4gICAgICAgICAgbm9kZS5faW5TaG93ID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3JlcGxhY2VDbG9uZShub2RlLCBpKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NsZWFyTm9kZXModGhpcy5fc2hvd1N0YXJ0SWR4LCAtMilcbiAgICAgIHRoaXMuX3Nob3dTdGFydElkeCA9IC0xXG4gICAgICB0aGlzLl9jbGVhck5vZGVzKDIsIHRoaXMuX3Nob3dFbmRJZHgpXG4gICAgICB0aGlzLl9zaG93RW5kSWR4ID0gMVxuICAgICAgdGhpcy5fc2xpZGluZyA9IGZhbHNlXG5cbiAgICAgIC8vIHNldCBjdXJyZW50IGluZGV4IHRvIHRoZSBuZXcgaW5kZXguXG4gICAgICB0aGlzLmN1cnJlbnRJbmRleCA9IG5ld0luZGV4XG4gICAgICB0aGlzLl9wcmVJbmRleCA9IG5ld0luZGV4XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGFjY29yZGluZyB0byB0aGUgYXR0cnM6IG5laWdoYm9yU2NhbGUsIG5laWdoYm9yQWxwaGEsIG5laWdoYm9yU3BhY2UuXG4gICAgICogMS4gYXBwbHkgdGhlIG1haW4gY2VsbCB0cmFuc2Zvcm0gZWZmZWN0cy5cbiAgICAgKiAyLiBzZXQgdGhlIHByZXZpb3VzIGNlbGwgYW5kIHRoZSBuZXh0IGNlbGwncyBwb3NpdG9uLCBzY2FsZSBhbmQgYWxwaGEuXG4gICAgICogMy4gc2V0IG90aGVyIGNlbGxzJyBzY2FsZSBhbmQgYWxwaGEuXG4gICAgICovXG4gICAgX3NldE5laWdoYm9ycyAoKSB7XG4gICAgICBmb3IgKGxldCBpID0gdGhpcy5fc2hvd1N0YXJ0SWR4OyBpIDw9IHRoaXMuX3Nob3dFbmRJZHg7IGkrKykge1xuICAgICAgICBjb25zdCBlbG0gPSB0aGlzLl9zaG93Tm9kZXNbaV0uZmlyc3RFbGVtZW50Q2hpbGRcbiAgICAgICAgZWxtLnN0eWxlLndlYmtpdFRyYW5zaXRpb24gPSBgYWxsICR7TkVJR0hCT1JfU0NBTEVfVElNRSAvIDEwMDB9cyBlYXNlYFxuICAgICAgICBlbG0uc3R5bGUubW96VHJhbnNpdGlvbiA9IGBhbGwgJHtORUlHSEJPUl9TQ0FMRV9USU1FIC8gMTAwMH1zIGVhc2VgXG4gICAgICAgIGVsbS5zdHlsZS50cmFuc2l0aW9uID0gYGFsbCAke05FSUdIQk9SX1NDQUxFX1RJTUUgLyAxMDAwfXMgZWFzZWBcbiAgICAgICAgY29uc3QgdHJhbnNPYmogPSB7XG4gICAgICAgICAgc2NhbGU6IGBzY2FsZSgke2kgPT09IDAgPyB0aGlzLmN1cnJlbnRJdGVtU2NhbGUgOiB0aGlzLm5laWdoYm9yU2NhbGV9KWBcbiAgICAgICAgfVxuICAgICAgICBsZXQgdHJhbnNsYXRlWFxuICAgICAgICBpZiAoIXRoaXMuX25laWdoYm9yV2lkdGgpIHtcbiAgICAgICAgICB0aGlzLl9uZWlnaGJvcldpZHRoID0gcGFyc2VGbG9hdChlbG0uc3R5bGUud2lkdGgpIHx8IGVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aFxuICAgICAgICB9XG4gICAgICAgIC8vIGNhbGN1bGF0ZSBwb3NpdGlvbiBvZmZzZXRzIGFjY29yZGluZyB0byBuZWlnaGJvciBzY2FsZXMuXG4gICAgICAgIGlmIChNYXRoLmFicyhpKSA9PT0gMSkge1xuICAgICAgICAgIGNvbnN0IGRpc3QgPSAoKHRoaXMuX3dyYXBwZXJXaWR0aCAtIHRoaXMuX25laWdoYm9yV2lkdGggKiB0aGlzLm5laWdoYm9yU2NhbGUpIC8gMlxuICAgICAgICAgICAgKyB0aGlzLm5laWdoYm9yU3BhY2UgKiB3ZWV4LmNvbmZpZy5lbnYuc2NhbGUpIC8gdGhpcy5uZWlnaGJvclNjYWxlXG4gICAgICAgICAgdHJhbnNsYXRlWCA9IC1pICogZGlzdFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIGNsZWFyIHBvc2l0aW9uIG9mZnNldHMuXG4gICAgICAgICAgdHJhbnNsYXRlWCA9IDBcbiAgICAgICAgfVxuICAgICAgICB0cmFuc09iai50cmFuc2xhdGUgPSBgdHJhbnNsYXRlM2QoJHt0cmFuc2xhdGVYfXB4LCAwcHgsIDBweClgXG4gICAgICAgIHdlZXgudXRpbHMuYWRkVHJhbnNmb3JtKGVsbSwgdHJhbnNPYmopXG4gICAgICAgIGVsbS5zdHlsZS5vcGFjaXR5ID0gaSA9PT0gMCA/IE1BSU5fU0xJREVfT1BBQ0lUWSA6IHRoaXMubmVpZ2hib3JBbHBoYVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBfbmV4dCAoKSB7XG4gICAgICBsZXQgbmV4dCA9IHRoaXMuY3VycmVudEluZGV4ICsgMVxuICAgICAgaWYgKHRoaXMuZnJhbWVDb3VudCA8PSAxKSB7XG4gICAgICAgIG5leHQtLVxuICAgICAgfVxuICAgICAgdGhpcy5fc2xpZGVUbyhuZXh0KVxuICAgIH0sXG5cbiAgICBfcHJldiAoKSB7XG4gICAgICBsZXQgcHJldiA9IHRoaXMuY3VycmVudEluZGV4IC0gMVxuICAgICAgaWYgKHRoaXMuZnJhbWVDb3VudCA8PSAxKSB7XG4gICAgICAgIHByZXYrK1xuICAgICAgfVxuICAgICAgdGhpcy5fc2xpZGVUbyhwcmV2KVxuICAgIH0sXG5cbiAgICBfaGFuZGxlVG91Y2hTdGFydCAoZXZlbnQpIHtcbiAgICAgIGNvbnN0IHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF1cbiAgICAgIHRoaXMuX3N0b3BBdXRvUGxheSgpXG4gICAgICBjb25zdCBpbm5lciA9IHRoaXMuJHJlZnMuaW5uZXJcbiAgICAgIHRoaXMuX3RvdWNoUGFyYW1zID0ge1xuICAgICAgICBvcmlnaW5hbFRyYW5zZm9ybTogaW5uZXIuc3R5bGUud2Via2l0VHJhbnNmb3JtXG4gICAgICAgICAgfHwgaW5uZXIuc3R5bGUubW96VHJhbnNmb3JtXG4gICAgICAgICAgfHwgaW5uZXIuc3R5bGUudHJhbnNmb3JtLFxuICAgICAgICBzdGFydFRvdWNoRXZlbnQ6IHRvdWNoLFxuICAgICAgICBzdGFydFg6IHRvdWNoLnBhZ2VYLFxuICAgICAgICBzdGFydFk6IHRvdWNoLnBhZ2VZLFxuICAgICAgICB0aW1lU3RhbXA6IGV2ZW50LnRpbWVTdGFtcFxuICAgICAgfVxuICAgIH0sXG5cbiAgICBfaGFuZGxlVG91Y2hNb3ZlIChldmVudCkge1xuICAgICAgY29uc3QgdHAgPSB0aGlzLl90b3VjaFBhcmFtc1xuICAgICAgaWYgKCF0cCkgeyByZXR1cm4gfVxuICAgICAgaWYgKHRoaXMuX3NsaWRpbmcpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBbdnVlLXJlbmRlcl0gd2FybjogY2FuJ3Qgc2Nyb2xsIHRoZSBzbGlkZXIgZHVyaW5nIHNsaWRpbmcuYClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgc3RhcnRYLCBzdGFydFkgfSA9IHRoaXMuX3RvdWNoUGFyYW1zXG4gICAgICBjb25zdCB0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdXG4gICAgICBjb25zdCBvZmZzZXRYID0gdG91Y2gucGFnZVggLSBzdGFydFhcbiAgICAgIGNvbnN0IG9mZnNldFkgPSB0b3VjaC5wYWdlWSAtIHN0YXJ0WVxuICAgICAgdHAub2Zmc2V0WCA9IG9mZnNldFhcbiAgICAgIHRwLm9mZnNldFkgPSBvZmZzZXRZXG4gICAgICBsZXQgaXNWID0gdHAuaXNWZXJ0aWNhbFxuICAgICAgaWYgKHR5cGVvZiBpc1YgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlzViA9IHRwLmlzVmVydGljYWwgPSBNYXRoLmFicyhvZmZzZXRYKSA8IE1hdGguYWJzKG9mZnNldFkpXG4gICAgICAgIGlmICghaXNWKSB7XG4gICAgICAgICAgdGhpcy5fZW1pdFNjcm9sbEV2ZW50KCdzY3JvbGxzdGFydCcpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIHZlcnRpY2FsIHNjcm9sbC4ganVzdCBpZ25vcmUgaXQuXG4gICAgICBpZiAoaXNWKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLy8gaG9yaXpvbnRhbCBzY3JvbGwuIHRyaWdnZXIgc2Nyb2xsIGV2ZW50LlxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgY29uc3QgaW5uZXIgPSB0aGlzLiRyZWZzLmlubmVyXG4gICAgICBpZiAoaW5uZXIgJiYgb2Zmc2V0WCkge1xuICAgICAgICBpZiAoIXRoaXMuX25vZGVzT2Zmc2V0Q2xlYXJlZCkge1xuICAgICAgICAgIHRoaXMuX25vZGVzT2Zmc2V0Q2xlYXJlZCA9IHRydWVcbiAgICAgICAgICB0aGlzLl9jbGVhck5vZGVzT2Zmc2V0KClcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lbWl0U2Nyb2xsRXZlbnQoJ3dlZXgkc2Nyb2xsJywge1xuICAgICAgICAgIG9mZnNldFhSYXRpbzogb2Zmc2V0WCAvIHRoaXMuX3dyYXBwZXJXaWR0aFxuICAgICAgICB9KVxuICAgICAgICBpbm5lci5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHt0aGlzLmlubmVyT2Zmc2V0ICsgb2Zmc2V0WH1weCwgMCwgMClgXG4gICAgICAgIGlubmVyLnN0eWxlLm1velRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke3RoaXMuaW5uZXJPZmZzZXQgKyBvZmZzZXRYfXB4LCAwLCAwKWBcbiAgICAgICAgaW5uZXIuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7dGhpcy5pbm5lck9mZnNldCArIG9mZnNldFh9cHgsIDAsIDApYFxuICAgICAgfVxuICAgIH0sXG5cbiAgICBfaGFuZGxlVG91Y2hFbmQgKGV2ZW50KSB7XG4gICAgICB0aGlzLl9zdGFydEF1dG9QbGF5KClcbiAgICAgIGNvbnN0IHRwID0gdGhpcy5fdG91Y2hQYXJhbXNcbiAgICAgIGlmICghdHApIHsgcmV0dXJuIH1cbiAgICAgIGNvbnN0IGlzViA9IHRwLmlzVmVydGljYWxcbiAgICAgIGlmICh0eXBlb2YgaXNWID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGNvbnN0IGlubmVyID0gdGhpcy4kcmVmcy5pbm5lclxuICAgICAgY29uc3QgeyBvZmZzZXRYIH0gPSB0cFxuICAgICAgaWYgKGlubmVyKSB7XG4gICAgICAgIHRoaXMuX25vZGVzT2Zmc2V0Q2xlYXJlZCA9IGZhbHNlXG4gICAgICAgIC8vIFRPRE86IHRlc3QgdGhlIHZlbG9jaXR5IGlmIGl0J3MgbGVzcyB0aGFuIDAuMi5cbiAgICAgICAgY29uc3QgcmVzZXQgPSBNYXRoLmFicyhvZmZzZXRYIC8gdGhpcy5fd3JhcHBlcldpZHRoKSA8IDAuMlxuICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBvZmZzZXRYID4gMCA/IDEgOiAtMVxuICAgICAgICBjb25zdCBuZXdJbmRleCA9IHJlc2V0ID8gdGhpcy5jdXJyZW50SW5kZXggOiAodGhpcy5jdXJyZW50SW5kZXggLSBkaXJlY3Rpb24pXG4gICAgICAgIHRoaXMuX3NsaWRlVG8obmV3SW5kZXgsIHRydWUpXG4gICAgICB9XG4gICAgICBkZWxldGUgdGhpcy5fdG91Y2hQYXJhbXNcbiAgICB9LFxuXG4gICAgX2hhbmRsZVRvdWNoQ2FuY2VsIChldmVudCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZVRvdWNoRW5kKGV2ZW50KVxuICAgIH0sXG5cbiAgICBfZW1pdFNjcm9sbEV2ZW50ICh0eXBlLCBkYXRhID0ge30pIHtcbiAgICAgIGNvbnN0IGVsID0gdGhpcy4kZWxcbiAgICAgIGlmIChlbCkge1xuICAgICAgICB3ZWV4LnV0aWxzLmRpc3BhdGNoTmF0aXZlRXZlbnQoZWwsIHR5cGUsIGRhdGEpXG4gICAgICB9XG4gICAgfSxcblxuICAgIF90aHJvdHRsZUVtaXRTY3JvbGwgKG9mZnNldCwgY2FsbGJhY2spIHtcbiAgICAgIGxldCBpID0gMFxuICAgICAgY29uc3QgdGhyb3R0bGVUaW1lID0gVEhST1RUTEVfU0NST0xMX1RJTUVcbiAgICAgIGNvbnN0IGNudCA9IHBhcnNlSW50KFRSQU5TSVRJT05fVElNRSAvIHRocm90dGxlVGltZSkgLSAxXG4gICAgICBjb25zdCBzaWduID0gb2Zmc2V0ID4gMCA/IDEgOiAtMVxuICAgICAgY29uc3QgciA9IE1hdGguYWJzKG9mZnNldCAvIHRoaXMuX3dyYXBwZXJXaWR0aClcbiAgICAgIGNvbnN0IHRocm90dGxlZFNjcm9sbCA9ICgpID0+IHtcbiAgICAgICAgaWYgKCsraSA+IGNudCkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKHRoaXMpXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmF0aW8gPSB0aGlzLl9zdGVwID09PSAwXG4gICAgICAgICAgPyBzaWduICogciAqICgxIC0gaSAvIGNudClcbiAgICAgICAgICA6IHNpZ24gKiAociArICgxIC0gcikgKiBpIC8gY250KVxuICAgICAgICB0aGlzLl9lbWl0U2Nyb2xsRXZlbnQoJ3dlZXgkc2Nyb2xsJywge1xuICAgICAgICAgIG9mZnNldFhSYXRpbzogcmF0aW9cbiAgICAgICAgfSlcbiAgICAgICAgc2V0VGltZW91dCh0aHJvdHRsZWRTY3JvbGwsIFRIUk9UVExFX1NDUk9MTF9USU1FKVxuICAgICAgfVxuICAgICAgdGhyb3R0bGVkU2Nyb2xsKClcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLy8gaW1wb3J0IHsgdmFsaWRhdGVTdHlsZXMgfSBmcm9tICcuLi8uLi92YWxpZGF0b3InXG4vLyBpbXBvcnQgaW5kaWNhdG9yIGZyb20gJy4vaW5kaWNhdG9yJ1xuaW1wb3J0IHNsaWRlTWl4aW4gZnJvbSAnLi9zbGlkZU1peGluJ1xuXG5jb25zdCBzbGlkZXIgPSB7XG4gIG1peGluczogW3NsaWRlTWl4aW5dLFxuICBwcm9wczoge1xuICAgIGluZGV4OiB7XG4gICAgICB0eXBlOiBbU3RyaW5nLCBOdW1iZXJdLFxuICAgICAgZGVmYXVsdDogMFxuICAgIH0sXG4gICAgJ2F1dG8tcGxheSc6IHtcbiAgICAgIHR5cGU6IFtTdHJpbmcsIEJvb2xlYW5dLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGludGVydmFsOiB7XG4gICAgICB0eXBlOiBbU3RyaW5nLCBOdW1iZXJdLFxuICAgICAgZGVmYXVsdDogMzAwMFxuICAgIH0sXG4gICAgaW5maW5pdGU6IHtcbiAgICAgIHR5cGU6IFtTdHJpbmcsIEJvb2xlYW5dLFxuICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgIH1cbiAgfSxcblxuICB3YXRjaDoge1xuICAgIGluZGV4ICgpIHtcbiAgICAgIHRoaXMuY3VycmVudEluZGV4ID0gdGhpcy5fbm9ybWFsaXplSW5kZXgodGhpcy5pbmRleClcbiAgICB9XG4gIH0sXG5cbiAgZGF0YSAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyYW1lQ291bnQ6IDAsXG4gICAgICBjdXJyZW50SW5kZXg6IHRoaXMuaW5kZXhcbiAgICB9XG4gIH0sXG5cbiAgYmVmb3JlQ3JlYXRlICgpIHtcbiAgICB0aGlzLndlZXhUeXBlID0gJ3NsaWRlcidcbiAgfSxcblxuICByZW5kZXIgKGNyZWF0ZUVsZW1lbnQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIC8vIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIC8vICAgdmFsaWRhdGVTdHlsZXMoJ3NsaWRlcicsIHRoaXMuJHZub2RlLmRhdGEgJiYgdGhpcy4kdm5vZGUuZGF0YS5zdGF0aWNTdHlsZSlcbiAgICAvLyB9XG4gICAgcmV0dXJuIHRoaXMuX3JlbmRlclNsaWRlcyhjcmVhdGVFbGVtZW50KVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdCAod2VleCkge1xuICAgIHdlZXgucmVnaXN0ZXJDb21wb25lbnQoJ3NsaWRlcicsIHNsaWRlcilcbiAgICB3ZWV4LnJlZ2lzdGVyQ29tcG9uZW50KCdjeWNsZXNsaWRlcicsIHNsaWRlcilcbiAgfVxufVxuIiwiLypcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgc2xpZGVNaXhpbiBmcm9tICcuL3NsaWRlTWl4aW4nXG5cbmNvbnN0IERFRkFVTFRfTkVJR0hCT1JfU1BBQ0UgPSAyMFxuY29uc3QgREVGQVVMVF9ORUlHSEJPUl9BTFBIQSA9IDAuNlxuY29uc3QgREVGQVVMVF9ORUlHSEJPUl9TQ0FMRSA9IDAuOFxuY29uc3QgREVGQVVMVF9DVVJSRU5UX0lURU1fU0NBTEUgPSAwLjlcblxuY29uc3Qgc2xpZGVyTmVpZ2hib3IgPSB7XG4gIG1peGluczogW3NsaWRlTWl4aW5dLFxuICBwcm9wczoge1xuICAgIGluZGV4OiB7XG4gICAgICB0eXBlOiBbU3RyaW5nLCBOdW1iZXJdLFxuICAgICAgZGVmYXVsdDogMFxuICAgIH0sXG4gICAgYXV0b1BsYXk6IHtcbiAgICAgIHR5cGU6IFtTdHJpbmcsIEJvb2xlYW5dLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGludGVydmFsOiB7XG4gICAgICB0eXBlOiBbU3RyaW5nLCBOdW1iZXJdLFxuICAgICAgZGVmYXVsdDogMzAwMFxuICAgIH0sXG4gICAgaW5maW5pdGU6IHtcbiAgICAgIHR5cGU6IFtTdHJpbmcsIEJvb2xlYW5dLFxuICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgIH0sXG4gICAgbmVpZ2hib3JTcGFjZToge1xuICAgICAgdHlwZTogW1N0cmluZywgTnVtYmVyXSxcbiAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICB2YWwgPSBwYXJzZUZsb2F0KHZhbClcbiAgICAgICAgcmV0dXJuICFpc05hTih2YWwpICYmIHZhbCA+IDBcbiAgICAgIH0sXG4gICAgICBkZWZhdWx0OiBERUZBVUxUX05FSUdIQk9SX1NQQUNFXG4gICAgfSxcbiAgICBuZWlnaGJvckFscGhhOiB7XG4gICAgICB0eXBlOiBbU3RyaW5nLCBOdW1iZXJdLFxuICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHZhbCA9IHBhcnNlRmxvYXQodmFsKVxuICAgICAgICByZXR1cm4gIWlzTmFOKHZhbCkgJiYgdmFsID49IDAgJiYgdmFsIDw9IDFcbiAgICAgIH0sXG4gICAgICBkZWZhdWx0OiBERUZBVUxUX05FSUdIQk9SX0FMUEhBXG4gICAgfSxcbiAgICBuZWlnaGJvclNjYWxlOiB7XG4gICAgICB0eXBlOiBbU3RyaW5nLCBOdW1iZXJdLFxuICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHZhbCA9IHBhcnNlRmxvYXQodmFsKVxuICAgICAgICByZXR1cm4gIWlzTmFOKHZhbCkgJiYgdmFsID49IDAgJiYgdmFsIDw9IDFcbiAgICAgIH0sXG4gICAgICBkZWZhdWx0OiBERUZBVUxUX05FSUdIQk9SX1NDQUxFXG4gICAgfSxcbiAgICBjdXJyZW50SXRlbVNjYWxlOiB7XG4gICAgICB0eXBlOiBbU3RyaW5nLCBOdW1iZXJdLFxuICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHZhbCA9IHBhcnNlRmxvYXQodmFsKVxuICAgICAgICByZXR1cm4gIWlzTmFOKHZhbCkgJiYgdmFsID49IDAgJiYgdmFsIDw9IDFcbiAgICAgIH0sXG4gICAgICBkZWZhdWx0OiBERUZBVUxUX0NVUlJFTlRfSVRFTV9TQ0FMRVxuICAgIH1cbiAgfSxcblxuICB3YXRjaDoge1xuICAgIGluZGV4ICgpIHtcbiAgICAgIHRoaXMuY3VycmVudEluZGV4ID0gdGhpcy5fbm9ybWFsaXplSW5kZXgodGhpcy5pbmRleClcbiAgICB9XG4gIH0sXG5cbiAgZGF0YSAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN1cnJlbnRJbmRleDogdGhpcy5pbmRleCxcbiAgICAgIGZyYW1lQ291bnQ6IDBcbiAgICB9XG4gIH0sXG5cbiAgYmVmb3JlQ3JlYXRlICgpIHtcbiAgICB0aGlzLmlzTmVpZ2hib3IgPSB0cnVlXG4gICAgdGhpcy53ZWV4VHlwZSA9ICdzbGlkZXItbmVpZ2hib3InXG4gIH0sXG5cbiAgcmVuZGVyIChjcmVhdGVFbGVtZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlbmRlclNsaWRlcyhjcmVhdGVFbGVtZW50KVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdCAod2VleCkge1xuICAgIHdlZXgucmVnaXN0ZXJDb21wb25lbnQoJ3NsaWRlci1uZWlnaGJvcicsIHNsaWRlck5laWdoYm9yKVxuICB9XG59XG4iLCIvKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxubGV0IGdldENvbXBvbmVudElubGluZVN0eWxlXG5cbmZ1bmN0aW9uIGdldEluZGljYXRvckl0ZW1TdHlsZSAobXMsIGlzQWN0aXZlKSB7XG4gIGNvbnN0IHN0eWxlID0ge31cbiAgY29uc3QgYmdDb2xvciA9IGlzQWN0aXZlXG4gICAgPyBtc1snaXRlbVNlbGVjdGVkQ29sb3InXSB8fCBtc1snaXRlbS1zZWxlY3RlZC1jb2xvciddXG4gICAgOiBtc1snaXRlbUNvbG9yJ10gfHwgbXNbJ2l0ZW0tY29sb3InXVxuICBzdHlsZVsnYmFja2dyb3VuZC1jb2xvciddID0gYmdDb2xvclxuICBzdHlsZVsnd2lkdGgnXSA9IHN0eWxlWydoZWlnaHQnXSA9IG1zWydpdGVtU2l6ZSddIHx8IG1zWydpdGVtLXNpemUnXVxuICByZXR1cm4gc3R5bGVcbn1cblxuZnVuY3Rpb24gZ2V0U2NvcGVJZHMgKGNvbnRleHQpIHtcbiAgbGV0IHNjb3BlSWRzID0gY29udGV4dC5fc2NvcGVJZHNcbiAgaWYgKHNjb3BlSWRzKSB7XG4gICAgcmV0dXJuIHNjb3BlSWRzXG4gIH1cbiAgZWxzZSB7XG4gICAgc2NvcGVJZHMgPSBbXVxuICB9XG4gIGxldCBwYXJlbnQgPSBjb250ZXh0LiRwYXJlbnRcbiAgd2hpbGUgKHBhcmVudCkge1xuICAgIGxldCBpXG4gICAgaWYgKChpID0gcGFyZW50LiRvcHRpb25zKSAmJiAoaSA9IGkuX3Njb3BlSWQpKSB7XG4gICAgICBzY29wZUlkcy5wdXNoKGkpXG4gICAgfVxuICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50XG4gIH1cbiAgY29udGV4dC5fc2NvcGVJZHMgPSBzY29wZUlkc1xuICByZXR1cm4gc2NvcGVJZHNcbn1cblxuZnVuY3Rpb24gX3JlbmRlciAoY29udGV4dCwgaCkge1xuICBjb25zdCBjaGlsZHJlbiA9IFtdXG4gIGNvbnN0IG1lcmdlZFN0eWxlID0gZ2V0Q29tcG9uZW50SW5saW5lU3R5bGUoY29udGV4dClcbiAgY29uc3Qgc2NvcGVJZHMgPSBnZXRTY29wZUlkcyhjb250ZXh0KVxuICBjb25zdCBhdHRycyA9IHt9XG4gIGZvciAobGV0IGkgPSAwLCBsID0gc2NvcGVJZHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgYXR0cnNbc2NvcGVJZHNbaV1dID0gJydcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IE51bWJlcihjb250ZXh0LmNvdW50KTsgKytpKSB7XG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IFsnd2VleC1pbmRpY2F0b3ItaXRlbSB3ZWV4LWVsJ11cbiAgICBsZXQgaXNBY3RpdmUgPSBmYWxzZVxuICAgIGlmIChpID09PSBOdW1iZXIoY29udGV4dC5hY3RpdmUpKSB7XG4gICAgICBjbGFzc05hbWVzLnB1c2goJ3dlZXgtaW5kaWNhdG9yLWl0ZW0tYWN0aXZlJylcbiAgICAgIGlzQWN0aXZlID0gdHJ1ZVxuICAgIH1cbiAgICBjaGlsZHJlbi5wdXNoKGgoJ21hcmsnLCB7XG4gICAgICBhdHRycyxcbiAgICAgIHN0YXRpY0NsYXNzOiBjbGFzc05hbWVzLmpvaW4oJyAnKSxcbiAgICAgIHN0YXRpY1N0eWxlOiBnZXRJbmRpY2F0b3JJdGVtU3R5bGUobWVyZ2VkU3R5bGUsIGlzQWN0aXZlKVxuICAgIH0pKVxuICB9XG4gIHJldHVybiBoKCduYXYnLCB7XG4gICAgYXR0cnM6IHsgJ3dlZXgtdHlwZSc6ICdpbmRpY2F0b3InIH0sXG4gICAgc3RhdGljQ2xhc3M6ICd3ZWV4LWluZGljYXRvciB3ZWV4LWN0J1xuICB9LCBbXG4gICAgLy8gdGhlIGluZGljYXRvciBuYXYgbWF5IGNvdmVyIHRoZSBzbGlkZXMsIGFuZCBtYXkgc3RvcCB0aGVcbiAgICAvLyBjbGljayBldmVudCBiZSB0cmlnZ2VyZWQgb24gdGhlIHNsaWRlcy5cbiAgICAvLyBzbyBhIHNtYWxsZXIgd3JhcHBlciBpcyBuZWVkZWQgdG8gcHJldmVudCB0aGUgb3ZlcmxhcC5cbiAgICAvLyBUaGlzIHdyYXBwZXIgd2lsbCBjb3ZlciBvbmx5IHRoZSB3aG9sZSBzaXplIG9mIGFsbCB0aGVcbiAgICAvLyBpbmRpY2F0b3IgcG9pbnRlcnMnIGl0ZW0tc2l6ZXMuXG4gICAgaCgnZGl2Jywge1xuICAgICAgc3RhdGljQ2xhc3M6ICd3ZWV4LWluZGljYXRvci1pbm5lcidcbiAgICB9LCBjaGlsZHJlbilcbiAgXSlcbn1cblxuY29uc3QgaW5kaWNhdG9yID0ge1xuICBuYW1lOiAnd2VleC1pbmRpY2F0b3InLFxuICBtZXRob2RzOiB7XG4gICAgc2hvdzogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy4kZWwuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJ1xuICAgIH1cbiAgfSxcbiAgcHJvcHM6IHtcbiAgICBpdGVtQ29sb3I6IFtTdHJpbmddLFxuICAgIGl0ZW1TZWxlY3RlZENvbG9yOiBbU3RyaW5nXSxcbiAgICBpdGVtU2l6ZTogW1N0cmluZ11cbiAgfSxcbiAgZGF0YSAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvdW50OiAwLFxuICAgICAgYWN0aXZlOiAwXG4gICAgfVxuICB9LFxuICByZW5kZXIgKGNyZWF0ZUVsZW1lbnQpIHtcbiAgICBjb25zdCB7IGNvdW50LCBhY3RpdmUgfSA9IHRoaXMuJHZub2RlLmRhdGEuYXR0cnMgfHwge31cbiAgICB0aGlzLmNvdW50ID0gY291bnRcbiAgICB0aGlzLmFjdGl2ZSA9IGFjdGl2ZVxuICAgIGlmICghdGhpcy5jb3VudCkgeyByZXR1cm4gfVxuICAgIHJldHVybiBfcmVuZGVyKHRoaXMsIGNyZWF0ZUVsZW1lbnQpXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0ICh3ZWV4KSB7XG4gICAgZ2V0Q29tcG9uZW50SW5saW5lU3R5bGUgPSB3ZWV4LmdldENvbXBvbmVudElubGluZVN0eWxlXG4gICAgd2VleC5yZWdpc3RlckNvbXBvbmVudCgnaW5kaWNhdG9yJywgaW5kaWNhdG9yKVxuICB9XG59XG4iLCIvKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHNsaWRlciBmcm9tICcuL3NsaWRlcidcbmltcG9ydCBuZWlnaGJvciBmcm9tICcuL3NsaWRlci1uZWlnaGJvcidcbmltcG9ydCBpbmRpY2F0b3IgZnJvbSAnLi9pbmRpY2F0b3InXG5pbXBvcnQgJy4vc3R5bGUuY3NzJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQgKHdlZXgpIHtcbiAgICB3ZWV4Lmluc3RhbGwoc2xpZGVyKVxuICAgIHdlZXguaW5zdGFsbChuZWlnaGJvcilcbiAgICB3ZWV4Lmluc3RhbGwoaW5kaWNhdG9yKVxuICB9XG59XG4iLCIvKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCAnLi9zdHlsZS5jc3MnXG5cbmZ1bmN0aW9uIGdldFRleHRhcmVhICh3ZWV4KSB7XG4gIGNvbnN0IHsgZXh0cmFjdENvbXBvbmVudFN0eWxlIH0gPSB3ZWV4XG4gIGNvbnN0IHsgaW5wdXRDb21tb24gfSA9IHdlZXgubWl4aW5zXG4gIGNvbnN0IHsgZXh0ZW5kLCBtYXBGb3JtRXZlbnRzIH0gPSB3ZWV4LnV0aWxzXG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnd2VleC10ZXh0YXJlYScsXG4gICAgbWl4aW5zOiBbaW5wdXRDb21tb25dLFxuICAgIHByb3BzOiB7XG4gICAgICB2YWx1ZTogU3RyaW5nLFxuICAgICAgcGxhY2Vob2xkZXI6IFN0cmluZyxcbiAgICAgIGRpc2FibGVkOiB7XG4gICAgICAgIHR5cGU6IFtTdHJpbmcsIEJvb2xlYW5dLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGF1dG9mb2N1czoge1xuICAgICAgICB0eXBlOiBbU3RyaW5nLCBCb29sZWFuXSxcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICByb3dzOiB7XG4gICAgICAgIHR5cGU6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgICAgIGRlZmF1bHQ6IDJcbiAgICAgIH0sXG4gICAgICByZXR1cm5LZXlUeXBlOiBTdHJpbmdcbiAgICB9LFxuXG4gICAgcmVuZGVyIChjcmVhdGVFbGVtZW50KSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgLy8gaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAvLyAgIHZhbGlkYXRlU3R5bGVzKCd0ZXh0YXJlYScsIHRoaXMuJHZub2RlLmRhdGEgJiYgdGhpcy4kdm5vZGUuZGF0YS5zdGF0aWNTdHlsZSlcbiAgICAgIC8vIH1cbiAgICAgIGNvbnN0IGV2ZW50cyA9IGV4dGVuZChtYXBGb3JtRXZlbnRzKHRoaXMpKVxuICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ2h0bWw6dGV4dGFyZWEnLCB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgJ3dlZXgtdHlwZSc6ICd0ZXh0YXJlYScsXG4gICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWUsXG4gICAgICAgICAgZGlzYWJsZWQ6ICh0aGlzLmRpc2FibGVkICE9PSAnZmFsc2UnICYmIHRoaXMuZGlzYWJsZWQgIT09IGZhbHNlKSxcbiAgICAgICAgICBhdXRvZm9jdXM6ICh0aGlzLmF1dG9mb2N1cyAhPT0gJ2ZhbHNlJyAmJiB0aGlzLmF1dG9mb2N1cyAhPT0gZmFsc2UpLFxuICAgICAgICAgIHBsYWNlaG9sZGVyOiB0aGlzLnBsYWNlaG9sZGVyLFxuICAgICAgICAgIHJvd3M6IHRoaXMucm93cyxcbiAgICAgICAgICAncmV0dXJuLWtleS10eXBlJzogdGhpcy5yZXR1cm5LZXlUeXBlXG4gICAgICAgIH0sXG4gICAgICAgIGRvbVByb3BzOiB7XG4gICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWVcbiAgICAgICAgfSxcbiAgICAgICAgb246IHRoaXMuY3JlYXRlS2V5Ym9hcmRFdmVudChldmVudHMpLFxuICAgICAgICBzdGF0aWNDbGFzczogJ3dlZXgtdGV4dGFyZWEgd2VleC1lbCcsXG4gICAgICAgIHN0YXRpY1N0eWxlOiBleHRyYWN0Q29tcG9uZW50U3R5bGUodGhpcylcbiAgICAgIH0pXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdCAod2VleCkge1xuICAgIHdlZXgucmVnaXN0ZXJDb21wb25lbnQoJ3RleHRhcmVhJywgZ2V0VGV4dGFyZWEod2VleCkpXG4gIH1cbn1cbiIsIi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuZnVuY3Rpb24gZ2V0VmlkZW8gKHdlZXgpIHtcbiAgY29uc3Qge1xuICAgIGV4dHJhY3RDb21wb25lbnRTdHlsZSxcbiAgICBtYXBOYXRpdmVFdmVudHNcbiAgfSA9IHdlZXhcbiAgY29uc3QgeyBkaXNwYXRjaE5hdGl2ZUV2ZW50IH0gPSB3ZWV4LnV0aWxzXG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnd2VleC12aWRlbycsXG4gICAgcHJvcHM6IHtcbiAgICAgIHNyYzogU3RyaW5nLFxuICAgICAgcGxheVN0YXR1czoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6ICdwYXVzZScsXG4gICAgICAgIHZhbGlkYXRvciAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gWydwbGF5JywgJ3BhdXNlJ10uaW5kZXhPZih2YWx1ZSkgIT09IC0xXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhdXRvcGxheToge1xuICAgICAgICB0eXBlOiBbU3RyaW5nLCBCb29sZWFuXSxcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBhdXRvUGxheToge1xuICAgICAgICB0eXBlOiBbU3RyaW5nLCBCb29sZWFuXSxcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBwbGF5c2lubGluZToge1xuICAgICAgICB0eXBlOiBbU3RyaW5nLCBCb29sZWFuXSxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGNvbnRyb2xzOiB7XG4gICAgICAgIHR5cGU6IFtTdHJpbmcsIEJvb2xlYW5dLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfVxuICAgIH0sXG5cbiAgICByZW5kZXIgKGNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIGlmICh0aGlzLnBsYXlTdGF0dXMgPT09ICdwbGF5Jykge1xuICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuJGVsICYmIHRoaXMuJGVsLnBsYXkoKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBkaXNwYXRjaE5hdGl2ZUV2ZW50KHRoaXMgJiYgdGhpcy4kZWwsICdlcnJvcicsIHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogZXJyLm1lc3NhZ2VcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy5wbGF5U3RhdHVzID09PSAncGF1c2UnKSB7XG4gICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLiRlbCAmJiB0aGlzLiRlbC5wYXVzZSgpXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdodG1sOnZpZGVvJywge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgICd3ZWV4LXR5cGUnOiAndmlkZW8nLFxuICAgICAgICAgIGF1dG9wbGF5OiAoKHRoaXMuYXV0b3BsYXkgIT09ICdmYWxzZScgJiYgdGhpcy5hdXRvcGxheSAhPT0gZmFsc2UpXG4gICAgICAgICAgICB8fCAodGhpcy5hdXRvUGxheSAhPT0gJ2ZhbHNlJyAmJiB0aGlzLmF1dG9QbGF5ICE9PSBmYWxzZSkpLFxuICAgICAgICAgICd3ZWJraXQtcGxheXNpbmxpbmUnOiB0aGlzLnBsYXlzaW5saW5lLFxuICAgICAgICAgIGNvbnRyb2xzOiB0aGlzLmNvbnRyb2xzLFxuICAgICAgICAgIHNyYzogdGhpcy5zcmNcbiAgICAgICAgfSxcbiAgICAgICAgb246IG1hcE5hdGl2ZUV2ZW50cyh0aGlzLCB7XG4gICAgICAgICAgcGxheTogJ3N0YXJ0JyxcbiAgICAgICAgICBlcnJvcjogJ2ZhaWwnXG4gICAgICAgIH0pLFxuICAgICAgICBzdGF0aWNDbGFzczogJ3dlZXgtdmlkZW8gd2VleC1lbCcsXG4gICAgICAgIHN0YXRpY1N0eWxlOiBleHRyYWN0Q29tcG9uZW50U3R5bGUodGhpcylcbiAgICAgIH0pXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdCAod2VleCkge1xuICAgIHdlZXgucmVnaXN0ZXJDb21wb25lbnQoJ3ZpZGVvJywgZ2V0VmlkZW8od2VleCkpXG4gIH1cbn1cbiIsIi8qXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0ICcuL3N0eWxlLmNzcydcblxuZnVuY3Rpb24gZ2V0V2ViICh3ZWV4KSB7XG4gIGNvbnN0IHsgZXh0cmFjdENvbXBvbmVudFN0eWxlIH0gPSB3ZWV4XG4gIGNvbnN0IHsgZGlzcGF0Y2hOYXRpdmVFdmVudCB9ID0gd2VleC51dGlsc1xuXG4gIHJldHVybiB7XG4gICAgZGF0YSAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjdXJyZW50U3JjOiAnJ1xuICAgICAgfVxuICAgIH0sXG4gICAgbmFtZTogJ3dlZXgtd2ViJyxcbiAgICBwcm9wczoge1xuICAgICAgc3JjOiBTdHJpbmdcbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICBzcmMgKG5ld1ZhbCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRTcmMgPSBuZXdWYWxcbiAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIGdvQmFjayAoKSB7XG4gICAgICAgIGNvbnN0IGVsID0gdGhpcy4kZWxcbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgY29uc3Qgd2luID0gZWwuY29udGVudFdpbmRvd1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3aW4uaGlzdG9yeS5iYWNrKClcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNyYyA9IHdpbi5sb2NhdGlvbi5ocmVmXG4gICAgICAgICAgfVxuICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoTmF0aXZlRXZlbnQoZWwsICdlcnJvcicsIGVycilcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBnb0ZvcndhcmQgKCkge1xuICAgICAgICBjb25zdCBlbCA9IHRoaXMuJGVsXG4gICAgICAgIGlmIChlbCkge1xuICAgICAgICAgIGNvbnN0IHdpbiA9IGVsLmNvbnRlbnRXaW5kb3dcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2luLmhpc3RvcnkuZm9yd2FyZCgpXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTcmMgPSB3aW4ubG9jYXRpb24uaHJlZlxuICAgICAgICAgIH1cbiAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBkaXNwYXRjaE5hdGl2ZUV2ZW50KGVsLCAnZXJyb3InLCBlcnIpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVsb2FkICgpIHtcbiAgICAgICAgY29uc3QgZWwgPSB0aGlzLiRlbFxuICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZWwuY29udGVudFdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICAgICAgICAgICAgZGlzcGF0Y2hOYXRpdmVFdmVudChlbCwgJ3BhZ2VzdGFydCcsIHsgdXJsOiB0aGlzLmN1cnJlbnRTcmMgfSlcbiAgICAgICAgICB9XG4gICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZGlzcGF0Y2hOYXRpdmVFdmVudChlbCwgJ2Vycm9yJywgZXJyKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBjcmVhdGVkICgpIHtcbiAgICAgIHRoaXMuY3VycmVudFNyYyA9IHRoaXMuc3JjXG4gICAgfSxcblxuICAgIG1vdW50ZWQgKCkge1xuICAgICAgY29uc3QgZWwgPSB0aGlzLiRlbFxuICAgICAgdGhpcy5fcHJldlNyYyA9IHRoaXMuY3VycmVudFNyY1xuICAgICAgaWYgKGVsKSB7XG4gICAgICAgIGRpc3BhdGNoTmF0aXZlRXZlbnQoZWwsICdwYWdlc3RhcnQnLCB7IHVybDogdGhpcy5jdXJyZW50U3JjIH0pXG4gICAgICB9XG4gICAgfSxcblxuICAgIHVwZGF0ZWQgKCkge1xuICAgICAgaWYgKHRoaXMuY3VycmVudFNyYyAhPT0gdGhpcy5fcHJldlNyYykge1xuICAgICAgICB0aGlzLl9wcmV2U3JjID0gdGhpcy5jdXJyZW50U3JjXG4gICAgICAgIGRpc3BhdGNoTmF0aXZlRXZlbnQodGhpcy4kZWwsICdwYWdlc3RhcnQnLCB7IHVybDogdGhpcy5jdXJyZW50U3JjIH0pXG4gICAgICB9XG4gICAgfSxcblxuICAgIHJlbmRlciAoY3JlYXRlRWxlbWVudCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScsIHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAnd2VleC10eXBlJzogJ3dlYicsXG4gICAgICAgICAgc3JjOiB0aGlzLmN1cnJlbnRTcmNcbiAgICAgICAgfSxcbiAgICAgICAgb246IHtcbiAgICAgICAgICBsb2FkOiBldmVudCA9PiB7XG4gICAgICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGVsID0gdGhpcy4kZWxcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBodG1sID0gZWwuY29udGVudFdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRcbiAgICAgICAgICAgICAgICBpZiAoaHRtbCkge1xuICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hOYXRpdmVFdmVudChlbCwgJ3BhZ2VmaW5pc2gnLCB7IHVybDogdGhpcy5jdXJyZW50U3JjIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hOYXRpdmVFdmVudChlbCwgJ2Vycm9yJywgbmV3IEVycm9yKCdbdnVlLXJlbmRlcl06Zm91bmQgbm8gcGFnZSBjb250ZW50LicpKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hOYXRpdmVFdmVudChlbCwgJ2Vycm9yJywgZXJyKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3RhdGljQ2xhc3M6ICd3ZWV4LXdlYiB3ZWV4LWVsJyxcbiAgICAgICAgc3RhdGljU3R5bGU6IGV4dHJhY3RDb21wb25lbnRTdHlsZSh0aGlzKVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0ICh3ZWV4KSB7XG4gICAgd2VleC5yZWdpc3RlckNvbXBvbmVudCgnd2ViJywgZ2V0V2ViKHdlZXgpKVxuICB9XG59XG4iLCIvKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8vIGltcG9ydCBhIGZyb20gJy4vYSdcbi8vIGltcG9ydCBkaXYgZnJvbSAnLi9kaXYnXG4vLyBpbXBvcnQgaW1hZ2UgZnJvbSAnLi9pbWFnZSdcbmltcG9ydCBpbnB1dCBmcm9tICcuL2lucHV0J1xuaW1wb3J0IF9zd2l0Y2ggZnJvbSAnLi9zd2l0Y2gnXG5pbXBvcnQgc2Nyb2xsYWJsZSBmcm9tICcuL3Njcm9sbGFibGUnXG5pbXBvcnQgc2xpZGVyIGZyb20gJy4vc2xpZGVyJ1xuLy8gaW1wb3J0IHRleHQgZnJvbSAnLi90ZXh0J1xuaW1wb3J0IHRleHRhcmVhIGZyb20gJy4vdGV4dGFyZWEnXG5pbXBvcnQgdmlkZW8gZnJvbSAnLi92aWRlbydcbmltcG9ydCB3ZWIgZnJvbSAnLi93ZWInXG5cbmV4cG9ydCBkZWZhdWx0IFtcbiAgLy8gYSxcbiAgLy8gZGl2LFxuICAvLyBpbWFnZSxcbiAgaW5wdXQsXG4gIF9zd2l0Y2gsXG4gIHNjcm9sbGFibGUsXG4gIHNsaWRlcixcbiAgLy8gdGV4dCxcbiAgdGV4dGFyZWEsXG4gIHZpZGVvLFxuICB3ZWJcbl1cbiIsIi8qXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHN1cHBvcnRHZW9sb2NhdGlvbiA9ICdnZW9sb2NhdGlvbicgaW4gbmF2aWdhdG9yXG5jb25zdCBlcnJvck1zZyA9IGBbaDUtcmVuZGVyXTogYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgZ2VvbG9jYXRpb24uYFxuXG5jb25zdCBnZW9sb2NhdGlvbiA9IHtcbiAgLy8gb3B0aW9uczpcbiAgLy8gICAtIGVuYWJsZUhpZ2hBY2N1cmFjeSBvcHRpb25hbCwgdmFsdWUgaXMgdHJ1ZSBvciBmYWxzZSwgZmFsc2UgYnkgZGVmYXVsdC5cbiAgLy8gICAtIHRpbWVvdXQgW25vbmUtbmF0aXZlXSBvcHRpb25hbCwgdmFsdWUgaXMgYSBudW1iZXIgKG1pbGxpc2Vjb25kcyksIGRlZmF1bHQgdmF1bGUgaXMgRklORklOSVRZLlxuICAvLyAgIC0gbWF4aW11bUFnZSBbbm9uZS1uYXRpdmVdIG9wdGlvbmFsLCB2YWx1ZSBpcyBhIG51bWJlciAobWlsbGlzZWNvbmRzKSwgZGVmYXVsdCB2YWx1ZSBpcyAwLlxuICBnZXRDdXJyZW50UG9zaXRpb24gKHN1Y2Nlc3NDYklkLCBlcnJvckNiSWQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzdWNjZXNzQ2IgPSBwb3MgPT4gdGhpcy5zZW5kZXIucGVyZm9ybUNhbGxiYWNrKHN1Y2Nlc3NDYklkLCBwb3MpXG4gICAgY29uc3QgZXJyb3JDYiA9IGVyciA9PiB0aGlzLnNlbmRlci5wZXJmb3JtQ2FsbGJhY2soZXJyb3JDYklkLCBlcnIpXG4gICAgaWYgKHN1cHBvcnRHZW9sb2NhdGlvbikge1xuICAgICAgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbihzdWNjZXNzQ2IsIGVycm9yQ2IsIG9wdGlvbnMpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKGVycm9yTXNnKVxuICAgICAgZXJyb3JDYihuZXcgRXJyb3IoZXJyb3JNc2cpKVxuICAgIH1cbiAgfSxcblxuICAvLyBvcHRpb25zOiB0aGUgc2FtZSB3aXRoIGBnZXRDdXJyZW50UG9zaXRpb25gLlxuICB3YXRjaFBvc2l0aW9uIChzdWNjZXNzQ2JJZCwgZXJyb3JDYklkLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc3VjY2Vzc0NiID0gcG9zID0+IHRoaXMuc2VuZGVyLnBlcmZvcm1DYWxsYmFjayhzdWNjZXNzQ2JJZCwgcG9zLCB0cnVlKVxuICAgIGNvbnN0IGVycm9yQ2IgPSBlcnIgPT4gdGhpcy5zZW5kZXIucGVyZm9ybUNhbGxiYWNrKGVycm9yQ2JJZCwgZXJyKVxuICAgIGlmIChzdXBwb3J0R2VvbG9jYXRpb24pIHtcbiAgICAgIGNvbnN0IGlkID0gbmF2aWdhdG9yLmdlb2xvY2F0aW9uLndhdGNoUG9zaXRpb24ocG9zID0+IHtcbiAgICAgICAgcG9zLndhdGNoSWQgPSBpZFxuICAgICAgICBzdWNjZXNzQ2IocG9zKVxuICAgICAgfSwgZXJyb3JDYiwgb3B0aW9ucylcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oZXJyb3JNc2cpXG4gICAgICBlcnJvckNiKG5ldyBFcnJvcihlcnJvck1zZykpXG4gICAgfVxuICB9LFxuXG4gIGNsZWFyV2F0Y2ggKHdhdGNoSWQpIHtcbiAgICBpZiAoc3VwcG9ydEdlb2xvY2F0aW9uKSB7XG4gICAgICBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCh3YXRjaElkKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihlcnJvck1zZylcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgbWV0YSA9IHtcbiAgZ2VvbG9jYXRpb246IFt7XG4gICAgbmFtZTogJ2dldEN1cnJlbnRQb3NpdGlvbicsXG4gICAgYXJnczogWydmdW5jdGlvbicsICdmdW5jdGlvbicsICdvYmplY3QnXVxuICB9LCB7XG4gICAgbmFtZTogJ3dhdGNoUG9zaXRpb24nLFxuICAgIGFyZ3M6IFsnZnVuY3Rpb24nLCAnZnVuY3Rpb24nLCAnb2JqZWN0J11cbiAgfSwge1xuICAgIG5hbWU6ICdjbGVhcldhdGNoJyxcbiAgICBhcmdzOiBbJ3N0cmluZyddXG4gIH1dXG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdCAoV2VleCkge1xuICAgIFdlZXgucmVnaXN0ZXJBcGlNb2R1bGUoJ2dlb2xvY2F0aW9uJywgZ2VvbG9jYXRpb24sIG1ldGEpXG4gIH1cbn1cbiIsIi8qXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyogZ2xvYmFsIGxvY2FsU3RvcmFnZSAqL1xuXG4ndXNlIHN0cmljdCdcblxubGV0IHN1cHBvcnRMb2NhbFN0b3JhZ2UgPSBmYWxzZVxudHJ5IHtcbiAgc3VwcG9ydExvY2FsU3RvcmFnZSA9IHR5cGVvZiBsb2NhbFN0b3JhZ2UgIT09ICd1bmRlZmluZWQnXG59XG5jYXRjaCAoZXJyKSB7XG4gIC8vIG5vdCBzdXBwb3J0LlxufVxuXG5jb25zdCBTVUNDRVNTID0gJ3N1Y2Nlc3MnXG5jb25zdCBGQUlMRUQgPSAnZmFpbGVkJ1xuY29uc3QgSU5WQUxJRF9QQVJBTSA9ICdpbnZhbGlkX3BhcmFtJ1xuY29uc3QgVU5ERUZJTkVEID0gJ3VuZGVmaW5lZCdcblxuZnVuY3Rpb24gY2FsbEZhaWwgKHNlbmRlciwgY2FsbGJhY2tJZCwgZXJyb3JNc2cpIHtcbiAgc2VuZGVyLnBlcmZvcm1DYWxsYmFjayhjYWxsYmFja0lkLCB7XG4gICAgcmVzdWx0OiBGQUlMRUQsXG4gICAgZGF0YTogZXJyb3JNc2cgfHwgVU5ERUZJTkVEXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNhbGxOb3RTdXBwb3J0RmFpbCAoc2VuZGVyLCBjYWxsYmFja0lkKSB7XG4gIHNlbmRlci5wZXJmb3JtQ2FsbGJhY2soY2FsbGJhY2tJZCwge1xuICAgIHJlc3VsdDogRkFJTEVELFxuICAgIGRhdGE6ICdsb2NhbFN0b3JhZ2UgaXMgZGlzYWJsZWQgb3Igbm90IHN1cHBvcnRlZC4nXG4gIH0pXG59XG5cbmNvbnN0IHN0b3JhZ2UgPSB7XG5cbiAgLyoqXG4gICAqIFdoZW4gcGFzc2VkIGEga2V5IG5hbWUgYW5kIHZhbHVlLCB3aWxsIGFkZCB0aGF0IGtleSB0byB0aGUgc3RvcmFnZSxcbiAgICogb3IgdXBkYXRlIHRoYXQga2V5J3MgdmFsdWUgaWYgaXQgYWxyZWFkeSBleGlzdHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIG5vdCBudWxsIG5vciB1bmRpZmluZWTvvIxidXQgMCB3b3Jrcy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tJZFxuICAgKi9cbiAgc2V0SXRlbTogZnVuY3Rpb24gKGtleSwgdmFsdWUsIGNhbGxiYWNrSWQpIHtcbiAgICBjb25zdCBzZW5kZXIgPSB0aGlzLnNlbmRlclxuICAgIGlmICghc3VwcG9ydExvY2FsU3RvcmFnZSkge1xuICAgICAgcmV0dXJuIGNhbGxOb3RTdXBwb3J0RmFpbChzZW5kZXIsIGNhbGxiYWNrSWQpXG4gICAgfVxuICAgIGlmICgha2V5IHx8ICghdmFsdWUgJiYgdmFsdWUgIT09IDApKSB7XG4gICAgICBzZW5kZXIucGVyZm9ybUNhbGxiYWNrKGNhbGxiYWNrSWQsIHtcbiAgICAgICAgcmVzdWx0OiAnZmFpbGVkJyxcbiAgICAgICAgZGF0YTogSU5WQUxJRF9QQVJBTVxuICAgICAgfSlcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0cnkge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSlcbiAgICAgIHNlbmRlci5wZXJmb3JtQ2FsbGJhY2soY2FsbGJhY2tJZCwge1xuICAgICAgICByZXN1bHQ6IFNVQ0NFU1MsXG4gICAgICAgIGRhdGE6IFVOREVGSU5FRFxuICAgICAgfSlcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGFjY2VwdCBhbnkgZXhjZXB0aW9uIHRocm93biBkdXJpbmcgYSBzdG9yYWdlIGF0dGVtcHQgYXMgYSBxdW90YSBlcnJvclxuICAgICAgY2FsbEZhaWwoc2VuZGVyLCBjYWxsYmFja0lkKVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogV2hlbiBwYXNzZWQgYSBrZXkgbmFtZSwgd2lsbCByZXR1cm4gdGhhdCBrZXkncyB2YWx1ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja0lkXG4gICAqL1xuICBnZXRJdGVtOiBmdW5jdGlvbiAoa2V5LCBjYWxsYmFja0lkKSB7XG4gICAgY29uc3Qgc2VuZGVyID0gdGhpcy5zZW5kZXJcbiAgICBpZiAoIXN1cHBvcnRMb2NhbFN0b3JhZ2UpIHtcbiAgICAgIHJldHVybiBjYWxsTm90U3VwcG9ydEZhaWwoc2VuZGVyLCBjYWxsYmFja0lkKVxuICAgIH1cbiAgICBpZiAoIWtleSkge1xuICAgICAgc2VuZGVyLnBlcmZvcm1DYWxsYmFjayhjYWxsYmFja0lkLCB7XG4gICAgICAgIHJlc3VsdDogRkFJTEVELFxuICAgICAgICBkYXRhOiBJTlZBTElEX1BBUkFNXG4gICAgICB9KVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCB2YWwgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpXG4gICAgICBzZW5kZXIucGVyZm9ybUNhbGxiYWNrKGNhbGxiYWNrSWQsIHtcbiAgICAgICAgcmVzdWx0OiB2YWwgPyBTVUNDRVNTIDogRkFJTEVELFxuICAgICAgICBkYXRhOiB2YWwgfHwgVU5ERUZJTkVEXG4gICAgICB9KVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgLy8gYWNjZXB0IGFueSBleGNlcHRpb24gdGhyb3duIGR1cmluZyBhIHN0b3JhZ2UgYXR0ZW1wdCBhcyBhIHF1b3RhIGVycm9yXG4gICAgICBjYWxsRmFpbChzZW5kZXIsIGNhbGxiYWNrSWQpXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKldoZW4gcGFzc2VkIGEga2V5IG5hbWUsIHdpbGwgcmVtb3ZlIHRoYXQga2V5IGZyb20gdGhlIHN0b3JhZ2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tJZFxuICAgKi9cbiAgcmVtb3ZlSXRlbTogZnVuY3Rpb24gKGtleSwgY2FsbGJhY2tJZCkge1xuICAgIGNvbnN0IHNlbmRlciA9IHRoaXMuc2VuZGVyXG4gICAgaWYgKCFzdXBwb3J0TG9jYWxTdG9yYWdlKSB7XG4gICAgICByZXR1cm4gY2FsbE5vdFN1cHBvcnRGYWlsKHNlbmRlciwgY2FsbGJhY2tJZClcbiAgICB9XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHNlbmRlci5wZXJmb3JtQ2FsbGJhY2soY2FsbGJhY2tJZCwge1xuICAgICAgICByZXN1bHQ6IEZBSUxFRCxcbiAgICAgICAgZGF0YTogSU5WQUxJRF9QQVJBTVxuICAgICAgfSlcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0cnkge1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KVxuICAgICAgc2VuZGVyLnBlcmZvcm1DYWxsYmFjayhjYWxsYmFja0lkLCB7XG4gICAgICAgIHJlc3VsdDogU1VDQ0VTUyxcbiAgICAgICAgZGF0YTogVU5ERUZJTkVEXG4gICAgICB9KVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgLy8gYWNjZXB0IGFueSBleGNlcHRpb24gdGhyb3duIGR1cmluZyBhIHN0b3JhZ2UgYXR0ZW1wdCBhcyBhIHF1b3RhIGVycm9yXG4gICAgICBjYWxsRmFpbChzZW5kZXIsIGNhbGxiYWNrSWQpXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGludGVnZXIgcmVwcmVzZW50aW5nIHRoZSBudW1iZXIgb2YgZGF0YSBpdGVtcyBzdG9yZWQgaW4gdGhlIFN0b3JhZ2Ugb2JqZWN0LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja0lkXG4gICAqL1xuICBsZW5ndGg6IGZ1bmN0aW9uIChjYWxsYmFja0lkKSB7XG4gICAgY29uc3Qgc2VuZGVyID0gdGhpcy5zZW5kZXJcbiAgICBpZiAoIXN1cHBvcnRMb2NhbFN0b3JhZ2UpIHtcbiAgICAgIHJldHVybiBjYWxsTm90U3VwcG9ydEZhaWwoc2VuZGVyLCBjYWxsYmFja0lkKVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgbGVuID0gbG9jYWxTdG9yYWdlLmxlbmd0aFxuICAgICAgc2VuZGVyLnBlcmZvcm1DYWxsYmFjayhjYWxsYmFja0lkLCB7XG4gICAgICAgIHJlc3VsdDogU1VDQ0VTUyxcbiAgICAgICAgZGF0YTogbGVuXG4gICAgICB9KVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgLy8gYWNjZXB0IGFueSBleGNlcHRpb24gdGhyb3duIGR1cmluZyBhIHN0b3JhZ2UgYXR0ZW1wdCBhcyBhIHF1b3RhIGVycm9yXG4gICAgICBjYWxsRmFpbChzZW5kZXIsIGNhbGxiYWNrSWQpXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IHRoYXQgY29udGFpbnMgYWxsIGtleXMgc3RvcmVkIGluIFN0b3JhZ2Ugb2JqZWN0LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja0lkXG4gICAqL1xuICBnZXRBbGxLZXlzOiBmdW5jdGlvbiAoY2FsbGJhY2tJZCkge1xuICAgIGNvbnN0IHNlbmRlciA9IHRoaXMuc2VuZGVyXG4gICAgaWYgKCFzdXBwb3J0TG9jYWxTdG9yYWdlKSB7XG4gICAgICByZXR1cm4gY2FsbE5vdFN1cHBvcnRGYWlsKHNlbmRlciwgY2FsbGJhY2tJZClcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IF9hcnIgPSBbXVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhbFN0b3JhZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgX2Fyci5wdXNoKGxvY2FsU3RvcmFnZS5rZXkoaSkpXG4gICAgICB9XG4gICAgICBzZW5kZXIucGVyZm9ybUNhbGxiYWNrKGNhbGxiYWNrSWQsIHtcbiAgICAgICAgcmVzdWx0OiBTVUNDRVNTLFxuICAgICAgICBkYXRhOiBfYXJyXG4gICAgICB9KVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgLy8gYWNjZXB0IGFueSBleGNlcHRpb24gdGhyb3duIGR1cmluZyBhIHN0b3JhZ2UgYXR0ZW1wdCBhcyBhIHF1b3RhIGVycm9yXG4gICAgICBjYWxsRmFpbChzZW5kZXIsIGNhbGxiYWNrSWQpXG4gICAgfVxuICB9XG59XG5cbmNvbnN0IG1ldGEgPSB7XG4gIHN0b3JhZ2U6IFt7XG4gICAgbmFtZTogJ3NldEl0ZW0nLFxuICAgIGFyZ3M6IFsnc3RyaW5nJywgJ3N0cmluZycsICdmdW5jdGlvbiddXG4gIH0sIHtcbiAgICBuYW1lOiAnZ2V0SXRlbScsXG4gICAgYXJnczogWydzdHJpbmcnLCAnZnVuY3Rpb24nXVxuICB9LCB7XG4gICAgbmFtZTogJ3JlbW92ZUl0ZW0nLFxuICAgIGFyZ3M6IFsnc3RyaW5nJywgJ2Z1bmN0aW9uJ11cbiAgfSwge1xuICAgIG5hbWU6ICdsZW5ndGgnLFxuICAgIGFyZ3M6IFsnZnVuY3Rpb24nXVxuICB9LCB7XG4gICAgbmFtZTogJ2dldEFsbEtleXMnLFxuICAgIGFyZ3M6IFsnZnVuY3Rpb24nXVxuICB9XVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQ6IGZ1bmN0aW9uIChXZWV4KSB7XG4gICAgV2VleC5yZWdpc3RlckFwaU1vZHVsZSgnc3RvcmFnZScsIHN0b3JhZ2UsIG1ldGEpXG4gIH1cbn1cbiIsIih0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgJiYgKHdpbmRvdyA9IHtjdHJsOiB7fSwgbGliOiB7fX0pOyF3aW5kb3cuY3RybCAmJiAod2luZG93LmN0cmwgPSB7fSk7IXdpbmRvdy5saWIgJiYgKHdpbmRvdy5saWIgPSB7fSk7IWZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhhKXt2YXIgYj17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyxcInBhcmFtc1wiLHtzZXQ6ZnVuY3Rpb24oYSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGEpe2Zvcih2YXIgYyBpbiBiKWRlbGV0ZSBiW2NdO2Zvcih2YXIgYyBpbiBhKWJbY109YVtjXX19LGdldDpmdW5jdGlvbigpe3JldHVybiBifSxlbnVtZXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsXCJzZWFyY2hcIix7c2V0OmZ1bmN0aW9uKGEpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBhKXswPT09YS5pbmRleE9mKFwiP1wiKSYmKGE9YS5zdWJzdHIoMSkpO3ZhciBjPWEuc3BsaXQoXCImXCIpO2Zvcih2YXIgZCBpbiBiKWRlbGV0ZSBiW2RdO2Zvcih2YXIgZT0wO2U8Yy5sZW5ndGg7ZSsrKXt2YXIgZj1jW2VdLnNwbGl0KFwiPVwiKTtpZih2b2lkIDAhPT1mWzFdJiYoZlsxXT1mWzFdLnRvU3RyaW5nKCkpLGZbMF0pdHJ5e2JbZGVjb2RlVVJJQ29tcG9uZW50KGZbMF0pXT1kZWNvZGVVUklDb21wb25lbnQoZlsxXSl9Y2F0Y2goZyl7YltmWzBdXT1mWzFdfX19fSxnZXQ6ZnVuY3Rpb24oKXt2YXIgYT1bXTtmb3IodmFyIGMgaW4gYilpZih2b2lkIDAhPT1iW2NdKWlmKFwiXCIhPT1iW2NdKXRyeXthLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGMpK1wiPVwiK2VuY29kZVVSSUNvbXBvbmVudChiW2NdKSl9Y2F0Y2goZCl7YS5wdXNoKGMrXCI9XCIrYltjXSl9ZWxzZSB0cnl7YS5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChjKSl9Y2F0Y2goZCl7YS5wdXNoKGMpfXJldHVybiBhLmxlbmd0aD9cIj9cIithLmpvaW4oXCImXCIpOlwiXCJ9LGVudW1lcmFibGU6ITB9KTt2YXIgYztPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyxcImhhc2hcIix7c2V0OmZ1bmN0aW9uKGEpe1wic3RyaW5nXCI9PXR5cGVvZiBhJiYoYSYmYS5pbmRleE9mKFwiI1wiKTwwJiYoYT1cIiNcIithKSxjPWF8fFwiXCIpfSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gY30sZW51bWVyYWJsZTohMH0pLHRoaXMuc2V0PWZ1bmN0aW9uKGEpe2E9YXx8XCJcIjt2YXIgYjtpZighKGI9YS5tYXRjaChuZXcgUmVnRXhwKFwiXihbYS16MC05LV0rOik/Wy9dezJ9KD86KFteQC86P10rKSg/OjooW15ALzpdKykpP0ApPyhbXjovPyNdKykoPzpbOl0oWzAtOV0rKSk/KFsvXVtePyM7XSopPyg/Ols/XShbXiNdKikpPyhbI11bXj9dKik/JFwiLFwiaVwiKSkpKXRocm93IG5ldyBFcnJvcihcIldyb25nIHVyaSBzY2hlbWUuXCIpO3RoaXMucHJvdG9jb2w9YlsxXXx8KFwib2JqZWN0XCI9PXR5cGVvZiBsb2NhdGlvbj9sb2NhdGlvbi5wcm90b2NvbDpcIlwiKSx0aGlzLnVzZXJuYW1lPWJbMl18fFwiXCIsdGhpcy5wYXNzd29yZD1iWzNdfHxcIlwiLHRoaXMuaG9zdG5hbWU9dGhpcy5ob3N0PWJbNF0sdGhpcy5wb3J0PWJbNV18fFwiXCIsdGhpcy5wYXRobmFtZT1iWzZdfHxcIi9cIix0aGlzLnNlYXJjaD1iWzddfHxcIlwiLHRoaXMuaGFzaD1iWzhdfHxcIlwiLHRoaXMub3JpZ2luPXRoaXMucHJvdG9jb2wrXCIvL1wiK3RoaXMuaG9zdG5hbWV9LHRoaXMudG9TdHJpbmc9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnByb3RvY29sK1wiLy9cIjtyZXR1cm4gdGhpcy51c2VybmFtZSYmKGErPXRoaXMudXNlcm5hbWUsdGhpcy5wYXNzd29yZCYmKGErPVwiOlwiK3RoaXMucGFzc3dvcmQpLGErPVwiQFwiKSxhKz10aGlzLmhvc3QsdGhpcy5wb3J0JiZcIjgwXCIhPT10aGlzLnBvcnQmJihhKz1cIjpcIit0aGlzLnBvcnQpLHRoaXMucGF0aG5hbWUmJihhKz10aGlzLnBhdGhuYW1lKSx0aGlzLnNlYXJjaCYmKGErPXRoaXMuc2VhcmNoKSx0aGlzLmhhc2gmJihhKz10aGlzLmhhc2gpLGF9LGEmJnRoaXMuc2V0KGEudG9TdHJpbmcoKSl9Yi5odHRwdXJsPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgYyhhKX19KHdpbmRvdyx3aW5kb3cubGlifHwod2luZG93LmxpYj17fSkpOzttb2R1bGUuZXhwb3J0cyA9IHdpbmRvdy5saWJbJ2h0dHB1cmwnXTsiLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcblx0cmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpLnJlcGxhY2UoL1shJygpKl0vZywgZnVuY3Rpb24gKGMpIHtcblx0XHRyZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHR9KTtcbn07XG4iLCIvKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cmljdFVyaUVuY29kZSA9IHJlcXVpcmUoJ3N0cmljdC11cmktZW5jb2RlJyk7XG52YXIgb2JqZWN0QXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG5mdW5jdGlvbiBlbmNvZGVyRm9yQXJyYXlGb3JtYXQob3B0cykge1xuXHRzd2l0Y2ggKG9wdHMuYXJyYXlGb3JtYXQpIHtcblx0XHRjYXNlICdpbmRleCc6XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGtleSwgdmFsdWUsIGluZGV4KSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IFtcblx0XHRcdFx0XHRlbmNvZGUoa2V5LCBvcHRzKSxcblx0XHRcdFx0XHQnWycsXG5cdFx0XHRcdFx0aW5kZXgsXG5cdFx0XHRcdFx0J10nXG5cdFx0XHRcdF0uam9pbignJykgOiBbXG5cdFx0XHRcdFx0ZW5jb2RlKGtleSwgb3B0cyksXG5cdFx0XHRcdFx0J1snLFxuXHRcdFx0XHRcdGVuY29kZShpbmRleCwgb3B0cyksXG5cdFx0XHRcdFx0J109Jyxcblx0XHRcdFx0XHRlbmNvZGUodmFsdWUsIG9wdHMpXG5cdFx0XHRcdF0uam9pbignJyk7XG5cdFx0XHR9O1xuXG5cdFx0Y2FzZSAnYnJhY2tldCc6XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSBudWxsID8gZW5jb2RlKGtleSwgb3B0cykgOiBbXG5cdFx0XHRcdFx0ZW5jb2RlKGtleSwgb3B0cyksXG5cdFx0XHRcdFx0J1tdPScsXG5cdFx0XHRcdFx0ZW5jb2RlKHZhbHVlLCBvcHRzKVxuXHRcdFx0XHRdLmpvaW4oJycpO1xuXHRcdFx0fTtcblxuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSBudWxsID8gZW5jb2RlKGtleSwgb3B0cykgOiBbXG5cdFx0XHRcdFx0ZW5jb2RlKGtleSwgb3B0cyksXG5cdFx0XHRcdFx0Jz0nLFxuXHRcdFx0XHRcdGVuY29kZSh2YWx1ZSwgb3B0cylcblx0XHRcdFx0XS5qb2luKCcnKTtcblx0XHRcdH07XG5cdH1cbn1cblxuZnVuY3Rpb24gcGFyc2VyRm9yQXJyYXlGb3JtYXQob3B0cykge1xuXHR2YXIgcmVzdWx0O1xuXG5cdHN3aXRjaCAob3B0cy5hcnJheUZvcm1hdCkge1xuXHRcdGNhc2UgJ2luZGV4Jzpcblx0XHRcdHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgYWNjdW11bGF0b3IpIHtcblx0XHRcdFx0cmVzdWx0ID0gL1xcWyhcXGQqKVxcXSQvLmV4ZWMoa2V5KTtcblxuXHRcdFx0XHRrZXkgPSBrZXkucmVwbGFjZSgvXFxbXFxkKlxcXSQvLCAnJyk7XG5cblx0XHRcdFx0aWYgKCFyZXN1bHQpIHtcblx0XHRcdFx0XHRhY2N1bXVsYXRvcltrZXldID0gdmFsdWU7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGFjY3VtdWxhdG9yW2tleV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGFjY3VtdWxhdG9yW2tleV0gPSB7fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFjY3VtdWxhdG9yW2tleV1bcmVzdWx0WzFdXSA9IHZhbHVlO1xuXHRcdFx0fTtcblxuXHRcdGNhc2UgJ2JyYWNrZXQnOlxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbHVlLCBhY2N1bXVsYXRvcikge1xuXHRcdFx0XHRyZXN1bHQgPSAvKFxcW1xcXSkkLy5leGVjKGtleSk7XG5cdFx0XHRcdGtleSA9IGtleS5yZXBsYWNlKC9cXFtcXF0kLywgJycpO1xuXG5cdFx0XHRcdGlmICghcmVzdWx0KSB7XG5cdFx0XHRcdFx0YWNjdW11bGF0b3Jba2V5XSA9IHZhbHVlO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fSBlbHNlIGlmIChhY2N1bXVsYXRvcltrZXldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRhY2N1bXVsYXRvcltrZXldID0gW3ZhbHVlXTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhY2N1bXVsYXRvcltrZXldID0gW10uY29uY2F0KGFjY3VtdWxhdG9yW2tleV0sIHZhbHVlKTtcblx0XHRcdH07XG5cblx0XHRkZWZhdWx0OlxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbHVlLCBhY2N1bXVsYXRvcikge1xuXHRcdFx0XHRpZiAoYWNjdW11bGF0b3Jba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0YWNjdW11bGF0b3Jba2V5XSA9IHZhbHVlO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFjY3VtdWxhdG9yW2tleV0gPSBbXS5jb25jYXQoYWNjdW11bGF0b3Jba2V5XSwgdmFsdWUpO1xuXHRcdFx0fTtcblx0fVxufVxuXG5mdW5jdGlvbiBlbmNvZGUodmFsdWUsIG9wdHMpIHtcblx0aWYgKG9wdHMuZW5jb2RlKSB7XG5cdFx0cmV0dXJuIG9wdHMuc3RyaWN0ID8gc3RyaWN0VXJpRW5jb2RlKHZhbHVlKSA6IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG5cdH1cblxuXHRyZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGtleXNTb3J0ZXIoaW5wdXQpIHtcblx0aWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG5cdFx0cmV0dXJuIGlucHV0LnNvcnQoKTtcblx0fSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnKSB7XG5cdFx0cmV0dXJuIGtleXNTb3J0ZXIoT2JqZWN0LmtleXMoaW5wdXQpKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRyZXR1cm4gTnVtYmVyKGEpIC0gTnVtYmVyKGIpO1xuXHRcdH0pLm1hcChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRyZXR1cm4gaW5wdXRba2V5XTtcblx0XHR9KTtcblx0fVxuXG5cdHJldHVybiBpbnB1dDtcbn1cblxuZXhwb3J0cy5leHRyYWN0ID0gZnVuY3Rpb24gKHN0cikge1xuXHRyZXR1cm4gc3RyLnNwbGl0KCc/JylbMV0gfHwgJyc7XG59O1xuXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHN0ciwgb3B0cykge1xuXHRvcHRzID0gb2JqZWN0QXNzaWduKHthcnJheUZvcm1hdDogJ25vbmUnfSwgb3B0cyk7XG5cblx0dmFyIGZvcm1hdHRlciA9IHBhcnNlckZvckFycmF5Rm9ybWF0KG9wdHMpO1xuXG5cdC8vIENyZWF0ZSBhbiBvYmplY3Qgd2l0aCBubyBwcm90b3R5cGVcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9xdWVyeS1zdHJpbmcvaXNzdWVzLzQ3XG5cdHZhciByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5cdGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuXHRcdHJldHVybiByZXQ7XG5cdH1cblxuXHRzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoL14oXFw/fCN8JikvLCAnJyk7XG5cblx0aWYgKCFzdHIpIHtcblx0XHRyZXR1cm4gcmV0O1xuXHR9XG5cblx0c3RyLnNwbGl0KCcmJykuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcblx0XHR2YXIgcGFydHMgPSBwYXJhbS5yZXBsYWNlKC9cXCsvZywgJyAnKS5zcGxpdCgnPScpO1xuXHRcdC8vIEZpcmVmb3ggKHByZSA0MCkgZGVjb2RlcyBgJTNEYCB0byBgPWBcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3F1ZXJ5LXN0cmluZy9wdWxsLzM3XG5cdFx0dmFyIGtleSA9IHBhcnRzLnNoaWZ0KCk7XG5cdFx0dmFyIHZhbCA9IHBhcnRzLmxlbmd0aCA+IDAgPyBwYXJ0cy5qb2luKCc9JykgOiB1bmRlZmluZWQ7XG5cblx0XHQvLyBtaXNzaW5nIGA9YCBzaG91bGQgYmUgYG51bGxgOlxuXHRcdC8vIGh0dHA6Ly93My5vcmcvVFIvMjAxMi9XRC11cmwtMjAxMjA1MjQvI2NvbGxlY3QtdXJsLXBhcmFtZXRlcnNcblx0XHR2YWwgPSB2YWwgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZWNvZGVVUklDb21wb25lbnQodmFsKTtcblxuXHRcdGZvcm1hdHRlcihkZWNvZGVVUklDb21wb25lbnQoa2V5KSwgdmFsLCByZXQpO1xuXHR9KTtcblxuXHRyZXR1cm4gT2JqZWN0LmtleXMocmV0KS5zb3J0KCkucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGtleSkge1xuXHRcdHZhciB2YWwgPSByZXRba2V5XTtcblx0XHRpZiAoQm9vbGVhbih2YWwpICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHZhbCkpIHtcblx0XHRcdC8vIFNvcnQgb2JqZWN0IGtleXMsIG5vdCB2YWx1ZXNcblx0XHRcdHJlc3VsdFtrZXldID0ga2V5c1NvcnRlcih2YWwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXN1bHRba2V5XSA9IHZhbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LCBPYmplY3QuY3JlYXRlKG51bGwpKTtcbn07XG5cbmV4cG9ydHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKG9iaiwgb3B0cykge1xuXHR2YXIgZGVmYXVsdHMgPSB7XG5cdFx0ZW5jb2RlOiB0cnVlLFxuXHRcdHN0cmljdDogdHJ1ZSxcblx0XHRhcnJheUZvcm1hdDogJ25vbmUnXG5cdH07XG5cblx0b3B0cyA9IG9iamVjdEFzc2lnbihkZWZhdWx0cywgb3B0cyk7XG5cblx0dmFyIGZvcm1hdHRlciA9IGVuY29kZXJGb3JBcnJheUZvcm1hdChvcHRzKTtcblxuXHRyZXR1cm4gb2JqID8gT2JqZWN0LmtleXMob2JqKS5zb3J0KCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcblx0XHR2YXIgdmFsID0gb2JqW2tleV07XG5cblx0XHRpZiAodmFsID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiAnJztcblx0XHR9XG5cblx0XHRpZiAodmFsID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gZW5jb2RlKGtleSwgb3B0cyk7XG5cdFx0fVxuXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuXHRcdFx0dmFyIHJlc3VsdCA9IFtdO1xuXG5cdFx0XHR2YWwuc2xpY2UoKS5mb3JFYWNoKGZ1bmN0aW9uICh2YWwyKSB7XG5cdFx0XHRcdGlmICh2YWwyID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQucHVzaChmb3JtYXR0ZXIoa2V5LCB2YWwyLCByZXN1bHQubGVuZ3RoKSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIHJlc3VsdC5qb2luKCcmJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVuY29kZShrZXksIG9wdHMpICsgJz0nICsgZW5jb2RlKHZhbCwgb3B0cyk7XG5cdH0pLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuXHRcdHJldHVybiB4Lmxlbmd0aCA+IDA7XG5cdH0pLmpvaW4oJyYnKSA6ICcnO1xufTtcbiIsIi8qXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyogZ2xvYmFsIGxpYiwgWE1MSHR0cFJlcXVlc3QgKi9cbi8qIGRlcHM6IGh0dHB1cmwgKi9cblxuJ3VzZSBzdHJpY3QnXG5cbmxldCB1dGlsc1xuXG5pbXBvcnQgJ2h0dHB1cmwnXG5pbXBvcnQgcXMgZnJvbSAncXVlcnktc3RyaW5nJ1xuXG5sZXQganNvbnBDbnQgPSAwXG5jb25zdCBFUlJPUl9TVEFURSA9IC0xXG5cbmZ1bmN0aW9uIF9qc29ucCAoY29uZmlnLCBjYWxsYmFjaywgcHJvZ3Jlc3NDYWxsYmFjaykge1xuICBjb25zdCBjYk5hbWUgPSBjb25maWcuanNvbnBDYWxsYmFja05hbWUgfHwgJ2pzb25wXycgKyAoKytqc29ucENudClcbiAgbGV0IHVybFxuXG4gIGlmICghY29uZmlnLnVybCkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1toNS1yZW5kZXJdIGNvbmZpZy51cmwgc2hvdWxkIGJlIHNldCBpbiBfanNvbnAgZm9yIFxcJ2ZldGNoXFwnIEFQSS4nKVxuICB9XG5cbiAgZ2xvYmFsW2NiTmFtZV0gPSAoZnVuY3Rpb24gKGNiKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgY2FsbGJhY2soe1xuICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgb2s6IHRydWUsXG4gICAgICAgIHN0YXR1c1RleHQ6ICdPSycsXG4gICAgICAgIGRhdGE6IHJlc3BvbnNlXG4gICAgICB9KVxuICAgICAgZGVsZXRlIGdsb2JhbFtjYl1cbiAgICB9XG4gIH0pKGNiTmFtZSlcblxuICBjb25zdCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKVxuICB0cnkge1xuICAgIHVybCA9IGxpYi5odHRwdXJsKGNvbmZpZy51cmwpXG4gIH1cbiAgY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1toNS1yZW5kZXJdIGludmFsaWQgY29uZmlnLnVybCBpbiBfanNvbnAgZm9yIFxcJ2ZldGNoXFwnIEFQSTogJ1xuICAgICAgKyBjb25maWcudXJsKVxuICB9XG4gIHVybC5wYXJhbXMuY2FsbGJhY2sgPSBjYk5hbWVcbiAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0J1xuICBzY3JpcHQuc3JjID0gdXJsLnRvU3RyaW5nKClcbiAgLy8gc2NyaXB0Lm9uZXJyb3IgaXMgbm90IHdvcmtpbmcgb24gSUUgb3Igc2FmYXJpLlxuICAvLyBidXQgdGhleSBhcmUgbm90IGNvbnNpZGVyZWQgaGVyZS5cbiAgc2NyaXB0Lm9uZXJyb3IgPSAoZnVuY3Rpb24gKGNiKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1toNS1yZW5kZXJdIHVuZXhwZWN0ZWQgZXJyb3IgaW4gX2pzb25wIGZvciBcXCdmZXRjaFxcJyBBUEknLCBlcnIpXG4gICAgICBjYWxsYmFjayh7XG4gICAgICAgIHN0YXR1czogRVJST1JfU1RBVEUsXG4gICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgc3RhdHVzVGV4dDogJycsXG4gICAgICAgIGRhdGE6ICcnXG4gICAgICB9KVxuICAgICAgZGVsZXRlIGdsb2JhbFtjYl1cbiAgICB9XG4gIH0pKGNiTmFtZSlcbiAgY29uc3QgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF1cbiAgaGVhZC5pbnNlcnRCZWZvcmUoc2NyaXB0LCBudWxsKVxufVxuXG5mdW5jdGlvbiBfeGhyIChjb25maWcsIGNhbGxiYWNrLCBwcm9ncmVzc0NhbGxiYWNrKSB7XG4gIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpXG4gIHhoci5yZXNwb25zZVR5cGUgPSBjb25maWcudHlwZVxuICB4aHIub3Blbihjb25maWcubWV0aG9kLCBjb25maWcudXJsLCB0cnVlKVxuXG4gIC8vIGNvcnMgY29va2llIHN1cHBvcnRcbiAgaWYgKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMgPT09IHRydWUpIHtcbiAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZVxuICB9XG5cbiAgY29uc3QgaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9XG4gIGZvciAoY29uc3QgayBpbiBoZWFkZXJzKSB7XG4gICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoaywgaGVhZGVyc1trXSlcbiAgfVxuXG4gIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAocmVzKSB7XG4gICAgY2FsbGJhY2soe1xuICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzLFxuICAgICAgb2s6IHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDAsXG4gICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCxcbiAgICAgIGRhdGE6IHhoci5yZXNwb25zZSxcbiAgICAgIGhlYWRlcnM6IHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKS5zcGxpdCgnXFxuJylcbiAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAob2JqLCBoZWFkZXJTdHIpIHtcbiAgICAgICAgICBjb25zdCBoZWFkZXJBcnIgPSBoZWFkZXJTdHIubWF0Y2goLyguKyk6ICguKykvKVxuICAgICAgICAgIGlmIChoZWFkZXJBcnIpIHtcbiAgICAgICAgICAgIG9ialtoZWFkZXJBcnJbMV1dID0gaGVhZGVyQXJyWzJdXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvYmpcbiAgICAgICAgfSwge30pXG4gICAgfSlcbiAgfVxuXG4gIGlmIChwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgeGhyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgcHJvZ3Jlc3NDYWxsYmFjayh7XG4gICAgICAgIHJlYWR5U3RhdGU6IHhoci5yZWFkeVN0YXRlLFxuICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXMsXG4gICAgICAgIGxlbmd0aDogZS5sb2FkZWQsXG4gICAgICAgIHRvdGFsOiBlLnRvdGFsLFxuICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpLnNwbGl0KCdcXG4nKVxuICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwgaGVhZGVyU3RyKSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJBcnIgPSBoZWFkZXJTdHIubWF0Y2goLyguKyk6ICguKykvKVxuICAgICAgICAgICAgaWYgKGhlYWRlckFycikge1xuICAgICAgICAgICAgICBvYmpbaGVhZGVyQXJyWzFdXSA9IGhlYWRlckFyclsyXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9ialxuICAgICAgICAgIH0sIHt9KVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICB4aHIub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbaDUtcmVuZGVyXSB1bmV4cGVjdGVkIGVycm9yIGluIF94aHIgZm9yIFxcJ2ZldGNoXFwnIEFQSScsIGVycilcbiAgICBjYWxsYmFjayh7XG4gICAgICBzdGF0dXM6IEVSUk9SX1NUQVRFLFxuICAgICAgb2s6IGZhbHNlLFxuICAgICAgc3RhdHVzVGV4dDogJycsXG4gICAgICBkYXRhOiAnJ1xuICAgIH0pXG4gIH1cblxuICB4aHIuc2VuZChjb25maWcuYm9keSB8fCBudWxsKVxufVxuXG5jb25zdCBzdHJlYW0gPSB7XG5cbiAgLyoqXG4gICAqIHNlbmRIdHRwXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIE5vdGU6IFRoaXMgQVBJIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2Ugc3RyZWFtLmZldGNoIGluc3RlYWQuXG4gICAqIHNlbmQgYSBodHRwIHJlcXVlc3QgdGhyb3VnaCBYSFIuXG4gICAqIEBwYXJhbSAge29ian0gcGFyYW1zXG4gICAqICAtIG1ldGhvZDogJ0dFVCcgfCAnUE9TVCcgfCAnUFVUJyB8ICdERUxFVEUnIHwgJ0hFQUQnIHwgJ1BBVENIJyxcbiAgICogIC0gdXJsOiB1cmwgcmVxdWVzdGVkXG4gICAqIEBwYXJhbSAge3N0cmluZ30gY2FsbGJhY2tJZFxuICAgKi9cbiAgc2VuZEh0dHA6IGZ1bmN0aW9uIChwYXJhbSwgY2FsbGJhY2tJZCkge1xuICAgIGlmICh0eXBlb2YgcGFyYW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwYXJhbSA9IEpTT04ucGFyc2UocGFyYW0pXG4gICAgICB9XG4gICAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYXJhbSAhPT0gJ29iamVjdCcgfHwgIXBhcmFtLnVybCkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICdbaDUtcmVuZGVyXSBpbnZhbGlkIGNvbmZpZyBvciBpbnZhbGlkIGNvbmZpZy51cmwgZm9yIHNlbmRIdHRwIEFQSScpXG4gICAgfVxuXG4gICAgY29uc3Qgc2VuZGVyID0gdGhpcy5zZW5kZXJcbiAgICBjb25zdCBtZXRob2QgPSBwYXJhbS5tZXRob2QgfHwgJ0dFVCdcbiAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuICAgIHhoci5vcGVuKG1ldGhvZCwgcGFyYW0udXJsLCB0cnVlKVxuICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZW5kZXIucGVyZm9ybUNhbGxiYWNrKGNhbGxiYWNrSWQsIHRoaXMucmVzcG9uc2VUZXh0KVxuICAgIH1cbiAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoJ1toNS1yZW5kZXJdIHVuZXhwZWN0ZWQgZXJyb3IgaW4gc2VuZEh0dHAgQVBJJywgZXJyb3IpXG4gICAgICAvLyBzZW5kZXIucGVyZm9ybUNhbGxiYWNrKFxuICAgICAgLy8gICBjYWxsYmFja0lkLFxuICAgICAgLy8gICBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgZXJyb3IgaW4gc2VuZEh0dHAgQVBJJylcbiAgICAgIC8vIClcbiAgICB9XG4gICAgeGhyLnNlbmQoKVxuICB9LFxuXG4gIC8qKlxuICAgKiBmZXRjaFxuICAgKiB1c2Ugc3RyZWFtLmZldGNoIHRvIHJlcXVlc3QgZm9yIGEganNvbiBmaWxlLCBhIHBsYWluIHRleHQgZmlsZSBvclxuICAgKiBhIGFycmF5YnVmZmVyIGZvciBhIGZpbGUgc3RyZWFtLiAoWW91IGNhbiB1c2UgQmxvYiBhbmQgRmlsZVJlYWRlclxuICAgKiBBUEkgaW1wbGVtZW50ZWQgYnkgbW9zdCBtb2Rlcm4gYnJvd3NlcnMgdG8gcmVhZCBhIGFycmF5YnVmZmVyLilcbiAgICogQHBhcmFtICB7b2JqZWN0fSBvcHRpb25zIGNvbmZpZyBvcHRpb25zXG4gICAqICAgLSBtZXRob2Q6ICdHRVQnIHwgJ1BPU1QnIHwgJ1BVVCcgfCAnREVMRVRFJyB8ICdIRUFEJyB8ICdQQVRDSCdcbiAgICogICAtIGhlYWRlcnMge29ian1cbiAgICogICAtIHVybCB7c3RyaW5nfVxuICAgKiAgIC0gbW9kZSB7c3RyaW5nfSAnY29ycycgfCAnbm8tY29ycycgfCAnc2FtZS1vcmlnaW4nIHwgJ25hdmlnYXRlJ1xuICAgKiAgIC0gd2l0aENyZWRlbnRpYWxzIHtib29sZWFufVxuICAgKiAgIC0gYm9keVxuICAgKiAgIC0gdHlwZSB7c3RyaW5nfSAnanNvbicgfCAnanNvbnAnIHwgJ3RleHQnXG4gICAqIEBwYXJhbSAge3N0cmluZ30gY2FsbGJhY2tJZFxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHByb2dyZXNzQ2FsbGJhY2tJZFxuICAgKi9cbiAgZmV0Y2g6IGZ1bmN0aW9uIChvcHRpb25zLCBjYWxsYmFja0lkLCBwcm9ncmVzc0NhbGxiYWNrSWQpIHtcbiAgICBjb25zdCBERUZBVUxUX01FVEhPRCA9ICdHRVQnXG4gICAgY29uc3QgREVGQVVMVF9NT0RFID0gJ2NvcnMnXG4gICAgY29uc3QgREVGQVVMVF9UWVBFID0gJ3RleHQnXG5cbiAgICBjb25zdCBtZXRob2RPcHRpb25zID0gWydHRVQnLCAnUE9TVCcsICdQVVQnLCAnREVMRVRFJywgJ0hFQUQnLCAnUEFUQ0gnXVxuICAgIGNvbnN0IG1vZGVPcHRpb25zID0gWydjb3JzJywgJ25vLWNvcnMnLCAnc2FtZS1vcmlnaW4nLCAnbmF2aWdhdGUnXVxuICAgIGNvbnN0IHR5cGVPcHRpb25zID0gWyd0ZXh0JywgJ2pzb24nLCAnanNvbnAnLCAnYXJyYXlidWZmZXInXVxuXG4gICAgLy8gY29uc3QgZmFsbGJhY2sgPSBmYWxzZSAgLy8gZmFsbGJhY2sgZnJvbSAnZmV0Y2gnIEFQSSB0byBYSFIuXG4gICAgY29uc3Qgc2VuZGVyID0gdGhpcy5zZW5kZXJcblxuICAgIGNvbnN0IGNvbmZpZyA9IHV0aWxzLmV4dGVuZCh7fSwgb3B0aW9ucylcblxuICAgIC8vIHZhbGlkYXRlIG9wdGlvbnMubWV0aG9kXG4gICAgaWYgKHR5cGVvZiBjb25maWcubWV0aG9kID09PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uZmlnLm1ldGhvZCA9IERFRkFVTFRfTUVUSE9EXG4gICAgICBjb25zb2xlLndhcm4oJ1toNS1yZW5kZXJdIG9wdGlvbnMubWV0aG9kIGZvciBcXCdmZXRjaFxcJyBBUEkgaGFzIGJlZW4gc2V0IHRvICdcbiAgICAgICAgKyAnZGVmYXVsdCB2YWx1ZSBcXCcnICsgY29uZmlnLm1ldGhvZCArICdcXCcnKVxuICAgIH1cbiAgICBlbHNlIGlmIChtZXRob2RPcHRpb25zLmluZGV4T2YoKGNvbmZpZy5tZXRob2QgKyAnJylcbiAgICAgIC50b1VwcGVyQ2FzZSgpKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKCdbaDUtcmVuZGVyXSBvcHRpb25zLm1ldGhvZCBcXCcnXG4gICAgICAgICsgY29uZmlnLm1ldGhvZFxuICAgICAgICArICdcXCcgZm9yIFxcJ2ZldGNoXFwnIEFQSSBzaG91bGQgYmUgb25lIG9mICdcbiAgICAgICAgKyBtZXRob2RPcHRpb25zICsgJy4nKVxuICAgIH1cblxuICAgIC8vIHZhbGlkYXRlIG9wdGlvbnMudXJsXG4gICAgaWYgKCFjb25maWcudXJsKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcignW2g1LXJlbmRlcl0gb3B0aW9ucy51cmwgc2hvdWxkIGJlIHNldCBmb3IgXFwnZmV0Y2hcXCcgQVBJLicpXG4gICAgfVxuXG4gICAgLy8gdmFsaWRhdGUgYm9keSBjb250ZW50IGZvciBtZXRob2QgJ0dFVCcuXG4gICAgaWYgKGNvbmZpZy5tZXRob2QudG9VcHBlckNhc2UoKSA9PT0gJ0dFVCcpIHtcbiAgICAgIGxldCBib2R5ID0gY29uZmlnLmJvZHlcbiAgICAgIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KGJvZHkpKSB7XG4gICAgICAgIGJvZHkgPSBxcy5zdHJpbmdpZnkoYm9keSlcbiAgICAgIH1cbiAgICAgIGxldCB1cmwgPSBjb25maWcudXJsXG4gICAgICBsZXQgaGFzaElkeCA9IHVybC5pbmRleE9mKCcjJylcbiAgICAgIGhhc2hJZHggPD0gLTEgJiYgKGhhc2hJZHggPSB1cmwubGVuZ3RoKVxuICAgICAgbGV0IGhhc2ggPSB1cmwuc3Vic3RyKGhhc2hJZHgpXG4gICAgICBpZiAoaGFzaCAmJiBoYXNoWzBdID09PSAnIycpIHtcbiAgICAgICAgaGFzaCA9IGhhc2guc3Vic3RyKDEpXG4gICAgICB9XG4gICAgICB1cmwgPSB1cmwuc3Vic3RyaW5nKDAsIGhhc2hJZHgpXG4gICAgICBpZiAoYm9keSkge1xuICAgICAgICB1cmwgKz0gKGNvbmZpZy51cmwuaW5kZXhPZignPycpIDw9IC0xID8gJz8nIDogJyYnKSArIGJvZHlcbiAgICAgIH1cbiAgICAgIHVybCArPSAnIycgKyBoYXNoXG4gICAgICBjb25maWcudXJsID0gdXJsXG4gICAgfVxuXG4gICAgLy8gdmFsaWRhdGUgb3B0aW9ucy5tb2RlXG4gICAgaWYgKHR5cGVvZiBjb25maWcubW9kZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbmZpZy5tb2RlID0gREVGQVVMVF9NT0RFXG4gICAgfVxuICAgIGVsc2UgaWYgKG1vZGVPcHRpb25zLmluZGV4T2YoKGNvbmZpZy5tb2RlICsgJycpLnRvTG93ZXJDYXNlKCkpID09PSAtMSkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoJ1toNS1yZW5kZXJdIG9wdGlvbnMubW9kZSBcXCcnXG4gICAgICAgICsgY29uZmlnLm1vZGVcbiAgICAgICAgKyAnXFwnIGZvciBcXCdmZXRjaFxcJyBBUEkgc2hvdWxkIGJlIG9uZSBvZiAnXG4gICAgICAgICsgbW9kZU9wdGlvbnMgKyAnLicpXG4gICAgfVxuXG4gICAgLy8gdmFsaWRhdGUgb3B0aW9ucy50eXBlXG4gICAgaWYgKHR5cGVvZiBjb25maWcudHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbmZpZy50eXBlID0gREVGQVVMVF9UWVBFXG4gICAgICBjb25zb2xlLndhcm4oJ1toNS1yZW5kZXJdIG9wdGlvbnMudHlwZSBmb3IgXFwnZmV0Y2hcXCcgQVBJIGhhcyBiZWVuIHNldCB0byAnXG4gICAgICAgICsgJ2RlZmF1bHQgdmFsdWUgXFwnJyArIGNvbmZpZy50eXBlICsgJ1xcJy4nKVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlT3B0aW9ucy5pbmRleE9mKChjb25maWcudHlwZSArICcnKS50b0xvd2VyQ2FzZSgpKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKCdbaDUtcmVuZGVyXSBvcHRpb25zLnR5cGUgXFwnJ1xuICAgICAgICAgICsgY29uZmlnLnR5cGVcbiAgICAgICAgICArICdcXCcgZm9yIFxcJ2ZldGNoXFwnIEFQSSBzaG91bGQgYmUgb25lIG9mICdcbiAgICAgICAgICArIHR5cGVPcHRpb25zICsgJy4nKVxuICAgIH1cblxuICAgIC8vIHZhbGlkYXRlIG9wdGlvbnMuaGVhZGVyc1xuICAgIGNvbmZpZy5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgfHwge31cbiAgICBpZiAoIXV0aWxzLmlzUGxhaW5PYmplY3QoY29uZmlnLmhlYWRlcnMpKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcignW2g1LXJlbmRlcl0gb3B0aW9ucy5oZWFkZXJzIHNob3VsZCBiZSBhIHBsYWluIG9iamVjdCcpXG4gICAgfVxuXG4gICAgLy8gdmFsaWRhdGUgb3B0aW9ucy50aW1lb3V0XG4gICAgY29uZmlnLnRpbWVvdXQgPSBwYXJzZUludChjb25maWcudGltZW91dCwgMTApIHx8IDI1MDBcblxuICAgIGNvbnN0IF9jYWxsQXJncyA9IFtjb25maWcsIGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIHNlbmRlci5wZXJmb3JtQ2FsbGJhY2soY2FsbGJhY2tJZCwgcmVzKVxuICAgIH1dXG4gICAgaWYgKHByb2dyZXNzQ2FsbGJhY2tJZCkge1xuICAgICAgX2NhbGxBcmdzLnB1c2goZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAvLyBTZXQgJ2tlZXBBbGl2ZScgdG8gdHJ1ZSBmb3Igc2VuZGluZyBjb250aW51b3VzIGNhbGxiYWNrc1xuICAgICAgICBzZW5kZXIucGVyZm9ybUNhbGxiYWNrKHByb2dyZXNzQ2FsbGJhY2tJZCwgcmVzLCB0cnVlKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLnR5cGUgPT09ICdqc29ucCcpIHtcbiAgICAgIF9qc29ucC5hcHBseSh0aGlzLCBfY2FsbEFyZ3MpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgX3hoci5hcHBseSh0aGlzLCBfY2FsbEFyZ3MpXG4gICAgfVxuICB9XG5cbn1cblxuY29uc3QgbWV0YSA9IHtcbiAgc3RyZWFtOiBbe1xuICAgIG5hbWU6ICdzZW5kSHR0cCcsXG4gICAgYXJnczogWydvYmplY3QnLCAnZnVuY3Rpb24nXVxuICB9LCB7XG4gICAgbmFtZTogJ2ZldGNoJyxcbiAgICBhcmdzOiBbJ29iamVjdCcsICdmdW5jdGlvbicsICdmdW5jdGlvbiddXG4gIH1dXG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdDogZnVuY3Rpb24gKFdlZXgpIHtcbiAgICB1dGlscyA9IFdlZXgudXRpbHNcbiAgICBXZWV4LnJlZ2lzdGVyQXBpTW9kdWxlKCdzdHJlYW0nLCBzdHJlYW0sIG1ldGEpXG4gIH1cbn1cbiIsIi8qXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuXG5BVUNUSU9OOlxudGFza1F1ZXVlXG5DbGlwYm9hcmQuc2V0U3RyaW5nKCkgIE5PVyBub3Qgd29ya3MsIGZhY2luZyB0byB1c2VyLWFjdCBsb3NlIG9mIHRhc2tRdWV1ZS5cblxud29ya3MgaW4gQ2hyb21lIEZpcmVmb3ggT3BlcmEuIGJ1dCBub3QgaW4gU2FmYXJpLlxuQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRG9jdW1lbnQvZXhlY0NvbW1hbmQjQnJvd3Nlcl9jb21wYXRpYmlsaXR5XG5cbkNsaXBib2FyZC5nZXRTdHJpbmcoKSB1bmltcGxlbWVudGVkLiBUaGVyZSBpcyBubyBlYXN5IHdheSB0byBkbyBwYXN0ZSBmcm9tIGNsaXBib2FyZCB0byBqcyB2YXJpYWJsZS5cblxuU28gbG9vayBvdXQgeW91ciBhcHAgYmVoYXZpb3IsIHdoZW4gZG93bmdyYWRlIHRvIGh0bWw1IHJlbmRlci5cbkFueSBpZGVhIGlzIHdlbGNvbWUuXG4qKi9cblxuY29uc3QgV0VFWF9DTElQQk9BUkRfSUQgPSAnX193ZWV4X2NsaXBib2FyZF9pZF9fJ1xuXG5jb25zdCBjbGlwYm9hcmQgPSB7XG5cbiAgZ2V0U3RyaW5nOiBmdW5jdGlvbiAoY2FsbGJhY2tJZCkge1xuICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gaHRtbDVcbiAgICBjb25zb2xlLmxvZygnY2xpcGJvYXJkLmdldFN0cmluZygpIGlzIG5vdCBzdXBwb3J0ZWQgbm93LicpXG4gIH0sXG5cbiAgc2V0U3RyaW5nOiBmdW5jdGlvbiAodGV4dCkge1xuICAgIC8vIG5vdCBzdXBwb3J0IHNhZmFyaVxuICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gJ3N0cmluZycgJiYgdGV4dCAhPT0gJycgJiYgZG9jdW1lbnQuZXhlY0NvbW1hbmQpIHtcbiAgICAgIGNvbnN0IHRlbXBJbnB1dCA9IGVsZW1lbnQoKVxuICAgICAgdGVtcElucHV0LnZhbHVlID0gdGV4dFxuXG4gICAgICB0ZW1wSW5wdXQuc2VsZWN0KClcbiAgICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKCdjb3B5JylcbiAgICAgIC8vIHZhciBvdXQgPSBkb2N1bWVudC5leGVjQ29tbWFuZCgnY29weScpO1xuICAgICAgLy8gY29uc29sZS5sb2coXCJleGVjQ29tbWFuZCBvdXQgaXMgXCIgKyBvdXQpO1xuICAgICAgdGVtcElucHV0LnZhbHVlID0gJydcbiAgICAgIHRlbXBJbnB1dC5ibHVyKClcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZygnb25seSBzdXBwb3J0IHN0cmluZyBpbnB1dCBub3cnKVxuICAgIH1cbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGVsZW1lbnQgKCkge1xuICBsZXQgdGVtcElucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoV0VFWF9DTElQQk9BUkRfSUQpXG4gIGlmICghdGVtcElucHV0KSB7XG4gICAgdGVtcElucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKVxuICAgIHRlbXBJbnB1dC5zZXRBdHRyaWJ1dGUoJ2lkJywgV0VFWF9DTElQQk9BUkRfSUQpXG4gICAgdGVtcElucHV0LnN0eWxlLmNzc1RleHQgPSAnaGVpZ2h0OjFweDt3aWR0aDoxcHg7Ym9yZGVyOm5vbmU7J1xuICAgIC8vIHRlbXBJbnB1dC5zdHlsZS5jc3NUZXh0ID0gXCJoZWlnaHQ6NDBweDt3aWR0aDozMDBweDtib3JkZXI6c29saWQ7XCJcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRlbXBJbnB1dClcbiAgfVxuICByZXR1cm4gdGVtcElucHV0XG59XG5cbmNvbnN0IG1ldGEgPSB7XG4gIGNsaXBib2FyZDogW3tcbiAgICBuYW1lOiAnZ2V0U3RyaW5nJyxcbiAgICBhcmdzOiBbJ2Z1bmN0aW9uJ11cbiAgfSwge1xuICAgIG5hbWU6ICdzZXRTdHJpbmcnLFxuICAgIGFyZ3M6IFsnc3RyaW5nJ11cbiAgfV1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0OiBmdW5jdGlvbiAoV2VleCkge1xuICAgIFdlZXgucmVnaXN0ZXJBcGlNb2R1bGUoJ2NsaXBib2FyZCcsIGNsaXBib2FyZCwgbWV0YSlcbiAgfVxufVxuIiwiLypcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCdcblxuY29uc3QgZXZlbnQgPSB7XG4gIC8qKlxuICAgKiBvcGVuVXJsXG4gICAqIEBwYXJhbSAge3N0cmluZ30gdXJsXG4gICAqL1xuICBvcGVuVVJMOiBmdW5jdGlvbiAodXJsKSB7XG4gICAgbG9jYXRpb24uaHJlZiA9IHVybFxuICB9XG5cbn1cblxuY29uc3QgbWV0YSA9IHtcbiAgZXZlbnQ6IFt7XG4gICAgbmFtZTogJ29wZW5VUkwnLFxuICAgIGFyZ3M6IFsnc3RyaW5nJ11cbiAgfV1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0OiBmdW5jdGlvbiAoV2VleCkge1xuICAgIFdlZXgucmVnaXN0ZXJBcGlNb2R1bGUoJ2V2ZW50JywgZXZlbnQsIG1ldGEpXG4gIH1cbn1cbiIsIi8qXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgdXRpbHMgPSB7fVxubGV0IGVuZEV2ZW50XG5sZXQgc3R5bGVOYW1lXG5cbmNvbnN0IERFU0lHTl9ST09UX1ZBTFVFID0gNzVcblxuY29uc3QgRVZFTlRfTkFNRV9NQVAgPSB7XG4gIHRyYW5zaXRpb246ICd0cmFuc2l0aW9uZW5kJyxcbiAgV2Via2l0VHJhbnNpdGlvbjogJ3dlYmtpdFRyYW5zaXRpb25FbmQnLFxuICBNb3pUcmFuc2l0aW9uOiAnbW96VHJhbnNpdGlvbkVuZCcsXG4gIE9UcmFuc2l0aW9uOiAnb1RyYW5zaXRpb25FbmQnLFxuICBtc1RyYW5zaXRpb246ICdNU1RyYW5zaXRpb25FbmQnXG59XG5cbmZ1bmN0aW9uIGRldGVjdEV2ZW50cyAoKSB7XG4gIGNvbnN0IHRlc3RFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIGNvbnN0IHN0eWxlID0gdGVzdEVsLnN0eWxlXG4gIGZvciAoY29uc3QgbmFtZSBpbiBFVkVOVF9OQU1FX01BUCkge1xuICAgIGlmIChuYW1lIGluIHN0eWxlKSB7XG4gICAgICBlbmRFdmVudCA9IEVWRU5UX05BTUVfTUFQW25hbWVdXG4gICAgICBzdHlsZU5hbWUgPSBuYW1lXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG5kZXRlY3RFdmVudHMoKVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uT25jZSAodm5vZGUsIGNvbmZpZywgY2FsbGJhY2spIHtcbiAgY29uc3Qge1xuICAgIG5leHRGcmFtZSxcbiAgICB0b0NTU1RleHQsXG4gICAgc3R5bGVPYmplY3QycmVtLFxuICAgIC8vIG5vcm1hbGl6ZVN0eWxlLFxuICAgIGlzQXJyYXlcbiAgfSA9IHV0aWxzXG5cbiAgaWYgKGlzQXJyYXkodm5vZGUpKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1t2dWUtcmVuZGVyXSB0aGUgcmVmIHBhc3NlZCB0byBhbmltYXRpb24udHJhbnNpdGlvbk9uY2UgaXMgYSBhcnJheS4nKVxuICAgIH1cbiAgICB2bm9kZSA9IHZub2RlWzBdXG4gIH1cblxuICBjb25zdCBkdXJhdGlvbiA9IGNvbmZpZy5kdXJhdGlvbiB8fCAwIC8vIG1zXG4gIGNvbnN0IHRpbWluZyA9IGNvbmZpZy50aW1pbmdGdW5jdGlvbiB8fCAnbGluZWFyJ1xuICBjb25zdCBkZWxheSA9IGNvbmZpZy5kZWxheSB8fCAwICAvLyBtc1xuXG4gIC8vIFRPRE86IHBhcnNlIHRyYW5zaXRpb24gcHJvcGVydGllc1xuICBjb25zdCB0cmFuc2l0aW9uVmFsdWUgPSBgYWxsICR7ZHVyYXRpb259bXMgJHt0aW1pbmd9ICR7ZGVsYXl9bXNgXG5cbiAgY29uc3QgZG9tID0gdm5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA/IHZub2RlIDogdm5vZGUuJGVsXG4gIC8vIHRyaWdnZXIgaW1hZ2UgbGF6eWxvYWRpbmcgYnkgZm9yY2UuXG4gIGRvbSAmJiB3ZWV4LnV0aWxzLmZpcmVMYXp5bG9hZChkb20sIHRydWUpXG5cbiAgY29uc3QgdHJhbnNpdGlvbkVuZEhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBldmVudCAmJiBldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuICAgIGlmIChlbmRFdmVudCkge1xuICAgICAgZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoZW5kRXZlbnQsIHRyYW5zaXRpb25FbmRIYW5kbGVyKVxuICAgICAgZG9tLnN0eWxlW3N0eWxlTmFtZV0gPSAnJ1xuICAgIH1cbiAgICBjYWxsYmFjaygpXG4gIH1cbiAgaWYgKGVuZEV2ZW50KSB7XG4gICAgZG9tLnN0eWxlW3N0eWxlTmFtZV0gPSB0cmFuc2l0aW9uVmFsdWVcbiAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcihlbmRFdmVudCwgdHJhbnNpdGlvbkVuZEhhbmRsZXIpXG4gIH1cbiAgbmV4dEZyYW1lKCgpID0+IHtcbiAgICBkb20uc3R5bGUuY3NzVGV4dFxuICAgICAgKz0gdG9DU1NUZXh0KHN0eWxlT2JqZWN0MnJlbShjb25maWcuc3R5bGVzLCBERVNJR05fUk9PVF9WQUxVRSkgfHwge30pXG4gIH0pXG59XG5cbmNvbnN0IGFuaW1hdGlvbiA9IHtcbiAgLyoqXG4gICAqIHRyYW5zaXRpb25cbiAgICogQHBhcmFtICB7U3RyaW5nfSB2bm9kZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGNvbmZpZ1xuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGNhbGxiYWNrXG4gICAqL1xuICB0cmFuc2l0aW9uICh2bm9kZSwgY29uZmlnLCBjYWxsYmFjaykge1xuICAgIGlmICghY29uZmlnLnN0eWxlcykgeyByZXR1cm4gfVxuICAgIHJldHVybiB0cmFuc2l0aW9uT25jZSh2bm9kZSwgY29uZmlnLCAoKSA9PiB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpXG4gICAgfSlcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQgKHdlZXgpIHtcbiAgICBjb25zdCBleHRlbmRLZXlzID0gd2VleC51dGlscy5leHRlbmRLZXlzXG4gICAgZXh0ZW5kS2V5cyh1dGlscywgd2VleC51dGlscywgW1xuICAgICAgJ25leHRGcmFtZScsXG4gICAgICAndG9DU1NUZXh0JyxcbiAgICAgICdzdHlsZU9iamVjdDJyZW0nLFxuICAgICAgLy8gJ2F1dG9QcmVmaXgnLFxuICAgICAgLy8gJ25vcm1hbGl6ZVN0eWxlJyxcbiAgICAgICdpc0FycmF5J1xuICAgIF0pXG5cbiAgICB3ZWV4LnJlZ2lzdGVyTW9kdWxlKCdhbmltYXRpb24nLCBhbmltYXRpb24pXG4gIH1cbn1cbiIsIi8qXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgdXRpbHMgPSB7fVxuXG5mdW5jdGlvbiBub3cgKCkge1xuICBjb25zdCBub3cgPSB3aW5kb3cucGVyZm9ybWFuY2UgJiYgd2luZG93LnBlcmZvcm1hbmNlLm5vd1xuICAgID8gd2luZG93LnBlcmZvcm1hbmNlLm5vdy5iaW5kKHdpbmRvdy5wZXJmb3JtYW5jZSkgOiBEYXRlLm5vd1xuICByZXR1cm4gbm93KClcbn1cblxuZnVuY3Rpb24gc2Nyb2xsRWxlbWVudCAoZFN1ZmZpeCwgcG9zaXRpb24pIHtcbiAgaWYgKCh0aGlzID09PSBkb2N1bWVudC5ib2R5KSB8fCAodGhpcyA9PT0gd2luZG93KVxuICAgICYmIHdpbmRvdy5zY3JvbGxUbykge1xuICAgIHJldHVybiB3aW5kb3cuc2Nyb2xsVG8oMCwgcG9zaXRpb24pXG4gIH1cbiAgdGhpc1tgc2Nyb2xsJHtkU3VmZml4fWBdID0gcG9zaXRpb25cbn1cbi8qKlxuICogc2VsZiBpbnZva2VkIGZ1bmN0aW9uIHRoYXQsIGdpdmVuIGEgY29udGV4dCwgc3RlcHMgdGhyb3VnaCBzY3JvbGxpbmdcbiAqIEBtZXRob2Qgc3RlcFxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gc3RlcCAoY29udGV4dCkge1xuICAvLyBjYWxsIG1ldGhvZCBhZ2FpbiBvbiBuZXh0IGF2YWlsYWJsZSBmcmFtZVxuICBjb250ZXh0LmZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwLmJpbmQod2luZG93LCBjb250ZXh0KSlcbiAgY29uc3QgdGltZSA9IG5vdygpXG4gIGxldCBlbGFwc2VkID0gKHRpbWUgLSBjb250ZXh0LnN0YXJ0VGltZSkgLyA0NjhcbiAgLy8gYXZvaWQgZWxhcHNlZCB0aW1lcyBoaWdoZXIgdGhhbiBvbmVcbiAgZWxhcHNlZCA9IGVsYXBzZWQgPiAxID8gMSA6IGVsYXBzZWRcbiAgLy8gYXBwbHkgZWFzaW5nIHRvIGVsYXBzZWQgdGltZVxuICBjb25zdCB2YWx1ZSA9IGVhc2UoZWxhcHNlZClcbiAgY29uc3QgY3VycmVudFBvc2l0aW9uID0gY29udGV4dC5zdGFydFBvc2l0aW9uICsgKGNvbnRleHQucG9zaXRpb24gLSBjb250ZXh0LnN0YXJ0UG9zaXRpb24pICogdmFsdWVcbiAgY29udGV4dC5tZXRob2QuY2FsbChjb250ZXh0LnNjcm9sbGFibGUsIGNvbnRleHQuZFN1ZmZpeCwgY3VycmVudFBvc2l0aW9uKVxuICAvLyByZXR1cm4gd2hlbiBlbmQgcG9pbnRzIGhhdmUgYmVlbiByZWFjaGVkXG4gIC8qKlxuICAgICogTk9URTogc2hvdWxkIHVzZSB+fiB0byBwYXJzZSBwb3NpdGlvbiBudW1iZXIgaW50byBpbnRlZ2VyLiBPdGhlcndpc2VcbiAgICAqIHRoaXMgdHdvIGZsb2F0IG51bWJlcnMgbWF5YmUgaGF2ZSBhIHNsaWNlbHkgbGl0dGxlIGRpZmZlcmVuY2UsIHdoaWNoXG4gICAgKiB3aWxsIGNhdXNlIHRoaXMgZnVuY3Rpb24gbmV2ZXIgdG8gc3RvcC5cbiAgKi9cbiAgaWYgKH5+Y3VycmVudFBvc2l0aW9uID09PSB+fmNvbnRleHQucG9zaXRpb24pIHtcbiAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoY29udGV4dC5mcmFtZSlcbiAgICByZXR1cm5cbiAgfVxufVxuLyoqXG4gKiByZXR1cm5zIHJlc3VsdCBvZiBhcHBseWluZyBlYXNlIG1hdGggZnVuY3Rpb24gdG8gYSBudW1iZXJcbiAqIEBtZXRob2QgZWFzZVxuICogQHBhcmFtIHtOdW1iZXJ9IGtcbiAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGVhc2UgKGspIHtcbiAgcmV0dXJuIDAuNSAqICgxIC0gTWF0aC5jb3MoTWF0aC5QSSAqIGspKVxufVxuY29uc3QgZG9tID0ge1xuICAvKipcbiAgICogc2Nyb2xsVG9FbGVtZW50XG4gICAqIEBwYXJhbSAge1Zub2RlIHwgVkNvbXBvbmVudH0gdm5vZGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zIHtvZmZzZXQ6TnVtYmVyfVxuICAgKiAgIHBzOiBzY3JvbGwtdG8gaGFzICdlYXNlJyBhbmQgJ2R1cmF0aW9uJyhtcykgYXMgb3B0aW9ucy5cbiAgICovXG4gIHNjcm9sbFRvRWxlbWVudDogZnVuY3Rpb24gKHZub2RlLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNBcnJheSxcbiAgICAgIGdldFBhcmVudFNjcm9sbGVyRWxlbWVudFxuICAgIH0gPSB1dGlsc1xuICAgIGlmIChpc0FycmF5KHZub2RlKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignW3Z1ZS1yZW5kZXJdIHRoZSByZWYgcGFzc2VkIHRvIGFuaW1hdGlvbi50cmFuc2l0aW9uT25jZSBpcyBhIGFycmF5LicpXG4gICAgICB9XG4gICAgICB2bm9kZSA9IHZub2RlWzBdXG4gICAgfVxuICAgIGNvbnN0IGlzRWxlbWVudCA9IHZub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnRcbiAgICBjb25zdCBlbCA9IGlzRWxlbWVudCA/IHZub2RlIDogKHZub2RlLiRlbCB8fCB2bm9kZS5lbG0pXG4gICAgY29uc3QgY3QgPSBnZXRQYXJlbnRTY3JvbGxlckVsZW1lbnQodm5vZGUpXG4gICAgY29uc3Qgc2Nyb2xsZXIgPSBjdC5fX3Z1ZV9fXG4gICAgY29uc3QgaXNXaW5kb3cgPSBjdCA9PT0gZG9jdW1lbnQuYm9keVxuICAgIGNvbnN0IHNjcm9sbERpcmVjdGlvbiA9XG4gICAgICBpc1dpbmRvdyA/ICd2ZXJ0aWNhbCdcbiAgICAgICAgOiAoc2Nyb2xsZXIgJiYgc2Nyb2xsZXIuc2Nyb2xsRGlyZWN0aW9uIHx8ICd2ZXJ0aWNhbCcpXG4gICAgaWYgKGN0ICYmIGVsKSB7XG4gICAgICBjb25zdCBkU3VmZml4ID0gKHtcbiAgICAgICAgaG9yaXpvbnRhbDogJ0xlZnQnLFxuICAgICAgICB2ZXJ0aWNhbDogJ1RvcCdcbiAgICAgIH0pW3Njcm9sbERpcmVjdGlvbl1cbiAgICAgIGNvbnN0IGN0UmVjdCA9IGN0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICBsZXQgZWxSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgIC8qKlxuICAgICAgICAqIGlmIGl0J3MgYSB3YXRlcmZhbGwsIGFuZCB5b3Ugd2FudCB0byBzY3JvbGwgdG8gYSBoZWFkZXIsIHRoZW4ganVzdFxuICAgICAgICAqIHNjcm9sbCB0byB0aGUgdG9wLlxuICAgICAgKi9cbiAgICAgIGlmIChcbiAgICAgICAgIWlzRWxlbWVudFxuICAgICAgICAmJiBzY3JvbGxlclxuICAgICAgICAmJiBzY3JvbGxlci53ZWV4VHlwZSA9PT0gJ3dhdGVyZmFsbCdcbiAgICAgICAgJiYgc2Nyb2xsZXIuX2hlYWRlcnNcbiAgICAgICAgJiYgc2Nyb2xsZXIuX2hlYWRlcnMuaW5kZXhPZih2bm9kZS4kdm5vZGUgfHwgdm5vZGUpID4gLTEpIHtcbiAgICAgICAgLy8gaXQncyBpbiB3YXRlcmZhbGwuIGp1c3Qgc2Nyb2xsIHRvIHRoZSB0b3AuXG4gICAgICAgIGVsUmVjdCA9IGN0LmZpcnN0RWxlbWVudENoaWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICB9XG4gICAgICBjb25zdCBkaXIgPSBkU3VmZml4LnRvTG93ZXJDYXNlKClcbiAgICAgIGxldCBvZmZzZXQgPSAoaXNXaW5kb3cgPyAwIDogY3RbYHNjcm9sbCR7ZFN1ZmZpeH1gXSkgKyBlbFJlY3RbZGlyXSAtIGN0UmVjdFtkaXJdXG4gICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBvZmZzZXQgKz0gb3B0aW9ucy5vZmZzZXQgJiYgb3B0aW9ucy5vZmZzZXQgKiB3ZWV4LmNvbmZpZy5lbnYuc2NhbGUgfHwgMFxuICAgICAgfVxuICAgICAgZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdbVnVlIFJlbmRlcl0gVGhlIHNlY29uZCBwYXJhbWV0ZXIgb2YgXCJzY3JvbGxUb0VsZW1lbnRcIiBpcyByZXF1aXJlZCwgJ1xuICAgICAgICArICdvdGhlcndpc2UgaXQgbWF5IG5vdCB3b3JrcyB3ZWxsIG9uIG5hdGl2ZS4nKVxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbmltYXRlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHNjcm9sbEVsZW1lbnQuY2FsbChjdCwgZFN1ZmZpeCwgb2Zmc2V0KVxuICAgICAgfVxuICAgICAgc3RlcCh7XG4gICAgICAgIHNjcm9sbGFibGU6IGN0LFxuICAgICAgICBzdGFydFRpbWU6IG5vdygpLFxuICAgICAgICBmcmFtZTogbnVsbCxcbiAgICAgICAgc3RhcnRQb3NpdGlvbjogaXNXaW5kb3cgPyB3aW5kb3cucGFnZVlPZmZzZXQgOiBjdFtgc2Nyb2xsJHtkU3VmZml4fWBdLFxuICAgICAgICBwb3NpdGlvbjogb2Zmc2V0LFxuICAgICAgICBtZXRob2Q6IHNjcm9sbEVsZW1lbnQsXG4gICAgICAgIGRTdWZmaXg6IGRTdWZmaXhcbiAgICAgIH0pXG4gICAgfVxuICB9LFxuICAvKipcbiAgICogZ2V0Q29tcG9uZW50UmVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdm5vZGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGdldENvbXBvbmVudFJlY3Q6IGZ1bmN0aW9uICh2bm9kZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCB7XG4gICAgICBpc0FycmF5XG4gICAgfSA9IHV0aWxzXG4gICAgaWYgKGlzQXJyYXkodm5vZGUpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdbdnVlLXJlbmRlcl0gdGhlIHJlZiBwYXNzZWQgdG8gYW5pbWF0aW9uLnRyYW5zaXRpb25PbmNlIGlzIGEgYXJyYXkuJylcbiAgICAgIH1cbiAgICAgIHZub2RlID0gdm5vZGVbMF1cbiAgICB9XG4gICAgY29uc3Qgc2NhbGUgPSB3aW5kb3cud2VleC5jb25maWcuZW52LnNjYWxlXG4gICAgY29uc3QgaW5mbyA9IHtcbiAgICAgIHJlc3VsdDogZmFsc2VcbiAgICB9XG4gICAgY29uc3QgcmVjdEtleXMgPSBbJ3dpZHRoJywgJ2hlaWdodCcsICd0b3AnLCAnYm90dG9tJywgJ2xlZnQnLCAncmlnaHQnXVxuXG4gICAgZnVuY3Rpb24gcmVjYWxjIChyZWN0KSB7XG4gICAgICBjb25zdCByZXMgPSB7fVxuICAgICAgcmVjdEtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBpZiAocmVjdFtrZXldKSB7XG4gICAgICAgICAgcmVzW2tleV0gPSByZWN0W2tleV0gLyBzY2FsZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgcmV0dXJuIHJlc1xuICAgIH1cbiAgICBpZiAodm5vZGUgJiYgdm5vZGUgPT09ICd2aWV3cG9ydCcpIHtcbiAgICAgIGluZm8ucmVzdWx0ID0gdHJ1ZVxuICAgICAgaW5mby5zaXplID0gcmVjYWxjKHtcbiAgICAgICAgd2lkdGg6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0LFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHJpZ2h0OiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsXG4gICAgICAgIGJvdHRvbTogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodFxuICAgICAgfSlcbiAgICB9XG4gICAgZWxzZSBpZiAodm5vZGUpIHtcbiAgICAgIGNvbnN0IGVsID0gdm5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudFxuICAgICAgICA/IHZub2RlXG4gICAgICAgIDogdm5vZGUuJGVsXG4gICAgICBpZiAoZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSB7XG4gICAgICAgIGluZm8ucmVzdWx0ID0gdHJ1ZVxuICAgICAgICBpbmZvLnNpemUgPSByZWNhbGMoZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaW5mby5yZXN1bHQgPSBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlID0gaW5mby5yZXN1bHQgPyBpbmZvIDoge1xuICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgIGVyck1zZzogJ0lsbGVnYWwgcGFyYW1ldGVyJ1xuICAgIH1cbiAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhtZXNzYWdlKVxuICAgIHJldHVybiBtZXNzYWdlXG4gIH0sXG4gIC8qKlxuICAgKiBmb3IgYWRkaW5nIGZvbnRGYWNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgZm9udEZhY2VcbiAgICogQHBhcmFtIHtvYmplY3R9IHN0eWxlcyBydWxlc1xuICAgKi9cbiAgYWRkUnVsZTogZnVuY3Rpb24gKGtleSwgc3R5bGVzKSB7XG4gICAgY29uc3Qge1xuICAgICAgY2FtZWxUb0tlYmFiLFxuICAgICAgYXBwZW5kQ3NzXG4gICAgfSA9IHV0aWxzXG4gICAga2V5ID0gY2FtZWxUb0tlYmFiKGtleSlcbiAgICBsZXQgc3R5bGVzVGV4dCA9ICcnXG4gICAgZm9yIChjb25zdCBrIGluIHN0eWxlcykge1xuICAgICAgaWYgKHN0eWxlcy5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICBzdHlsZXNUZXh0ICs9IGNhbWVsVG9LZWJhYihrKSArICc6JyArIHN0eWxlc1trXSArICc7J1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzdHlsZVRleHQgPSBgQCR7a2V5fXske3N0eWxlc1RleHR9fWBcbiAgICBhcHBlbmRDc3Moc3R5bGVUZXh0LCAnZG9tLWFkZGVkLXJ1bGVzJylcbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0ICh3ZWV4KSB7XG4gICAgY29uc3QgZXh0ZW5kS2V5cyA9IHdlZXgudXRpbHMuZXh0ZW5kS2V5c1xuICAgIGV4dGVuZEtleXModXRpbHMsIHdlZXgudXRpbHMsIFsnY2FtZWxUb0tlYmFiJywgJ2FwcGVuZENzcycsICdpc0FycmF5JywgJ2dldFBhcmVudFNjcm9sbGVyRWxlbWVudCddKVxuICAgIHdlZXgucmVnaXN0ZXJNb2R1bGUoJ2RvbScsIGRvbSlcbiAgfVxufVxuIiwiLypcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIGdsb2JhbEV2ZW50IEFQSTpcbiAqIEBkb2MgaHR0cDovL3dlZXguYXBhY2hlLm9yZy9jbi9yZWZlcmVuY2VzL21vZHVsZXMvZ2xvYmFsZXZlbnQuaHRtbFxuICovXG4vLyB0cmFjayB2YXJpZXMga2luZHMgb2YgZXZlbnRzIGFuZCBsaXN0ZW5lcnMuXG5jb25zdCBoYW5kbGVyVHJha2VyID0ge31cblxuY29uc3QgZ2xvYmFsRXZlbnQgPSB7XG4gIC8qKlxuICAgKiBhZGRFdmVudExpc3RlbmVyXG4gICAqIE5PVEU6IG9uZSBjYWxsYmFjayBjYW4gb25seSBiZSBib3VuZCB0byB0aGUgc2FtZSBldmVudCBvbmNlLiBCaW5kIGEgY2FsbGJhY2sgdHdpY2UgZG9lc24ndFxuICAgKiAgbWVhbiBpdCB3aWxsIGJlIGNhbGxlZCB0d2ljZSB3aGVuIHRoZSBldmVudCBmaXJlZCBvbmNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0IC0gdGhlIGV2ZW50IG5hbWUgdG8gYWRkIGEgbGlzdGVuZXIgb24uXG4gICAqL1xuICBhZGRFdmVudExpc3RlbmVyIChldnQsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFt2dWUtcmVuZGVyXSBtaXNzaW5nIGNhbGxiYWNrIGFyZyBpbiBnbG9iYWxFdmVudC5hZGRFdmVudExpc3RlbmVyLmApXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgbGV0IGhhbmRsZXJzID0gaGFuZGxlclRyYWtlcltldnRdXG4gICAgaWYgKCFoYW5kbGVycykge1xuICAgICAgaGFuZGxlcnMgPSBoYW5kbGVyVHJha2VyW2V2dF0gPSBbXVxuICAgIH1cbiAgICBjb25zdCBsZW4gPSBoYW5kbGVycy5sZW5ndGhcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoaGFuZGxlcnNbaV0gPT09IGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIHRoaXMgY2FsbGJhY2sgaXMgYWxyZWFkeSBib3VuZC4gbm8gbmVlZCB0byBiaW5kIGl0IGFnYWluLlxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlcnMucHVzaChjYWxsYmFjaylcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGV2dCwgY2FsbGJhY2spXG4gIH0sXG5cbiAgLyoqXG4gICAqIHJlbW92ZUV2ZW50TGlzdGVuZXJcbiAgICogTk9URTogcmVtb3ZlIGFsbCB0aGUgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQgdHlwZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dCAtIHRoZSBldmVudCBuYW1lIHRvIHJlbW92ZSBhIGxpc3RlbmVyIGZyb20uXG4gICAqL1xuICByZW1vdmVFdmVudExpc3RlbmVyIChldnQpIHtcbiAgICBjb25zdCBoYW5kbGVycyA9IGhhbmRsZXJUcmFrZXJbZXZ0XVxuICAgIGlmICghaGFuZGxlcnMpIHtcbiAgICAgIC8vIGV2dCBoYW5kbGVycyBoYXMgYmVlbiBhbHJlYWR5IHJlbW92ZWQuXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaGFuZGxlcnMuZm9yRWFjaChjYiA9PiBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dCwgY2IpKVxuICAgIGRlbGV0ZSBoYW5kbGVyVHJha2VyW2V2dF1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQgKHdlZXgpIHtcbiAgICB3ZWV4LnJlZ2lzdGVyTW9kdWxlKCdnbG9iYWxFdmVudCcsIGdsb2JhbEV2ZW50KVxuICB9XG59XG4iLCIvKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IHF1ZXVlID0gW11cbmxldCBpc1Byb2Nlc3NpbmcgPSBmYWxzZVxubGV0IHRvYXN0V2luXG5jb25zdCBUT0FTVF9XSU5fQ0xBU1NfTkFNRSA9ICd3ZWV4LXRvYXN0J1xuY29uc3QgVE9BU1RfVFJBTlNJVElPTl9EVVJBVElPTiA9IDAuNFxuXG5jb25zdCBERUZBVUxUX0RVUkFUSU9OID0gMC44XG5cbmZ1bmN0aW9uIHNob3dUb2FzdFdpbmRvdyAobXNnLCBjYWxsYmFjaykge1xuICBpZiAoIXRvYXN0V2luKSB7XG4gICAgdG9hc3RXaW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIHRvYXN0V2luLmNsYXNzTGlzdC5hZGQoVE9BU1RfV0lOX0NMQVNTX05BTUUpXG4gICAgdG9hc3RXaW4uY2xhc3NMaXN0LmFkZCgnaGlkZScpXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0b2FzdFdpbilcbiAgfVxuICB0b2FzdFdpbi50ZXh0Q29udGVudCA9IG1zZ1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICB0b2FzdFdpbi5jbGFzc0xpc3QucmVtb3ZlKCdoaWRlJylcbiAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpXG4gIH0sIDE2KVxufVxuXG5mdW5jdGlvbiBoaWRlVG9hc3RXaW5kb3cgKGNhbGxiYWNrKSB7XG4gIGlmICghdG9hc3RXaW4pIHtcbiAgICByZXR1cm5cbiAgfVxuICB0b2FzdFdpbi5jbGFzc0xpc3QuYWRkKCdoaWRlJylcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKVxuICB9LCBUT0FTVF9UUkFOU0lUSU9OX0RVUkFUSU9OICogMTAwMClcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBwdXNoOiBmdW5jdGlvbiAobXNnLCBkdXJhdGlvbikge1xuICAgIHF1ZXVlLnB1c2goe1xuICAgICAgbXNnOiBtc2csXG4gICAgICBkdXJhdGlvbjogZHVyYXRpb24gfHwgREVGQVVMVF9EVVJBVElPTlxuICAgIH0pXG4gICAgdGhpcy5zaG93KClcbiAgfSxcblxuICBzaG93OiBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgdGhhdCA9IHRoaXNcblxuICAgIC8vIEFsbCBtZXNzYWdlcyBoYWQgYmVlbiB0b2FzdGVkIGFscmVhZHksIHNvIHJlbW92ZSB0aGUgdG9hc3Qgd2luZG93LFxuICAgIGlmICghcXVldWUubGVuZ3RoKSB7XG4gICAgICB0b2FzdFdpbiAmJiB0b2FzdFdpbi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRvYXN0V2luKVxuICAgICAgdG9hc3RXaW4gPSBudWxsXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB0aGUgcHJldmlvdXMgdG9hc3QgaXMgbm90IGVuZGVkIHlldC5cbiAgICBpZiAoaXNQcm9jZXNzaW5nKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaXNQcm9jZXNzaW5nID0gdHJ1ZVxuXG4gICAgY29uc3QgdG9hc3RJbmZvID0gcXVldWUuc2hpZnQoKVxuICAgIHNob3dUb2FzdFdpbmRvdyh0b2FzdEluZm8ubXNnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaGlkZVRvYXN0V2luZG93KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpc1Byb2Nlc3NpbmcgPSBmYWxzZVxuICAgICAgICAgIHRoYXQuc2hvdygpXG4gICAgICAgIH0pXG4gICAgICB9LCB0b2FzdEluZm8uZHVyYXRpb24gKiAxMDAwKVxuICAgIH0pXG4gIH1cbn1cbiIsIi8qXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgb25lIGluc3RhbmNlIG9mIG1vZGFsLlxuY29uc3QgTU9EQUxfV1JBUF9DTEFTUyA9ICd3ZWV4LW1vZGFsLXdyYXAnXG5jb25zdCBNT0RBTF9OT0RFX0NMQVNTID0gJ3dlZXgtbW9kYWwtbm9kZSdcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTW9kYWwgKCkge1xuICB0aGlzLndyYXAgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKE1PREFMX1dSQVBfQ0xBU1MpXG4gIHRoaXMubm9kZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoTU9EQUxfTk9ERV9DTEFTUylcbiAgaWYgKCF0aGlzLndyYXApIHtcbiAgICB0aGlzLmNyZWF0ZVdyYXAoKVxuICB9XG4gIGlmICghdGhpcy5ub2RlKSB7XG4gICAgdGhpcy5jcmVhdGVOb2RlKClcbiAgfVxuICB0aGlzLmNsZWFyTm9kZSgpXG4gIHRoaXMuY3JlYXRlTm9kZUNvbnRlbnQoKVxuICB0aGlzLmJpbmRFdmVudHMoKVxufVxuXG5Nb2RhbC5wcm90b3R5cGUgPSB7XG5cbiAgc2hvdzogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMud3JhcC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgIHRoaXMubm9kZS5jbGFzc0xpc3QucmVtb3ZlKCdoaWRlJylcbiAgfSxcblxuICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLndyYXApXG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUpXG4gICAgdGhpcy53cmFwID0gbnVsbFxuICAgIHRoaXMubm9kZSA9IG51bGxcbiAgfSxcblxuICBjcmVhdGVXcmFwOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy53cmFwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB0aGlzLndyYXAuY2xhc3NOYW1lID0gTU9EQUxfV1JBUF9DTEFTU1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy53cmFwKVxuICB9LFxuXG4gIGNyZWF0ZU5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIHRoaXMubm9kZS5jbGFzc0xpc3QuYWRkKE1PREFMX05PREVfQ0xBU1MsICdoaWRlJylcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMubm9kZSlcbiAgfSxcblxuICBjbGVhck5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm5vZGUuaW5uZXJIVE1MID0gJydcbiAgfSxcblxuICBjcmVhdGVOb2RlQ29udGVudDogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gZG8gbm90aGluZy5cbiAgICAvLyBjaGlsZCBjbGFzc2VzIGNhbiBvdmVycmlkZSB0aGlzIG1ldGhvZC5cbiAgfSxcblxuICBiaW5kRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy53cmFwLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgIH0pXG4gIH1cbn1cbiIsIi8qXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IE1vZGFsIGZyb20gJy4vbW9kYWwnXG5cbmNvbnN0IENPTlRFTlRfQ0xBU1MgPSAnY29udGVudCdcbmNvbnN0IE1TR19DTEFTUyA9ICdjb250ZW50LW1zZydcbmNvbnN0IEJVVFRPTl9HUk9VUF9DTEFTUyA9ICdidG4tZ3JvdXAnXG5jb25zdCBCVVRUT05fQ0xBU1MgPSAnYnRuJ1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBbGVydCAoY29uZmlnKSB7XG4gIHRoaXMubXNnID0gY29uZmlnLm1lc3NhZ2UgfHwgJydcbiAgdGhpcy5jYWxsYmFjayA9IGNvbmZpZy5jYWxsYmFja1xuICB0aGlzLm9rVGl0bGUgPSBjb25maWcub2tUaXRsZSB8fCAnT0snXG4gIE1vZGFsLmNhbGwodGhpcylcbiAgdGhpcy5ub2RlLmNsYXNzTGlzdC5hZGQoJ3dlZXgtYWxlcnQnKVxufVxuXG5BbGVydC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE1vZGFsLnByb3RvdHlwZSlcblxuQWxlcnQucHJvdG90eXBlLmNyZWF0ZU5vZGVDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgY29udGVudC5jbGFzc0xpc3QuYWRkKENPTlRFTlRfQ0xBU1MpXG4gIHRoaXMubm9kZS5hcHBlbmRDaGlsZChjb250ZW50KVxuXG4gIGNvbnN0IG1zZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIG1zZy5jbGFzc0xpc3QuYWRkKE1TR19DTEFTUylcbiAgbXNnLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMubXNnKSlcbiAgY29udGVudC5hcHBlbmRDaGlsZChtc2cpXG5cbiAgY29uc3QgYnV0dG9uR3JvdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBidXR0b25Hcm91cC5jbGFzc0xpc3QuYWRkKEJVVFRPTl9HUk9VUF9DTEFTUylcbiAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKGJ1dHRvbkdyb3VwKVxuICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBidXR0b24uY2xhc3NMaXN0LmFkZChCVVRUT05fQ0xBU1MsICdhbGVydC1vaycpXG4gIGJ1dHRvbi5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLm9rVGl0bGUpKVxuICBidXR0b25Hcm91cC5hcHBlbmRDaGlsZChidXR0b24pXG59XG5cbkFsZXJ0LnByb3RvdHlwZS5iaW5kRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICBNb2RhbC5wcm90b3R5cGUuYmluZEV2ZW50cy5jYWxsKHRoaXMpXG4gIGNvbnN0IGJ1dHRvbiA9IHRoaXMubm9kZS5xdWVyeVNlbGVjdG9yKCcuJyArIEJVVFRPTl9DTEFTUylcbiAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGVzdHJveSgpXG4gICAgdGhpcy5jYWxsYmFjayAmJiB0aGlzLmNhbGxiYWNrKClcbiAgfS5iaW5kKHRoaXMpKVxufVxuIiwiLypcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgTW9kYWwgZnJvbSAnLi9tb2RhbCdcblxuY29uc3QgQ09OVEVOVF9DTEFTUyA9ICdjb250ZW50J1xuY29uc3QgTVNHX0NMQVNTID0gJ2NvbnRlbnQtbXNnJ1xuY29uc3QgQlVUVE9OX0dST1VQX0NMQVNTID0gJ2J0bi1ncm91cCdcbmNvbnN0IEJVVFRPTl9DTEFTUyA9ICdidG4nXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENvbmZpcm0gKGNvbmZpZykge1xuICB0aGlzLm1zZyA9IGNvbmZpZy5tZXNzYWdlIHx8ICcnXG4gIHRoaXMuY2FsbGJhY2sgPSBjb25maWcuY2FsbGJhY2tcbiAgdGhpcy5va1RpdGxlID0gY29uZmlnLm9rVGl0bGUgfHwgJ09LJ1xuICB0aGlzLmNhbmNlbFRpdGxlID0gY29uZmlnLmNhbmNlbFRpdGxlIHx8ICdDYW5jZWwnXG4gIE1vZGFsLmNhbGwodGhpcylcbiAgdGhpcy5ub2RlLmNsYXNzTGlzdC5hZGQoJ3dlZXgtY29uZmlybScpXG59XG5cbkNvbmZpcm0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShNb2RhbC5wcm90b3R5cGUpXG5cbkNvbmZpcm0ucHJvdG90eXBlLmNyZWF0ZU5vZGVDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgY29udGVudC5jbGFzc0xpc3QuYWRkKENPTlRFTlRfQ0xBU1MpXG4gIHRoaXMubm9kZS5hcHBlbmRDaGlsZChjb250ZW50KVxuXG4gIGNvbnN0IG1zZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIG1zZy5jbGFzc0xpc3QuYWRkKE1TR19DTEFTUylcbiAgbXNnLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMubXNnKSlcbiAgY29udGVudC5hcHBlbmRDaGlsZChtc2cpXG5cbiAgY29uc3QgYnV0dG9uR3JvdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBidXR0b25Hcm91cC5jbGFzc0xpc3QuYWRkKEJVVFRPTl9HUk9VUF9DTEFTUylcbiAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKGJ1dHRvbkdyb3VwKVxuICBjb25zdCBidG5PayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIGJ0bk9rLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMub2tUaXRsZSkpXG4gIGJ0bk9rLmNsYXNzTGlzdC5hZGQoJ2J0bi1vaycsIEJVVFRPTl9DTEFTUylcbiAgY29uc3QgYnRuQ2FuY2VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgYnRuQ2FuY2VsLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMuY2FuY2VsVGl0bGUpKVxuICBidG5DYW5jZWwuY2xhc3NMaXN0LmFkZCgnYnRuLWNhbmNlbCcsIEJVVFRPTl9DTEFTUylcbiAgYnV0dG9uR3JvdXAuYXBwZW5kQ2hpbGQoYnRuT2spXG4gIGJ1dHRvbkdyb3VwLmFwcGVuZENoaWxkKGJ0bkNhbmNlbClcbiAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKGJ1dHRvbkdyb3VwKVxufVxuXG5Db25maXJtLnByb3RvdHlwZS5iaW5kRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICBNb2RhbC5wcm90b3R5cGUuYmluZEV2ZW50cy5jYWxsKHRoaXMpXG4gIGNvbnN0IGJ0bk9rID0gdGhpcy5ub2RlLnF1ZXJ5U2VsZWN0b3IoJy4nICsgQlVUVE9OX0NMQVNTICsgJy5idG4tb2snKVxuICBjb25zdCBidG5DYW5jZWwgPSB0aGlzLm5vZGUucXVlcnlTZWxlY3RvcignLicgKyBCVVRUT05fQ0xBU1MgKyAnLmJ0bi1jYW5jZWwnKVxuICBidG5Pay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRlc3Ryb3koKVxuICAgIHRoaXMuY2FsbGJhY2sgJiYgdGhpcy5jYWxsYmFjayh0aGlzLm9rVGl0bGUpXG4gIH0uYmluZCh0aGlzKSlcbiAgYnRuQ2FuY2VsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGVzdHJveSgpXG4gICAgdGhpcy5jYWxsYmFjayAmJiB0aGlzLmNhbGxiYWNrKHRoaXMuY2FuY2VsVGl0bGUpXG4gIH0uYmluZCh0aGlzKSlcbn1cbiIsIi8qXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IE1vZGFsIGZyb20gJy4vbW9kYWwnXG5cbmNvbnN0IENPTlRFTlRfQ0xBU1MgPSAnY29udGVudCdcbmNvbnN0IE1TR19DTEFTUyA9ICdjb250ZW50LW1zZydcbmNvbnN0IEJVVFRPTl9HUk9VUF9DTEFTUyA9ICdidG4tZ3JvdXAnXG5jb25zdCBCVVRUT05fQ0xBU1MgPSAnYnRuJ1xuY29uc3QgSU5QVVRfV1JBUF9DTEFTUyA9ICdpbnB1dC13cmFwJ1xuY29uc3QgSU5QVVRfQ0xBU1MgPSAnaW5wdXQnXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFByb21wdCAoY29uZmlnKSB7XG4gIHRoaXMubXNnID0gY29uZmlnLm1lc3NhZ2UgfHwgJydcbiAgdGhpcy5kZWZhdWx0TXNnID0gY29uZmlnLmRlZmF1bHQgfHwgJydcbiAgdGhpcy5jYWxsYmFjayA9IGNvbmZpZy5jYWxsYmFja1xuICB0aGlzLm9rVGl0bGUgPSBjb25maWcub2tUaXRsZSB8fCAnT0snXG4gIHRoaXMuY2FuY2VsVGl0bGUgPSBjb25maWcuY2FuY2VsVGl0bGUgfHwgJ0NhbmNlbCdcbiAgTW9kYWwuY2FsbCh0aGlzKVxuICB0aGlzLm5vZGUuY2xhc3NMaXN0LmFkZCgnd2VleC1wcm9tcHQnKVxufVxuXG5Qcm9tcHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShNb2RhbC5wcm90b3R5cGUpXG5cblByb21wdC5wcm90b3R5cGUuY3JlYXRlTm9kZUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBjb250ZW50LmNsYXNzTGlzdC5hZGQoQ09OVEVOVF9DTEFTUylcbiAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKGNvbnRlbnQpXG5cbiAgY29uc3QgbXNnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgbXNnLmNsYXNzTGlzdC5hZGQoTVNHX0NMQVNTKVxuICBtc2cuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5tc2cpKVxuICBjb250ZW50LmFwcGVuZENoaWxkKG1zZylcblxuICBjb25zdCBpbnB1dFdyYXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBpbnB1dFdyYXAuY2xhc3NMaXN0LmFkZChJTlBVVF9XUkFQX0NMQVNTKVxuICBjb250ZW50LmFwcGVuZENoaWxkKGlucHV0V3JhcClcbiAgY29uc3QgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpXG4gIGlucHV0LmNsYXNzTGlzdC5hZGQoSU5QVVRfQ0xBU1MpXG4gIGlucHV0LnR5cGUgPSAndGV4dCdcbiAgaW5wdXQuYXV0b2ZvY3VzID0gdHJ1ZVxuICBpbnB1dC5wbGFjZWhvbGRlciA9IHRoaXMuZGVmYXVsdE1zZ1xuICBpbnB1dFdyYXAuYXBwZW5kQ2hpbGQoaW5wdXQpXG5cbiAgY29uc3QgYnV0dG9uR3JvdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBidXR0b25Hcm91cC5jbGFzc0xpc3QuYWRkKEJVVFRPTl9HUk9VUF9DTEFTUylcbiAgY29uc3QgYnRuT2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBidG5Pay5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLm9rVGl0bGUpKVxuICBidG5Pay5jbGFzc0xpc3QuYWRkKCdidG4tb2snLCBCVVRUT05fQ0xBU1MpXG4gIGNvbnN0IGJ0bkNhbmNlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIGJ0bkNhbmNlbC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLmNhbmNlbFRpdGxlKSlcbiAgYnRuQ2FuY2VsLmNsYXNzTGlzdC5hZGQoJ2J0bi1jYW5jZWwnLCBCVVRUT05fQ0xBU1MpXG4gIGJ1dHRvbkdyb3VwLmFwcGVuZENoaWxkKGJ0bk9rKVxuICBidXR0b25Hcm91cC5hcHBlbmRDaGlsZChidG5DYW5jZWwpXG4gIHRoaXMubm9kZS5hcHBlbmRDaGlsZChidXR0b25Hcm91cClcbn1cblxuUHJvbXB0LnByb3RvdHlwZS5iaW5kRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICBNb2RhbC5wcm90b3R5cGUuYmluZEV2ZW50cy5jYWxsKHRoaXMpXG4gIGNvbnN0IGJ0bk9rID0gdGhpcy5ub2RlLnF1ZXJ5U2VsZWN0b3IoJy4nICsgQlVUVE9OX0NMQVNTICsgJy5idG4tb2snKVxuICBjb25zdCBidG5DYW5jZWwgPSB0aGlzLm5vZGUucXVlcnlTZWxlY3RvcignLicgKyBCVVRUT05fQ0xBU1MgKyAnLmJ0bi1jYW5jZWwnKVxuICBjb25zdCB0aGF0ID0gdGhpc1xuICBidG5Pay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCB2YWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpLnZhbHVlXG4gICAgdGhpcy5kZXN0cm95KClcbiAgICB0aGlzLmNhbGxiYWNrICYmIHRoaXMuY2FsbGJhY2soe1xuICAgICAgcmVzdWx0OiB0aGF0Lm9rVGl0bGUsXG4gICAgICBkYXRhOiB2YWxcbiAgICB9KVxuICB9LmJpbmQodGhpcykpXG4gIGJ0bkNhbmNlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCB2YWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpLnZhbHVlXG4gICAgdGhpcy5kZXN0cm95KClcbiAgICB0aGlzLmNhbGxiYWNrICYmIHRoaXMuY2FsbGJhY2soe1xuICAgICAgcmVzdWx0OiB0aGF0LmNhbmNlbFRpdGxlLFxuICAgICAgZGF0YTogdmFsXG4gICAgfSlcbiAgfS5iaW5kKHRoaXMpKVxufVxuIiwiLypcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5leHBvcnQgZGVmYXVsdCBgXG4ud2VleC10b2FzdCB7XG4gIGZvbnQtc2l6ZTogMC40MjY2NjdyZW07XG4gIGxpbmUtaGVpZ2h0OiAwLjQyNjY2N3JlbTtcbiAgcG9zaXRpb246IGZpeGVkO1xuICB6LWluZGV4OiAxOTk5OTk5OTk5O1xuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICBtYXgtd2lkdGg6IDgwJTtcbiAgYm90dG9tOiA1MCU7XG4gIGxlZnQ6IDUwJTtcbiAgcGFkZGluZzogMC4yMTMzMzNyZW07XG4gIGJhY2tncm91bmQtY29sb3I6ICMwMDA7XG4gIGNvbG9yOiAjZmZmO1xuICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gIG9wYWNpdHk6IDAuNztcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBhbGwgMC40cyBlYXNlLWluLW91dDtcbiAgLW1vei10cmFuc2l0aW9uOiBhbGwgMC40cyBlYXNlLWluLW91dDtcbiAgLW1zLXRyYW5zaXRpb246IGFsbCAwLjRzIGVhc2UtaW4tb3V0O1xuICB0cmFuc2l0aW9uOiBhbGwgMC40cyBlYXNlLWluLW91dDtcbiAgYm9yZGVyLXJhZGl1czogMC4wNjY2NjdyZW07XG4gIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpO1xuICAtbW96LXRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKTtcbiAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKTtcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpO1xufVxuXG4ud2VleC10b2FzdC5oaWRlIHtcbiAgb3BhY2l0eTogMDtcbn1cblxuLndlZXgtYWxlcnQgLndlZXgtYWxlcnQtb2sge1xuICB3aWR0aDogMTAwJTtcbn1cblxuLndlZXgtY29uZmlybSAuYnRuLWdyb3VwIC5idG4ge1xuICBmbG9hdDogbGVmdDtcbiAgd2lkdGg6IDUwJTtcbn1cblxuLndlZXgtY29uZmlybSAuYnRuLWdyb3VwIC5idG4uYnRuLW9rIHtcbiAgYm9yZGVyLXJpZ2h0OiAwLjAxMzMzM3JlbSBzb2xpZCAjZGRkO1xufVxuXG4ud2VleC1tb2RhbC13cmFwIHtcbiAgZGlzcGxheTogbm9uZTtcbiAgcG9zaXRpb246IGZpeGVkO1xuICB6LWluZGV4OiA5OTk5OTk5OTk7XG4gIHRvcDogMDtcbiAgbGVmdDogMDtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogMTAwJTtcbiAgYmFja2dyb3VuZC1jb2xvcjogIzAwMDtcbiAgb3BhY2l0eTogMC41O1xufVxuXG4ud2VleC1tb2RhbC1ub2RlIHtcbiAgcG9zaXRpb246IGZpeGVkO1xuICB6LWluZGV4OiA5OTk5OTk5OTk5O1xuICB0b3A6IDUwJTtcbiAgbGVmdDogNTAlO1xuICB3aWR0aDogNi42NjY2NjdyZW07XG4gIG1pbi1oZWlnaHQ6IDIuNjY2NjY3cmVtO1xuICBib3JkZXItcmFkaXVzOiAwLjA2NjY2N3JlbTtcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcbiAgLW1vei10cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcbiAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcbn1cblxuLndlZXgtbW9kYWwtbm9kZS5oaWRlIHtcbiAgZGlzcGxheTogbm9uZTtcbn1cblxuLndlZXgtbW9kYWwtbm9kZSAuY29udGVudCB7XG4gIGRpc3BsYXk6IC13ZWJraXQtYm94O1xuICBkaXNwbGF5OiAtd2Via2l0LWZsZXg7XG4gIGRpc3BsYXk6IC1tb3otYm94O1xuICBkaXNwbGF5OiAtbXMtZmxleGJveDtcbiAgZGlzcGxheTogZmxleDtcbiAgLXdlYmtpdC1ib3gtb3JpZW50OiB2ZXJ0aWNhbDtcbiAgLXdlYmtpdC1mbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAtbW96LWJveC1vcmllbnQ6IHZlcnRpY2FsO1xuICAtbW96LWJveC1kaXJlY3Rpb246IG5vcm1hbDtcbiAgLW1zLWZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAtd2Via2l0LWJveC1hbGlnbjogY2VudGVyO1xuICAtd2Via2l0LWFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIC1tcy1mbGV4LWFsaWduOiBjZW50ZXI7XG4gIC1tb3otYm94LWFsaWduOiBjZW50ZXI7XG4gIC1tcy1mbGV4LWFsaWduOiBjZW50ZXI7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIC13ZWJraXQtYm94LXBhY2s6IGNlbnRlcjtcbiAgLXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgLW1vei1ib3gtcGFjazogY2VudGVyO1xuICAtbXMtZmxleC1wYWNrOiBjZW50ZXI7XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICB3aWR0aDogMTAwJTtcbiAgbWluLWhlaWdodDogMS44NjY2NjdyZW07XG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gIGZvbnQtc2l6ZTogMC40MjY2NjdyZW07XG4gIGxpbmUtaGVpZ2h0OiAwLjQyNjY2N3JlbTtcbiAgcGFkZGluZzogMC4yMTMzMzNyZW07XG4gIGJvcmRlci1ib3R0b206IDAuMDEzMzMzcmVtIHNvbGlkICNkZGQ7XG59XG5cbi53ZWV4LW1vZGFsLW5vZGUgLmJ0bi1ncm91cCB7XG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IDAuOHJlbTtcbiAgZm9udC1zaXplOiAwLjM3MzMzM3JlbTtcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xuICBtYXJnaW46IDA7XG4gIHBhZGRpbmc6IDA7XG4gIGJvcmRlcjogbm9uZTtcbn1cblxuLndlZXgtbW9kYWwtbm9kZSAuYnRuLWdyb3VwIC5idG4ge1xuICB0ZXh0LWFsaWduOiBjZW50ZXI7XG59XG5cbi53ZWV4LW1vZGFsLW5vZGUgLmJ0bi1ncm91cCAuYnRuIHtcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgaGVpZ2h0OiAwLjhyZW07XG4gIGxpbmUtaGVpZ2h0OiAwLjhyZW07XG4gIG1hcmdpbjogMDtcbiAgcGFkZGluZzogMDtcbiAgYm9yZGVyOiBub25lO1xuICBiYWNrZ3JvdW5kOiBub25lO1xuICB0ZXh0LWFsaWduOiBjZW50ZXI7XG59XG5cbi53ZWV4LXByb21wdCAuaW5wdXQtd3JhcCB7XG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gIHdpZHRoOiAxMDAlO1xuICBtYXJnaW4tdG9wOiAwLjEzMzMzM3JlbTtcbiAgaGVpZ2h0OiAwLjk2cmVtO1xufVxuXG4ud2VleC1wcm9tcHQgLmlucHV0LXdyYXAgLmlucHV0IHtcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogMC41NnJlbTtcbiAgbGluZS1oZWlnaHQ6IDAuNTZyZW07XG4gIGZvbnQtc2l6ZTogMC40MjY2NjdyZW07XG4gIGJvcmRlcjogMC4wMTMzMzNyZW0gc29saWQgIzk5OTtcbn1cblxuLndlZXgtcHJvbXB0IC5idG4tZ3JvdXAgLmJ0biB7XG4gIGZsb2F0OiBsZWZ0O1xuICB3aWR0aDogNTAlO1xufVxuXG4ud2VleC1wcm9tcHQgLmJ0bi1ncm91cCAuYnRuLmJ0bi1vayB7XG4gIGJvcmRlci1yaWdodDogMC4wMTMzMzNyZW0gc29saWQgI2RkZDtcbn1cbmBcbiIsIi8qXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHRvYXN0IGZyb20gJy4vdG9hc3QnXG5pbXBvcnQgQWxlcnQgZnJvbSAnLi9hbGVydCdcbmltcG9ydCBDb25maXJtIGZyb20gJy4vY29uZmlybSdcbmltcG9ydCBQcm9tcHQgZnJvbSAnLi9wcm9tcHQnXG5pbXBvcnQgX2NzcyBmcm9tICcuL3N0eWxlJ1xuXG4vLyBUT0RPOiByZXdyaXRlIHRoZSBtb2RhbCBzdHlsZXNcbmNvbnN0IG1vZGFsID0ge1xuXG4gIC8vIGR1cmF0aW9uOiBkZWZhdWx0IGlzIDAuOCBzZWNvbmRzLlxuICB0b2FzdDogZnVuY3Rpb24gKGNvbmZpZykge1xuICAgIHRvYXN0LnB1c2goY29uZmlnLm1lc3NhZ2UsIGNvbmZpZy5kdXJhdGlvbilcbiAgfSxcblxuICAvLyBjb25maWc6XG4gIC8vICAtIG1lc3NhZ2U6IHN0cmluZ1xuICAvLyAgLSBva1RpdGxlOiB0aXRsZSBvZiBvayBidXR0b25cbiAgLy8gIC0gY2FsbGJhY2tcbiAgYWxlcnQ6IGZ1bmN0aW9uIChjb25maWcsIGNhbGxiYWNrKSB7XG4gICAgY29uZmlnLmNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKVxuICAgIH1cbiAgICBuZXcgQWxlcnQoY29uZmlnKS5zaG93KClcbiAgfSxcblxuICAvLyBjb25maWc6XG4gIC8vICAtIG1lc3NhZ2U6IHN0cmluZ1xuICAvLyAgLSBva1RpdGxlOiB0aXRsZSBvZiBvayBidXR0b25cbiAgLy8gIC0gY2FuY2VsVGl0bGU6IHRpdGxlIG9mIGNhbmNlbCBidXR0b25cbiAgLy8gIC0gY2FsbGJhY2tcbiAgY29uZmlybTogZnVuY3Rpb24gKGNvbmZpZywgY2FsbGJhY2spIHtcbiAgICBjb25maWcuY2FsbGJhY2sgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayh2YWwpXG4gICAgfVxuICAgIG5ldyBDb25maXJtKGNvbmZpZykuc2hvdygpXG4gIH0sXG5cbiAgLy8gY29uZmlnOlxuICAvLyAgLSBtZXNzYWdlOiBzdHJpbmdcbiAgLy8gIC0gb2tUaXRsZTogdGl0bGUgb2Ygb2sgYnV0dG9uXG4gIC8vICAtIGNhbmNlbFRpdGxlOiB0aXRsZSBvZiBjYW5jZWwgYnV0dG9uXG4gIC8vICAtIGNhbGxiYWNrXG4gIHByb21wdDogZnVuY3Rpb24gKGNvbmZpZywgY2FsbGJhY2spIHtcbiAgICBjb25maWcuY2FsbGJhY2sgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayh2YWwpXG4gICAgfVxuICAgIG5ldyBQcm9tcHQoY29uZmlnKS5zaG93KClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQ6IGZ1bmN0aW9uIChXZWV4KSB7XG4gICAgV2VleC51dGlscy5hcHBlbmRDc3MoX2NzcywgJ3dlZXgtbXVkLW1vZGFsJylcbiAgICBXZWV4LnJlZ2lzdGVyTW9kdWxlKCdtb2RhbCcsIG1vZGFsKVxuICB9XG59XG4iLCIvKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBOYXZpZ2F0b3IgbW9kdWxlXG4gKi9cbmNvbnN0IG5hdmlnYXRvck1vZHVsZSA9IHtcbiAgcHVzaDogZnVuY3Rpb24gKGNvbmZpZywgY2FsbGJhY2spIHtcbiAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGNvbmZpZy51cmxcbiAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpXG4gIH0sXG5cbiAgcG9wOiBmdW5jdGlvbiAoY29uZmlnLCBjYWxsYmFjaykge1xuICAgIHdpbmRvdy5oaXN0b3J5LmJhY2soKVxuICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQgKHdlZXgpIHtcbiAgICB3ZWV4LnJlZ2lzdGVyTW9kdWxlKCduYXZpZ2F0b3InLCBuYXZpZ2F0b3JNb2R1bGUpXG4gIH1cbn1cbiIsIi8qXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIFdlYnZpZXcgbW9kdWxlXG4gKi9cbmxldCBpc0FycmF5XG5cbmNvbnN0IHdlYnZpZXcgPSB7XG4gIGdvQmFjayAodm5vZGUpIHtcbiAgICBpZiAoaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1t2dWUtcmVuZGVyXSB0aGUgcmVmIHBhc3NlZCB0byB3ZWJ2aWV3LmdvQmFjayBpcyBhIGFycmF5LicpXG4gICAgICB9XG4gICAgICB2bm9kZSA9IHZub2RlWzBdXG4gICAgfVxuICAgIGlmICh2bm9kZSAmJiB0eXBlb2Ygdm5vZGUuZ29CYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2bm9kZS5nb0JhY2soKVxuICAgIH1cbiAgfSxcbiAgZ29Gb3J3YXJkICh2bm9kZSkge1xuICAgIGlmIChpc0FycmF5KHZub2RlKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignW3Z1ZS1yZW5kZXJdIHRoZSByZWYgcGFzc2VkIHRvIHdlYnZpZXcuZ29Gb3J3YXJkIGlzIGEgYXJyYXkuJylcbiAgICAgIH1cbiAgICAgIHZub2RlID0gdm5vZGVbMF1cbiAgICB9XG4gICAgaWYgKHZub2RlICYmIHR5cGVvZiB2bm9kZS5nb0ZvcndhcmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZub2RlLmdvRm9yd2FyZCgpXG4gICAgfVxuICB9LFxuICByZWxvYWQgKHZub2RlKSB7XG4gICAgaWYgKGlzQXJyYXkodm5vZGUpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdbdnVlLXJlbmRlcl0gdGhlIHJlZiBwYXNzZWQgdG8gd2Vidmlldy5yZWxvYWQgaXMgYSBhcnJheS4nKVxuICAgICAgfVxuICAgICAgdm5vZGUgPSB2bm9kZVswXVxuICAgIH1cbiAgICBpZiAodm5vZGUgJiYgdHlwZW9mIHZub2RlLnJlbG9hZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdm5vZGUucmVsb2FkKClcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0ICh3ZWV4KSB7XG4gICAgaXNBcnJheSA9IHdlZXgudXRpbHMuaXNBcnJheVxuICAgIHdlZXgucmVnaXN0ZXJNb2R1bGUoJ3dlYnZpZXcnLCB3ZWJ2aWV3KVxuICB9XG59XG4iLCIvKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogd2Vic29ja2V0IG1vZHVsZVxuICovXG4vKmdsb2JhbCBXZWJTb2NrZXQqL1xuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgcmVnaXN0ZXJMaXN0ZW5lcnMgPSBbJ29ub3BlbicsICdvbm1lc3NhZ2UnLCAnb25lcnJvcicsICdvbmNsb3NlJ11cbiAgY29uc3Qgd3MgPSB7XG4gICAgSU5TVEFOQ0U6IG51bGwsXG4gICAgV2ViU29ja2V0OiBmdW5jdGlvbiAodXJsLCBwcm90b2NvbCkge1xuICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgd3MuSU5TVEFOQ0UgPSBudWxsXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgaWYgKCFwcm90b2NvbCkge1xuICAgICAgICB3cy5JTlNUQU5DRSA9IG5ldyBXZWJTb2NrZXQodXJsKVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHdzLklOU1RBTkNFID0gbmV3IFdlYlNvY2tldCh1cmwsIHByb3RvY29sKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHdzLklOU1RBTkNFXG4gICAgfSxcbiAgICBzZW5kOiBmdW5jdGlvbiAobWVzc2FnZXMpIHtcbiAgICAgIHdzLklOU1RBTkNFICYmIHdzLklOU1RBTkNFLnNlbmQobWVzc2FnZXMpXG4gICAgfSxcbiAgICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgd3MuSU5TVEFOQ0UgJiYgd3MuSU5TVEFOQ0UuY2xvc2UoKVxuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGkgaW4gcmVnaXN0ZXJMaXN0ZW5lcnMpIHtcbiAgICBpZiAocmVnaXN0ZXJMaXN0ZW5lcnMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3cywgcmVnaXN0ZXJMaXN0ZW5lcnNbaV0sIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHdzLklOU1RBTkNFICYmIHdzLklOU1RBTkNFW3JlZ2lzdGVyTGlzdGVuZXJzW2ldXVxuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgIGlmICh3cy5JTlNUQU5DRSkge1xuICAgICAgICAgICAgd3MuSU5TVEFOQ0VbcmVnaXN0ZXJMaXN0ZW5lcnNbaV1dID0gZm5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG4gIHJldHVybiB3c1xufSkoKVxuIiwiLypcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgd2Vic29ja2V0IGZyb20gJy4vd2Vic29ja2V0J1xuXG4vLyBUT0RPOiByZXdyaXRlIHRoZSBtb2R1bGUgbWV0YVxuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0OiBmdW5jdGlvbiAoV2VleCkge1xuICAgIFdlZXgucmVnaXN0ZXJNb2R1bGUoJ3dlYlNvY2tldCcsIHdlYnNvY2tldCwgeyByZWdpc3RlclR5cGU6ICdhc3NpZ25tZW50JyB9KVxuICB9XG59XG4iLCIvKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgcmVzZXRWaWV3cG9ydCB9IGZyb20gJy4uL3dlZXgvdmlld3BvcnQnXG5cbmNvbnN0IG1ldGEgPSB7XG4gIC8qKlxuICAgKiBzZXRWaWV3cG9ydC5cbiAgICogQ2hhbmdpbmcgdmlld3BvcnQgZGVzaWduIHdpZHRoIGF0IHJ1bnRpbWUuXG4gICAqL1xuICBzZXRWaWV3cG9ydCAob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgY29uc29sZS5lcnJvcihgW3Z1ZS1yZW5kZXJdIHNldCB2aWV3cG9ydCB3aWR0aCBpbnZhbGlkIG9wdGlvbnM6ICR7b3B0aW9uc31gKVxuICAgIH1cbiAgICBjb25zdCBuZXdXaWR0aCA9IHBhcnNlSW50KG9wdGlvbnMud2lkdGgpXG4gICAgaWYgKCFpc05hTihuZXdXaWR0aCkgJiYgbmV3V2lkdGggPiAwKSB7XG4gICAgICByZXNldFZpZXdwb3J0KG9wdGlvbnMud2lkdGgpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihgW3Z1ZS1yZW5kZXJdIHNldCB2aWV3cG9ydCB3aWR0aCBpbnZhbGlkIG9wdGlvbnMud2lkdGg6ICR7b3B0aW9ucy53aWR0aH1gKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQgKHdlZXgpIHtcbiAgICB3ZWV4LnJlZ2lzdGVyTW9kdWxlKCdtZXRhJywgbWV0YSlcbiAgfVxufVxuIiwiLypcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8vIG1vZHVsZXMgZnJvbSByZW5kZXIvYnJvd2VzciAobGVnYWN5IG1vZHVsZXMpXG5cbmltcG9ydCBnZW9sb2NhdGlvbiBmcm9tICcuL2dlb2xvY2F0aW9uJ1xuaW1wb3J0IHN0b3JhZ2UgZnJvbSAnLi9zdG9yYWdlJ1xuaW1wb3J0IHN0cmVhbSBmcm9tICcuL3N0cmVhbSdcbmltcG9ydCBjbGlwYm9hcmQgZnJvbSAnLi9jbGlwYm9hcmQnXG5pbXBvcnQgZXZlbnRNb2R1bGUgZnJvbSAnLi9ldmVudCdcblxuLy8gY3VzdG9tIG1vZHVsZXNcbmltcG9ydCBhbmltYXRpb24gZnJvbSAnLi9hbmltYXRpb24nXG5pbXBvcnQgZG9tIGZyb20gJy4vZG9tJ1xuaW1wb3J0IGdsb2JhbEV2ZW50IGZyb20gJy4vZ2xvYmFsRXZlbnQnXG5pbXBvcnQgbW9kYWwgZnJvbSAnLi9tb2RhbCdcbmltcG9ydCBuYXZpZ2F0b3JNb2R1bGUgZnJvbSAnLi9uYXZpZ2F0b3InXG5pbXBvcnQgd2VidmlldyBmcm9tICcuL3dlYnZpZXcnXG5pbXBvcnQgd2Vic29ja2V0IGZyb20gJy4vd2Vic29ja2V0J1xuaW1wb3J0IG1ldGEgZnJvbSAnLi9tZXRhJ1xuXG5leHBvcnQgZGVmYXVsdCBbXG4gIGdlb2xvY2F0aW9uLFxuICBzdG9yYWdlLFxuICBzdHJlYW0sXG4gIGNsaXBib2FyZCxcbiAgZXZlbnRNb2R1bGUsXG4gIG1vZGFsLFxuICB3ZWJzb2NrZXQsXG4gIGFuaW1hdGlvbixcbiAgZG9tLFxuICBnbG9iYWxFdmVudCxcbiAgbmF2aWdhdG9yTW9kdWxlLFxuICB3ZWJ2aWV3LFxuICBtZXRhXG5dXG4iLCIvKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IHZhbE1hcCA9IHtcbiAgY29udGFpbjogJ2NvbnRhaW4nLFxuICBjb3ZlcjogJ2NvdmVyJyxcbiAgc3RyZXRjaDogJzEwMCUgMTAwJSdcbn1cbmNvbnN0IHZhbHMgPSBPYmplY3Qua2V5cyh2YWxNYXApXG5jb25zdCBkZWZhdWx0VmFsID0gJ3N0cmV0Y2gnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdCAod2VleCkge1xuICAgIHdlZXguX192dWVfXy5kaXJlY3RpdmUoJ3dlZXgtcmVzaXplJywgZnVuY3Rpb24gKGVsLCBiaW5kaW5nKSB7XG4gICAgICBpZiAoZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnZmlndXJlJykge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGxldCB2YWx1ZSA9IGJpbmRpbmcudmFsdWVcbiAgICAgIGNvbnN0IG9sZFZhbHVlID0gYmluZGluZy5vbGR2YWx1ZVxuICAgICAgaWYgKHZhbHVlID09PSBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGlmICh2YWxzLmluZGV4T2YodmFsdWUpIDw9IC0xKSB7XG4gICAgICAgIHZhbHVlID0gZGVmYXVsdFZhbFxuICAgICAgfVxuICAgICAgZWwuc3R5bGUuYmFja2dyb3VuZFNpemUgPSB2YWxNYXBbdmFsdWVdXG4gICAgfSlcbiAgfVxufVxuIiwiLypcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgcmVzaXplIGZyb20gJy4vcmVzaXplJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHJlc2l6ZVxufVxuIiwiaW1wb3J0IHdlZXggZnJvbSAnLi4vLi4vLi4vc3JjJ1xuXG5pbXBvcnQgY29tcG9uZW50cyBmcm9tICcuLi8uLi8uLi9zcmMvY29tcG9uZW50cydcbmltcG9ydCBtb2R1bGVzIGZyb20gJy4uLy4uLy4uL3NyYy9tb2R1bGVzJ1xuaW1wb3J0IGRpcmVjdGl2ZXMgZnJvbSAnLi4vLi4vLi4vc3JjL2RpcmVjdGl2ZXMnXG5cbmNvbnN0IHByZUluaXQgPSB3ZWV4LmluaXRcblxud2VleC5pbml0ID0gZnVuY3Rpb24gKCkge1xuICBwcmVJbml0LmFwcGx5KHdlZXgsIGFyZ3VtZW50cylcbiAgY29uc3QgcGx1Z2lucyA9IGNvbXBvbmVudHMuY29uY2F0KG1vZHVsZXMpXG5cbiAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICB3ZWV4Lmluc3RhbGwocGx1Z2luKVxuICB9KVxuXG4gIGZvciAoY29uc3QgayBpbiBkaXJlY3RpdmVzKSB7XG4gICAgd2VleC5pbnN0YWxsKGRpcmVjdGl2ZXNba10pXG4gIH1cbn1cblxuaWYgKGdsb2JhbC5WdWUpIHtcbiAgd2VleC5pbml0KGdsb2JhbC5WdWUpXG59XG5cbmV4cG9ydCBkZWZhdWx0IHdlZXhcbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///24\\n\")},function(module,exports){eval(\"// shim for using process in browser\\nvar process = module.exports = {};\\n\\n// cached from whatever global is present so that test runners that stub it\\n// don't break things.  But we need to wrap it in a try catch in case it is\\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\\n// function because try/catches deoptimize in certain engines.\\n\\nvar cachedSetTimeout;\\nvar cachedClearTimeout;\\n\\nfunction defaultSetTimout() {\\n    throw new Error('setTimeout has not been defined');\\n}\\nfunction defaultClearTimeout () {\\n    throw new Error('clearTimeout has not been defined');\\n}\\n(function () {\\n    try {\\n        if (typeof setTimeout === 'function') {\\n            cachedSetTimeout = setTimeout;\\n        } else {\\n            cachedSetTimeout = defaultSetTimout;\\n        }\\n    } catch (e) {\\n        cachedSetTimeout = defaultSetTimout;\\n    }\\n    try {\\n        if (typeof clearTimeout === 'function') {\\n            cachedClearTimeout = clearTimeout;\\n        } else {\\n            cachedClearTimeout = defaultClearTimeout;\\n        }\\n    } catch (e) {\\n        cachedClearTimeout = defaultClearTimeout;\\n    }\\n} ())\\nfunction runTimeout(fun) {\\n    if (cachedSetTimeout === setTimeout) {\\n        //normal enviroments in sane situations\\n        return setTimeout(fun, 0);\\n    }\\n    // if setTimeout wasn't available but was latter defined\\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\\n        cachedSetTimeout = setTimeout;\\n        return setTimeout(fun, 0);\\n    }\\n    try {\\n        // when when somebody has screwed with setTimeout but no I.E. maddness\\n        return cachedSetTimeout(fun, 0);\\n    } catch(e){\\n        try {\\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\\n            return cachedSetTimeout.call(null, fun, 0);\\n        } catch(e){\\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\\n            return cachedSetTimeout.call(this, fun, 0);\\n        }\\n    }\\n\\n\\n}\\nfunction runClearTimeout(marker) {\\n    if (cachedClearTimeout === clearTimeout) {\\n        //normal enviroments in sane situations\\n        return clearTimeout(marker);\\n    }\\n    // if clearTimeout wasn't available but was latter defined\\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\\n        cachedClearTimeout = clearTimeout;\\n        return clearTimeout(marker);\\n    }\\n    try {\\n        // when when somebody has screwed with setTimeout but no I.E. maddness\\n        return cachedClearTimeout(marker);\\n    } catch (e){\\n        try {\\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\\n            return cachedClearTimeout.call(null, marker);\\n        } catch (e){\\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\\n            return cachedClearTimeout.call(this, marker);\\n        }\\n    }\\n\\n\\n\\n}\\nvar queue = [];\\nvar draining = false;\\nvar currentQueue;\\nvar queueIndex = -1;\\n\\nfunction cleanUpNextTick() {\\n    if (!draining || !currentQueue) {\\n        return;\\n    }\\n    draining = false;\\n    if (currentQueue.length) {\\n        queue = currentQueue.concat(queue);\\n    } else {\\n        queueIndex = -1;\\n    }\\n    if (queue.length) {\\n        drainQueue();\\n    }\\n}\\n\\nfunction drainQueue() {\\n    if (draining) {\\n        return;\\n    }\\n    var timeout = runTimeout(cleanUpNextTick);\\n    draining = true;\\n\\n    var len = queue.length;\\n    while(len) {\\n        currentQueue = queue;\\n        queue = [];\\n        while (++queueIndex < len) {\\n            if (currentQueue) {\\n                currentQueue[queueIndex].run();\\n            }\\n        }\\n        queueIndex = -1;\\n        len = queue.length;\\n    }\\n    currentQueue = null;\\n    draining = false;\\n    runClearTimeout(timeout);\\n}\\n\\nprocess.nextTick = function (fun) {\\n    var args = new Array(arguments.length - 1);\\n    if (arguments.length > 1) {\\n        for (var i = 1; i < arguments.length; i++) {\\n            args[i - 1] = arguments[i];\\n        }\\n    }\\n    queue.push(new Item(fun, args));\\n    if (queue.length === 1 && !draining) {\\n        runTimeout(drainQueue);\\n    }\\n};\\n\\n// v8 likes predictible objects\\nfunction Item(fun, array) {\\n    this.fun = fun;\\n    this.array = array;\\n}\\nItem.prototype.run = function () {\\n    this.fun.apply(null, this.array);\\n};\\nprocess.title = 'browser';\\nprocess.browser = true;\\nprocess.env = {};\\nprocess.argv = [];\\nprocess.version = ''; // empty string to avoid regexp issues\\nprocess.versions = {};\\n\\nfunction noop() {}\\n\\nprocess.on = noop;\\nprocess.addListener = noop;\\nprocess.once = noop;\\nprocess.off = noop;\\nprocess.removeListener = noop;\\nprocess.removeAllListeners = noop;\\nprocess.emit = noop;\\nprocess.prependListener = noop;\\nprocess.prependOnceListener = noop;\\n\\nprocess.listeners = function (name) { return [] }\\n\\nprocess.binding = function (name) {\\n    throw new Error('process.binding is not supported');\\n};\\n\\nprocess.cwd = function () { return '/' };\\nprocess.chdir = function (dir) {\\n    throw new Error('process.chdir is not supported');\\n};\\nprocess.umask = function() { return 0; };\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanM/MjYyYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVIiwiZmlsZSI6IjI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///25\\n\")},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\\n    \"use strict\";\\n\\n    if (global.setImmediate) {\\n        return;\\n    }\\n\\n    var nextHandle = 1; // Spec says greater than zero\\n    var tasksByHandle = {};\\n    var currentlyRunningATask = false;\\n    var doc = global.document;\\n    var registerImmediate;\\n\\n    function setImmediate(callback) {\\n      // Callback can either be a function or a string\\n      if (typeof callback !== \"function\") {\\n        callback = new Function(\"\" + callback);\\n      }\\n      // Copy function arguments\\n      var args = new Array(arguments.length - 1);\\n      for (var i = 0; i < args.length; i++) {\\n          args[i] = arguments[i + 1];\\n      }\\n      // Store and register the task\\n      var task = { callback: callback, args: args };\\n      tasksByHandle[nextHandle] = task;\\n      registerImmediate(nextHandle);\\n      return nextHandle++;\\n    }\\n\\n    function clearImmediate(handle) {\\n        delete tasksByHandle[handle];\\n    }\\n\\n    function run(task) {\\n        var callback = task.callback;\\n        var args = task.args;\\n        switch (args.length) {\\n        case 0:\\n            callback();\\n            break;\\n        case 1:\\n            callback(args[0]);\\n            break;\\n        case 2:\\n            callback(args[0], args[1]);\\n            break;\\n        case 3:\\n            callback(args[0], args[1], args[2]);\\n            break;\\n        default:\\n            callback.apply(undefined, args);\\n            break;\\n        }\\n    }\\n\\n    function runIfPresent(handle) {\\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\\n        // So if we\\'re currently running a task, we\\'ll need to delay this invocation.\\n        if (currentlyRunningATask) {\\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\\n            // \"too much recursion\" error.\\n            setTimeout(runIfPresent, 0, handle);\\n        } else {\\n            var task = tasksByHandle[handle];\\n            if (task) {\\n                currentlyRunningATask = true;\\n                try {\\n                    run(task);\\n                } finally {\\n                    clearImmediate(handle);\\n                    currentlyRunningATask = false;\\n                }\\n            }\\n        }\\n    }\\n\\n    function installNextTickImplementation() {\\n        registerImmediate = function(handle) {\\n            process.nextTick(function () { runIfPresent(handle); });\\n        };\\n    }\\n\\n    function canUsePostMessage() {\\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\\n        // where `global.postMessage` means something completely different and can\\'t be used for this purpose.\\n        if (global.postMessage && !global.importScripts) {\\n            var postMessageIsAsynchronous = true;\\n            var oldOnMessage = global.onmessage;\\n            global.onmessage = function() {\\n                postMessageIsAsynchronous = false;\\n            };\\n            global.postMessage(\"\", \"*\");\\n            global.onmessage = oldOnMessage;\\n            return postMessageIsAsynchronous;\\n        }\\n    }\\n\\n    function installPostMessageImplementation() {\\n        // Installs an event handler on `global` for the `message` event: see\\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\\n\\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\\n        var onGlobalMessage = function(event) {\\n            if (event.source === global &&\\n                typeof event.data === \"string\" &&\\n                event.data.indexOf(messagePrefix) === 0) {\\n                runIfPresent(+event.data.slice(messagePrefix.length));\\n            }\\n        };\\n\\n        if (global.addEventListener) {\\n            global.addEventListener(\"message\", onGlobalMessage, false);\\n        } else {\\n            global.attachEvent(\"onmessage\", onGlobalMessage);\\n        }\\n\\n        registerImmediate = function(handle) {\\n            global.postMessage(messagePrefix + handle, \"*\");\\n        };\\n    }\\n\\n    function installMessageChannelImplementation() {\\n        var channel = new MessageChannel();\\n        channel.port1.onmessage = function(event) {\\n            var handle = event.data;\\n            runIfPresent(handle);\\n        };\\n\\n        registerImmediate = function(handle) {\\n            channel.port2.postMessage(handle);\\n        };\\n    }\\n\\n    function installReadyStateChangeImplementation() {\\n        var html = doc.documentElement;\\n        registerImmediate = function(handle) {\\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it\\'s been called.\\n            var script = doc.createElement(\"script\");\\n            script.onreadystatechange = function () {\\n                runIfPresent(handle);\\n                script.onreadystatechange = null;\\n                html.removeChild(script);\\n                script = null;\\n            };\\n            html.appendChild(script);\\n        };\\n    }\\n\\n    function installSetTimeoutImplementation() {\\n        registerImmediate = function(handle) {\\n            setTimeout(runIfPresent, 0, handle);\\n        };\\n    }\\n\\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\\n\\n    // Don\\'t get fooled by e.g. browserify environments.\\n    if ({}.toString.call(global.process) === \"[object process]\") {\\n        // For Node.js before 0.9\\n        installNextTickImplementation();\\n\\n    } else if (canUsePostMessage()) {\\n        // For non-IE10 modern browsers\\n        installPostMessageImplementation();\\n\\n    } else if (global.MessageChannel) {\\n        // For web workers, where supported\\n        installMessageChannelImplementation();\\n\\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\\n        // For IE 68\\n        installReadyStateChangeImplementation();\\n\\n    } else {\\n        // For older browsers\\n        installSetTimeoutImplementation();\\n    }\\n\\n    attachTo.setImmediate = setImmediate;\\n    attachTo.clearImmediate = clearImmediate;\\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\\n\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(0), __webpack_require__(25)))//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzPzlmMmYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQixFQUFFO0FBQ2xFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///26\\n')},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== \"undefined\" && global) ||\\n            (typeof self !== \"undefined\" && self) ||\\n            window;\\nvar apply = Function.prototype.apply;\\n\\n// DOM APIs, for completeness\\n\\nexports.setTimeout = function() {\\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\\n};\\nexports.setInterval = function() {\\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\\n};\\nexports.clearTimeout =\\nexports.clearInterval = function(timeout) {\\n  if (timeout) {\\n    timeout.close();\\n  }\\n};\\n\\nfunction Timeout(id, clearFn) {\\n  this._id = id;\\n  this._clearFn = clearFn;\\n}\\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\\nTimeout.prototype.close = function() {\\n  this._clearFn.call(scope, this._id);\\n};\\n\\n// Does not start the time, just sets up the members needed.\\nexports.enroll = function(item, msecs) {\\n  clearTimeout(item._idleTimeoutId);\\n  item._idleTimeout = msecs;\\n};\\n\\nexports.unenroll = function(item) {\\n  clearTimeout(item._idleTimeoutId);\\n  item._idleTimeout = -1;\\n};\\n\\nexports._unrefActive = exports.active = function(item) {\\n  clearTimeout(item._idleTimeoutId);\\n\\n  var msecs = item._idleTimeout;\\n  if (msecs >= 0) {\\n    item._idleTimeoutId = setTimeout(function onTimeout() {\\n      if (item._onTimeout)\\n        item._onTimeout();\\n    }, msecs);\\n  }\\n};\\n\\n// setimmediate attaches itself to the global object\\n__webpack_require__(26);\\n// On some exotic environments, it\\'s not clear which object `setimmediate` was\\n// able to install onto.  Search each possibility in the same order as the\\n// `setimmediate` library.\\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\\n                       (this && this.setImmediate);\\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\\n                         (this && this.clearImmediate);\\n\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(0)))//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzP2FhMTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHNjb3BlID0gKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYpIHx8XG4gICAgICAgICAgICB3aW5kb3c7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbChzY29wZSwgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG4vLyBPbiBzb21lIGV4b3RpYyBlbnZpcm9ubWVudHMsIGl0J3Mgbm90IGNsZWFyIHdoaWNoIG9iamVjdCBgc2V0aW1tZWRpYXRlYCB3YXNcbi8vIGFibGUgdG8gaW5zdGFsbCBvbnRvLiAgU2VhcmNoIGVhY2ggcG9zc2liaWxpdHkgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4vLyBgc2V0aW1tZWRpYXRlYCBsaWJyYXJ5LlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuc2V0SW1tZWRpYXRlKTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5jbGVhckltbWVkaWF0ZSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///27\\n')},function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval(\"__webpack_require__.r(__webpack_exports__);\\n/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*!\\n * Vue.js v2.5.16\\n * (c) 2014-2018 Evan You\\n * Released under the MIT License.\\n */\\n/*  */\\n\\nvar emptyObject = Object.freeze({});\\n\\n// these helpers produces better vm code in JS engines due to their\\n// explicitness and function inlining\\nfunction isUndef (v) {\\n  return v === undefined || v === null\\n}\\n\\nfunction isDef (v) {\\n  return v !== undefined && v !== null\\n}\\n\\nfunction isTrue (v) {\\n  return v === true\\n}\\n\\nfunction isFalse (v) {\\n  return v === false\\n}\\n\\n/**\\n * Check if value is primitive\\n */\\nfunction isPrimitive (value) {\\n  return (\\n    typeof value === 'string' ||\\n    typeof value === 'number' ||\\n    // $flow-disable-line\\n    typeof value === 'symbol' ||\\n    typeof value === 'boolean'\\n  )\\n}\\n\\n/**\\n * Quick object check - this is primarily used to tell\\n * Objects from primitive values when we know the value\\n * is a JSON-compliant type.\\n */\\nfunction isObject (obj) {\\n  return obj !== null && typeof obj === 'object'\\n}\\n\\n/**\\n * Get the raw type string of a value e.g. [object Object]\\n */\\nvar _toString = Object.prototype.toString;\\n\\nfunction toRawType (value) {\\n  return _toString.call(value).slice(8, -1)\\n}\\n\\n/**\\n * Strict object type check. Only returns true\\n * for plain JavaScript objects.\\n */\\nfunction isPlainObject (obj) {\\n  return _toString.call(obj) === '[object Object]'\\n}\\n\\nfunction isRegExp (v) {\\n  return _toString.call(v) === '[object RegExp]'\\n}\\n\\n/**\\n * Check if val is a valid array index.\\n */\\nfunction isValidArrayIndex (val) {\\n  var n = parseFloat(String(val));\\n  return n >= 0 && Math.floor(n) === n && isFinite(val)\\n}\\n\\n/**\\n * Convert a value to a string that is actually rendered.\\n */\\nfunction toString (val) {\\n  return val == null\\n    ? ''\\n    : typeof val === 'object'\\n      ? JSON.stringify(val, null, 2)\\n      : String(val)\\n}\\n\\n/**\\n * Convert a input value to a number for persistence.\\n * If the conversion fails, return original string.\\n */\\nfunction toNumber (val) {\\n  var n = parseFloat(val);\\n  return isNaN(n) ? val : n\\n}\\n\\n/**\\n * Make a map and return a function for checking if a key\\n * is in that map.\\n */\\nfunction makeMap (\\n  str,\\n  expectsLowerCase\\n) {\\n  var map = Object.create(null);\\n  var list = str.split(',');\\n  for (var i = 0; i < list.length; i++) {\\n    map[list[i]] = true;\\n  }\\n  return expectsLowerCase\\n    ? function (val) { return map[val.toLowerCase()]; }\\n    : function (val) { return map[val]; }\\n}\\n\\n/**\\n * Check if a tag is a built-in tag.\\n */\\nvar isBuiltInTag = makeMap('slot,component', true);\\n\\n/**\\n * Check if a attribute is a reserved attribute.\\n */\\nvar isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\\n\\n/**\\n * Remove an item from an array\\n */\\nfunction remove (arr, item) {\\n  if (arr.length) {\\n    var index = arr.indexOf(item);\\n    if (index > -1) {\\n      return arr.splice(index, 1)\\n    }\\n  }\\n}\\n\\n/**\\n * Check whether the object has the property.\\n */\\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\\nfunction hasOwn (obj, key) {\\n  return hasOwnProperty.call(obj, key)\\n}\\n\\n/**\\n * Create a cached version of a pure function.\\n */\\nfunction cached (fn) {\\n  var cache = Object.create(null);\\n  return (function cachedFn (str) {\\n    var hit = cache[str];\\n    return hit || (cache[str] = fn(str))\\n  })\\n}\\n\\n/**\\n * Camelize a hyphen-delimited string.\\n */\\nvar camelizeRE = /-(\\\\w)/g;\\nvar camelize = cached(function (str) {\\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\\n});\\n\\n/**\\n * Capitalize a string.\\n */\\nvar capitalize = cached(function (str) {\\n  return str.charAt(0).toUpperCase() + str.slice(1)\\n});\\n\\n/**\\n * Hyphenate a camelCase string.\\n */\\nvar hyphenateRE = /\\\\B([A-Z])/g;\\nvar hyphenate = cached(function (str) {\\n  return str.replace(hyphenateRE, '-$1').toLowerCase()\\n});\\n\\n/**\\n * Simple bind polyfill for environments that do not support it... e.g.\\n * PhantomJS 1.x. Technically we don't need this anymore since native bind is\\n * now more performant in most browsers, but removing it would be breaking for\\n * code that was able to run in PhantomJS 1.x, so this must be kept for\\n * backwards compatibility.\\n */\\n\\n/* istanbul ignore next */\\nfunction polyfillBind (fn, ctx) {\\n  function boundFn (a) {\\n    var l = arguments.length;\\n    return l\\n      ? l > 1\\n        ? fn.apply(ctx, arguments)\\n        : fn.call(ctx, a)\\n      : fn.call(ctx)\\n  }\\n\\n  boundFn._length = fn.length;\\n  return boundFn\\n}\\n\\nfunction nativeBind (fn, ctx) {\\n  return fn.bind(ctx)\\n}\\n\\nvar bind = Function.prototype.bind\\n  ? nativeBind\\n  : polyfillBind;\\n\\n/**\\n * Convert an Array-like object to a real Array.\\n */\\nfunction toArray (list, start) {\\n  start = start || 0;\\n  var i = list.length - start;\\n  var ret = new Array(i);\\n  while (i--) {\\n    ret[i] = list[i + start];\\n  }\\n  return ret\\n}\\n\\n/**\\n * Mix properties into target object.\\n */\\nfunction extend (to, _from) {\\n  for (var key in _from) {\\n    to[key] = _from[key];\\n  }\\n  return to\\n}\\n\\n/**\\n * Merge an Array of Objects into a single Object.\\n */\\nfunction toObject (arr) {\\n  var res = {};\\n  for (var i = 0; i < arr.length; i++) {\\n    if (arr[i]) {\\n      extend(res, arr[i]);\\n    }\\n  }\\n  return res\\n}\\n\\n/**\\n * Perform no operation.\\n * Stubbing args to make Flow happy without leaving useless transpiled code\\n * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)\\n */\\nfunction noop (a, b, c) {}\\n\\n/**\\n * Always return false.\\n */\\nvar no = function (a, b, c) { return false; };\\n\\n/**\\n * Return same value\\n */\\nvar identity = function (_) { return _; };\\n\\n/**\\n * Generate a static keys string from compiler modules.\\n */\\n\\n\\n/**\\n * Check if two values are loosely equal - that is,\\n * if they are plain objects, do they have the same shape?\\n */\\nfunction looseEqual (a, b) {\\n  if (a === b) { return true }\\n  var isObjectA = isObject(a);\\n  var isObjectB = isObject(b);\\n  if (isObjectA && isObjectB) {\\n    try {\\n      var isArrayA = Array.isArray(a);\\n      var isArrayB = Array.isArray(b);\\n      if (isArrayA && isArrayB) {\\n        return a.length === b.length && a.every(function (e, i) {\\n          return looseEqual(e, b[i])\\n        })\\n      } else if (!isArrayA && !isArrayB) {\\n        var keysA = Object.keys(a);\\n        var keysB = Object.keys(b);\\n        return keysA.length === keysB.length && keysA.every(function (key) {\\n          return looseEqual(a[key], b[key])\\n        })\\n      } else {\\n        /* istanbul ignore next */\\n        return false\\n      }\\n    } catch (e) {\\n      /* istanbul ignore next */\\n      return false\\n    }\\n  } else if (!isObjectA && !isObjectB) {\\n    return String(a) === String(b)\\n  } else {\\n    return false\\n  }\\n}\\n\\nfunction looseIndexOf (arr, val) {\\n  for (var i = 0; i < arr.length; i++) {\\n    if (looseEqual(arr[i], val)) { return i }\\n  }\\n  return -1\\n}\\n\\n/**\\n * Ensure a function is called only once.\\n */\\nfunction once (fn) {\\n  var called = false;\\n  return function () {\\n    if (!called) {\\n      called = true;\\n      fn.apply(this, arguments);\\n    }\\n  }\\n}\\n\\nvar SSR_ATTR = 'data-server-rendered';\\n\\nvar ASSET_TYPES = [\\n  'component',\\n  'directive',\\n  'filter'\\n];\\n\\nvar LIFECYCLE_HOOKS = [\\n  'beforeCreate',\\n  'created',\\n  'beforeMount',\\n  'mounted',\\n  'beforeUpdate',\\n  'updated',\\n  'beforeDestroy',\\n  'destroyed',\\n  'activated',\\n  'deactivated',\\n  'errorCaptured'\\n];\\n\\n/*  */\\n\\nvar config = ({\\n  /**\\n   * Option merge strategies (used in core/util/options)\\n   */\\n  // $flow-disable-line\\n  optionMergeStrategies: Object.create(null),\\n\\n  /**\\n   * Whether to suppress warnings.\\n   */\\n  silent: false,\\n\\n  /**\\n   * Show production mode tip message on boot?\\n   */\\n  productionTip: \\\"development\\\" !== 'production',\\n\\n  /**\\n   * Whether to enable devtools\\n   */\\n  devtools: \\\"development\\\" !== 'production',\\n\\n  /**\\n   * Whether to record perf\\n   */\\n  performance: false,\\n\\n  /**\\n   * Error handler for watcher errors\\n   */\\n  errorHandler: null,\\n\\n  /**\\n   * Warn handler for watcher warns\\n   */\\n  warnHandler: null,\\n\\n  /**\\n   * Ignore certain custom elements\\n   */\\n  ignoredElements: [],\\n\\n  /**\\n   * Custom user key aliases for v-on\\n   */\\n  // $flow-disable-line\\n  keyCodes: Object.create(null),\\n\\n  /**\\n   * Check if a tag is reserved so that it cannot be registered as a\\n   * component. This is platform-dependent and may be overwritten.\\n   */\\n  isReservedTag: no,\\n\\n  /**\\n   * Check if an attribute is reserved so that it cannot be used as a component\\n   * prop. This is platform-dependent and may be overwritten.\\n   */\\n  isReservedAttr: no,\\n\\n  /**\\n   * Check if a tag is an unknown element.\\n   * Platform-dependent.\\n   */\\n  isUnknownElement: no,\\n\\n  /**\\n   * Get the namespace of an element\\n   */\\n  getTagNamespace: noop,\\n\\n  /**\\n   * Parse the real tag name for the specific platform.\\n   */\\n  parsePlatformTagName: identity,\\n\\n  /**\\n   * Check if an attribute must be bound using property, e.g. value\\n   * Platform-dependent.\\n   */\\n  mustUseProp: no,\\n\\n  /**\\n   * Exposed for legacy reasons\\n   */\\n  _lifecycleHooks: LIFECYCLE_HOOKS\\n})\\n\\n/*  */\\n\\n/**\\n * Check if a string starts with $ or _\\n */\\nfunction isReserved (str) {\\n  var c = (str + '').charCodeAt(0);\\n  return c === 0x24 || c === 0x5F\\n}\\n\\n/**\\n * Define a property.\\n */\\nfunction def (obj, key, val, enumerable) {\\n  Object.defineProperty(obj, key, {\\n    value: val,\\n    enumerable: !!enumerable,\\n    writable: true,\\n    configurable: true\\n  });\\n}\\n\\n/**\\n * Parse simple path.\\n */\\nvar bailRE = /[^\\\\w.$]/;\\nfunction parsePath (path) {\\n  if (bailRE.test(path)) {\\n    return\\n  }\\n  var segments = path.split('.');\\n  return function (obj) {\\n    for (var i = 0; i < segments.length; i++) {\\n      if (!obj) { return }\\n      obj = obj[segments[i]];\\n    }\\n    return obj\\n  }\\n}\\n\\n/*  */\\n\\n// can we use __proto__?\\nvar hasProto = '__proto__' in {};\\n\\n// Browser environment sniffing\\nvar inBrowser = typeof window !== 'undefined';\\nvar inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;\\nvar weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();\\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\\nvar isIE = UA && /msie|trident/.test(UA);\\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\\nvar isEdge = UA && UA.indexOf('edge/') > 0;\\nvar isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');\\nvar isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');\\nvar isChrome = UA && /chrome\\\\/\\\\d+/.test(UA) && !isEdge;\\n\\n// Firefox has a \\\"watch\\\" function on Object.prototype...\\nvar nativeWatch = ({}).watch;\\n\\nvar supportsPassive = false;\\nif (inBrowser) {\\n  try {\\n    var opts = {};\\n    Object.defineProperty(opts, 'passive', ({\\n      get: function get () {\\n        /* istanbul ignore next */\\n        supportsPassive = true;\\n      }\\n    })); // https://github.com/facebook/flow/issues/285\\n    window.addEventListener('test-passive', null, opts);\\n  } catch (e) {}\\n}\\n\\n// this needs to be lazy-evaled because vue may be required before\\n// vue-server-renderer can set VUE_ENV\\nvar _isServer;\\nvar isServerRendering = function () {\\n  if (_isServer === undefined) {\\n    /* istanbul ignore if */\\n    if (!inBrowser && !inWeex && typeof global !== 'undefined') {\\n      // detect presence of vue-server-renderer and avoid\\n      // Webpack shimming the process\\n      _isServer = global['process'].env.VUE_ENV === 'server';\\n    } else {\\n      _isServer = false;\\n    }\\n  }\\n  return _isServer\\n};\\n\\n// detect devtools\\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\\n\\n/* istanbul ignore next */\\nfunction isNative (Ctor) {\\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\\n}\\n\\nvar hasSymbol =\\n  typeof Symbol !== 'undefined' && isNative(Symbol) &&\\n  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\\n\\nvar _Set;\\n/* istanbul ignore if */ // $flow-disable-line\\nif (typeof Set !== 'undefined' && isNative(Set)) {\\n  // use native Set when available.\\n  _Set = Set;\\n} else {\\n  // a non-standard Set polyfill that only works with primitive keys.\\n  _Set = (function () {\\n    function Set () {\\n      this.set = Object.create(null);\\n    }\\n    Set.prototype.has = function has (key) {\\n      return this.set[key] === true\\n    };\\n    Set.prototype.add = function add (key) {\\n      this.set[key] = true;\\n    };\\n    Set.prototype.clear = function clear () {\\n      this.set = Object.create(null);\\n    };\\n\\n    return Set;\\n  }());\\n}\\n\\n/*  */\\n\\nvar warn = noop;\\nvar tip = noop;\\nvar generateComponentTrace = (noop); // work around flow check\\nvar formatComponentName = (noop);\\n\\nif (true) {\\n  var hasConsole = typeof console !== 'undefined';\\n  var classifyRE = /(?:^|[-_])(\\\\w)/g;\\n  var classify = function (str) { return str\\n    .replace(classifyRE, function (c) { return c.toUpperCase(); })\\n    .replace(/[-_]/g, ''); };\\n\\n  warn = function (msg, vm) {\\n    var trace = vm ? generateComponentTrace(vm) : '';\\n\\n    if (config.warnHandler) {\\n      config.warnHandler.call(null, msg, vm, trace);\\n    } else if (hasConsole && (!config.silent)) {\\n      console.error((\\\"[Vue warn]: \\\" + msg + trace));\\n    }\\n  };\\n\\n  tip = function (msg, vm) {\\n    if (hasConsole && (!config.silent)) {\\n      console.warn(\\\"[Vue tip]: \\\" + msg + (\\n        vm ? generateComponentTrace(vm) : ''\\n      ));\\n    }\\n  };\\n\\n  formatComponentName = function (vm, includeFile) {\\n    if (vm.$root === vm) {\\n      return '<Root>'\\n    }\\n    var options = typeof vm === 'function' && vm.cid != null\\n      ? vm.options\\n      : vm._isVue\\n        ? vm.$options || vm.constructor.options\\n        : vm || {};\\n    var name = options.name || options._componentTag;\\n    var file = options.__file;\\n    if (!name && file) {\\n      var match = file.match(/([^/\\\\\\\\]+)\\\\.vue$/);\\n      name = match && match[1];\\n    }\\n\\n    return (\\n      (name ? (\\\"<\\\" + (classify(name)) + \\\">\\\") : \\\"<Anonymous>\\\") +\\n      (file && includeFile !== false ? (\\\" at \\\" + file) : '')\\n    )\\n  };\\n\\n  var repeat = function (str, n) {\\n    var res = '';\\n    while (n) {\\n      if (n % 2 === 1) { res += str; }\\n      if (n > 1) { str += str; }\\n      n >>= 1;\\n    }\\n    return res\\n  };\\n\\n  generateComponentTrace = function (vm) {\\n    if (vm._isVue && vm.$parent) {\\n      var tree = [];\\n      var currentRecursiveSequence = 0;\\n      while (vm) {\\n        if (tree.length > 0) {\\n          var last = tree[tree.length - 1];\\n          if (last.constructor === vm.constructor) {\\n            currentRecursiveSequence++;\\n            vm = vm.$parent;\\n            continue\\n          } else if (currentRecursiveSequence > 0) {\\n            tree[tree.length - 1] = [last, currentRecursiveSequence];\\n            currentRecursiveSequence = 0;\\n          }\\n        }\\n        tree.push(vm);\\n        vm = vm.$parent;\\n      }\\n      return '\\\\n\\\\nfound in\\\\n\\\\n' + tree\\n        .map(function (vm, i) { return (\\\"\\\" + (i === 0 ? '---\\x3e ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)\\n            ? ((formatComponentName(vm[0])) + \\\"... (\\\" + (vm[1]) + \\\" recursive calls)\\\")\\n            : formatComponentName(vm))); })\\n        .join('\\\\n')\\n    } else {\\n      return (\\\"\\\\n\\\\n(found in \\\" + (formatComponentName(vm)) + \\\")\\\")\\n    }\\n  };\\n}\\n\\n/*  */\\n\\n\\nvar uid = 0;\\n\\n/**\\n * A dep is an observable that can have multiple\\n * directives subscribing to it.\\n */\\nvar Dep = function Dep () {\\n  this.id = uid++;\\n  this.subs = [];\\n};\\n\\nDep.prototype.addSub = function addSub (sub) {\\n  this.subs.push(sub);\\n};\\n\\nDep.prototype.removeSub = function removeSub (sub) {\\n  remove(this.subs, sub);\\n};\\n\\nDep.prototype.depend = function depend () {\\n  if (Dep.target) {\\n    Dep.target.addDep(this);\\n  }\\n};\\n\\nDep.prototype.notify = function notify () {\\n  // stabilize the subscriber list first\\n  var subs = this.subs.slice();\\n  for (var i = 0, l = subs.length; i < l; i++) {\\n    subs[i].update();\\n  }\\n};\\n\\n// the current target watcher being evaluated.\\n// this is globally unique because there could be only one\\n// watcher being evaluated at any time.\\nDep.target = null;\\nvar targetStack = [];\\n\\nfunction pushTarget (_target) {\\n  if (Dep.target) { targetStack.push(Dep.target); }\\n  Dep.target = _target;\\n}\\n\\nfunction popTarget () {\\n  Dep.target = targetStack.pop();\\n}\\n\\n/*  */\\n\\nvar VNode = function VNode (\\n  tag,\\n  data,\\n  children,\\n  text,\\n  elm,\\n  context,\\n  componentOptions,\\n  asyncFactory\\n) {\\n  this.tag = tag;\\n  this.data = data;\\n  this.children = children;\\n  this.text = text;\\n  this.elm = elm;\\n  this.ns = undefined;\\n  this.context = context;\\n  this.fnContext = undefined;\\n  this.fnOptions = undefined;\\n  this.fnScopeId = undefined;\\n  this.key = data && data.key;\\n  this.componentOptions = componentOptions;\\n  this.componentInstance = undefined;\\n  this.parent = undefined;\\n  this.raw = false;\\n  this.isStatic = false;\\n  this.isRootInsert = true;\\n  this.isComment = false;\\n  this.isCloned = false;\\n  this.isOnce = false;\\n  this.asyncFactory = asyncFactory;\\n  this.asyncMeta = undefined;\\n  this.isAsyncPlaceholder = false;\\n};\\n\\nvar prototypeAccessors = { child: { configurable: true } };\\n\\n// DEPRECATED: alias for componentInstance for backwards compat.\\n/* istanbul ignore next */\\nprototypeAccessors.child.get = function () {\\n  return this.componentInstance\\n};\\n\\nObject.defineProperties( VNode.prototype, prototypeAccessors );\\n\\nvar createEmptyVNode = function (text) {\\n  if ( text === void 0 ) text = '';\\n\\n  var node = new VNode();\\n  node.text = text;\\n  node.isComment = true;\\n  return node\\n};\\n\\nfunction createTextVNode (val) {\\n  return new VNode(undefined, undefined, undefined, String(val))\\n}\\n\\n// optimized shallow clone\\n// used for static nodes and slot nodes because they may be reused across\\n// multiple renders, cloning them avoids errors when DOM manipulations rely\\n// on their elm reference.\\nfunction cloneVNode (vnode) {\\n  var cloned = new VNode(\\n    vnode.tag,\\n    vnode.data,\\n    vnode.children,\\n    vnode.text,\\n    vnode.elm,\\n    vnode.context,\\n    vnode.componentOptions,\\n    vnode.asyncFactory\\n  );\\n  cloned.ns = vnode.ns;\\n  cloned.isStatic = vnode.isStatic;\\n  cloned.key = vnode.key;\\n  cloned.isComment = vnode.isComment;\\n  cloned.fnContext = vnode.fnContext;\\n  cloned.fnOptions = vnode.fnOptions;\\n  cloned.fnScopeId = vnode.fnScopeId;\\n  cloned.isCloned = true;\\n  return cloned\\n}\\n\\n/*\\n * not type checking this file because flow doesn't play well with\\n * dynamically accessing methods on Array prototype\\n */\\n\\nvar arrayProto = Array.prototype;\\nvar arrayMethods = Object.create(arrayProto);\\n\\nvar methodsToPatch = [\\n  'push',\\n  'pop',\\n  'shift',\\n  'unshift',\\n  'splice',\\n  'sort',\\n  'reverse'\\n];\\n\\n/**\\n * Intercept mutating methods and emit events\\n */\\nmethodsToPatch.forEach(function (method) {\\n  // cache original method\\n  var original = arrayProto[method];\\n  def(arrayMethods, method, function mutator () {\\n    var args = [], len = arguments.length;\\n    while ( len-- ) args[ len ] = arguments[ len ];\\n\\n    var result = original.apply(this, args);\\n    var ob = this.__ob__;\\n    var inserted;\\n    switch (method) {\\n      case 'push':\\n      case 'unshift':\\n        inserted = args;\\n        break\\n      case 'splice':\\n        inserted = args.slice(2);\\n        break\\n    }\\n    if (inserted) { ob.observeArray(inserted); }\\n    // notify change\\n    ob.dep.notify();\\n    return result\\n  });\\n});\\n\\n/*  */\\n\\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\\n\\n/**\\n * In some cases we may want to disable observation inside a component's\\n * update computation.\\n */\\nvar shouldObserve = true;\\n\\nfunction toggleObserving (value) {\\n  shouldObserve = value;\\n}\\n\\n/**\\n * Observer class that is attached to each observed\\n * object. Once attached, the observer converts the target\\n * object's property keys into getter/setters that\\n * collect dependencies and dispatch updates.\\n */\\nvar Observer = function Observer (value) {\\n  this.value = value;\\n  this.dep = new Dep();\\n  this.vmCount = 0;\\n  def(value, '__ob__', this);\\n  if (Array.isArray(value)) {\\n    var augment = hasProto\\n      ? protoAugment\\n      : copyAugment;\\n    augment(value, arrayMethods, arrayKeys);\\n    this.observeArray(value);\\n  } else {\\n    this.walk(value);\\n  }\\n};\\n\\n/**\\n * Walk through each property and convert them into\\n * getter/setters. This method should only be called when\\n * value type is Object.\\n */\\nObserver.prototype.walk = function walk (obj) {\\n  var keys = Object.keys(obj);\\n  for (var i = 0; i < keys.length; i++) {\\n    defineReactive(obj, keys[i]);\\n  }\\n};\\n\\n/**\\n * Observe a list of Array items.\\n */\\nObserver.prototype.observeArray = function observeArray (items) {\\n  for (var i = 0, l = items.length; i < l; i++) {\\n    observe(items[i]);\\n  }\\n};\\n\\n// helpers\\n\\n/**\\n * Augment an target Object or Array by intercepting\\n * the prototype chain using __proto__\\n */\\nfunction protoAugment (target, src, keys) {\\n  /* eslint-disable no-proto */\\n  target.__proto__ = src;\\n  /* eslint-enable no-proto */\\n}\\n\\n/**\\n * Augment an target Object or Array by defining\\n * hidden properties.\\n */\\n/* istanbul ignore next */\\nfunction copyAugment (target, src, keys) {\\n  for (var i = 0, l = keys.length; i < l; i++) {\\n    var key = keys[i];\\n    def(target, key, src[key]);\\n  }\\n}\\n\\n/**\\n * Attempt to create an observer instance for a value,\\n * returns the new observer if successfully observed,\\n * or the existing observer if the value already has one.\\n */\\nfunction observe (value, asRootData) {\\n  if (!isObject(value) || value instanceof VNode) {\\n    return\\n  }\\n  var ob;\\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\\n    ob = value.__ob__;\\n  } else if (\\n    shouldObserve &&\\n    !isServerRendering() &&\\n    (Array.isArray(value) || isPlainObject(value)) &&\\n    Object.isExtensible(value) &&\\n    !value._isVue\\n  ) {\\n    ob = new Observer(value);\\n  }\\n  if (asRootData && ob) {\\n    ob.vmCount++;\\n  }\\n  return ob\\n}\\n\\n/**\\n * Define a reactive property on an Object.\\n */\\nfunction defineReactive (\\n  obj,\\n  key,\\n  val,\\n  customSetter,\\n  shallow\\n) {\\n  var dep = new Dep();\\n\\n  var property = Object.getOwnPropertyDescriptor(obj, key);\\n  if (property && property.configurable === false) {\\n    return\\n  }\\n\\n  // cater for pre-defined getter/setters\\n  var getter = property && property.get;\\n  if (!getter && arguments.length === 2) {\\n    val = obj[key];\\n  }\\n  var setter = property && property.set;\\n\\n  var childOb = !shallow && observe(val);\\n  Object.defineProperty(obj, key, {\\n    enumerable: true,\\n    configurable: true,\\n    get: function reactiveGetter () {\\n      var value = getter ? getter.call(obj) : val;\\n      if (Dep.target) {\\n        dep.depend();\\n        if (childOb) {\\n          childOb.dep.depend();\\n          if (Array.isArray(value)) {\\n            dependArray(value);\\n          }\\n        }\\n      }\\n      return value\\n    },\\n    set: function reactiveSetter (newVal) {\\n      var value = getter ? getter.call(obj) : val;\\n      /* eslint-disable no-self-compare */\\n      if (newVal === value || (newVal !== newVal && value !== value)) {\\n        return\\n      }\\n      /* eslint-enable no-self-compare */\\n      if (\\\"development\\\" !== 'production' && customSetter) {\\n        customSetter();\\n      }\\n      if (setter) {\\n        setter.call(obj, newVal);\\n      } else {\\n        val = newVal;\\n      }\\n      childOb = !shallow && observe(newVal);\\n      dep.notify();\\n    }\\n  });\\n}\\n\\n/**\\n * Set a property on an object. Adds the new property and\\n * triggers change notification if the property doesn't\\n * already exist.\\n */\\nfunction set (target, key, val) {\\n  if (\\\"development\\\" !== 'production' &&\\n    (isUndef(target) || isPrimitive(target))\\n  ) {\\n    warn((\\\"Cannot set reactive property on undefined, null, or primitive value: \\\" + ((target))));\\n  }\\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\\n    target.length = Math.max(target.length, key);\\n    target.splice(key, 1, val);\\n    return val\\n  }\\n  if (key in target && !(key in Object.prototype)) {\\n    target[key] = val;\\n    return val\\n  }\\n  var ob = (target).__ob__;\\n  if (target._isVue || (ob && ob.vmCount)) {\\n    \\\"development\\\" !== 'production' && warn(\\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\\n      'at runtime - declare it upfront in the data option.'\\n    );\\n    return val\\n  }\\n  if (!ob) {\\n    target[key] = val;\\n    return val\\n  }\\n  defineReactive(ob.value, key, val);\\n  ob.dep.notify();\\n  return val\\n}\\n\\n/**\\n * Delete a property and trigger change if necessary.\\n */\\nfunction del (target, key) {\\n  if (\\\"development\\\" !== 'production' &&\\n    (isUndef(target) || isPrimitive(target))\\n  ) {\\n    warn((\\\"Cannot delete reactive property on undefined, null, or primitive value: \\\" + ((target))));\\n  }\\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\\n    target.splice(key, 1);\\n    return\\n  }\\n  var ob = (target).__ob__;\\n  if (target._isVue || (ob && ob.vmCount)) {\\n    \\\"development\\\" !== 'production' && warn(\\n      'Avoid deleting properties on a Vue instance or its root $data ' +\\n      '- just set it to null.'\\n    );\\n    return\\n  }\\n  if (!hasOwn(target, key)) {\\n    return\\n  }\\n  delete target[key];\\n  if (!ob) {\\n    return\\n  }\\n  ob.dep.notify();\\n}\\n\\n/**\\n * Collect dependencies on array elements when the array is touched, since\\n * we cannot intercept array element access like property getters.\\n */\\nfunction dependArray (value) {\\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\\n    e = value[i];\\n    e && e.__ob__ && e.__ob__.dep.depend();\\n    if (Array.isArray(e)) {\\n      dependArray(e);\\n    }\\n  }\\n}\\n\\n/*  */\\n\\n/**\\n * Option overwriting strategies are functions that handle\\n * how to merge a parent option value and a child option\\n * value into the final value.\\n */\\nvar strats = config.optionMergeStrategies;\\n\\n/**\\n * Options with restrictions\\n */\\nif (true) {\\n  strats.el = strats.propsData = function (parent, child, vm, key) {\\n    if (!vm) {\\n      warn(\\n        \\\"option \\\\\\\"\\\" + key + \\\"\\\\\\\" can only be used during instance \\\" +\\n        'creation with the `new` keyword.'\\n      );\\n    }\\n    return defaultStrat(parent, child)\\n  };\\n}\\n\\n/**\\n * Helper that recursively merges two data objects together.\\n */\\nfunction mergeData (to, from) {\\n  if (!from) { return to }\\n  var key, toVal, fromVal;\\n  var keys = Object.keys(from);\\n  for (var i = 0; i < keys.length; i++) {\\n    key = keys[i];\\n    toVal = to[key];\\n    fromVal = from[key];\\n    if (!hasOwn(to, key)) {\\n      set(to, key, fromVal);\\n    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\\n      mergeData(toVal, fromVal);\\n    }\\n  }\\n  return to\\n}\\n\\n/**\\n * Data\\n */\\nfunction mergeDataOrFn (\\n  parentVal,\\n  childVal,\\n  vm\\n) {\\n  if (!vm) {\\n    // in a Vue.extend merge, both should be functions\\n    if (!childVal) {\\n      return parentVal\\n    }\\n    if (!parentVal) {\\n      return childVal\\n    }\\n    // when parentVal & childVal are both present,\\n    // we need to return a function that returns the\\n    // merged result of both functions... no need to\\n    // check if parentVal is a function here because\\n    // it has to be a function to pass previous merges.\\n    return function mergedDataFn () {\\n      return mergeData(\\n        typeof childVal === 'function' ? childVal.call(this, this) : childVal,\\n        typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal\\n      )\\n    }\\n  } else {\\n    return function mergedInstanceDataFn () {\\n      // instance merge\\n      var instanceData = typeof childVal === 'function'\\n        ? childVal.call(vm, vm)\\n        : childVal;\\n      var defaultData = typeof parentVal === 'function'\\n        ? parentVal.call(vm, vm)\\n        : parentVal;\\n      if (instanceData) {\\n        return mergeData(instanceData, defaultData)\\n      } else {\\n        return defaultData\\n      }\\n    }\\n  }\\n}\\n\\nstrats.data = function (\\n  parentVal,\\n  childVal,\\n  vm\\n) {\\n  if (!vm) {\\n    if (childVal && typeof childVal !== 'function') {\\n      \\\"development\\\" !== 'production' && warn(\\n        'The \\\"data\\\" option should be a function ' +\\n        'that returns a per-instance value in component ' +\\n        'definitions.',\\n        vm\\n      );\\n\\n      return parentVal\\n    }\\n    return mergeDataOrFn(parentVal, childVal)\\n  }\\n\\n  return mergeDataOrFn(parentVal, childVal, vm)\\n};\\n\\n/**\\n * Hooks and props are merged as arrays.\\n */\\nfunction mergeHook (\\n  parentVal,\\n  childVal\\n) {\\n  return childVal\\n    ? parentVal\\n      ? parentVal.concat(childVal)\\n      : Array.isArray(childVal)\\n        ? childVal\\n        : [childVal]\\n    : parentVal\\n}\\n\\nLIFECYCLE_HOOKS.forEach(function (hook) {\\n  strats[hook] = mergeHook;\\n});\\n\\n/**\\n * Assets\\n *\\n * When a vm is present (instance creation), we need to do\\n * a three-way merge between constructor options, instance\\n * options and parent options.\\n */\\nfunction mergeAssets (\\n  parentVal,\\n  childVal,\\n  vm,\\n  key\\n) {\\n  var res = Object.create(parentVal || null);\\n  if (childVal) {\\n    \\\"development\\\" !== 'production' && assertObjectType(key, childVal, vm);\\n    return extend(res, childVal)\\n  } else {\\n    return res\\n  }\\n}\\n\\nASSET_TYPES.forEach(function (type) {\\n  strats[type + 's'] = mergeAssets;\\n});\\n\\n/**\\n * Watchers.\\n *\\n * Watchers hashes should not overwrite one\\n * another, so we merge them as arrays.\\n */\\nstrats.watch = function (\\n  parentVal,\\n  childVal,\\n  vm,\\n  key\\n) {\\n  // work around Firefox's Object.prototype.watch...\\n  if (parentVal === nativeWatch) { parentVal = undefined; }\\n  if (childVal === nativeWatch) { childVal = undefined; }\\n  /* istanbul ignore if */\\n  if (!childVal) { return Object.create(parentVal || null) }\\n  if (true) {\\n    assertObjectType(key, childVal, vm);\\n  }\\n  if (!parentVal) { return childVal }\\n  var ret = {};\\n  extend(ret, parentVal);\\n  for (var key$1 in childVal) {\\n    var parent = ret[key$1];\\n    var child = childVal[key$1];\\n    if (parent && !Array.isArray(parent)) {\\n      parent = [parent];\\n    }\\n    ret[key$1] = parent\\n      ? parent.concat(child)\\n      : Array.isArray(child) ? child : [child];\\n  }\\n  return ret\\n};\\n\\n/**\\n * Other object hashes.\\n */\\nstrats.props =\\nstrats.methods =\\nstrats.inject =\\nstrats.computed = function (\\n  parentVal,\\n  childVal,\\n  vm,\\n  key\\n) {\\n  if (childVal && \\\"development\\\" !== 'production') {\\n    assertObjectType(key, childVal, vm);\\n  }\\n  if (!parentVal) { return childVal }\\n  var ret = Object.create(null);\\n  extend(ret, parentVal);\\n  if (childVal) { extend(ret, childVal); }\\n  return ret\\n};\\nstrats.provide = mergeDataOrFn;\\n\\n/**\\n * Default strategy.\\n */\\nvar defaultStrat = function (parentVal, childVal) {\\n  return childVal === undefined\\n    ? parentVal\\n    : childVal\\n};\\n\\n/**\\n * Validate component names\\n */\\nfunction checkComponents (options) {\\n  for (var key in options.components) {\\n    validateComponentName(key);\\n  }\\n}\\n\\nfunction validateComponentName (name) {\\n  if (!/^[a-zA-Z][\\\\w-]*$/.test(name)) {\\n    warn(\\n      'Invalid component name: \\\"' + name + '\\\". Component names ' +\\n      'can only contain alphanumeric characters and the hyphen, ' +\\n      'and must start with a letter.'\\n    );\\n  }\\n  if (isBuiltInTag(name) || config.isReservedTag(name)) {\\n    warn(\\n      'Do not use built-in or reserved HTML elements as component ' +\\n      'id: ' + name\\n    );\\n  }\\n}\\n\\n/**\\n * Ensure all props option syntax are normalized into the\\n * Object-based format.\\n */\\nfunction normalizeProps (options, vm) {\\n  var props = options.props;\\n  if (!props) { return }\\n  var res = {};\\n  var i, val, name;\\n  if (Array.isArray(props)) {\\n    i = props.length;\\n    while (i--) {\\n      val = props[i];\\n      if (typeof val === 'string') {\\n        name = camelize(val);\\n        res[name] = { type: null };\\n      } else if (true) {\\n        warn('props must be strings when using array syntax.');\\n      }\\n    }\\n  } else if (isPlainObject(props)) {\\n    for (var key in props) {\\n      val = props[key];\\n      name = camelize(key);\\n      res[name] = isPlainObject(val)\\n        ? val\\n        : { type: val };\\n    }\\n  } else if (true) {\\n    warn(\\n      \\\"Invalid value for option \\\\\\\"props\\\\\\\": expected an Array or an Object, \\\" +\\n      \\\"but got \\\" + (toRawType(props)) + \\\".\\\",\\n      vm\\n    );\\n  }\\n  options.props = res;\\n}\\n\\n/**\\n * Normalize all injections into Object-based format\\n */\\nfunction normalizeInject (options, vm) {\\n  var inject = options.inject;\\n  if (!inject) { return }\\n  var normalized = options.inject = {};\\n  if (Array.isArray(inject)) {\\n    for (var i = 0; i < inject.length; i++) {\\n      normalized[inject[i]] = { from: inject[i] };\\n    }\\n  } else if (isPlainObject(inject)) {\\n    for (var key in inject) {\\n      var val = inject[key];\\n      normalized[key] = isPlainObject(val)\\n        ? extend({ from: key }, val)\\n        : { from: val };\\n    }\\n  } else if (true) {\\n    warn(\\n      \\\"Invalid value for option \\\\\\\"inject\\\\\\\": expected an Array or an Object, \\\" +\\n      \\\"but got \\\" + (toRawType(inject)) + \\\".\\\",\\n      vm\\n    );\\n  }\\n}\\n\\n/**\\n * Normalize raw function directives into object format.\\n */\\nfunction normalizeDirectives (options) {\\n  var dirs = options.directives;\\n  if (dirs) {\\n    for (var key in dirs) {\\n      var def = dirs[key];\\n      if (typeof def === 'function') {\\n        dirs[key] = { bind: def, update: def };\\n      }\\n    }\\n  }\\n}\\n\\nfunction assertObjectType (name, value, vm) {\\n  if (!isPlainObject(value)) {\\n    warn(\\n      \\\"Invalid value for option \\\\\\\"\\\" + name + \\\"\\\\\\\": expected an Object, \\\" +\\n      \\\"but got \\\" + (toRawType(value)) + \\\".\\\",\\n      vm\\n    );\\n  }\\n}\\n\\n/**\\n * Merge two option objects into a new one.\\n * Core utility used in both instantiation and inheritance.\\n */\\nfunction mergeOptions (\\n  parent,\\n  child,\\n  vm\\n) {\\n  if (true) {\\n    checkComponents(child);\\n  }\\n\\n  if (typeof child === 'function') {\\n    child = child.options;\\n  }\\n\\n  normalizeProps(child, vm);\\n  normalizeInject(child, vm);\\n  normalizeDirectives(child);\\n  var extendsFrom = child.extends;\\n  if (extendsFrom) {\\n    parent = mergeOptions(parent, extendsFrom, vm);\\n  }\\n  if (child.mixins) {\\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\\n      parent = mergeOptions(parent, child.mixins[i], vm);\\n    }\\n  }\\n  var options = {};\\n  var key;\\n  for (key in parent) {\\n    mergeField(key);\\n  }\\n  for (key in child) {\\n    if (!hasOwn(parent, key)) {\\n      mergeField(key);\\n    }\\n  }\\n  function mergeField (key) {\\n    var strat = strats[key] || defaultStrat;\\n    options[key] = strat(parent[key], child[key], vm, key);\\n  }\\n  return options\\n}\\n\\n/**\\n * Resolve an asset.\\n * This function is used because child instances need access\\n * to assets defined in its ancestor chain.\\n */\\nfunction resolveAsset (\\n  options,\\n  type,\\n  id,\\n  warnMissing\\n) {\\n  /* istanbul ignore if */\\n  if (typeof id !== 'string') {\\n    return\\n  }\\n  var assets = options[type];\\n  // check local registration variations first\\n  if (hasOwn(assets, id)) { return assets[id] }\\n  var camelizedId = camelize(id);\\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\\n  var PascalCaseId = capitalize(camelizedId);\\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\\n  // fallback to prototype chain\\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\\n  if (\\\"development\\\" !== 'production' && warnMissing && !res) {\\n    warn(\\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\\n      options\\n    );\\n  }\\n  return res\\n}\\n\\n/*  */\\n\\nfunction validateProp (\\n  key,\\n  propOptions,\\n  propsData,\\n  vm\\n) {\\n  var prop = propOptions[key];\\n  var absent = !hasOwn(propsData, key);\\n  var value = propsData[key];\\n  // boolean casting\\n  var booleanIndex = getTypeIndex(Boolean, prop.type);\\n  if (booleanIndex > -1) {\\n    if (absent && !hasOwn(prop, 'default')) {\\n      value = false;\\n    } else if (value === '' || value === hyphenate(key)) {\\n      // only cast empty string / same name to boolean if\\n      // boolean has higher priority\\n      var stringIndex = getTypeIndex(String, prop.type);\\n      if (stringIndex < 0 || booleanIndex < stringIndex) {\\n        value = true;\\n      }\\n    }\\n  }\\n  // check default value\\n  if (value === undefined) {\\n    value = getPropDefaultValue(vm, prop, key);\\n    // since the default value is a fresh copy,\\n    // make sure to observe it.\\n    var prevShouldObserve = shouldObserve;\\n    toggleObserving(true);\\n    observe(value);\\n    toggleObserving(prevShouldObserve);\\n  }\\n  if (\\n    true\\n  ) {\\n    assertProp(prop, key, value, vm, absent);\\n  }\\n  return value\\n}\\n\\n/**\\n * Get the default value of a prop.\\n */\\nfunction getPropDefaultValue (vm, prop, key) {\\n  // no default, return undefined\\n  if (!hasOwn(prop, 'default')) {\\n    return undefined\\n  }\\n  var def = prop.default;\\n  // warn against non-factory defaults for Object & Array\\n  if (\\\"development\\\" !== 'production' && isObject(def)) {\\n    warn(\\n      'Invalid default value for prop \\\"' + key + '\\\": ' +\\n      'Props with type Object/Array must use a factory function ' +\\n      'to return the default value.',\\n      vm\\n    );\\n  }\\n  // the raw prop value was also undefined from previous render,\\n  // return previous default value to avoid unnecessary watcher trigger\\n  if (vm && vm.$options.propsData &&\\n    vm.$options.propsData[key] === undefined &&\\n    vm._props[key] !== undefined\\n  ) {\\n    return vm._props[key]\\n  }\\n  // call factory function for non-Function types\\n  // a value is Function if its prototype is function even across different execution context\\n  return typeof def === 'function' && getType(prop.type) !== 'Function'\\n    ? def.call(vm)\\n    : def\\n}\\n\\n/**\\n * Assert whether a prop is valid.\\n */\\nfunction assertProp (\\n  prop,\\n  name,\\n  value,\\n  vm,\\n  absent\\n) {\\n  if (prop.required && absent) {\\n    warn(\\n      'Missing required prop: \\\"' + name + '\\\"',\\n      vm\\n    );\\n    return\\n  }\\n  if (value == null && !prop.required) {\\n    return\\n  }\\n  var type = prop.type;\\n  var valid = !type || type === true;\\n  var expectedTypes = [];\\n  if (type) {\\n    if (!Array.isArray(type)) {\\n      type = [type];\\n    }\\n    for (var i = 0; i < type.length && !valid; i++) {\\n      var assertedType = assertType(value, type[i]);\\n      expectedTypes.push(assertedType.expectedType || '');\\n      valid = assertedType.valid;\\n    }\\n  }\\n  if (!valid) {\\n    warn(\\n      \\\"Invalid prop: type check failed for prop \\\\\\\"\\\" + name + \\\"\\\\\\\".\\\" +\\n      \\\" Expected \\\" + (expectedTypes.map(capitalize).join(', ')) +\\n      \\\", got \\\" + (toRawType(value)) + \\\".\\\",\\n      vm\\n    );\\n    return\\n  }\\n  var validator = prop.validator;\\n  if (validator) {\\n    if (!validator(value)) {\\n      warn(\\n        'Invalid prop: custom validator check failed for prop \\\"' + name + '\\\".',\\n        vm\\n      );\\n    }\\n  }\\n}\\n\\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\\n\\nfunction assertType (value, type) {\\n  var valid;\\n  var expectedType = getType(type);\\n  if (simpleCheckRE.test(expectedType)) {\\n    var t = typeof value;\\n    valid = t === expectedType.toLowerCase();\\n    // for primitive wrapper objects\\n    if (!valid && t === 'object') {\\n      valid = value instanceof type;\\n    }\\n  } else if (expectedType === 'Object') {\\n    valid = isPlainObject(value);\\n  } else if (expectedType === 'Array') {\\n    valid = Array.isArray(value);\\n  } else {\\n    valid = value instanceof type;\\n  }\\n  return {\\n    valid: valid,\\n    expectedType: expectedType\\n  }\\n}\\n\\n/**\\n * Use function string name to check built-in types,\\n * because a simple equality check will fail when running\\n * across different vms / iframes.\\n */\\nfunction getType (fn) {\\n  var match = fn && fn.toString().match(/^\\\\s*function (\\\\w+)/);\\n  return match ? match[1] : ''\\n}\\n\\nfunction isSameType (a, b) {\\n  return getType(a) === getType(b)\\n}\\n\\nfunction getTypeIndex (type, expectedTypes) {\\n  if (!Array.isArray(expectedTypes)) {\\n    return isSameType(expectedTypes, type) ? 0 : -1\\n  }\\n  for (var i = 0, len = expectedTypes.length; i < len; i++) {\\n    if (isSameType(expectedTypes[i], type)) {\\n      return i\\n    }\\n  }\\n  return -1\\n}\\n\\n/*  */\\n\\nfunction handleError (err, vm, info) {\\n  if (vm) {\\n    var cur = vm;\\n    while ((cur = cur.$parent)) {\\n      var hooks = cur.$options.errorCaptured;\\n      if (hooks) {\\n        for (var i = 0; i < hooks.length; i++) {\\n          try {\\n            var capture = hooks[i].call(cur, err, vm, info) === false;\\n            if (capture) { return }\\n          } catch (e) {\\n            globalHandleError(e, cur, 'errorCaptured hook');\\n          }\\n        }\\n      }\\n    }\\n  }\\n  globalHandleError(err, vm, info);\\n}\\n\\nfunction globalHandleError (err, vm, info) {\\n  if (config.errorHandler) {\\n    try {\\n      return config.errorHandler.call(null, err, vm, info)\\n    } catch (e) {\\n      logError(e, null, 'config.errorHandler');\\n    }\\n  }\\n  logError(err, vm, info);\\n}\\n\\nfunction logError (err, vm, info) {\\n  if (true) {\\n    warn((\\\"Error in \\\" + info + \\\": \\\\\\\"\\\" + (err.toString()) + \\\"\\\\\\\"\\\"), vm);\\n  }\\n  /* istanbul ignore else */\\n  if ((inBrowser || inWeex) && typeof console !== 'undefined') {\\n    console.error(err);\\n  } else {\\n    throw err\\n  }\\n}\\n\\n/*  */\\n/* globals MessageChannel */\\n\\nvar callbacks = [];\\nvar pending = false;\\n\\nfunction flushCallbacks () {\\n  pending = false;\\n  var copies = callbacks.slice(0);\\n  callbacks.length = 0;\\n  for (var i = 0; i < copies.length; i++) {\\n    copies[i]();\\n  }\\n}\\n\\n// Here we have async deferring wrappers using both microtasks and (macro) tasks.\\n// In < 2.4 we used microtasks everywhere, but there are some scenarios where\\n// microtasks have too high a priority and fire in between supposedly\\n// sequential events (e.g. #4521, #6690) or even between bubbling of the same\\n// event (#6566). However, using (macro) tasks everywhere also has subtle problems\\n// when state is changed right before repaint (e.g. #6813, out-in transitions).\\n// Here we use microtask by default, but expose a way to force (macro) task when\\n// needed (e.g. in event handlers attached by v-on).\\nvar microTimerFunc;\\nvar macroTimerFunc;\\nvar useMacroTask = false;\\n\\n// Determine (macro) task defer implementation.\\n// Technically setImmediate should be the ideal choice, but it's only available\\n// in IE. The only polyfill that consistently queues the callback after all DOM\\n// events triggered in the same loop is by using MessageChannel.\\n/* istanbul ignore if */\\nif (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\\n  macroTimerFunc = function () {\\n    setImmediate(flushCallbacks);\\n  };\\n} else if (typeof MessageChannel !== 'undefined' && (\\n  isNative(MessageChannel) ||\\n  // PhantomJS\\n  MessageChannel.toString() === '[object MessageChannelConstructor]'\\n)) {\\n  var channel = new MessageChannel();\\n  var port = channel.port2;\\n  channel.port1.onmessage = flushCallbacks;\\n  macroTimerFunc = function () {\\n    port.postMessage(1);\\n  };\\n} else {\\n  /* istanbul ignore next */\\n  macroTimerFunc = function () {\\n    setTimeout(flushCallbacks, 0);\\n  };\\n}\\n\\n// Determine microtask defer implementation.\\n/* istanbul ignore next, $flow-disable-line */\\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\\n  var p = Promise.resolve();\\n  microTimerFunc = function () {\\n    p.then(flushCallbacks);\\n    // in problematic UIWebViews, Promise.then doesn't completely break, but\\n    // it can get stuck in a weird state where callbacks are pushed into the\\n    // microtask queue but the queue isn't being flushed, until the browser\\n    // needs to do some other work, e.g. handle a timer. Therefore we can\\n    // \\\"force\\\" the microtask queue to be flushed by adding an empty timer.\\n    if (isIOS) { setTimeout(noop); }\\n  };\\n} else {\\n  // fallback to macro\\n  microTimerFunc = macroTimerFunc;\\n}\\n\\n/**\\n * Wrap a function so that if any code inside triggers state change,\\n * the changes are queued using a (macro) task instead of a microtask.\\n */\\nfunction withMacroTask (fn) {\\n  return fn._withTask || (fn._withTask = function () {\\n    useMacroTask = true;\\n    var res = fn.apply(null, arguments);\\n    useMacroTask = false;\\n    return res\\n  })\\n}\\n\\nfunction nextTick (cb, ctx) {\\n  var _resolve;\\n  callbacks.push(function () {\\n    if (cb) {\\n      try {\\n        cb.call(ctx);\\n      } catch (e) {\\n        handleError(e, ctx, 'nextTick');\\n      }\\n    } else if (_resolve) {\\n      _resolve(ctx);\\n    }\\n  });\\n  if (!pending) {\\n    pending = true;\\n    if (useMacroTask) {\\n      macroTimerFunc();\\n    } else {\\n      microTimerFunc();\\n    }\\n  }\\n  // $flow-disable-line\\n  if (!cb && typeof Promise !== 'undefined') {\\n    return new Promise(function (resolve) {\\n      _resolve = resolve;\\n    })\\n  }\\n}\\n\\n/*  */\\n\\n/* not type checking this file because flow doesn't play well with Proxy */\\n\\nvar initProxy;\\n\\nif (true) {\\n  var allowedGlobals = makeMap(\\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\\n    'require' // for Webpack/Browserify\\n  );\\n\\n  var warnNonPresent = function (target, key) {\\n    warn(\\n      \\\"Property or method \\\\\\\"\\\" + key + \\\"\\\\\\\" is not defined on the instance but \\\" +\\n      'referenced during render. Make sure that this property is reactive, ' +\\n      'either in the data option, or for class-based components, by ' +\\n      'initializing the property. ' +\\n      'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',\\n      target\\n    );\\n  };\\n\\n  var hasProxy =\\n    typeof Proxy !== 'undefined' && isNative(Proxy);\\n\\n  if (hasProxy) {\\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');\\n    config.keyCodes = new Proxy(config.keyCodes, {\\n      set: function set (target, key, value) {\\n        if (isBuiltInModifier(key)) {\\n          warn((\\\"Avoid overwriting built-in modifier in config.keyCodes: .\\\" + key));\\n          return false\\n        } else {\\n          target[key] = value;\\n          return true\\n        }\\n      }\\n    });\\n  }\\n\\n  var hasHandler = {\\n    has: function has (target, key) {\\n      var has = key in target;\\n      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\\n      if (!has && !isAllowed) {\\n        warnNonPresent(target, key);\\n      }\\n      return has || !isAllowed\\n    }\\n  };\\n\\n  var getHandler = {\\n    get: function get (target, key) {\\n      if (typeof key === 'string' && !(key in target)) {\\n        warnNonPresent(target, key);\\n      }\\n      return target[key]\\n    }\\n  };\\n\\n  initProxy = function initProxy (vm) {\\n    if (hasProxy) {\\n      // determine which proxy handler to use\\n      var options = vm.$options;\\n      var handlers = options.render && options.render._withStripped\\n        ? getHandler\\n        : hasHandler;\\n      vm._renderProxy = new Proxy(vm, handlers);\\n    } else {\\n      vm._renderProxy = vm;\\n    }\\n  };\\n}\\n\\n/*  */\\n\\nvar seenObjects = new _Set();\\n\\n/**\\n * Recursively traverse an object to evoke all converted\\n * getters, so that every nested property inside the object\\n * is collected as a \\\"deep\\\" dependency.\\n */\\nfunction traverse (val) {\\n  _traverse(val, seenObjects);\\n  seenObjects.clear();\\n}\\n\\nfunction _traverse (val, seen) {\\n  var i, keys;\\n  var isA = Array.isArray(val);\\n  if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {\\n    return\\n  }\\n  if (val.__ob__) {\\n    var depId = val.__ob__.dep.id;\\n    if (seen.has(depId)) {\\n      return\\n    }\\n    seen.add(depId);\\n  }\\n  if (isA) {\\n    i = val.length;\\n    while (i--) { _traverse(val[i], seen); }\\n  } else {\\n    keys = Object.keys(val);\\n    i = keys.length;\\n    while (i--) { _traverse(val[keys[i]], seen); }\\n  }\\n}\\n\\nvar mark;\\nvar measure;\\n\\nif (true) {\\n  var perf = inBrowser && window.performance;\\n  /* istanbul ignore if */\\n  if (\\n    perf &&\\n    perf.mark &&\\n    perf.measure &&\\n    perf.clearMarks &&\\n    perf.clearMeasures\\n  ) {\\n    mark = function (tag) { return perf.mark(tag); };\\n    measure = function (name, startTag, endTag) {\\n      perf.measure(name, startTag, endTag);\\n      perf.clearMarks(startTag);\\n      perf.clearMarks(endTag);\\n      perf.clearMeasures(name);\\n    };\\n  }\\n}\\n\\n/*  */\\n\\nvar normalizeEvent = cached(function (name) {\\n  var passive = name.charAt(0) === '&';\\n  name = passive ? name.slice(1) : name;\\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\\n  name = once$$1 ? name.slice(1) : name;\\n  var capture = name.charAt(0) === '!';\\n  name = capture ? name.slice(1) : name;\\n  return {\\n    name: name,\\n    once: once$$1,\\n    capture: capture,\\n    passive: passive\\n  }\\n});\\n\\nfunction createFnInvoker (fns) {\\n  function invoker () {\\n    var arguments$1 = arguments;\\n\\n    var fns = invoker.fns;\\n    if (Array.isArray(fns)) {\\n      var cloned = fns.slice();\\n      for (var i = 0; i < cloned.length; i++) {\\n        cloned[i].apply(null, arguments$1);\\n      }\\n    } else {\\n      // return handler return value for single handlers\\n      return fns.apply(null, arguments)\\n    }\\n  }\\n  invoker.fns = fns;\\n  return invoker\\n}\\n\\nfunction updateListeners (\\n  on,\\n  oldOn,\\n  add,\\n  remove$$1,\\n  vm\\n) {\\n  var name, def, cur, old, event;\\n  for (name in on) {\\n    def = cur = on[name];\\n    old = oldOn[name];\\n    event = normalizeEvent(name);\\n    /* istanbul ignore if */\\n    if (isUndef(cur)) {\\n      \\\"development\\\" !== 'production' && warn(\\n        \\\"Invalid handler for event \\\\\\\"\\\" + (event.name) + \\\"\\\\\\\": got \\\" + String(cur),\\n        vm\\n      );\\n    } else if (isUndef(old)) {\\n      if (isUndef(cur.fns)) {\\n        cur = on[name] = createFnInvoker(cur);\\n      }\\n      add(event.name, cur, event.once, event.capture, event.passive, event.params);\\n    } else if (cur !== old) {\\n      old.fns = cur;\\n      on[name] = old;\\n    }\\n  }\\n  for (name in oldOn) {\\n    if (isUndef(on[name])) {\\n      event = normalizeEvent(name);\\n      remove$$1(event.name, oldOn[name], event.capture);\\n    }\\n  }\\n}\\n\\n/*  */\\n\\nfunction mergeVNodeHook (def, hookKey, hook) {\\n  if (def instanceof VNode) {\\n    def = def.data.hook || (def.data.hook = {});\\n  }\\n  var invoker;\\n  var oldHook = def[hookKey];\\n\\n  function wrappedHook () {\\n    hook.apply(this, arguments);\\n    // important: remove merged hook to ensure it's called only once\\n    // and prevent memory leak\\n    remove(invoker.fns, wrappedHook);\\n  }\\n\\n  if (isUndef(oldHook)) {\\n    // no existing hook\\n    invoker = createFnInvoker([wrappedHook]);\\n  } else {\\n    /* istanbul ignore if */\\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\\n      // already a merged invoker\\n      invoker = oldHook;\\n      invoker.fns.push(wrappedHook);\\n    } else {\\n      // existing plain hook\\n      invoker = createFnInvoker([oldHook, wrappedHook]);\\n    }\\n  }\\n\\n  invoker.merged = true;\\n  def[hookKey] = invoker;\\n}\\n\\n/*  */\\n\\nfunction extractPropsFromVNodeData (\\n  data,\\n  Ctor,\\n  tag\\n) {\\n  // we are only extracting raw values here.\\n  // validation and default values are handled in the child\\n  // component itself.\\n  var propOptions = Ctor.options.props;\\n  if (isUndef(propOptions)) {\\n    return\\n  }\\n  var res = {};\\n  var attrs = data.attrs;\\n  var props = data.props;\\n  if (isDef(attrs) || isDef(props)) {\\n    for (var key in propOptions) {\\n      var altKey = hyphenate(key);\\n      if (true) {\\n        var keyInLowerCase = key.toLowerCase();\\n        if (\\n          key !== keyInLowerCase &&\\n          attrs && hasOwn(attrs, keyInLowerCase)\\n        ) {\\n          tip(\\n            \\\"Prop \\\\\\\"\\\" + keyInLowerCase + \\\"\\\\\\\" is passed to component \\\" +\\n            (formatComponentName(tag || Ctor)) + \\\", but the declared prop name is\\\" +\\n            \\\" \\\\\\\"\\\" + key + \\\"\\\\\\\". \\\" +\\n            \\\"Note that HTML attributes are case-insensitive and camelCased \\\" +\\n            \\\"props need to use their kebab-case equivalents when using in-DOM \\\" +\\n            \\\"templates. You should probably use \\\\\\\"\\\" + altKey + \\\"\\\\\\\" instead of \\\\\\\"\\\" + key + \\\"\\\\\\\".\\\"\\n          );\\n        }\\n      }\\n      checkProp(res, props, key, altKey, true) ||\\n      checkProp(res, attrs, key, altKey, false);\\n    }\\n  }\\n  return res\\n}\\n\\nfunction checkProp (\\n  res,\\n  hash,\\n  key,\\n  altKey,\\n  preserve\\n) {\\n  if (isDef(hash)) {\\n    if (hasOwn(hash, key)) {\\n      res[key] = hash[key];\\n      if (!preserve) {\\n        delete hash[key];\\n      }\\n      return true\\n    } else if (hasOwn(hash, altKey)) {\\n      res[key] = hash[altKey];\\n      if (!preserve) {\\n        delete hash[altKey];\\n      }\\n      return true\\n    }\\n  }\\n  return false\\n}\\n\\n/*  */\\n\\n// The template compiler attempts to minimize the need for normalization by\\n// statically analyzing the template at compile time.\\n//\\n// For plain HTML markup, normalization can be completely skipped because the\\n// generated render function is guaranteed to return Array<VNode>. There are\\n// two cases where extra normalization is needed:\\n\\n// 1. When the children contains components - because a functional component\\n// may return an Array instead of a single root. In this case, just a simple\\n// normalization is needed - if any child is an Array, we flatten the whole\\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\\n// because functional components already normalize their own children.\\nfunction simpleNormalizeChildren (children) {\\n  for (var i = 0; i < children.length; i++) {\\n    if (Array.isArray(children[i])) {\\n      return Array.prototype.concat.apply([], children)\\n    }\\n  }\\n  return children\\n}\\n\\n// 2. When the children contains constructs that always generated nested Arrays,\\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\\n// with hand-written render functions / JSX. In such cases a full normalization\\n// is needed to cater to all possible types of children values.\\nfunction normalizeChildren (children) {\\n  return isPrimitive(children)\\n    ? [createTextVNode(children)]\\n    : Array.isArray(children)\\n      ? normalizeArrayChildren(children)\\n      : undefined\\n}\\n\\nfunction isTextNode (node) {\\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment)\\n}\\n\\nfunction normalizeArrayChildren (children, nestedIndex) {\\n  var res = [];\\n  var i, c, lastIndex, last;\\n  for (i = 0; i < children.length; i++) {\\n    c = children[i];\\n    if (isUndef(c) || typeof c === 'boolean') { continue }\\n    lastIndex = res.length - 1;\\n    last = res[lastIndex];\\n    //  nested\\n    if (Array.isArray(c)) {\\n      if (c.length > 0) {\\n        c = normalizeArrayChildren(c, ((nestedIndex || '') + \\\"_\\\" + i));\\n        // merge adjacent text nodes\\n        if (isTextNode(c[0]) && isTextNode(last)) {\\n          res[lastIndex] = createTextVNode(last.text + (c[0]).text);\\n          c.shift();\\n        }\\n        res.push.apply(res, c);\\n      }\\n    } else if (isPrimitive(c)) {\\n      if (isTextNode(last)) {\\n        // merge adjacent text nodes\\n        // this is necessary for SSR hydration because text nodes are\\n        // essentially merged when rendered to HTML strings\\n        res[lastIndex] = createTextVNode(last.text + c);\\n      } else if (c !== '') {\\n        // convert primitive to vnode\\n        res.push(createTextVNode(c));\\n      }\\n    } else {\\n      if (isTextNode(c) && isTextNode(last)) {\\n        // merge adjacent text nodes\\n        res[lastIndex] = createTextVNode(last.text + c.text);\\n      } else {\\n        // default key for nested array children (likely generated by v-for)\\n        if (isTrue(children._isVList) &&\\n          isDef(c.tag) &&\\n          isUndef(c.key) &&\\n          isDef(nestedIndex)) {\\n          c.key = \\\"__vlist\\\" + nestedIndex + \\\"_\\\" + i + \\\"__\\\";\\n        }\\n        res.push(c);\\n      }\\n    }\\n  }\\n  return res\\n}\\n\\n/*  */\\n\\nfunction ensureCtor (comp, base) {\\n  if (\\n    comp.__esModule ||\\n    (hasSymbol && comp[Symbol.toStringTag] === 'Module')\\n  ) {\\n    comp = comp.default;\\n  }\\n  return isObject(comp)\\n    ? base.extend(comp)\\n    : comp\\n}\\n\\nfunction createAsyncPlaceholder (\\n  factory,\\n  data,\\n  context,\\n  children,\\n  tag\\n) {\\n  var node = createEmptyVNode();\\n  node.asyncFactory = factory;\\n  node.asyncMeta = { data: data, context: context, children: children, tag: tag };\\n  return node\\n}\\n\\nfunction resolveAsyncComponent (\\n  factory,\\n  baseCtor,\\n  context\\n) {\\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\\n    return factory.errorComp\\n  }\\n\\n  if (isDef(factory.resolved)) {\\n    return factory.resolved\\n  }\\n\\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\\n    return factory.loadingComp\\n  }\\n\\n  if (isDef(factory.contexts)) {\\n    // already pending\\n    factory.contexts.push(context);\\n  } else {\\n    var contexts = factory.contexts = [context];\\n    var sync = true;\\n\\n    var forceRender = function () {\\n      for (var i = 0, l = contexts.length; i < l; i++) {\\n        contexts[i].$forceUpdate();\\n      }\\n    };\\n\\n    var resolve = once(function (res) {\\n      // cache resolved\\n      factory.resolved = ensureCtor(res, baseCtor);\\n      // invoke callbacks only if this is not a synchronous resolve\\n      // (async resolves are shimmed as synchronous during SSR)\\n      if (!sync) {\\n        forceRender();\\n      }\\n    });\\n\\n    var reject = once(function (reason) {\\n      \\\"development\\\" !== 'production' && warn(\\n        \\\"Failed to resolve async component: \\\" + (String(factory)) +\\n        (reason ? (\\\"\\\\nReason: \\\" + reason) : '')\\n      );\\n      if (isDef(factory.errorComp)) {\\n        factory.error = true;\\n        forceRender();\\n      }\\n    });\\n\\n    var res = factory(resolve, reject);\\n\\n    if (isObject(res)) {\\n      if (typeof res.then === 'function') {\\n        // () => Promise\\n        if (isUndef(factory.resolved)) {\\n          res.then(resolve, reject);\\n        }\\n      } else if (isDef(res.component) && typeof res.component.then === 'function') {\\n        res.component.then(resolve, reject);\\n\\n        if (isDef(res.error)) {\\n          factory.errorComp = ensureCtor(res.error, baseCtor);\\n        }\\n\\n        if (isDef(res.loading)) {\\n          factory.loadingComp = ensureCtor(res.loading, baseCtor);\\n          if (res.delay === 0) {\\n            factory.loading = true;\\n          } else {\\n            setTimeout(function () {\\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\\n                factory.loading = true;\\n                forceRender();\\n              }\\n            }, res.delay || 200);\\n          }\\n        }\\n\\n        if (isDef(res.timeout)) {\\n          setTimeout(function () {\\n            if (isUndef(factory.resolved)) {\\n              reject(\\n                 true\\n                  ? (\\\"timeout (\\\" + (res.timeout) + \\\"ms)\\\")\\n                  : undefined\\n              );\\n            }\\n          }, res.timeout);\\n        }\\n      }\\n    }\\n\\n    sync = false;\\n    // return in case resolved synchronously\\n    return factory.loading\\n      ? factory.loadingComp\\n      : factory.resolved\\n  }\\n}\\n\\n/*  */\\n\\nfunction isAsyncPlaceholder (node) {\\n  return node.isComment && node.asyncFactory\\n}\\n\\n/*  */\\n\\nfunction getFirstComponentChild (children) {\\n  if (Array.isArray(children)) {\\n    for (var i = 0; i < children.length; i++) {\\n      var c = children[i];\\n      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\\n        return c\\n      }\\n    }\\n  }\\n}\\n\\n/*  */\\n\\n/*  */\\n\\nfunction initEvents (vm) {\\n  vm._events = Object.create(null);\\n  vm._hasHookEvent = false;\\n  // init parent attached events\\n  var listeners = vm.$options._parentListeners;\\n  if (listeners) {\\n    updateComponentListeners(vm, listeners);\\n  }\\n}\\n\\nvar target;\\n\\nfunction add (event, fn, once) {\\n  if (once) {\\n    target.$once(event, fn);\\n  } else {\\n    target.$on(event, fn);\\n  }\\n}\\n\\nfunction remove$1 (event, fn) {\\n  target.$off(event, fn);\\n}\\n\\nfunction updateComponentListeners (\\n  vm,\\n  listeners,\\n  oldListeners\\n) {\\n  target = vm;\\n  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);\\n  target = undefined;\\n}\\n\\nfunction eventsMixin (Vue) {\\n  var hookRE = /^hook:/;\\n  Vue.prototype.$on = function (event, fn) {\\n    var this$1 = this;\\n\\n    var vm = this;\\n    if (Array.isArray(event)) {\\n      for (var i = 0, l = event.length; i < l; i++) {\\n        this$1.$on(event[i], fn);\\n      }\\n    } else {\\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\\n      // optimize hook:event cost by using a boolean flag marked at registration\\n      // instead of a hash lookup\\n      if (hookRE.test(event)) {\\n        vm._hasHookEvent = true;\\n      }\\n    }\\n    return vm\\n  };\\n\\n  Vue.prototype.$once = function (event, fn) {\\n    var vm = this;\\n    function on () {\\n      vm.$off(event, on);\\n      fn.apply(vm, arguments);\\n    }\\n    on.fn = fn;\\n    vm.$on(event, on);\\n    return vm\\n  };\\n\\n  Vue.prototype.$off = function (event, fn) {\\n    var this$1 = this;\\n\\n    var vm = this;\\n    // all\\n    if (!arguments.length) {\\n      vm._events = Object.create(null);\\n      return vm\\n    }\\n    // array of events\\n    if (Array.isArray(event)) {\\n      for (var i = 0, l = event.length; i < l; i++) {\\n        this$1.$off(event[i], fn);\\n      }\\n      return vm\\n    }\\n    // specific event\\n    var cbs = vm._events[event];\\n    if (!cbs) {\\n      return vm\\n    }\\n    if (!fn) {\\n      vm._events[event] = null;\\n      return vm\\n    }\\n    if (fn) {\\n      // specific handler\\n      var cb;\\n      var i$1 = cbs.length;\\n      while (i$1--) {\\n        cb = cbs[i$1];\\n        if (cb === fn || cb.fn === fn) {\\n          cbs.splice(i$1, 1);\\n          break\\n        }\\n      }\\n    }\\n    return vm\\n  };\\n\\n  Vue.prototype.$emit = function (event) {\\n    var vm = this;\\n    if (true) {\\n      var lowerCaseEvent = event.toLowerCase();\\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\\n        tip(\\n          \\\"Event \\\\\\\"\\\" + lowerCaseEvent + \\\"\\\\\\\" is emitted in component \\\" +\\n          (formatComponentName(vm)) + \\\" but the handler is registered for \\\\\\\"\\\" + event + \\\"\\\\\\\". \\\" +\\n          \\\"Note that HTML attributes are case-insensitive and you cannot use \\\" +\\n          \\\"v-on to listen to camelCase events when using in-DOM templates. \\\" +\\n          \\\"You should probably use \\\\\\\"\\\" + (hyphenate(event)) + \\\"\\\\\\\" instead of \\\\\\\"\\\" + event + \\\"\\\\\\\".\\\"\\n        );\\n      }\\n    }\\n    var cbs = vm._events[event];\\n    if (cbs) {\\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\\n      var args = toArray(arguments, 1);\\n      for (var i = 0, l = cbs.length; i < l; i++) {\\n        try {\\n          cbs[i].apply(vm, args);\\n        } catch (e) {\\n          handleError(e, vm, (\\\"event handler for \\\\\\\"\\\" + event + \\\"\\\\\\\"\\\"));\\n        }\\n      }\\n    }\\n    return vm\\n  };\\n}\\n\\n/*  */\\n\\n\\n\\n/**\\n * Runtime helper for resolving raw children VNodes into a slot object.\\n */\\nfunction resolveSlots (\\n  children,\\n  context\\n) {\\n  var slots = {};\\n  if (!children) {\\n    return slots\\n  }\\n  for (var i = 0, l = children.length; i < l; i++) {\\n    var child = children[i];\\n    var data = child.data;\\n    // remove slot attribute if the node is resolved as a Vue slot node\\n    if (data && data.attrs && data.attrs.slot) {\\n      delete data.attrs.slot;\\n    }\\n    // named slots should only be respected if the vnode was rendered in the\\n    // same context.\\n    if ((child.context === context || child.fnContext === context) &&\\n      data && data.slot != null\\n    ) {\\n      var name = data.slot;\\n      var slot = (slots[name] || (slots[name] = []));\\n      if (child.tag === 'template') {\\n        slot.push.apply(slot, child.children || []);\\n      } else {\\n        slot.push(child);\\n      }\\n    } else {\\n      (slots.default || (slots.default = [])).push(child);\\n    }\\n  }\\n  // ignore slots that contains only whitespace\\n  for (var name$1 in slots) {\\n    if (slots[name$1].every(isWhitespace)) {\\n      delete slots[name$1];\\n    }\\n  }\\n  return slots\\n}\\n\\nfunction isWhitespace (node) {\\n  return (node.isComment && !node.asyncFactory) || node.text === ' '\\n}\\n\\nfunction resolveScopedSlots (\\n  fns, // see flow/vnode\\n  res\\n) {\\n  res = res || {};\\n  for (var i = 0; i < fns.length; i++) {\\n    if (Array.isArray(fns[i])) {\\n      resolveScopedSlots(fns[i], res);\\n    } else {\\n      res[fns[i].key] = fns[i].fn;\\n    }\\n  }\\n  return res\\n}\\n\\n/*  */\\n\\nvar activeInstance = null;\\nvar isUpdatingChildComponent = false;\\n\\nfunction initLifecycle (vm) {\\n  var options = vm.$options;\\n\\n  // locate first non-abstract parent\\n  var parent = options.parent;\\n  if (parent && !options.abstract) {\\n    while (parent.$options.abstract && parent.$parent) {\\n      parent = parent.$parent;\\n    }\\n    parent.$children.push(vm);\\n  }\\n\\n  vm.$parent = parent;\\n  vm.$root = parent ? parent.$root : vm;\\n\\n  vm.$children = [];\\n  vm.$refs = {};\\n\\n  vm._watcher = null;\\n  vm._inactive = null;\\n  vm._directInactive = false;\\n  vm._isMounted = false;\\n  vm._isDestroyed = false;\\n  vm._isBeingDestroyed = false;\\n}\\n\\nfunction lifecycleMixin (Vue) {\\n  Vue.prototype._update = function (vnode, hydrating) {\\n    var vm = this;\\n    if (vm._isMounted) {\\n      callHook(vm, 'beforeUpdate');\\n    }\\n    var prevEl = vm.$el;\\n    var prevVnode = vm._vnode;\\n    var prevActiveInstance = activeInstance;\\n    activeInstance = vm;\\n    vm._vnode = vnode;\\n    // Vue.prototype.__patch__ is injected in entry points\\n    // based on the rendering backend used.\\n    if (!prevVnode) {\\n      // initial render\\n      vm.$el = vm.__patch__(\\n        vm.$el, vnode, hydrating, false /* removeOnly */,\\n        vm.$options._parentElm,\\n        vm.$options._refElm\\n      );\\n      // no need for the ref nodes after initial patch\\n      // this prevents keeping a detached DOM tree in memory (#5851)\\n      vm.$options._parentElm = vm.$options._refElm = null;\\n    } else {\\n      // updates\\n      vm.$el = vm.__patch__(prevVnode, vnode);\\n    }\\n    activeInstance = prevActiveInstance;\\n    // update __vue__ reference\\n    if (prevEl) {\\n      prevEl.__vue__ = null;\\n    }\\n    if (vm.$el) {\\n      vm.$el.__vue__ = vm;\\n    }\\n    // if parent is an HOC, update its $el as well\\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\\n      vm.$parent.$el = vm.$el;\\n    }\\n    // updated hook is called by the scheduler to ensure that children are\\n    // updated in a parent's updated hook.\\n  };\\n\\n  Vue.prototype.$forceUpdate = function () {\\n    var vm = this;\\n    if (vm._watcher) {\\n      vm._watcher.update();\\n    }\\n  };\\n\\n  Vue.prototype.$destroy = function () {\\n    var vm = this;\\n    if (vm._isBeingDestroyed) {\\n      return\\n    }\\n    callHook(vm, 'beforeDestroy');\\n    vm._isBeingDestroyed = true;\\n    // remove self from parent\\n    var parent = vm.$parent;\\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\\n      remove(parent.$children, vm);\\n    }\\n    // teardown watchers\\n    if (vm._watcher) {\\n      vm._watcher.teardown();\\n    }\\n    var i = vm._watchers.length;\\n    while (i--) {\\n      vm._watchers[i].teardown();\\n    }\\n    // remove reference from data ob\\n    // frozen object may not have observer.\\n    if (vm._data.__ob__) {\\n      vm._data.__ob__.vmCount--;\\n    }\\n    // call the last hook...\\n    vm._isDestroyed = true;\\n    // invoke destroy hooks on current rendered tree\\n    vm.__patch__(vm._vnode, null);\\n    // fire destroyed hook\\n    callHook(vm, 'destroyed');\\n    // turn off all instance listeners.\\n    vm.$off();\\n    // remove __vue__ reference\\n    if (vm.$el) {\\n      vm.$el.__vue__ = null;\\n    }\\n    // release circular reference (#6759)\\n    if (vm.$vnode) {\\n      vm.$vnode.parent = null;\\n    }\\n  };\\n}\\n\\nfunction mountComponent (\\n  vm,\\n  el,\\n  hydrating\\n) {\\n  vm.$el = el;\\n  if (!vm.$options.render) {\\n    vm.$options.render = createEmptyVNode;\\n    if (true) {\\n      /* istanbul ignore if */\\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\\n        vm.$options.el || el) {\\n        warn(\\n          'You are using the runtime-only build of Vue where the template ' +\\n          'compiler is not available. Either pre-compile the templates into ' +\\n          'render functions, or use the compiler-included build.',\\n          vm\\n        );\\n      } else {\\n        warn(\\n          'Failed to mount component: template or render function not defined.',\\n          vm\\n        );\\n      }\\n    }\\n  }\\n  callHook(vm, 'beforeMount');\\n\\n  var updateComponent;\\n  /* istanbul ignore if */\\n  if (\\\"development\\\" !== 'production' && config.performance && mark) {\\n    updateComponent = function () {\\n      var name = vm._name;\\n      var id = vm._uid;\\n      var startTag = \\\"vue-perf-start:\\\" + id;\\n      var endTag = \\\"vue-perf-end:\\\" + id;\\n\\n      mark(startTag);\\n      var vnode = vm._render();\\n      mark(endTag);\\n      measure((\\\"vue \\\" + name + \\\" render\\\"), startTag, endTag);\\n\\n      mark(startTag);\\n      vm._update(vnode, hydrating);\\n      mark(endTag);\\n      measure((\\\"vue \\\" + name + \\\" patch\\\"), startTag, endTag);\\n    };\\n  } else {\\n    updateComponent = function () {\\n      vm._update(vm._render(), hydrating);\\n    };\\n  }\\n\\n  // we set this to vm._watcher inside the watcher's constructor\\n  // since the watcher's initial patch may call $forceUpdate (e.g. inside child\\n  // component's mounted hook), which relies on vm._watcher being already defined\\n  new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */);\\n  hydrating = false;\\n\\n  // manually mounted instance, call mounted on self\\n  // mounted is called for render-created child components in its inserted hook\\n  if (vm.$vnode == null) {\\n    vm._isMounted = true;\\n    callHook(vm, 'mounted');\\n  }\\n  return vm\\n}\\n\\nfunction updateChildComponent (\\n  vm,\\n  propsData,\\n  listeners,\\n  parentVnode,\\n  renderChildren\\n) {\\n  if (true) {\\n    isUpdatingChildComponent = true;\\n  }\\n\\n  // determine whether component has slot children\\n  // we need to do this before overwriting $options._renderChildren\\n  var hasChildren = !!(\\n    renderChildren ||               // has new static slots\\n    vm.$options._renderChildren ||  // has old static slots\\n    parentVnode.data.scopedSlots || // has new scoped slots\\n    vm.$scopedSlots !== emptyObject // has old scoped slots\\n  );\\n\\n  vm.$options._parentVnode = parentVnode;\\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\\n\\n  if (vm._vnode) { // update child tree's parent\\n    vm._vnode.parent = parentVnode;\\n  }\\n  vm.$options._renderChildren = renderChildren;\\n\\n  // update $attrs and $listeners hash\\n  // these are also reactive so they may trigger child update if the child\\n  // used them during render\\n  vm.$attrs = parentVnode.data.attrs || emptyObject;\\n  vm.$listeners = listeners || emptyObject;\\n\\n  // update props\\n  if (propsData && vm.$options.props) {\\n    toggleObserving(false);\\n    var props = vm._props;\\n    var propKeys = vm.$options._propKeys || [];\\n    for (var i = 0; i < propKeys.length; i++) {\\n      var key = propKeys[i];\\n      var propOptions = vm.$options.props; // wtf flow?\\n      props[key] = validateProp(key, propOptions, propsData, vm);\\n    }\\n    toggleObserving(true);\\n    // keep a copy of raw propsData\\n    vm.$options.propsData = propsData;\\n  }\\n\\n  // update listeners\\n  listeners = listeners || emptyObject;\\n  var oldListeners = vm.$options._parentListeners;\\n  vm.$options._parentListeners = listeners;\\n  updateComponentListeners(vm, listeners, oldListeners);\\n\\n  // resolve slots + force update if has children\\n  if (hasChildren) {\\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\\n    vm.$forceUpdate();\\n  }\\n\\n  if (true) {\\n    isUpdatingChildComponent = false;\\n  }\\n}\\n\\nfunction isInInactiveTree (vm) {\\n  while (vm && (vm = vm.$parent)) {\\n    if (vm._inactive) { return true }\\n  }\\n  return false\\n}\\n\\nfunction activateChildComponent (vm, direct) {\\n  if (direct) {\\n    vm._directInactive = false;\\n    if (isInInactiveTree(vm)) {\\n      return\\n    }\\n  } else if (vm._directInactive) {\\n    return\\n  }\\n  if (vm._inactive || vm._inactive === null) {\\n    vm._inactive = false;\\n    for (var i = 0; i < vm.$children.length; i++) {\\n      activateChildComponent(vm.$children[i]);\\n    }\\n    callHook(vm, 'activated');\\n  }\\n}\\n\\nfunction deactivateChildComponent (vm, direct) {\\n  if (direct) {\\n    vm._directInactive = true;\\n    if (isInInactiveTree(vm)) {\\n      return\\n    }\\n  }\\n  if (!vm._inactive) {\\n    vm._inactive = true;\\n    for (var i = 0; i < vm.$children.length; i++) {\\n      deactivateChildComponent(vm.$children[i]);\\n    }\\n    callHook(vm, 'deactivated');\\n  }\\n}\\n\\nfunction callHook (vm, hook) {\\n  // #7573 disable dep collection when invoking lifecycle hooks\\n  pushTarget();\\n  var handlers = vm.$options[hook];\\n  if (handlers) {\\n    for (var i = 0, j = handlers.length; i < j; i++) {\\n      try {\\n        handlers[i].call(vm);\\n      } catch (e) {\\n        handleError(e, vm, (hook + \\\" hook\\\"));\\n      }\\n    }\\n  }\\n  if (vm._hasHookEvent) {\\n    vm.$emit('hook:' + hook);\\n  }\\n  popTarget();\\n}\\n\\n/*  */\\n\\n\\nvar MAX_UPDATE_COUNT = 100;\\n\\nvar queue = [];\\nvar activatedChildren = [];\\nvar has = {};\\nvar circular = {};\\nvar waiting = false;\\nvar flushing = false;\\nvar index = 0;\\n\\n/**\\n * Reset the scheduler's state.\\n */\\nfunction resetSchedulerState () {\\n  index = queue.length = activatedChildren.length = 0;\\n  has = {};\\n  if (true) {\\n    circular = {};\\n  }\\n  waiting = flushing = false;\\n}\\n\\n/**\\n * Flush both queues and run the watchers.\\n */\\nfunction flushSchedulerQueue () {\\n  flushing = true;\\n  var watcher, id;\\n\\n  // Sort queue before flush.\\n  // This ensures that:\\n  // 1. Components are updated from parent to child. (because parent is always\\n  //    created before the child)\\n  // 2. A component's user watchers are run before its render watcher (because\\n  //    user watchers are created before the render watcher)\\n  // 3. If a component is destroyed during a parent component's watcher run,\\n  //    its watchers can be skipped.\\n  queue.sort(function (a, b) { return a.id - b.id; });\\n\\n  // do not cache length because more watchers might be pushed\\n  // as we run existing watchers\\n  for (index = 0; index < queue.length; index++) {\\n    watcher = queue[index];\\n    id = watcher.id;\\n    has[id] = null;\\n    watcher.run();\\n    // in dev build, check and stop circular updates.\\n    if (\\\"development\\\" !== 'production' && has[id] != null) {\\n      circular[id] = (circular[id] || 0) + 1;\\n      if (circular[id] > MAX_UPDATE_COUNT) {\\n        warn(\\n          'You may have an infinite update loop ' + (\\n            watcher.user\\n              ? (\\\"in watcher with expression \\\\\\\"\\\" + (watcher.expression) + \\\"\\\\\\\"\\\")\\n              : \\\"in a component render function.\\\"\\n          ),\\n          watcher.vm\\n        );\\n        break\\n      }\\n    }\\n  }\\n\\n  // keep copies of post queues before resetting state\\n  var activatedQueue = activatedChildren.slice();\\n  var updatedQueue = queue.slice();\\n\\n  resetSchedulerState();\\n\\n  // call component updated and activated hooks\\n  callActivatedHooks(activatedQueue);\\n  callUpdatedHooks(updatedQueue);\\n\\n  // devtool hook\\n  /* istanbul ignore if */\\n  if (devtools && config.devtools) {\\n    devtools.emit('flush');\\n  }\\n}\\n\\nfunction callUpdatedHooks (queue) {\\n  var i = queue.length;\\n  while (i--) {\\n    var watcher = queue[i];\\n    var vm = watcher.vm;\\n    if (vm._watcher === watcher && vm._isMounted) {\\n      callHook(vm, 'updated');\\n    }\\n  }\\n}\\n\\n/**\\n * Queue a kept-alive component that was activated during patch.\\n * The queue will be processed after the entire tree has been patched.\\n */\\nfunction queueActivatedComponent (vm) {\\n  // setting _inactive to false here so that a render function can\\n  // rely on checking whether it's in an inactive tree (e.g. router-view)\\n  vm._inactive = false;\\n  activatedChildren.push(vm);\\n}\\n\\nfunction callActivatedHooks (queue) {\\n  for (var i = 0; i < queue.length; i++) {\\n    queue[i]._inactive = true;\\n    activateChildComponent(queue[i], true /* true */);\\n  }\\n}\\n\\n/**\\n * Push a watcher into the watcher queue.\\n * Jobs with duplicate IDs will be skipped unless it's\\n * pushed when the queue is being flushed.\\n */\\nfunction queueWatcher (watcher) {\\n  var id = watcher.id;\\n  if (has[id] == null) {\\n    has[id] = true;\\n    if (!flushing) {\\n      queue.push(watcher);\\n    } else {\\n      // if already flushing, splice the watcher based on its id\\n      // if already past its id, it will be run next immediately.\\n      var i = queue.length - 1;\\n      while (i > index && queue[i].id > watcher.id) {\\n        i--;\\n      }\\n      queue.splice(i + 1, 0, watcher);\\n    }\\n    // queue the flush\\n    if (!waiting) {\\n      waiting = true;\\n      nextTick(flushSchedulerQueue);\\n    }\\n  }\\n}\\n\\n/*  */\\n\\nvar uid$1 = 0;\\n\\n/**\\n * A watcher parses an expression, collects dependencies,\\n * and fires callback when the expression value changes.\\n * This is used for both the $watch() api and directives.\\n */\\nvar Watcher = function Watcher (\\n  vm,\\n  expOrFn,\\n  cb,\\n  options,\\n  isRenderWatcher\\n) {\\n  this.vm = vm;\\n  if (isRenderWatcher) {\\n    vm._watcher = this;\\n  }\\n  vm._watchers.push(this);\\n  // options\\n  if (options) {\\n    this.deep = !!options.deep;\\n    this.user = !!options.user;\\n    this.lazy = !!options.lazy;\\n    this.sync = !!options.sync;\\n  } else {\\n    this.deep = this.user = this.lazy = this.sync = false;\\n  }\\n  this.cb = cb;\\n  this.id = ++uid$1; // uid for batching\\n  this.active = true;\\n  this.dirty = this.lazy; // for lazy watchers\\n  this.deps = [];\\n  this.newDeps = [];\\n  this.depIds = new _Set();\\n  this.newDepIds = new _Set();\\n  this.expression =  true\\n    ? expOrFn.toString()\\n    : undefined;\\n  // parse expression for getter\\n  if (typeof expOrFn === 'function') {\\n    this.getter = expOrFn;\\n  } else {\\n    this.getter = parsePath(expOrFn);\\n    if (!this.getter) {\\n      this.getter = function () {};\\n      \\\"development\\\" !== 'production' && warn(\\n        \\\"Failed watching path: \\\\\\\"\\\" + expOrFn + \\\"\\\\\\\" \\\" +\\n        'Watcher only accepts simple dot-delimited paths. ' +\\n        'For full control, use a function instead.',\\n        vm\\n      );\\n    }\\n  }\\n  this.value = this.lazy\\n    ? undefined\\n    : this.get();\\n};\\n\\n/**\\n * Evaluate the getter, and re-collect dependencies.\\n */\\nWatcher.prototype.get = function get () {\\n  pushTarget(this);\\n  var value;\\n  var vm = this.vm;\\n  try {\\n    value = this.getter.call(vm, vm);\\n  } catch (e) {\\n    if (this.user) {\\n      handleError(e, vm, (\\\"getter for watcher \\\\\\\"\\\" + (this.expression) + \\\"\\\\\\\"\\\"));\\n    } else {\\n      throw e\\n    }\\n  } finally {\\n    // \\\"touch\\\" every property so they are all tracked as\\n    // dependencies for deep watching\\n    if (this.deep) {\\n      traverse(value);\\n    }\\n    popTarget();\\n    this.cleanupDeps();\\n  }\\n  return value\\n};\\n\\n/**\\n * Add a dependency to this directive.\\n */\\nWatcher.prototype.addDep = function addDep (dep) {\\n  var id = dep.id;\\n  if (!this.newDepIds.has(id)) {\\n    this.newDepIds.add(id);\\n    this.newDeps.push(dep);\\n    if (!this.depIds.has(id)) {\\n      dep.addSub(this);\\n    }\\n  }\\n};\\n\\n/**\\n * Clean up for dependency collection.\\n */\\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\\n    var this$1 = this;\\n\\n  var i = this.deps.length;\\n  while (i--) {\\n    var dep = this$1.deps[i];\\n    if (!this$1.newDepIds.has(dep.id)) {\\n      dep.removeSub(this$1);\\n    }\\n  }\\n  var tmp = this.depIds;\\n  this.depIds = this.newDepIds;\\n  this.newDepIds = tmp;\\n  this.newDepIds.clear();\\n  tmp = this.deps;\\n  this.deps = this.newDeps;\\n  this.newDeps = tmp;\\n  this.newDeps.length = 0;\\n};\\n\\n/**\\n * Subscriber interface.\\n * Will be called when a dependency changes.\\n */\\nWatcher.prototype.update = function update () {\\n  /* istanbul ignore else */\\n  if (this.lazy) {\\n    this.dirty = true;\\n  } else if (this.sync) {\\n    this.run();\\n  } else {\\n    queueWatcher(this);\\n  }\\n};\\n\\n/**\\n * Scheduler job interface.\\n * Will be called by the scheduler.\\n */\\nWatcher.prototype.run = function run () {\\n  if (this.active) {\\n    var value = this.get();\\n    if (\\n      value !== this.value ||\\n      // Deep watchers and watchers on Object/Arrays should fire even\\n      // when the value is the same, because the value may\\n      // have mutated.\\n      isObject(value) ||\\n      this.deep\\n    ) {\\n      // set new value\\n      var oldValue = this.value;\\n      this.value = value;\\n      if (this.user) {\\n        try {\\n          this.cb.call(this.vm, value, oldValue);\\n        } catch (e) {\\n          handleError(e, this.vm, (\\\"callback for watcher \\\\\\\"\\\" + (this.expression) + \\\"\\\\\\\"\\\"));\\n        }\\n      } else {\\n        this.cb.call(this.vm, value, oldValue);\\n      }\\n    }\\n  }\\n};\\n\\n/**\\n * Evaluate the value of the watcher.\\n * This only gets called for lazy watchers.\\n */\\nWatcher.prototype.evaluate = function evaluate () {\\n  this.value = this.get();\\n  this.dirty = false;\\n};\\n\\n/**\\n * Depend on all deps collected by this watcher.\\n */\\nWatcher.prototype.depend = function depend () {\\n    var this$1 = this;\\n\\n  var i = this.deps.length;\\n  while (i--) {\\n    this$1.deps[i].depend();\\n  }\\n};\\n\\n/**\\n * Remove self from all dependencies' subscriber list.\\n */\\nWatcher.prototype.teardown = function teardown () {\\n    var this$1 = this;\\n\\n  if (this.active) {\\n    // remove self from vm's watcher list\\n    // this is a somewhat expensive operation so we skip it\\n    // if the vm is being destroyed.\\n    if (!this.vm._isBeingDestroyed) {\\n      remove(this.vm._watchers, this);\\n    }\\n    var i = this.deps.length;\\n    while (i--) {\\n      this$1.deps[i].removeSub(this$1);\\n    }\\n    this.active = false;\\n  }\\n};\\n\\n/*  */\\n\\nvar sharedPropertyDefinition = {\\n  enumerable: true,\\n  configurable: true,\\n  get: noop,\\n  set: noop\\n};\\n\\nfunction proxy (target, sourceKey, key) {\\n  sharedPropertyDefinition.get = function proxyGetter () {\\n    return this[sourceKey][key]\\n  };\\n  sharedPropertyDefinition.set = function proxySetter (val) {\\n    this[sourceKey][key] = val;\\n  };\\n  Object.defineProperty(target, key, sharedPropertyDefinition);\\n}\\n\\nfunction initState (vm) {\\n  vm._watchers = [];\\n  var opts = vm.$options;\\n  if (opts.props) { initProps(vm, opts.props); }\\n  if (opts.methods) { initMethods(vm, opts.methods); }\\n  if (opts.data) {\\n    initData(vm);\\n  } else {\\n    observe(vm._data = {}, true /* asRootData */);\\n  }\\n  if (opts.computed) { initComputed(vm, opts.computed); }\\n  if (opts.watch && opts.watch !== nativeWatch) {\\n    initWatch(vm, opts.watch);\\n  }\\n}\\n\\nfunction initProps (vm, propsOptions) {\\n  var propsData = vm.$options.propsData || {};\\n  var props = vm._props = {};\\n  // cache prop keys so that future props updates can iterate using Array\\n  // instead of dynamic object key enumeration.\\n  var keys = vm.$options._propKeys = [];\\n  var isRoot = !vm.$parent;\\n  // root instance props should be converted\\n  if (!isRoot) {\\n    toggleObserving(false);\\n  }\\n  var loop = function ( key ) {\\n    keys.push(key);\\n    var value = validateProp(key, propsOptions, propsData, vm);\\n    /* istanbul ignore else */\\n    if (true) {\\n      var hyphenatedKey = hyphenate(key);\\n      if (isReservedAttribute(hyphenatedKey) ||\\n          config.isReservedAttr(hyphenatedKey)) {\\n        warn(\\n          (\\\"\\\\\\\"\\\" + hyphenatedKey + \\\"\\\\\\\" is a reserved attribute and cannot be used as component prop.\\\"),\\n          vm\\n        );\\n      }\\n      defineReactive(props, key, value, function () {\\n        if (vm.$parent && !isUpdatingChildComponent) {\\n          warn(\\n            \\\"Avoid mutating a prop directly since the value will be \\\" +\\n            \\\"overwritten whenever the parent component re-renders. \\\" +\\n            \\\"Instead, use a data or computed property based on the prop's \\\" +\\n            \\\"value. Prop being mutated: \\\\\\\"\\\" + key + \\\"\\\\\\\"\\\",\\n            vm\\n          );\\n        }\\n      });\\n    } else {}\\n    // static props are already proxied on the component's prototype\\n    // during Vue.extend(). We only need to proxy props defined at\\n    // instantiation here.\\n    if (!(key in vm)) {\\n      proxy(vm, \\\"_props\\\", key);\\n    }\\n  };\\n\\n  for (var key in propsOptions) loop( key );\\n  toggleObserving(true);\\n}\\n\\nfunction initData (vm) {\\n  var data = vm.$options.data;\\n  data = vm._data = typeof data === 'function'\\n    ? getData(data, vm)\\n    : data || {};\\n  if (!isPlainObject(data)) {\\n    data = {};\\n    \\\"development\\\" !== 'production' && warn(\\n      'data functions should return an object:\\\\n' +\\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\\n      vm\\n    );\\n  }\\n  // proxy data on instance\\n  var keys = Object.keys(data);\\n  var props = vm.$options.props;\\n  var methods = vm.$options.methods;\\n  var i = keys.length;\\n  while (i--) {\\n    var key = keys[i];\\n    if (true) {\\n      if (methods && hasOwn(methods, key)) {\\n        warn(\\n          (\\\"Method \\\\\\\"\\\" + key + \\\"\\\\\\\" has already been defined as a data property.\\\"),\\n          vm\\n        );\\n      }\\n    }\\n    if (props && hasOwn(props, key)) {\\n      \\\"development\\\" !== 'production' && warn(\\n        \\\"The data property \\\\\\\"\\\" + key + \\\"\\\\\\\" is already declared as a prop. \\\" +\\n        \\\"Use prop default value instead.\\\",\\n        vm\\n      );\\n    } else if (!isReserved(key)) {\\n      proxy(vm, \\\"_data\\\", key);\\n    }\\n  }\\n  // observe data\\n  observe(data, true /* asRootData */);\\n}\\n\\nfunction getData (data, vm) {\\n  // #7573 disable dep collection when invoking data getters\\n  pushTarget();\\n  try {\\n    return data.call(vm, vm)\\n  } catch (e) {\\n    handleError(e, vm, \\\"data()\\\");\\n    return {}\\n  } finally {\\n    popTarget();\\n  }\\n}\\n\\nvar computedWatcherOptions = { lazy: true };\\n\\nfunction initComputed (vm, computed) {\\n  // $flow-disable-line\\n  var watchers = vm._computedWatchers = Object.create(null);\\n  // computed properties are just getters during SSR\\n  var isSSR = isServerRendering();\\n\\n  for (var key in computed) {\\n    var userDef = computed[key];\\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\\n    if (\\\"development\\\" !== 'production' && getter == null) {\\n      warn(\\n        (\\\"Getter is missing for computed property \\\\\\\"\\\" + key + \\\"\\\\\\\".\\\"),\\n        vm\\n      );\\n    }\\n\\n    if (!isSSR) {\\n      // create internal watcher for the computed property.\\n      watchers[key] = new Watcher(\\n        vm,\\n        getter || noop,\\n        noop,\\n        computedWatcherOptions\\n      );\\n    }\\n\\n    // component-defined computed properties are already defined on the\\n    // component prototype. We only need to define computed properties defined\\n    // at instantiation here.\\n    if (!(key in vm)) {\\n      defineComputed(vm, key, userDef);\\n    } else if (true) {\\n      if (key in vm.$data) {\\n        warn((\\\"The computed property \\\\\\\"\\\" + key + \\\"\\\\\\\" is already defined in data.\\\"), vm);\\n      } else if (vm.$options.props && key in vm.$options.props) {\\n        warn((\\\"The computed property \\\\\\\"\\\" + key + \\\"\\\\\\\" is already defined as a prop.\\\"), vm);\\n      }\\n    }\\n  }\\n}\\n\\nfunction defineComputed (\\n  target,\\n  key,\\n  userDef\\n) {\\n  var shouldCache = !isServerRendering();\\n  if (typeof userDef === 'function') {\\n    sharedPropertyDefinition.get = shouldCache\\n      ? createComputedGetter(key)\\n      : userDef;\\n    sharedPropertyDefinition.set = noop;\\n  } else {\\n    sharedPropertyDefinition.get = userDef.get\\n      ? shouldCache && userDef.cache !== false\\n        ? createComputedGetter(key)\\n        : userDef.get\\n      : noop;\\n    sharedPropertyDefinition.set = userDef.set\\n      ? userDef.set\\n      : noop;\\n  }\\n  if (\\\"development\\\" !== 'production' &&\\n      sharedPropertyDefinition.set === noop) {\\n    sharedPropertyDefinition.set = function () {\\n      warn(\\n        (\\\"Computed property \\\\\\\"\\\" + key + \\\"\\\\\\\" was assigned to but it has no setter.\\\"),\\n        this\\n      );\\n    };\\n  }\\n  Object.defineProperty(target, key, sharedPropertyDefinition);\\n}\\n\\nfunction createComputedGetter (key) {\\n  return function computedGetter () {\\n    var watcher = this._computedWatchers && this._computedWatchers[key];\\n    if (watcher) {\\n      if (watcher.dirty) {\\n        watcher.evaluate();\\n      }\\n      if (Dep.target) {\\n        watcher.depend();\\n      }\\n      return watcher.value\\n    }\\n  }\\n}\\n\\nfunction initMethods (vm, methods) {\\n  var props = vm.$options.props;\\n  for (var key in methods) {\\n    if (true) {\\n      if (methods[key] == null) {\\n        warn(\\n          \\\"Method \\\\\\\"\\\" + key + \\\"\\\\\\\" has an undefined value in the component definition. \\\" +\\n          \\\"Did you reference the function correctly?\\\",\\n          vm\\n        );\\n      }\\n      if (props && hasOwn(props, key)) {\\n        warn(\\n          (\\\"Method \\\\\\\"\\\" + key + \\\"\\\\\\\" has already been defined as a prop.\\\"),\\n          vm\\n        );\\n      }\\n      if ((key in vm) && isReserved(key)) {\\n        warn(\\n          \\\"Method \\\\\\\"\\\" + key + \\\"\\\\\\\" conflicts with an existing Vue instance method. \\\" +\\n          \\\"Avoid defining component methods that start with _ or $.\\\"\\n        );\\n      }\\n    }\\n    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);\\n  }\\n}\\n\\nfunction initWatch (vm, watch) {\\n  for (var key in watch) {\\n    var handler = watch[key];\\n    if (Array.isArray(handler)) {\\n      for (var i = 0; i < handler.length; i++) {\\n        createWatcher(vm, key, handler[i]);\\n      }\\n    } else {\\n      createWatcher(vm, key, handler);\\n    }\\n  }\\n}\\n\\nfunction createWatcher (\\n  vm,\\n  expOrFn,\\n  handler,\\n  options\\n) {\\n  if (isPlainObject(handler)) {\\n    options = handler;\\n    handler = handler.handler;\\n  }\\n  if (typeof handler === 'string') {\\n    handler = vm[handler];\\n  }\\n  return vm.$watch(expOrFn, handler, options)\\n}\\n\\nfunction stateMixin (Vue) {\\n  // flow somehow has problems with directly declared definition object\\n  // when using Object.defineProperty, so we have to procedurally build up\\n  // the object here.\\n  var dataDef = {};\\n  dataDef.get = function () { return this._data };\\n  var propsDef = {};\\n  propsDef.get = function () { return this._props };\\n  if (true) {\\n    dataDef.set = function (newData) {\\n      warn(\\n        'Avoid replacing instance root $data. ' +\\n        'Use nested data properties instead.',\\n        this\\n      );\\n    };\\n    propsDef.set = function () {\\n      warn(\\\"$props is readonly.\\\", this);\\n    };\\n  }\\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\\n\\n  Vue.prototype.$set = set;\\n  Vue.prototype.$delete = del;\\n\\n  Vue.prototype.$watch = function (\\n    expOrFn,\\n    cb,\\n    options\\n  ) {\\n    var vm = this;\\n    if (isPlainObject(cb)) {\\n      return createWatcher(vm, expOrFn, cb, options)\\n    }\\n    options = options || {};\\n    options.user = true;\\n    var watcher = new Watcher(vm, expOrFn, cb, options);\\n    if (options.immediate) {\\n      cb.call(vm, watcher.value);\\n    }\\n    return function unwatchFn () {\\n      watcher.teardown();\\n    }\\n  };\\n}\\n\\n/*  */\\n\\nfunction initProvide (vm) {\\n  var provide = vm.$options.provide;\\n  if (provide) {\\n    vm._provided = typeof provide === 'function'\\n      ? provide.call(vm)\\n      : provide;\\n  }\\n}\\n\\nfunction initInjections (vm) {\\n  var result = resolveInject(vm.$options.inject, vm);\\n  if (result) {\\n    toggleObserving(false);\\n    Object.keys(result).forEach(function (key) {\\n      /* istanbul ignore else */\\n      if (true) {\\n        defineReactive(vm, key, result[key], function () {\\n          warn(\\n            \\\"Avoid mutating an injected value directly since the changes will be \\\" +\\n            \\\"overwritten whenever the provided component re-renders. \\\" +\\n            \\\"injection being mutated: \\\\\\\"\\\" + key + \\\"\\\\\\\"\\\",\\n            vm\\n          );\\n        });\\n      } else {}\\n    });\\n    toggleObserving(true);\\n  }\\n}\\n\\nfunction resolveInject (inject, vm) {\\n  if (inject) {\\n    // inject is :any because flow is not smart enough to figure out cached\\n    var result = Object.create(null);\\n    var keys = hasSymbol\\n      ? Reflect.ownKeys(inject).filter(function (key) {\\n        /* istanbul ignore next */\\n        return Object.getOwnPropertyDescriptor(inject, key).enumerable\\n      })\\n      : Object.keys(inject);\\n\\n    for (var i = 0; i < keys.length; i++) {\\n      var key = keys[i];\\n      var provideKey = inject[key].from;\\n      var source = vm;\\n      while (source) {\\n        if (source._provided && hasOwn(source._provided, provideKey)) {\\n          result[key] = source._provided[provideKey];\\n          break\\n        }\\n        source = source.$parent;\\n      }\\n      if (!source) {\\n        if ('default' in inject[key]) {\\n          var provideDefault = inject[key].default;\\n          result[key] = typeof provideDefault === 'function'\\n            ? provideDefault.call(vm)\\n            : provideDefault;\\n        } else if (true) {\\n          warn((\\\"Injection \\\\\\\"\\\" + key + \\\"\\\\\\\" not found\\\"), vm);\\n        }\\n      }\\n    }\\n    return result\\n  }\\n}\\n\\n/*  */\\n\\n/**\\n * Runtime helper for rendering v-for lists.\\n */\\nfunction renderList (\\n  val,\\n  render\\n) {\\n  var ret, i, l, keys, key;\\n  if (Array.isArray(val) || typeof val === 'string') {\\n    ret = new Array(val.length);\\n    for (i = 0, l = val.length; i < l; i++) {\\n      ret[i] = render(val[i], i);\\n    }\\n  } else if (typeof val === 'number') {\\n    ret = new Array(val);\\n    for (i = 0; i < val; i++) {\\n      ret[i] = render(i + 1, i);\\n    }\\n  } else if (isObject(val)) {\\n    keys = Object.keys(val);\\n    ret = new Array(keys.length);\\n    for (i = 0, l = keys.length; i < l; i++) {\\n      key = keys[i];\\n      ret[i] = render(val[key], key, i);\\n    }\\n  }\\n  if (isDef(ret)) {\\n    (ret)._isVList = true;\\n  }\\n  return ret\\n}\\n\\n/*  */\\n\\n/**\\n * Runtime helper for rendering <slot>\\n */\\nfunction renderSlot (\\n  name,\\n  fallback,\\n  props,\\n  bindObject\\n) {\\n  var scopedSlotFn = this.$scopedSlots[name];\\n  var nodes;\\n  if (scopedSlotFn) { // scoped slot\\n    props = props || {};\\n    if (bindObject) {\\n      if (\\\"development\\\" !== 'production' && !isObject(bindObject)) {\\n        warn(\\n          'slot v-bind without argument expects an Object',\\n          this\\n        );\\n      }\\n      props = extend(extend({}, bindObject), props);\\n    }\\n    nodes = scopedSlotFn(props) || fallback;\\n  } else {\\n    var slotNodes = this.$slots[name];\\n    // warn duplicate slot usage\\n    if (slotNodes) {\\n      if (\\\"development\\\" !== 'production' && slotNodes._rendered) {\\n        warn(\\n          \\\"Duplicate presence of slot \\\\\\\"\\\" + name + \\\"\\\\\\\" found in the same render tree \\\" +\\n          \\\"- this will likely cause render errors.\\\",\\n          this\\n        );\\n      }\\n      slotNodes._rendered = true;\\n    }\\n    nodes = slotNodes || fallback;\\n  }\\n\\n  var target = props && props.slot;\\n  if (target) {\\n    return this.$createElement('template', { slot: target }, nodes)\\n  } else {\\n    return nodes\\n  }\\n}\\n\\n/*  */\\n\\n/**\\n * Runtime helper for resolving filters\\n */\\nfunction resolveFilter (id) {\\n  return resolveAsset(this.$options, 'filters', id, true) || identity\\n}\\n\\n/*  */\\n\\nfunction isKeyNotMatch (expect, actual) {\\n  if (Array.isArray(expect)) {\\n    return expect.indexOf(actual) === -1\\n  } else {\\n    return expect !== actual\\n  }\\n}\\n\\n/**\\n * Runtime helper for checking keyCodes from config.\\n * exposed as Vue.prototype._k\\n * passing in eventKeyName as last argument separately for backwards compat\\n */\\nfunction checkKeyCodes (\\n  eventKeyCode,\\n  key,\\n  builtInKeyCode,\\n  eventKeyName,\\n  builtInKeyName\\n) {\\n  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\\n  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\\n    return isKeyNotMatch(builtInKeyName, eventKeyName)\\n  } else if (mappedKeyCode) {\\n    return isKeyNotMatch(mappedKeyCode, eventKeyCode)\\n  } else if (eventKeyName) {\\n    return hyphenate(eventKeyName) !== key\\n  }\\n}\\n\\n/*  */\\n\\n/**\\n * Runtime helper for merging v-bind=\\\"object\\\" into a VNode's data.\\n */\\nfunction bindObjectProps (\\n  data,\\n  tag,\\n  value,\\n  asProp,\\n  isSync\\n) {\\n  if (value) {\\n    if (!isObject(value)) {\\n      \\\"development\\\" !== 'production' && warn(\\n        'v-bind without argument expects an Object or Array value',\\n        this\\n      );\\n    } else {\\n      if (Array.isArray(value)) {\\n        value = toObject(value);\\n      }\\n      var hash;\\n      var loop = function ( key ) {\\n        if (\\n          key === 'class' ||\\n          key === 'style' ||\\n          isReservedAttribute(key)\\n        ) {\\n          hash = data;\\n        } else {\\n          var type = data.attrs && data.attrs.type;\\n          hash = asProp || config.mustUseProp(tag, type, key)\\n            ? data.domProps || (data.domProps = {})\\n            : data.attrs || (data.attrs = {});\\n        }\\n        if (!(key in hash)) {\\n          hash[key] = value[key];\\n\\n          if (isSync) {\\n            var on = data.on || (data.on = {});\\n            on[(\\\"update:\\\" + key)] = function ($event) {\\n              value[key] = $event;\\n            };\\n          }\\n        }\\n      };\\n\\n      for (var key in value) loop( key );\\n    }\\n  }\\n  return data\\n}\\n\\n/*  */\\n\\n/**\\n * Runtime helper for rendering static trees.\\n */\\nfunction renderStatic (\\n  index,\\n  isInFor\\n) {\\n  var cached = this._staticTrees || (this._staticTrees = []);\\n  var tree = cached[index];\\n  // if has already-rendered static tree and not inside v-for,\\n  // we can reuse the same tree.\\n  if (tree && !isInFor) {\\n    return tree\\n  }\\n  // otherwise, render a fresh tree.\\n  tree = cached[index] = this.$options.staticRenderFns[index].call(\\n    this._renderProxy,\\n    null,\\n    this // for render fns generated for functional component templates\\n  );\\n  markStatic(tree, (\\\"__static__\\\" + index), false);\\n  return tree\\n}\\n\\n/**\\n * Runtime helper for v-once.\\n * Effectively it means marking the node as static with a unique key.\\n */\\nfunction markOnce (\\n  tree,\\n  index,\\n  key\\n) {\\n  markStatic(tree, (\\\"__once__\\\" + index + (key ? (\\\"_\\\" + key) : \\\"\\\")), true);\\n  return tree\\n}\\n\\nfunction markStatic (\\n  tree,\\n  key,\\n  isOnce\\n) {\\n  if (Array.isArray(tree)) {\\n    for (var i = 0; i < tree.length; i++) {\\n      if (tree[i] && typeof tree[i] !== 'string') {\\n        markStaticNode(tree[i], (key + \\\"_\\\" + i), isOnce);\\n      }\\n    }\\n  } else {\\n    markStaticNode(tree, key, isOnce);\\n  }\\n}\\n\\nfunction markStaticNode (node, key, isOnce) {\\n  node.isStatic = true;\\n  node.key = key;\\n  node.isOnce = isOnce;\\n}\\n\\n/*  */\\n\\nfunction bindObjectListeners (data, value) {\\n  if (value) {\\n    if (!isPlainObject(value)) {\\n      \\\"development\\\" !== 'production' && warn(\\n        'v-on without argument expects an Object value',\\n        this\\n      );\\n    } else {\\n      var on = data.on = data.on ? extend({}, data.on) : {};\\n      for (var key in value) {\\n        var existing = on[key];\\n        var ours = value[key];\\n        on[key] = existing ? [].concat(existing, ours) : ours;\\n      }\\n    }\\n  }\\n  return data\\n}\\n\\n/*  */\\n\\nfunction installRenderHelpers (target) {\\n  target._o = markOnce;\\n  target._n = toNumber;\\n  target._s = toString;\\n  target._l = renderList;\\n  target._t = renderSlot;\\n  target._q = looseEqual;\\n  target._i = looseIndexOf;\\n  target._m = renderStatic;\\n  target._f = resolveFilter;\\n  target._k = checkKeyCodes;\\n  target._b = bindObjectProps;\\n  target._v = createTextVNode;\\n  target._e = createEmptyVNode;\\n  target._u = resolveScopedSlots;\\n  target._g = bindObjectListeners;\\n}\\n\\n/*  */\\n\\nfunction FunctionalRenderContext (\\n  data,\\n  props,\\n  children,\\n  parent,\\n  Ctor\\n) {\\n  var options = Ctor.options;\\n  // ensure the createElement function in functional components\\n  // gets a unique context - this is necessary for correct named slot check\\n  var contextVm;\\n  if (hasOwn(parent, '_uid')) {\\n    contextVm = Object.create(parent);\\n    // $flow-disable-line\\n    contextVm._original = parent;\\n  } else {\\n    // the context vm passed in is a functional context as well.\\n    // in this case we want to make sure we are able to get a hold to the\\n    // real context instance.\\n    contextVm = parent;\\n    // $flow-disable-line\\n    parent = parent._original;\\n  }\\n  var isCompiled = isTrue(options._compiled);\\n  var needNormalization = !isCompiled;\\n\\n  this.data = data;\\n  this.props = props;\\n  this.children = children;\\n  this.parent = parent;\\n  this.listeners = data.on || emptyObject;\\n  this.injections = resolveInject(options.inject, parent);\\n  this.slots = function () { return resolveSlots(children, parent); };\\n\\n  // support for compiled functional template\\n  if (isCompiled) {\\n    // exposing $options for renderStatic()\\n    this.$options = options;\\n    // pre-resolve slots for renderSlot()\\n    this.$slots = this.slots();\\n    this.$scopedSlots = data.scopedSlots || emptyObject;\\n  }\\n\\n  if (options._scopeId) {\\n    this._c = function (a, b, c, d) {\\n      var vnode = createElement(contextVm, a, b, c, d, needNormalization);\\n      if (vnode && !Array.isArray(vnode)) {\\n        vnode.fnScopeId = options._scopeId;\\n        vnode.fnContext = parent;\\n      }\\n      return vnode\\n    };\\n  } else {\\n    this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };\\n  }\\n}\\n\\ninstallRenderHelpers(FunctionalRenderContext.prototype);\\n\\nfunction createFunctionalComponent (\\n  Ctor,\\n  propsData,\\n  data,\\n  contextVm,\\n  children\\n) {\\n  var options = Ctor.options;\\n  var props = {};\\n  var propOptions = options.props;\\n  if (isDef(propOptions)) {\\n    for (var key in propOptions) {\\n      props[key] = validateProp(key, propOptions, propsData || emptyObject);\\n    }\\n  } else {\\n    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }\\n    if (isDef(data.props)) { mergeProps(props, data.props); }\\n  }\\n\\n  var renderContext = new FunctionalRenderContext(\\n    data,\\n    props,\\n    children,\\n    contextVm,\\n    Ctor\\n  );\\n\\n  var vnode = options.render.call(null, renderContext._c, renderContext);\\n\\n  if (vnode instanceof VNode) {\\n    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options)\\n  } else if (Array.isArray(vnode)) {\\n    var vnodes = normalizeChildren(vnode) || [];\\n    var res = new Array(vnodes.length);\\n    for (var i = 0; i < vnodes.length; i++) {\\n      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options);\\n    }\\n    return res\\n  }\\n}\\n\\nfunction cloneAndMarkFunctionalResult (vnode, data, contextVm, options) {\\n  // #7817 clone node before setting fnContext, otherwise if the node is reused\\n  // (e.g. it was from a cached normal slot) the fnContext causes named slots\\n  // that should not be matched to match.\\n  var clone = cloneVNode(vnode);\\n  clone.fnContext = contextVm;\\n  clone.fnOptions = options;\\n  if (data.slot) {\\n    (clone.data || (clone.data = {})).slot = data.slot;\\n  }\\n  return clone\\n}\\n\\nfunction mergeProps (to, from) {\\n  for (var key in from) {\\n    to[camelize(key)] = from[key];\\n  }\\n}\\n\\n/*  */\\n\\n\\n\\n\\n// Register the component hook to weex native render engine.\\n// The hook will be triggered by native, not javascript.\\n\\n\\n// Updates the state of the component to weex native render engine.\\n\\n/*  */\\n\\n// https://github.com/Hanks10100/weex-native-directive/tree/master/component\\n\\n// listening on native callback\\n\\n/*  */\\n\\n/*  */\\n\\n// inline hooks to be invoked on component VNodes during patch\\nvar componentVNodeHooks = {\\n  init: function init (\\n    vnode,\\n    hydrating,\\n    parentElm,\\n    refElm\\n  ) {\\n    if (\\n      vnode.componentInstance &&\\n      !vnode.componentInstance._isDestroyed &&\\n      vnode.data.keepAlive\\n    ) {\\n      // kept-alive components, treat as a patch\\n      var mountedNode = vnode; // work around flow\\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\\n    } else {\\n      var child = vnode.componentInstance = createComponentInstanceForVnode(\\n        vnode,\\n        activeInstance,\\n        parentElm,\\n        refElm\\n      );\\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\\n    }\\n  },\\n\\n  prepatch: function prepatch (oldVnode, vnode) {\\n    var options = vnode.componentOptions;\\n    var child = vnode.componentInstance = oldVnode.componentInstance;\\n    updateChildComponent(\\n      child,\\n      options.propsData, // updated props\\n      options.listeners, // updated listeners\\n      vnode, // new parent vnode\\n      options.children // new children\\n    );\\n  },\\n\\n  insert: function insert (vnode) {\\n    var context = vnode.context;\\n    var componentInstance = vnode.componentInstance;\\n    if (!componentInstance._isMounted) {\\n      componentInstance._isMounted = true;\\n      callHook(componentInstance, 'mounted');\\n    }\\n    if (vnode.data.keepAlive) {\\n      if (context._isMounted) {\\n        // vue-router#1212\\n        // During updates, a kept-alive component's child components may\\n        // change, so directly walking the tree here may call activated hooks\\n        // on incorrect children. Instead we push them into a queue which will\\n        // be processed after the whole patch process ended.\\n        queueActivatedComponent(componentInstance);\\n      } else {\\n        activateChildComponent(componentInstance, true /* direct */);\\n      }\\n    }\\n  },\\n\\n  destroy: function destroy (vnode) {\\n    var componentInstance = vnode.componentInstance;\\n    if (!componentInstance._isDestroyed) {\\n      if (!vnode.data.keepAlive) {\\n        componentInstance.$destroy();\\n      } else {\\n        deactivateChildComponent(componentInstance, true /* direct */);\\n      }\\n    }\\n  }\\n};\\n\\nvar hooksToMerge = Object.keys(componentVNodeHooks);\\n\\nfunction createComponent (\\n  Ctor,\\n  data,\\n  context,\\n  children,\\n  tag\\n) {\\n  if (isUndef(Ctor)) {\\n    return\\n  }\\n\\n  var baseCtor = context.$options._base;\\n\\n  // plain options object: turn it into a constructor\\n  if (isObject(Ctor)) {\\n    Ctor = baseCtor.extend(Ctor);\\n  }\\n\\n  // if at this stage it's not a constructor or an async component factory,\\n  // reject.\\n  if (typeof Ctor !== 'function') {\\n    if (true) {\\n      warn((\\\"Invalid Component definition: \\\" + (String(Ctor))), context);\\n    }\\n    return\\n  }\\n\\n  // async component\\n  var asyncFactory;\\n  if (isUndef(Ctor.cid)) {\\n    asyncFactory = Ctor;\\n    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);\\n    if (Ctor === undefined) {\\n      // return a placeholder node for async component, which is rendered\\n      // as a comment node but preserves all the raw information for the node.\\n      // the information will be used for async server-rendering and hydration.\\n      return createAsyncPlaceholder(\\n        asyncFactory,\\n        data,\\n        context,\\n        children,\\n        tag\\n      )\\n    }\\n  }\\n\\n  data = data || {};\\n\\n  // resolve constructor options in case global mixins are applied after\\n  // component constructor creation\\n  resolveConstructorOptions(Ctor);\\n\\n  // transform component v-model data into props & events\\n  if (isDef(data.model)) {\\n    transformModel(Ctor.options, data);\\n  }\\n\\n  // extract props\\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag);\\n\\n  // functional component\\n  if (isTrue(Ctor.options.functional)) {\\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\\n  }\\n\\n  // extract listeners, since these needs to be treated as\\n  // child component listeners instead of DOM listeners\\n  var listeners = data.on;\\n  // replace with listeners with .native modifier\\n  // so it gets processed during parent component patch.\\n  data.on = data.nativeOn;\\n\\n  if (isTrue(Ctor.options.abstract)) {\\n    // abstract components do not keep anything\\n    // other than props & listeners & slot\\n\\n    // work around flow\\n    var slot = data.slot;\\n    data = {};\\n    if (slot) {\\n      data.slot = slot;\\n    }\\n  }\\n\\n  // install component management hooks onto the placeholder node\\n  installComponentHooks(data);\\n\\n  // return a placeholder vnode\\n  var name = Ctor.options.name || tag;\\n  var vnode = new VNode(\\n    (\\\"vue-component-\\\" + (Ctor.cid) + (name ? (\\\"-\\\" + name) : '')),\\n    data, undefined, undefined, undefined, context,\\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },\\n    asyncFactory\\n  );\\n\\n  // Weex specific: invoke recycle-list optimized @render function for\\n  // extracting cell-slot template.\\n  // https://github.com/Hanks10100/weex-native-directive/tree/master/component\\n  /* istanbul ignore if */\\n  return vnode\\n}\\n\\nfunction createComponentInstanceForVnode (\\n  vnode, // we know it's MountedComponentVNode but flow doesn't\\n  parent, // activeInstance in lifecycle state\\n  parentElm,\\n  refElm\\n) {\\n  var options = {\\n    _isComponent: true,\\n    parent: parent,\\n    _parentVnode: vnode,\\n    _parentElm: parentElm || null,\\n    _refElm: refElm || null\\n  };\\n  // check inline-template render functions\\n  var inlineTemplate = vnode.data.inlineTemplate;\\n  if (isDef(inlineTemplate)) {\\n    options.render = inlineTemplate.render;\\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\\n  }\\n  return new vnode.componentOptions.Ctor(options)\\n}\\n\\nfunction installComponentHooks (data) {\\n  var hooks = data.hook || (data.hook = {});\\n  for (var i = 0; i < hooksToMerge.length; i++) {\\n    var key = hooksToMerge[i];\\n    hooks[key] = componentVNodeHooks[key];\\n  }\\n}\\n\\n// transform component v-model info (value and callback) into\\n// prop and event handler respectively.\\nfunction transformModel (options, data) {\\n  var prop = (options.model && options.model.prop) || 'value';\\n  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;\\n  var on = data.on || (data.on = {});\\n  if (isDef(on[event])) {\\n    on[event] = [data.model.callback].concat(on[event]);\\n  } else {\\n    on[event] = data.model.callback;\\n  }\\n}\\n\\n/*  */\\n\\nvar SIMPLE_NORMALIZE = 1;\\nvar ALWAYS_NORMALIZE = 2;\\n\\n// wrapper function for providing a more flexible interface\\n// without getting yelled at by flow\\nfunction createElement (\\n  context,\\n  tag,\\n  data,\\n  children,\\n  normalizationType,\\n  alwaysNormalize\\n) {\\n  if (Array.isArray(data) || isPrimitive(data)) {\\n    normalizationType = children;\\n    children = data;\\n    data = undefined;\\n  }\\n  if (isTrue(alwaysNormalize)) {\\n    normalizationType = ALWAYS_NORMALIZE;\\n  }\\n  return _createElement(context, tag, data, children, normalizationType)\\n}\\n\\nfunction _createElement (\\n  context,\\n  tag,\\n  data,\\n  children,\\n  normalizationType\\n) {\\n  if (isDef(data) && isDef((data).__ob__)) {\\n    \\\"development\\\" !== 'production' && warn(\\n      \\\"Avoid using observed data object as vnode data: \\\" + (JSON.stringify(data)) + \\\"\\\\n\\\" +\\n      'Always create fresh vnode data objects in each render!',\\n      context\\n    );\\n    return createEmptyVNode()\\n  }\\n  // object syntax in v-bind\\n  if (isDef(data) && isDef(data.is)) {\\n    tag = data.is;\\n  }\\n  if (!tag) {\\n    // in case of component :is set to falsy value\\n    return createEmptyVNode()\\n  }\\n  // warn against non-primitive key\\n  if (\\\"development\\\" !== 'production' &&\\n    isDef(data) && isDef(data.key) && !isPrimitive(data.key)\\n  ) {\\n    {\\n      warn(\\n        'Avoid using non-primitive value as key, ' +\\n        'use string/number value instead.',\\n        context\\n      );\\n    }\\n  }\\n  // support single function children as default scoped slot\\n  if (Array.isArray(children) &&\\n    typeof children[0] === 'function'\\n  ) {\\n    data = data || {};\\n    data.scopedSlots = { default: children[0] };\\n    children.length = 0;\\n  }\\n  if (normalizationType === ALWAYS_NORMALIZE) {\\n    children = normalizeChildren(children);\\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\\n    children = simpleNormalizeChildren(children);\\n  }\\n  var vnode, ns;\\n  if (typeof tag === 'string') {\\n    var Ctor;\\n    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);\\n    if (config.isReservedTag(tag)) {\\n      // platform built-in elements\\n      vnode = new VNode(\\n        config.parsePlatformTagName(tag), data, children,\\n        undefined, undefined, context\\n      );\\n    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\\n      // component\\n      vnode = createComponent(Ctor, data, context, children, tag);\\n    } else {\\n      // unknown or unlisted namespaced elements\\n      // check at runtime because it may get assigned a namespace when its\\n      // parent normalizes children\\n      vnode = new VNode(\\n        tag, data, children,\\n        undefined, undefined, context\\n      );\\n    }\\n  } else {\\n    // direct component options / constructor\\n    vnode = createComponent(tag, data, context, children);\\n  }\\n  if (Array.isArray(vnode)) {\\n    return vnode\\n  } else if (isDef(vnode)) {\\n    if (isDef(ns)) { applyNS(vnode, ns); }\\n    if (isDef(data)) { registerDeepBindings(data); }\\n    return vnode\\n  } else {\\n    return createEmptyVNode()\\n  }\\n}\\n\\nfunction applyNS (vnode, ns, force) {\\n  vnode.ns = ns;\\n  if (vnode.tag === 'foreignObject') {\\n    // use default namespace inside foreignObject\\n    ns = undefined;\\n    force = true;\\n  }\\n  if (isDef(vnode.children)) {\\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\\n      var child = vnode.children[i];\\n      if (isDef(child.tag) && (\\n        isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {\\n        applyNS(child, ns, force);\\n      }\\n    }\\n  }\\n}\\n\\n// ref #5318\\n// necessary to ensure parent re-render when deep bindings like :style and\\n// :class are used on slot nodes\\nfunction registerDeepBindings (data) {\\n  if (isObject(data.style)) {\\n    traverse(data.style);\\n  }\\n  if (isObject(data.class)) {\\n    traverse(data.class);\\n  }\\n}\\n\\n/*  */\\n\\nfunction initRender (vm) {\\n  vm._vnode = null; // the root of the child tree\\n  vm._staticTrees = null; // v-once cached trees\\n  var options = vm.$options;\\n  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree\\n  var renderContext = parentVnode && parentVnode.context;\\n  vm.$slots = resolveSlots(options._renderChildren, renderContext);\\n  vm.$scopedSlots = emptyObject;\\n  // bind the createElement fn to this instance\\n  // so that we get proper render context inside it.\\n  // args order: tag, data, children, normalizationType, alwaysNormalize\\n  // internal version is used by render functions compiled from templates\\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\\n  // normalization is always applied for the public version, used in\\n  // user-written render functions.\\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\\n\\n  // $attrs & $listeners are exposed for easier HOC creation.\\n  // they need to be reactive so that HOCs using them are always updated\\n  var parentData = parentVnode && parentVnode.data;\\n\\n  /* istanbul ignore else */\\n  if (true) {\\n    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {\\n      !isUpdatingChildComponent && warn(\\\"$attrs is readonly.\\\", vm);\\n    }, true);\\n    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, function () {\\n      !isUpdatingChildComponent && warn(\\\"$listeners is readonly.\\\", vm);\\n    }, true);\\n  } else {}\\n}\\n\\nfunction renderMixin (Vue) {\\n  // install runtime convenience helpers\\n  installRenderHelpers(Vue.prototype);\\n\\n  Vue.prototype.$nextTick = function (fn) {\\n    return nextTick(fn, this)\\n  };\\n\\n  Vue.prototype._render = function () {\\n    var vm = this;\\n    var ref = vm.$options;\\n    var render = ref.render;\\n    var _parentVnode = ref._parentVnode;\\n\\n    // reset _rendered flag on slots for duplicate slot check\\n    if (true) {\\n      for (var key in vm.$slots) {\\n        // $flow-disable-line\\n        vm.$slots[key]._rendered = false;\\n      }\\n    }\\n\\n    if (_parentVnode) {\\n      vm.$scopedSlots = _parentVnode.data.scopedSlots || emptyObject;\\n    }\\n\\n    // set parent vnode. this allows render functions to have access\\n    // to the data on the placeholder node.\\n    vm.$vnode = _parentVnode;\\n    // render self\\n    var vnode;\\n    try {\\n      vnode = render.call(vm._renderProxy, vm.$createElement);\\n    } catch (e) {\\n      handleError(e, vm, \\\"render\\\");\\n      // return error render result,\\n      // or previous vnode to prevent render error causing blank component\\n      /* istanbul ignore else */\\n      if (true) {\\n        if (vm.$options.renderError) {\\n          try {\\n            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);\\n          } catch (e) {\\n            handleError(e, vm, \\\"renderError\\\");\\n            vnode = vm._vnode;\\n          }\\n        } else {\\n          vnode = vm._vnode;\\n        }\\n      } else {}\\n    }\\n    // return empty vnode in case the render function errored out\\n    if (!(vnode instanceof VNode)) {\\n      if (\\\"development\\\" !== 'production' && Array.isArray(vnode)) {\\n        warn(\\n          'Multiple root nodes returned from render function. Render function ' +\\n          'should return a single root node.',\\n          vm\\n        );\\n      }\\n      vnode = createEmptyVNode();\\n    }\\n    // set parent\\n    vnode.parent = _parentVnode;\\n    return vnode\\n  };\\n}\\n\\n/*  */\\n\\nvar uid$3 = 0;\\n\\nfunction initMixin (Vue) {\\n  Vue.prototype._init = function (options) {\\n    var vm = this;\\n    // a uid\\n    vm._uid = uid$3++;\\n\\n    var startTag, endTag;\\n    /* istanbul ignore if */\\n    if (\\\"development\\\" !== 'production' && config.performance && mark) {\\n      startTag = \\\"vue-perf-start:\\\" + (vm._uid);\\n      endTag = \\\"vue-perf-end:\\\" + (vm._uid);\\n      mark(startTag);\\n    }\\n\\n    // a flag to avoid this being observed\\n    vm._isVue = true;\\n    // merge options\\n    if (options && options._isComponent) {\\n      // optimize internal component instantiation\\n      // since dynamic options merging is pretty slow, and none of the\\n      // internal component options needs special treatment.\\n      initInternalComponent(vm, options);\\n    } else {\\n      vm.$options = mergeOptions(\\n        resolveConstructorOptions(vm.constructor),\\n        options || {},\\n        vm\\n      );\\n    }\\n    /* istanbul ignore else */\\n    if (true) {\\n      initProxy(vm);\\n    } else {}\\n    // expose real self\\n    vm._self = vm;\\n    initLifecycle(vm);\\n    initEvents(vm);\\n    initRender(vm);\\n    callHook(vm, 'beforeCreate');\\n    initInjections(vm); // resolve injections before data/props\\n    initState(vm);\\n    initProvide(vm); // resolve provide after data/props\\n    callHook(vm, 'created');\\n\\n    /* istanbul ignore if */\\n    if (\\\"development\\\" !== 'production' && config.performance && mark) {\\n      vm._name = formatComponentName(vm, false);\\n      mark(endTag);\\n      measure((\\\"vue \\\" + (vm._name) + \\\" init\\\"), startTag, endTag);\\n    }\\n\\n    if (vm.$options.el) {\\n      vm.$mount(vm.$options.el);\\n    }\\n  };\\n}\\n\\nfunction initInternalComponent (vm, options) {\\n  var opts = vm.$options = Object.create(vm.constructor.options);\\n  // doing this because it's faster than dynamic enumeration.\\n  var parentVnode = options._parentVnode;\\n  opts.parent = options.parent;\\n  opts._parentVnode = parentVnode;\\n  opts._parentElm = options._parentElm;\\n  opts._refElm = options._refElm;\\n\\n  var vnodeComponentOptions = parentVnode.componentOptions;\\n  opts.propsData = vnodeComponentOptions.propsData;\\n  opts._parentListeners = vnodeComponentOptions.listeners;\\n  opts._renderChildren = vnodeComponentOptions.children;\\n  opts._componentTag = vnodeComponentOptions.tag;\\n\\n  if (options.render) {\\n    opts.render = options.render;\\n    opts.staticRenderFns = options.staticRenderFns;\\n  }\\n}\\n\\nfunction resolveConstructorOptions (Ctor) {\\n  var options = Ctor.options;\\n  if (Ctor.super) {\\n    var superOptions = resolveConstructorOptions(Ctor.super);\\n    var cachedSuperOptions = Ctor.superOptions;\\n    if (superOptions !== cachedSuperOptions) {\\n      // super option changed,\\n      // need to resolve new options.\\n      Ctor.superOptions = superOptions;\\n      // check if there are any late-modified/attached options (#4976)\\n      var modifiedOptions = resolveModifiedOptions(Ctor);\\n      // update base extend options\\n      if (modifiedOptions) {\\n        extend(Ctor.extendOptions, modifiedOptions);\\n      }\\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\\n      if (options.name) {\\n        options.components[options.name] = Ctor;\\n      }\\n    }\\n  }\\n  return options\\n}\\n\\nfunction resolveModifiedOptions (Ctor) {\\n  var modified;\\n  var latest = Ctor.options;\\n  var extended = Ctor.extendOptions;\\n  var sealed = Ctor.sealedOptions;\\n  for (var key in latest) {\\n    if (latest[key] !== sealed[key]) {\\n      if (!modified) { modified = {}; }\\n      modified[key] = dedupe(latest[key], extended[key], sealed[key]);\\n    }\\n  }\\n  return modified\\n}\\n\\nfunction dedupe (latest, extended, sealed) {\\n  // compare latest and sealed to ensure lifecycle hooks won't be duplicated\\n  // between merges\\n  if (Array.isArray(latest)) {\\n    var res = [];\\n    sealed = Array.isArray(sealed) ? sealed : [sealed];\\n    extended = Array.isArray(extended) ? extended : [extended];\\n    for (var i = 0; i < latest.length; i++) {\\n      // push original options and not sealed options to exclude duplicated options\\n      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {\\n        res.push(latest[i]);\\n      }\\n    }\\n    return res\\n  } else {\\n    return latest\\n  }\\n}\\n\\nfunction Vue (options) {\\n  if (\\\"development\\\" !== 'production' &&\\n    !(this instanceof Vue)\\n  ) {\\n    warn('Vue is a constructor and should be called with the `new` keyword');\\n  }\\n  this._init(options);\\n}\\n\\ninitMixin(Vue);\\nstateMixin(Vue);\\neventsMixin(Vue);\\nlifecycleMixin(Vue);\\nrenderMixin(Vue);\\n\\n/*  */\\n\\nfunction initUse (Vue) {\\n  Vue.use = function (plugin) {\\n    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));\\n    if (installedPlugins.indexOf(plugin) > -1) {\\n      return this\\n    }\\n\\n    // additional parameters\\n    var args = toArray(arguments, 1);\\n    args.unshift(this);\\n    if (typeof plugin.install === 'function') {\\n      plugin.install.apply(plugin, args);\\n    } else if (typeof plugin === 'function') {\\n      plugin.apply(null, args);\\n    }\\n    installedPlugins.push(plugin);\\n    return this\\n  };\\n}\\n\\n/*  */\\n\\nfunction initMixin$1 (Vue) {\\n  Vue.mixin = function (mixin) {\\n    this.options = mergeOptions(this.options, mixin);\\n    return this\\n  };\\n}\\n\\n/*  */\\n\\nfunction initExtend (Vue) {\\n  /**\\n   * Each instance constructor, including Vue, has a unique\\n   * cid. This enables us to create wrapped \\\"child\\n   * constructors\\\" for prototypal inheritance and cache them.\\n   */\\n  Vue.cid = 0;\\n  var cid = 1;\\n\\n  /**\\n   * Class inheritance\\n   */\\n  Vue.extend = function (extendOptions) {\\n    extendOptions = extendOptions || {};\\n    var Super = this;\\n    var SuperId = Super.cid;\\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\\n    if (cachedCtors[SuperId]) {\\n      return cachedCtors[SuperId]\\n    }\\n\\n    var name = extendOptions.name || Super.options.name;\\n    if (\\\"development\\\" !== 'production' && name) {\\n      validateComponentName(name);\\n    }\\n\\n    var Sub = function VueComponent (options) {\\n      this._init(options);\\n    };\\n    Sub.prototype = Object.create(Super.prototype);\\n    Sub.prototype.constructor = Sub;\\n    Sub.cid = cid++;\\n    Sub.options = mergeOptions(\\n      Super.options,\\n      extendOptions\\n    );\\n    Sub['super'] = Super;\\n\\n    // For props and computed properties, we define the proxy getters on\\n    // the Vue instances at extension time, on the extended prototype. This\\n    // avoids Object.defineProperty calls for each instance created.\\n    if (Sub.options.props) {\\n      initProps$1(Sub);\\n    }\\n    if (Sub.options.computed) {\\n      initComputed$1(Sub);\\n    }\\n\\n    // allow further extension/mixin/plugin usage\\n    Sub.extend = Super.extend;\\n    Sub.mixin = Super.mixin;\\n    Sub.use = Super.use;\\n\\n    // create asset registers, so extended classes\\n    // can have their private assets too.\\n    ASSET_TYPES.forEach(function (type) {\\n      Sub[type] = Super[type];\\n    });\\n    // enable recursive self-lookup\\n    if (name) {\\n      Sub.options.components[name] = Sub;\\n    }\\n\\n    // keep a reference to the super options at extension time.\\n    // later at instantiation we can check if Super's options have\\n    // been updated.\\n    Sub.superOptions = Super.options;\\n    Sub.extendOptions = extendOptions;\\n    Sub.sealedOptions = extend({}, Sub.options);\\n\\n    // cache constructor\\n    cachedCtors[SuperId] = Sub;\\n    return Sub\\n  };\\n}\\n\\nfunction initProps$1 (Comp) {\\n  var props = Comp.options.props;\\n  for (var key in props) {\\n    proxy(Comp.prototype, \\\"_props\\\", key);\\n  }\\n}\\n\\nfunction initComputed$1 (Comp) {\\n  var computed = Comp.options.computed;\\n  for (var key in computed) {\\n    defineComputed(Comp.prototype, key, computed[key]);\\n  }\\n}\\n\\n/*  */\\n\\nfunction initAssetRegisters (Vue) {\\n  /**\\n   * Create asset registration methods.\\n   */\\n  ASSET_TYPES.forEach(function (type) {\\n    Vue[type] = function (\\n      id,\\n      definition\\n    ) {\\n      if (!definition) {\\n        return this.options[type + 's'][id]\\n      } else {\\n        /* istanbul ignore if */\\n        if (\\\"development\\\" !== 'production' && type === 'component') {\\n          validateComponentName(id);\\n        }\\n        if (type === 'component' && isPlainObject(definition)) {\\n          definition.name = definition.name || id;\\n          definition = this.options._base.extend(definition);\\n        }\\n        if (type === 'directive' && typeof definition === 'function') {\\n          definition = { bind: definition, update: definition };\\n        }\\n        this.options[type + 's'][id] = definition;\\n        return definition\\n      }\\n    };\\n  });\\n}\\n\\n/*  */\\n\\nfunction getComponentName (opts) {\\n  return opts && (opts.Ctor.options.name || opts.tag)\\n}\\n\\nfunction matches (pattern, name) {\\n  if (Array.isArray(pattern)) {\\n    return pattern.indexOf(name) > -1\\n  } else if (typeof pattern === 'string') {\\n    return pattern.split(',').indexOf(name) > -1\\n  } else if (isRegExp(pattern)) {\\n    return pattern.test(name)\\n  }\\n  /* istanbul ignore next */\\n  return false\\n}\\n\\nfunction pruneCache (keepAliveInstance, filter) {\\n  var cache = keepAliveInstance.cache;\\n  var keys = keepAliveInstance.keys;\\n  var _vnode = keepAliveInstance._vnode;\\n  for (var key in cache) {\\n    var cachedNode = cache[key];\\n    if (cachedNode) {\\n      var name = getComponentName(cachedNode.componentOptions);\\n      if (name && !filter(name)) {\\n        pruneCacheEntry(cache, key, keys, _vnode);\\n      }\\n    }\\n  }\\n}\\n\\nfunction pruneCacheEntry (\\n  cache,\\n  key,\\n  keys,\\n  current\\n) {\\n  var cached$$1 = cache[key];\\n  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {\\n    cached$$1.componentInstance.$destroy();\\n  }\\n  cache[key] = null;\\n  remove(keys, key);\\n}\\n\\nvar patternTypes = [String, RegExp, Array];\\n\\nvar KeepAlive = {\\n  name: 'keep-alive',\\n  abstract: true,\\n\\n  props: {\\n    include: patternTypes,\\n    exclude: patternTypes,\\n    max: [String, Number]\\n  },\\n\\n  created: function created () {\\n    this.cache = Object.create(null);\\n    this.keys = [];\\n  },\\n\\n  destroyed: function destroyed () {\\n    var this$1 = this;\\n\\n    for (var key in this$1.cache) {\\n      pruneCacheEntry(this$1.cache, key, this$1.keys);\\n    }\\n  },\\n\\n  mounted: function mounted () {\\n    var this$1 = this;\\n\\n    this.$watch('include', function (val) {\\n      pruneCache(this$1, function (name) { return matches(val, name); });\\n    });\\n    this.$watch('exclude', function (val) {\\n      pruneCache(this$1, function (name) { return !matches(val, name); });\\n    });\\n  },\\n\\n  render: function render () {\\n    var slot = this.$slots.default;\\n    var vnode = getFirstComponentChild(slot);\\n    var componentOptions = vnode && vnode.componentOptions;\\n    if (componentOptions) {\\n      // check pattern\\n      var name = getComponentName(componentOptions);\\n      var ref = this;\\n      var include = ref.include;\\n      var exclude = ref.exclude;\\n      if (\\n        // not included\\n        (include && (!name || !matches(include, name))) ||\\n        // excluded\\n        (exclude && name && matches(exclude, name))\\n      ) {\\n        return vnode\\n      }\\n\\n      var ref$1 = this;\\n      var cache = ref$1.cache;\\n      var keys = ref$1.keys;\\n      var key = vnode.key == null\\n        // same constructor may get registered as different local components\\n        // so cid alone is not enough (#3269)\\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\\\"::\\\" + (componentOptions.tag)) : '')\\n        : vnode.key;\\n      if (cache[key]) {\\n        vnode.componentInstance = cache[key].componentInstance;\\n        // make current key freshest\\n        remove(keys, key);\\n        keys.push(key);\\n      } else {\\n        cache[key] = vnode;\\n        keys.push(key);\\n        // prune oldest entry\\n        if (this.max && keys.length > parseInt(this.max)) {\\n          pruneCacheEntry(cache, keys[0], keys, this._vnode);\\n        }\\n      }\\n\\n      vnode.data.keepAlive = true;\\n    }\\n    return vnode || (slot && slot[0])\\n  }\\n}\\n\\nvar builtInComponents = {\\n  KeepAlive: KeepAlive\\n}\\n\\n/*  */\\n\\nfunction initGlobalAPI (Vue) {\\n  // config\\n  var configDef = {};\\n  configDef.get = function () { return config; };\\n  if (true) {\\n    configDef.set = function () {\\n      warn(\\n        'Do not replace the Vue.config object, set individual fields instead.'\\n      );\\n    };\\n  }\\n  Object.defineProperty(Vue, 'config', configDef);\\n\\n  // exposed util methods.\\n  // NOTE: these are not considered part of the public API - avoid relying on\\n  // them unless you are aware of the risk.\\n  Vue.util = {\\n    warn: warn,\\n    extend: extend,\\n    mergeOptions: mergeOptions,\\n    defineReactive: defineReactive\\n  };\\n\\n  Vue.set = set;\\n  Vue.delete = del;\\n  Vue.nextTick = nextTick;\\n\\n  Vue.options = Object.create(null);\\n  ASSET_TYPES.forEach(function (type) {\\n    Vue.options[type + 's'] = Object.create(null);\\n  });\\n\\n  // this is used to identify the \\\"base\\\" constructor to extend all plain-object\\n  // components with in Weex's multi-instance scenarios.\\n  Vue.options._base = Vue;\\n\\n  extend(Vue.options.components, builtInComponents);\\n\\n  initUse(Vue);\\n  initMixin$1(Vue);\\n  initExtend(Vue);\\n  initAssetRegisters(Vue);\\n}\\n\\ninitGlobalAPI(Vue);\\n\\nObject.defineProperty(Vue.prototype, '$isServer', {\\n  get: isServerRendering\\n});\\n\\nObject.defineProperty(Vue.prototype, '$ssrContext', {\\n  get: function get () {\\n    /* istanbul ignore next */\\n    return this.$vnode && this.$vnode.ssrContext\\n  }\\n});\\n\\n// expose FunctionalRenderContext for ssr runtime helper installation\\nObject.defineProperty(Vue, 'FunctionalRenderContext', {\\n  value: FunctionalRenderContext\\n});\\n\\nVue.version = '2.5.16';\\n\\n/*  */\\n\\n// these are reserved for web because they are directly compiled away\\n// during template compilation\\nvar isReservedAttr = makeMap('style,class');\\n\\n// attributes that should be using props for binding\\nvar acceptValue = makeMap('input,textarea,option,select,progress');\\nvar mustUseProp = function (tag, type, attr) {\\n  return (\\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\\n    (attr === 'selected' && tag === 'option') ||\\n    (attr === 'checked' && tag === 'input') ||\\n    (attr === 'muted' && tag === 'video')\\n  )\\n};\\n\\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\\n\\nvar isBooleanAttr = makeMap(\\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\\n  'truespeed,typemustmatch,visible'\\n);\\n\\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\\n\\nvar isXlink = function (name) {\\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\\n};\\n\\nvar getXlinkProp = function (name) {\\n  return isXlink(name) ? name.slice(6, name.length) : ''\\n};\\n\\nvar isFalsyAttrValue = function (val) {\\n  return val == null || val === false\\n};\\n\\n/*  */\\n\\nfunction genClassForVnode (vnode) {\\n  var data = vnode.data;\\n  var parentNode = vnode;\\n  var childNode = vnode;\\n  while (isDef(childNode.componentInstance)) {\\n    childNode = childNode.componentInstance._vnode;\\n    if (childNode && childNode.data) {\\n      data = mergeClassData(childNode.data, data);\\n    }\\n  }\\n  while (isDef(parentNode = parentNode.parent)) {\\n    if (parentNode && parentNode.data) {\\n      data = mergeClassData(data, parentNode.data);\\n    }\\n  }\\n  return renderClass(data.staticClass, data.class)\\n}\\n\\nfunction mergeClassData (child, parent) {\\n  return {\\n    staticClass: concat(child.staticClass, parent.staticClass),\\n    class: isDef(child.class)\\n      ? [child.class, parent.class]\\n      : parent.class\\n  }\\n}\\n\\nfunction renderClass (\\n  staticClass,\\n  dynamicClass\\n) {\\n  if (isDef(staticClass) || isDef(dynamicClass)) {\\n    return concat(staticClass, stringifyClass(dynamicClass))\\n  }\\n  /* istanbul ignore next */\\n  return ''\\n}\\n\\nfunction concat (a, b) {\\n  return a ? b ? (a + ' ' + b) : a : (b || '')\\n}\\n\\nfunction stringifyClass (value) {\\n  if (Array.isArray(value)) {\\n    return stringifyArray(value)\\n  }\\n  if (isObject(value)) {\\n    return stringifyObject(value)\\n  }\\n  if (typeof value === 'string') {\\n    return value\\n  }\\n  /* istanbul ignore next */\\n  return ''\\n}\\n\\nfunction stringifyArray (value) {\\n  var res = '';\\n  var stringified;\\n  for (var i = 0, l = value.length; i < l; i++) {\\n    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\\n      if (res) { res += ' '; }\\n      res += stringified;\\n    }\\n  }\\n  return res\\n}\\n\\nfunction stringifyObject (value) {\\n  var res = '';\\n  for (var key in value) {\\n    if (value[key]) {\\n      if (res) { res += ' '; }\\n      res += key;\\n    }\\n  }\\n  return res\\n}\\n\\n/*  */\\n\\nvar namespaceMap = {\\n  svg: 'http://www.w3.org/2000/svg',\\n  math: 'http://www.w3.org/1998/Math/MathML'\\n};\\n\\nvar isHTMLTag = makeMap(\\n  'html,body,base,head,link,meta,style,title,' +\\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\\n  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +\\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\\n  'output,progress,select,textarea,' +\\n  'details,dialog,menu,menuitem,summary,' +\\n  'content,element,shadow,template,blockquote,iframe,tfoot'\\n);\\n\\n// this map is intentionally selective, only covering SVG elements that may\\n// contain child elements.\\nvar isSVG = makeMap(\\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\\n  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\\n  true\\n);\\n\\n\\n\\nvar isReservedTag = function (tag) {\\n  return isHTMLTag(tag) || isSVG(tag)\\n};\\n\\nfunction getTagNamespace (tag) {\\n  if (isSVG(tag)) {\\n    return 'svg'\\n  }\\n  // basic support for MathML\\n  // note it doesn't support other MathML elements being component roots\\n  if (tag === 'math') {\\n    return 'math'\\n  }\\n}\\n\\nvar unknownElementCache = Object.create(null);\\nfunction isUnknownElement (tag) {\\n  /* istanbul ignore if */\\n  if (!inBrowser) {\\n    return true\\n  }\\n  if (isReservedTag(tag)) {\\n    return false\\n  }\\n  tag = tag.toLowerCase();\\n  /* istanbul ignore if */\\n  if (unknownElementCache[tag] != null) {\\n    return unknownElementCache[tag]\\n  }\\n  var el = document.createElement(tag);\\n  if (tag.indexOf('-') > -1) {\\n    // http://stackoverflow.com/a/28210364/1070244\\n    return (unknownElementCache[tag] = (\\n      el.constructor === window.HTMLUnknownElement ||\\n      el.constructor === window.HTMLElement\\n    ))\\n  } else {\\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\\n  }\\n}\\n\\nvar isTextInputType = makeMap('text,number,password,search,email,tel,url');\\n\\n/*  */\\n\\n/**\\n * Query an element selector if it's not an element already.\\n */\\nfunction query (el) {\\n  if (typeof el === 'string') {\\n    var selected = document.querySelector(el);\\n    if (!selected) {\\n      \\\"development\\\" !== 'production' && warn(\\n        'Cannot find element: ' + el\\n      );\\n      return document.createElement('div')\\n    }\\n    return selected\\n  } else {\\n    return el\\n  }\\n}\\n\\n/*  */\\n\\nfunction createElement$1 (tagName, vnode) {\\n  var elm = document.createElement(tagName);\\n  if (tagName !== 'select') {\\n    return elm\\n  }\\n  // false or null will remove the attribute but undefined will not\\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\\n    elm.setAttribute('multiple', 'multiple');\\n  }\\n  return elm\\n}\\n\\nfunction createElementNS (namespace, tagName) {\\n  return document.createElementNS(namespaceMap[namespace], tagName)\\n}\\n\\nfunction createTextNode (text) {\\n  return document.createTextNode(text)\\n}\\n\\nfunction createComment (text) {\\n  return document.createComment(text)\\n}\\n\\nfunction insertBefore (parentNode, newNode, referenceNode) {\\n  parentNode.insertBefore(newNode, referenceNode);\\n}\\n\\nfunction removeChild (node, child) {\\n  node.removeChild(child);\\n}\\n\\nfunction appendChild (node, child) {\\n  node.appendChild(child);\\n}\\n\\nfunction parentNode (node) {\\n  return node.parentNode\\n}\\n\\nfunction nextSibling (node) {\\n  return node.nextSibling\\n}\\n\\nfunction tagName (node) {\\n  return node.tagName\\n}\\n\\nfunction setTextContent (node, text) {\\n  node.textContent = text;\\n}\\n\\nfunction setStyleScope (node, scopeId) {\\n  node.setAttribute(scopeId, '');\\n}\\n\\n\\nvar nodeOps = Object.freeze({\\n\\tcreateElement: createElement$1,\\n\\tcreateElementNS: createElementNS,\\n\\tcreateTextNode: createTextNode,\\n\\tcreateComment: createComment,\\n\\tinsertBefore: insertBefore,\\n\\tremoveChild: removeChild,\\n\\tappendChild: appendChild,\\n\\tparentNode: parentNode,\\n\\tnextSibling: nextSibling,\\n\\ttagName: tagName,\\n\\tsetTextContent: setTextContent,\\n\\tsetStyleScope: setStyleScope\\n});\\n\\n/*  */\\n\\nvar ref = {\\n  create: function create (_, vnode) {\\n    registerRef(vnode);\\n  },\\n  update: function update (oldVnode, vnode) {\\n    if (oldVnode.data.ref !== vnode.data.ref) {\\n      registerRef(oldVnode, true);\\n      registerRef(vnode);\\n    }\\n  },\\n  destroy: function destroy (vnode) {\\n    registerRef(vnode, true);\\n  }\\n}\\n\\nfunction registerRef (vnode, isRemoval) {\\n  var key = vnode.data.ref;\\n  if (!isDef(key)) { return }\\n\\n  var vm = vnode.context;\\n  var ref = vnode.componentInstance || vnode.elm;\\n  var refs = vm.$refs;\\n  if (isRemoval) {\\n    if (Array.isArray(refs[key])) {\\n      remove(refs[key], ref);\\n    } else if (refs[key] === ref) {\\n      refs[key] = undefined;\\n    }\\n  } else {\\n    if (vnode.data.refInFor) {\\n      if (!Array.isArray(refs[key])) {\\n        refs[key] = [ref];\\n      } else if (refs[key].indexOf(ref) < 0) {\\n        // $flow-disable-line\\n        refs[key].push(ref);\\n      }\\n    } else {\\n      refs[key] = ref;\\n    }\\n  }\\n}\\n\\n/**\\n * Virtual DOM patching algorithm based on Snabbdom by\\n * Simon Friis Vindum (@paldepind)\\n * Licensed under the MIT License\\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\\n *\\n * modified by Evan You (@yyx990803)\\n *\\n * Not type-checking this because this file is perf-critical and the cost\\n * of making flow understand it is not worth it.\\n */\\n\\nvar emptyNode = new VNode('', {}, []);\\n\\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\\n\\nfunction sameVnode (a, b) {\\n  return (\\n    a.key === b.key && (\\n      (\\n        a.tag === b.tag &&\\n        a.isComment === b.isComment &&\\n        isDef(a.data) === isDef(b.data) &&\\n        sameInputType(a, b)\\n      ) || (\\n        isTrue(a.isAsyncPlaceholder) &&\\n        a.asyncFactory === b.asyncFactory &&\\n        isUndef(b.asyncFactory.error)\\n      )\\n    )\\n  )\\n}\\n\\nfunction sameInputType (a, b) {\\n  if (a.tag !== 'input') { return true }\\n  var i;\\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\\n  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)\\n}\\n\\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\\n  var i, key;\\n  var map = {};\\n  for (i = beginIdx; i <= endIdx; ++i) {\\n    key = children[i].key;\\n    if (isDef(key)) { map[key] = i; }\\n  }\\n  return map\\n}\\n\\nfunction createPatchFunction (backend) {\\n  var i, j;\\n  var cbs = {};\\n\\n  var modules = backend.modules;\\n  var nodeOps = backend.nodeOps;\\n\\n  for (i = 0; i < hooks.length; ++i) {\\n    cbs[hooks[i]] = [];\\n    for (j = 0; j < modules.length; ++j) {\\n      if (isDef(modules[j][hooks[i]])) {\\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\\n      }\\n    }\\n  }\\n\\n  function emptyNodeAt (elm) {\\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\\n  }\\n\\n  function createRmCb (childElm, listeners) {\\n    function remove () {\\n      if (--remove.listeners === 0) {\\n        removeNode(childElm);\\n      }\\n    }\\n    remove.listeners = listeners;\\n    return remove\\n  }\\n\\n  function removeNode (el) {\\n    var parent = nodeOps.parentNode(el);\\n    // element may have already been removed due to v-html / v-text\\n    if (isDef(parent)) {\\n      nodeOps.removeChild(parent, el);\\n    }\\n  }\\n\\n  function isUnknownElement$$1 (vnode, inVPre) {\\n    return (\\n      !inVPre &&\\n      !vnode.ns &&\\n      !(\\n        config.ignoredElements.length &&\\n        config.ignoredElements.some(function (ignore) {\\n          return isRegExp(ignore)\\n            ? ignore.test(vnode.tag)\\n            : ignore === vnode.tag\\n        })\\n      ) &&\\n      config.isUnknownElement(vnode.tag)\\n    )\\n  }\\n\\n  var creatingElmInVPre = 0;\\n\\n  function createElm (\\n    vnode,\\n    insertedVnodeQueue,\\n    parentElm,\\n    refElm,\\n    nested,\\n    ownerArray,\\n    index\\n  ) {\\n    if (isDef(vnode.elm) && isDef(ownerArray)) {\\n      // This vnode was used in a previous render!\\n      // now it's used as a new node, overwriting its elm would cause\\n      // potential patch errors down the road when it's used as an insertion\\n      // reference node. Instead, we clone the node on-demand before creating\\n      // associated DOM element for it.\\n      vnode = ownerArray[index] = cloneVNode(vnode);\\n    }\\n\\n    vnode.isRootInsert = !nested; // for transition enter check\\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\\n      return\\n    }\\n\\n    var data = vnode.data;\\n    var children = vnode.children;\\n    var tag = vnode.tag;\\n    if (isDef(tag)) {\\n      if (true) {\\n        if (data && data.pre) {\\n          creatingElmInVPre++;\\n        }\\n        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {\\n          warn(\\n            'Unknown custom element: <' + tag + '> - did you ' +\\n            'register the component correctly? For recursive components, ' +\\n            'make sure to provide the \\\"name\\\" option.',\\n            vnode.context\\n          );\\n        }\\n      }\\n\\n      vnode.elm = vnode.ns\\n        ? nodeOps.createElementNS(vnode.ns, tag)\\n        : nodeOps.createElement(tag, vnode);\\n      setScope(vnode);\\n\\n      /* istanbul ignore if */\\n      {\\n        createChildren(vnode, children, insertedVnodeQueue);\\n        if (isDef(data)) {\\n          invokeCreateHooks(vnode, insertedVnodeQueue);\\n        }\\n        insert(parentElm, vnode.elm, refElm);\\n      }\\n\\n      if (\\\"development\\\" !== 'production' && data && data.pre) {\\n        creatingElmInVPre--;\\n      }\\n    } else if (isTrue(vnode.isComment)) {\\n      vnode.elm = nodeOps.createComment(vnode.text);\\n      insert(parentElm, vnode.elm, refElm);\\n    } else {\\n      vnode.elm = nodeOps.createTextNode(vnode.text);\\n      insert(parentElm, vnode.elm, refElm);\\n    }\\n  }\\n\\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\\n    var i = vnode.data;\\n    if (isDef(i)) {\\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\\n        i(vnode, false /* hydrating */, parentElm, refElm);\\n      }\\n      // after calling the init hook, if the vnode is a child component\\n      // it should've created a child instance and mounted it. the child\\n      // component also has set the placeholder vnode's elm.\\n      // in that case we can just return the element and be done.\\n      if (isDef(vnode.componentInstance)) {\\n        initComponent(vnode, insertedVnodeQueue);\\n        if (isTrue(isReactivated)) {\\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\\n        }\\n        return true\\n      }\\n    }\\n  }\\n\\n  function initComponent (vnode, insertedVnodeQueue) {\\n    if (isDef(vnode.data.pendingInsert)) {\\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\\n      vnode.data.pendingInsert = null;\\n    }\\n    vnode.elm = vnode.componentInstance.$el;\\n    if (isPatchable(vnode)) {\\n      invokeCreateHooks(vnode, insertedVnodeQueue);\\n      setScope(vnode);\\n    } else {\\n      // empty component root.\\n      // skip all element-related modules except for ref (#3455)\\n      registerRef(vnode);\\n      // make sure to invoke the insert hook\\n      insertedVnodeQueue.push(vnode);\\n    }\\n  }\\n\\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\\n    var i;\\n    // hack for #4339: a reactivated component with inner transition\\n    // does not trigger because the inner node's created hooks are not called\\n    // again. It's not ideal to involve module-specific logic in here but\\n    // there doesn't seem to be a better way to do it.\\n    var innerNode = vnode;\\n    while (innerNode.componentInstance) {\\n      innerNode = innerNode.componentInstance._vnode;\\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\\n        for (i = 0; i < cbs.activate.length; ++i) {\\n          cbs.activate[i](emptyNode, innerNode);\\n        }\\n        insertedVnodeQueue.push(innerNode);\\n        break\\n      }\\n    }\\n    // unlike a newly created component,\\n    // a reactivated keep-alive component doesn't insert itself\\n    insert(parentElm, vnode.elm, refElm);\\n  }\\n\\n  function insert (parent, elm, ref$$1) {\\n    if (isDef(parent)) {\\n      if (isDef(ref$$1)) {\\n        if (ref$$1.parentNode === parent) {\\n          nodeOps.insertBefore(parent, elm, ref$$1);\\n        }\\n      } else {\\n        nodeOps.appendChild(parent, elm);\\n      }\\n    }\\n  }\\n\\n  function createChildren (vnode, children, insertedVnodeQueue) {\\n    if (Array.isArray(children)) {\\n      if (true) {\\n        checkDuplicateKeys(children);\\n      }\\n      for (var i = 0; i < children.length; ++i) {\\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);\\n      }\\n    } else if (isPrimitive(vnode.text)) {\\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\\n    }\\n  }\\n\\n  function isPatchable (vnode) {\\n    while (vnode.componentInstance) {\\n      vnode = vnode.componentInstance._vnode;\\n    }\\n    return isDef(vnode.tag)\\n  }\\n\\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\\n      cbs.create[i$1](emptyNode, vnode);\\n    }\\n    i = vnode.data.hook; // Reuse variable\\n    if (isDef(i)) {\\n      if (isDef(i.create)) { i.create(emptyNode, vnode); }\\n      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\\n    }\\n  }\\n\\n  // set scope id attribute for scoped CSS.\\n  // this is implemented as a special case to avoid the overhead\\n  // of going through the normal attribute patching process.\\n  function setScope (vnode) {\\n    var i;\\n    if (isDef(i = vnode.fnScopeId)) {\\n      nodeOps.setStyleScope(vnode.elm, i);\\n    } else {\\n      var ancestor = vnode;\\n      while (ancestor) {\\n        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\\n          nodeOps.setStyleScope(vnode.elm, i);\\n        }\\n        ancestor = ancestor.parent;\\n      }\\n    }\\n    // for slot content they should also get the scopeId from the host instance.\\n    if (isDef(i = activeInstance) &&\\n      i !== vnode.context &&\\n      i !== vnode.fnContext &&\\n      isDef(i = i.$options._scopeId)\\n    ) {\\n      nodeOps.setStyleScope(vnode.elm, i);\\n    }\\n  }\\n\\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\\n    for (; startIdx <= endIdx; ++startIdx) {\\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\\n    }\\n  }\\n\\n  function invokeDestroyHook (vnode) {\\n    var i, j;\\n    var data = vnode.data;\\n    if (isDef(data)) {\\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\\n    }\\n    if (isDef(i = vnode.children)) {\\n      for (j = 0; j < vnode.children.length; ++j) {\\n        invokeDestroyHook(vnode.children[j]);\\n      }\\n    }\\n  }\\n\\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\\n    for (; startIdx <= endIdx; ++startIdx) {\\n      var ch = vnodes[startIdx];\\n      if (isDef(ch)) {\\n        if (isDef(ch.tag)) {\\n          removeAndInvokeRemoveHook(ch);\\n          invokeDestroyHook(ch);\\n        } else { // Text node\\n          removeNode(ch.elm);\\n        }\\n      }\\n    }\\n  }\\n\\n  function removeAndInvokeRemoveHook (vnode, rm) {\\n    if (isDef(rm) || isDef(vnode.data)) {\\n      var i;\\n      var listeners = cbs.remove.length + 1;\\n      if (isDef(rm)) {\\n        // we have a recursively passed down rm callback\\n        // increase the listeners count\\n        rm.listeners += listeners;\\n      } else {\\n        // directly removing\\n        rm = createRmCb(vnode.elm, listeners);\\n      }\\n      // recursively invoke hooks on child component root node\\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\\n        removeAndInvokeRemoveHook(i, rm);\\n      }\\n      for (i = 0; i < cbs.remove.length; ++i) {\\n        cbs.remove[i](vnode, rm);\\n      }\\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\\n        i(vnode, rm);\\n      } else {\\n        rm();\\n      }\\n    } else {\\n      removeNode(vnode.elm);\\n    }\\n  }\\n\\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\\n    var oldStartIdx = 0;\\n    var newStartIdx = 0;\\n    var oldEndIdx = oldCh.length - 1;\\n    var oldStartVnode = oldCh[0];\\n    var oldEndVnode = oldCh[oldEndIdx];\\n    var newEndIdx = newCh.length - 1;\\n    var newStartVnode = newCh[0];\\n    var newEndVnode = newCh[newEndIdx];\\n    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;\\n\\n    // removeOnly is a special flag used only by <transition-group>\\n    // to ensure removed elements stay in correct relative positions\\n    // during leaving transitions\\n    var canMove = !removeOnly;\\n\\n    if (true) {\\n      checkDuplicateKeys(newCh);\\n    }\\n\\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\\n      if (isUndef(oldStartVnode)) {\\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\\n      } else if (isUndef(oldEndVnode)) {\\n        oldEndVnode = oldCh[--oldEndIdx];\\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\\n        oldStartVnode = oldCh[++oldStartIdx];\\n        newStartVnode = newCh[++newStartIdx];\\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\\n        oldEndVnode = oldCh[--oldEndIdx];\\n        newEndVnode = newCh[--newEndIdx];\\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\\n        oldStartVnode = oldCh[++oldStartIdx];\\n        newEndVnode = newCh[--newEndIdx];\\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\\n        oldEndVnode = oldCh[--oldEndIdx];\\n        newStartVnode = newCh[++newStartIdx];\\n      } else {\\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\\n        idxInOld = isDef(newStartVnode.key)\\n          ? oldKeyToIdx[newStartVnode.key]\\n          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\\n        if (isUndef(idxInOld)) { // New element\\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\\n        } else {\\n          vnodeToMove = oldCh[idxInOld];\\n          if (sameVnode(vnodeToMove, newStartVnode)) {\\n            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue);\\n            oldCh[idxInOld] = undefined;\\n            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\\n          } else {\\n            // same key but different element. treat as new element\\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\\n          }\\n        }\\n        newStartVnode = newCh[++newStartIdx];\\n      }\\n    }\\n    if (oldStartIdx > oldEndIdx) {\\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\\n    } else if (newStartIdx > newEndIdx) {\\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\\n    }\\n  }\\n\\n  function checkDuplicateKeys (children) {\\n    var seenKeys = {};\\n    for (var i = 0; i < children.length; i++) {\\n      var vnode = children[i];\\n      var key = vnode.key;\\n      if (isDef(key)) {\\n        if (seenKeys[key]) {\\n          warn(\\n            (\\\"Duplicate keys detected: '\\\" + key + \\\"'. This may cause an update error.\\\"),\\n            vnode.context\\n          );\\n        } else {\\n          seenKeys[key] = true;\\n        }\\n      }\\n    }\\n  }\\n\\n  function findIdxInOld (node, oldCh, start, end) {\\n    for (var i = start; i < end; i++) {\\n      var c = oldCh[i];\\n      if (isDef(c) && sameVnode(node, c)) { return i }\\n    }\\n  }\\n\\n  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\\n    if (oldVnode === vnode) {\\n      return\\n    }\\n\\n    var elm = vnode.elm = oldVnode.elm;\\n\\n    if (isTrue(oldVnode.isAsyncPlaceholder)) {\\n      if (isDef(vnode.asyncFactory.resolved)) {\\n        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\\n      } else {\\n        vnode.isAsyncPlaceholder = true;\\n      }\\n      return\\n    }\\n\\n    // reuse element for static trees.\\n    // note we only do this if the vnode is cloned -\\n    // if the new node is not cloned it means the render functions have been\\n    // reset by the hot-reload-api and we need to do a proper re-render.\\n    if (isTrue(vnode.isStatic) &&\\n      isTrue(oldVnode.isStatic) &&\\n      vnode.key === oldVnode.key &&\\n      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\\n    ) {\\n      vnode.componentInstance = oldVnode.componentInstance;\\n      return\\n    }\\n\\n    var i;\\n    var data = vnode.data;\\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\\n      i(oldVnode, vnode);\\n    }\\n\\n    var oldCh = oldVnode.children;\\n    var ch = vnode.children;\\n    if (isDef(data) && isPatchable(vnode)) {\\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\\n    }\\n    if (isUndef(vnode.text)) {\\n      if (isDef(oldCh) && isDef(ch)) {\\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\\n      } else if (isDef(ch)) {\\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\\n      } else if (isDef(oldCh)) {\\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\\n      } else if (isDef(oldVnode.text)) {\\n        nodeOps.setTextContent(elm, '');\\n      }\\n    } else if (oldVnode.text !== vnode.text) {\\n      nodeOps.setTextContent(elm, vnode.text);\\n    }\\n    if (isDef(data)) {\\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\\n    }\\n  }\\n\\n  function invokeInsertHook (vnode, queue, initial) {\\n    // delay insert hooks for component root nodes, invoke them after the\\n    // element is really inserted\\n    if (isTrue(initial) && isDef(vnode.parent)) {\\n      vnode.parent.data.pendingInsert = queue;\\n    } else {\\n      for (var i = 0; i < queue.length; ++i) {\\n        queue[i].data.hook.insert(queue[i]);\\n      }\\n    }\\n  }\\n\\n  var hydrationBailed = false;\\n  // list of modules that can skip create hook during hydration because they\\n  // are already rendered on the client or has no need for initialization\\n  // Note: style is excluded because it relies on initial clone for future\\n  // deep updates (#7063).\\n  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');\\n\\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\\n  function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {\\n    var i;\\n    var tag = vnode.tag;\\n    var data = vnode.data;\\n    var children = vnode.children;\\n    inVPre = inVPre || (data && data.pre);\\n    vnode.elm = elm;\\n\\n    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\\n      vnode.isAsyncPlaceholder = true;\\n      return true\\n    }\\n    // assert node match\\n    if (true) {\\n      if (!assertNodeMatch(elm, vnode, inVPre)) {\\n        return false\\n      }\\n    }\\n    if (isDef(data)) {\\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\\n      if (isDef(i = vnode.componentInstance)) {\\n        // child component. it should have hydrated its own tree.\\n        initComponent(vnode, insertedVnodeQueue);\\n        return true\\n      }\\n    }\\n    if (isDef(tag)) {\\n      if (isDef(children)) {\\n        // empty element, allow client to pick up and populate children\\n        if (!elm.hasChildNodes()) {\\n          createChildren(vnode, children, insertedVnodeQueue);\\n        } else {\\n          // v-html and domProps: innerHTML\\n          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\\n            if (i !== elm.innerHTML) {\\n              /* istanbul ignore if */\\n              if (\\\"development\\\" !== 'production' &&\\n                typeof console !== 'undefined' &&\\n                !hydrationBailed\\n              ) {\\n                hydrationBailed = true;\\n                console.warn('Parent: ', elm);\\n                console.warn('server innerHTML: ', i);\\n                console.warn('client innerHTML: ', elm.innerHTML);\\n              }\\n              return false\\n            }\\n          } else {\\n            // iterate and compare children lists\\n            var childrenMatch = true;\\n            var childNode = elm.firstChild;\\n            for (var i$1 = 0; i$1 < children.length; i$1++) {\\n              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {\\n                childrenMatch = false;\\n                break\\n              }\\n              childNode = childNode.nextSibling;\\n            }\\n            // if childNode is not null, it means the actual childNodes list is\\n            // longer than the virtual children list.\\n            if (!childrenMatch || childNode) {\\n              /* istanbul ignore if */\\n              if (\\\"development\\\" !== 'production' &&\\n                typeof console !== 'undefined' &&\\n                !hydrationBailed\\n              ) {\\n                hydrationBailed = true;\\n                console.warn('Parent: ', elm);\\n                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\\n              }\\n              return false\\n            }\\n          }\\n        }\\n      }\\n      if (isDef(data)) {\\n        var fullInvoke = false;\\n        for (var key in data) {\\n          if (!isRenderedModule(key)) {\\n            fullInvoke = true;\\n            invokeCreateHooks(vnode, insertedVnodeQueue);\\n            break\\n          }\\n        }\\n        if (!fullInvoke && data['class']) {\\n          // ensure collecting deps for deep class bindings for future updates\\n          traverse(data['class']);\\n        }\\n      }\\n    } else if (elm.data !== vnode.text) {\\n      elm.data = vnode.text;\\n    }\\n    return true\\n  }\\n\\n  function assertNodeMatch (node, vnode, inVPre) {\\n    if (isDef(vnode.tag)) {\\n      return vnode.tag.indexOf('vue-component') === 0 || (\\n        !isUnknownElement$$1(vnode, inVPre) &&\\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\\n      )\\n    } else {\\n      return node.nodeType === (vnode.isComment ? 8 : 3)\\n    }\\n  }\\n\\n  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\\n    if (isUndef(vnode)) {\\n      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\\n      return\\n    }\\n\\n    var isInitialPatch = false;\\n    var insertedVnodeQueue = [];\\n\\n    if (isUndef(oldVnode)) {\\n      // empty mount (likely as component), create new root element\\n      isInitialPatch = true;\\n      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\\n    } else {\\n      var isRealElement = isDef(oldVnode.nodeType);\\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\\n        // patch existing root node\\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\\n      } else {\\n        if (isRealElement) {\\n          // mounting to a real element\\n          // check if this is server-rendered content and if we can perform\\n          // a successful hydration.\\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\\n            oldVnode.removeAttribute(SSR_ATTR);\\n            hydrating = true;\\n          }\\n          if (isTrue(hydrating)) {\\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\\n              return oldVnode\\n            } else if (true) {\\n              warn(\\n                'The client-side rendered virtual DOM tree is not matching ' +\\n                'server-rendered content. This is likely caused by incorrect ' +\\n                'HTML markup, for example nesting block-level elements inside ' +\\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\\n                'full client-side render.'\\n              );\\n            }\\n          }\\n          // either not server-rendered, or hydration failed.\\n          // create an empty node and replace it\\n          oldVnode = emptyNodeAt(oldVnode);\\n        }\\n\\n        // replacing existing element\\n        var oldElm = oldVnode.elm;\\n        var parentElm$1 = nodeOps.parentNode(oldElm);\\n\\n        // create new node\\n        createElm(\\n          vnode,\\n          insertedVnodeQueue,\\n          // extremely rare edge case: do not insert if old element is in a\\n          // leaving transition. Only happens when combining transition +\\n          // keep-alive + HOCs. (#4590)\\n          oldElm._leaveCb ? null : parentElm$1,\\n          nodeOps.nextSibling(oldElm)\\n        );\\n\\n        // update parent placeholder node element, recursively\\n        if (isDef(vnode.parent)) {\\n          var ancestor = vnode.parent;\\n          var patchable = isPatchable(vnode);\\n          while (ancestor) {\\n            for (var i = 0; i < cbs.destroy.length; ++i) {\\n              cbs.destroy[i](ancestor);\\n            }\\n            ancestor.elm = vnode.elm;\\n            if (patchable) {\\n              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\\n                cbs.create[i$1](emptyNode, ancestor);\\n              }\\n              // #6513\\n              // invoke insert hooks that may have been merged by create hooks.\\n              // e.g. for directives that uses the \\\"inserted\\\" hook.\\n              var insert = ancestor.data.hook.insert;\\n              if (insert.merged) {\\n                // start at index 1 to avoid re-invoking component mounted hook\\n                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\\n                  insert.fns[i$2]();\\n                }\\n              }\\n            } else {\\n              registerRef(ancestor);\\n            }\\n            ancestor = ancestor.parent;\\n          }\\n        }\\n\\n        // destroy old node\\n        if (isDef(parentElm$1)) {\\n          removeVnodes(parentElm$1, [oldVnode], 0, 0);\\n        } else if (isDef(oldVnode.tag)) {\\n          invokeDestroyHook(oldVnode);\\n        }\\n      }\\n    }\\n\\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\\n    return vnode.elm\\n  }\\n}\\n\\n/*  */\\n\\nvar directives = {\\n  create: updateDirectives,\\n  update: updateDirectives,\\n  destroy: function unbindDirectives (vnode) {\\n    updateDirectives(vnode, emptyNode);\\n  }\\n}\\n\\nfunction updateDirectives (oldVnode, vnode) {\\n  if (oldVnode.data.directives || vnode.data.directives) {\\n    _update(oldVnode, vnode);\\n  }\\n}\\n\\nfunction _update (oldVnode, vnode) {\\n  var isCreate = oldVnode === emptyNode;\\n  var isDestroy = vnode === emptyNode;\\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\\n\\n  var dirsWithInsert = [];\\n  var dirsWithPostpatch = [];\\n\\n  var key, oldDir, dir;\\n  for (key in newDirs) {\\n    oldDir = oldDirs[key];\\n    dir = newDirs[key];\\n    if (!oldDir) {\\n      // new directive, bind\\n      callHook$1(dir, 'bind', vnode, oldVnode);\\n      if (dir.def && dir.def.inserted) {\\n        dirsWithInsert.push(dir);\\n      }\\n    } else {\\n      // existing directive, update\\n      dir.oldValue = oldDir.value;\\n      callHook$1(dir, 'update', vnode, oldVnode);\\n      if (dir.def && dir.def.componentUpdated) {\\n        dirsWithPostpatch.push(dir);\\n      }\\n    }\\n  }\\n\\n  if (dirsWithInsert.length) {\\n    var callInsert = function () {\\n      for (var i = 0; i < dirsWithInsert.length; i++) {\\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\\n      }\\n    };\\n    if (isCreate) {\\n      mergeVNodeHook(vnode, 'insert', callInsert);\\n    } else {\\n      callInsert();\\n    }\\n  }\\n\\n  if (dirsWithPostpatch.length) {\\n    mergeVNodeHook(vnode, 'postpatch', function () {\\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\\n      }\\n    });\\n  }\\n\\n  if (!isCreate) {\\n    for (key in oldDirs) {\\n      if (!newDirs[key]) {\\n        // no longer present, unbind\\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\\n      }\\n    }\\n  }\\n}\\n\\nvar emptyModifiers = Object.create(null);\\n\\nfunction normalizeDirectives$1 (\\n  dirs,\\n  vm\\n) {\\n  var res = Object.create(null);\\n  if (!dirs) {\\n    // $flow-disable-line\\n    return res\\n  }\\n  var i, dir;\\n  for (i = 0; i < dirs.length; i++) {\\n    dir = dirs[i];\\n    if (!dir.modifiers) {\\n      // $flow-disable-line\\n      dir.modifiers = emptyModifiers;\\n    }\\n    res[getRawDirName(dir)] = dir;\\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\\n  }\\n  // $flow-disable-line\\n  return res\\n}\\n\\nfunction getRawDirName (dir) {\\n  return dir.rawName || ((dir.name) + \\\".\\\" + (Object.keys(dir.modifiers || {}).join('.')))\\n}\\n\\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\\n  var fn = dir.def && dir.def[hook];\\n  if (fn) {\\n    try {\\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\\n    } catch (e) {\\n      handleError(e, vnode.context, (\\\"directive \\\" + (dir.name) + \\\" \\\" + hook + \\\" hook\\\"));\\n    }\\n  }\\n}\\n\\nvar baseModules = [\\n  ref,\\n  directives\\n]\\n\\n/*  */\\n\\nfunction updateAttrs (oldVnode, vnode) {\\n  var opts = vnode.componentOptions;\\n  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\\n    return\\n  }\\n  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\\n    return\\n  }\\n  var key, cur, old;\\n  var elm = vnode.elm;\\n  var oldAttrs = oldVnode.data.attrs || {};\\n  var attrs = vnode.data.attrs || {};\\n  // clone observed objects, as the user probably wants to mutate it\\n  if (isDef(attrs.__ob__)) {\\n    attrs = vnode.data.attrs = extend({}, attrs);\\n  }\\n\\n  for (key in attrs) {\\n    cur = attrs[key];\\n    old = oldAttrs[key];\\n    if (old !== cur) {\\n      setAttr(elm, key, cur);\\n    }\\n  }\\n  // #4391: in IE9, setting type can reset value for input[type=radio]\\n  // #6666: IE/Edge forces progress value down to 1 before setting a max\\n  /* istanbul ignore if */\\n  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\\n    setAttr(elm, 'value', attrs.value);\\n  }\\n  for (key in oldAttrs) {\\n    if (isUndef(attrs[key])) {\\n      if (isXlink(key)) {\\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\\n      } else if (!isEnumeratedAttr(key)) {\\n        elm.removeAttribute(key);\\n      }\\n    }\\n  }\\n}\\n\\nfunction setAttr (el, key, value) {\\n  if (el.tagName.indexOf('-') > -1) {\\n    baseSetAttr(el, key, value);\\n  } else if (isBooleanAttr(key)) {\\n    // set attribute for blank value\\n    // e.g. <option disabled>Select one</option>\\n    if (isFalsyAttrValue(value)) {\\n      el.removeAttribute(key);\\n    } else {\\n      // technically allowfullscreen is a boolean attribute for <iframe>,\\n      // but Flash expects a value of \\\"true\\\" when used on <embed> tag\\n      value = key === 'allowfullscreen' && el.tagName === 'EMBED'\\n        ? 'true'\\n        : key;\\n      el.setAttribute(key, value);\\n    }\\n  } else if (isEnumeratedAttr(key)) {\\n    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\\n  } else if (isXlink(key)) {\\n    if (isFalsyAttrValue(value)) {\\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\\n    } else {\\n      el.setAttributeNS(xlinkNS, key, value);\\n    }\\n  } else {\\n    baseSetAttr(el, key, value);\\n  }\\n}\\n\\nfunction baseSetAttr (el, key, value) {\\n  if (isFalsyAttrValue(value)) {\\n    el.removeAttribute(key);\\n  } else {\\n    // #7138: IE10 & 11 fires input event when setting placeholder on\\n    // <textarea>... block the first input event and remove the blocker\\n    // immediately.\\n    /* istanbul ignore if */\\n    if (\\n      isIE && !isIE9 &&\\n      el.tagName === 'TEXTAREA' &&\\n      key === 'placeholder' && !el.__ieph\\n    ) {\\n      var blocker = function (e) {\\n        e.stopImmediatePropagation();\\n        el.removeEventListener('input', blocker);\\n      };\\n      el.addEventListener('input', blocker);\\n      // $flow-disable-line\\n      el.__ieph = true; /* IE placeholder patched */\\n    }\\n    el.setAttribute(key, value);\\n  }\\n}\\n\\nvar attrs = {\\n  create: updateAttrs,\\n  update: updateAttrs\\n}\\n\\n/*  */\\n\\nfunction updateClass (oldVnode, vnode) {\\n  var el = vnode.elm;\\n  var data = vnode.data;\\n  var oldData = oldVnode.data;\\n  if (\\n    isUndef(data.staticClass) &&\\n    isUndef(data.class) && (\\n      isUndef(oldData) || (\\n        isUndef(oldData.staticClass) &&\\n        isUndef(oldData.class)\\n      )\\n    )\\n  ) {\\n    return\\n  }\\n\\n  var cls = genClassForVnode(vnode);\\n\\n  // handle transition classes\\n  var transitionClass = el._transitionClasses;\\n  if (isDef(transitionClass)) {\\n    cls = concat(cls, stringifyClass(transitionClass));\\n  }\\n\\n  // set the class\\n  if (cls !== el._prevClass) {\\n    el.setAttribute('class', cls);\\n    el._prevClass = cls;\\n  }\\n}\\n\\nvar klass = {\\n  create: updateClass,\\n  update: updateClass\\n}\\n\\n/*  */\\n\\n/*  */\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n// add a raw attr (use this in preTransforms)\\n\\n\\n\\n\\n\\n\\n\\n\\n// note: this only removes the attr from the Array (attrsList) so that it\\n// doesn't get processed by processAttrs.\\n// By default it does NOT remove it from the map (attrsMap) because the map is\\n// needed during codegen.\\n\\n/*  */\\n\\n/**\\n * Cross-platform code generation for component v-model\\n */\\n\\n\\n/**\\n * Cross-platform codegen helper for generating v-model value assignment code.\\n */\\n\\n/*  */\\n\\n// in some cases, the event used has to be determined at runtime\\n// so we used some reserved tokens during compile.\\nvar RANGE_TOKEN = '__r';\\nvar CHECKBOX_RADIO_TOKEN = '__c';\\n\\n/*  */\\n\\n// normalize v-model event tokens that can only be determined at runtime.\\n// it's important to place the event as the first in the array because\\n// the whole point is ensuring the v-model callback gets called before\\n// user-attached handlers.\\nfunction normalizeEvents (on) {\\n  /* istanbul ignore if */\\n  if (isDef(on[RANGE_TOKEN])) {\\n    // IE input[type=range] only supports `change` event\\n    var event = isIE ? 'change' : 'input';\\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\\n    delete on[RANGE_TOKEN];\\n  }\\n  // This was originally intended to fix #4521 but no longer necessary\\n  // after 2.5. Keeping it for backwards compat with generated code from < 2.4\\n  /* istanbul ignore if */\\n  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\\n    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\\n    delete on[CHECKBOX_RADIO_TOKEN];\\n  }\\n}\\n\\nvar target$1;\\n\\nfunction createOnceHandler (handler, event, capture) {\\n  var _target = target$1; // save current target element in closure\\n  return function onceHandler () {\\n    var res = handler.apply(null, arguments);\\n    if (res !== null) {\\n      remove$2(event, onceHandler, capture, _target);\\n    }\\n  }\\n}\\n\\nfunction add$1 (\\n  event,\\n  handler,\\n  once$$1,\\n  capture,\\n  passive\\n) {\\n  handler = withMacroTask(handler);\\n  if (once$$1) { handler = createOnceHandler(handler, event, capture); }\\n  target$1.addEventListener(\\n    event,\\n    handler,\\n    supportsPassive\\n      ? { capture: capture, passive: passive }\\n      : capture\\n  );\\n}\\n\\nfunction remove$2 (\\n  event,\\n  handler,\\n  capture,\\n  _target\\n) {\\n  (_target || target$1).removeEventListener(\\n    event,\\n    handler._withTask || handler,\\n    capture\\n  );\\n}\\n\\nfunction updateDOMListeners (oldVnode, vnode) {\\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\\n    return\\n  }\\n  var on = vnode.data.on || {};\\n  var oldOn = oldVnode.data.on || {};\\n  target$1 = vnode.elm;\\n  normalizeEvents(on);\\n  updateListeners(on, oldOn, add$1, remove$2, vnode.context);\\n  target$1 = undefined;\\n}\\n\\nvar events = {\\n  create: updateDOMListeners,\\n  update: updateDOMListeners\\n}\\n\\n/*  */\\n\\nfunction updateDOMProps (oldVnode, vnode) {\\n  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\\n    return\\n  }\\n  var key, cur;\\n  var elm = vnode.elm;\\n  var oldProps = oldVnode.data.domProps || {};\\n  var props = vnode.data.domProps || {};\\n  // clone observed objects, as the user probably wants to mutate it\\n  if (isDef(props.__ob__)) {\\n    props = vnode.data.domProps = extend({}, props);\\n  }\\n\\n  for (key in oldProps) {\\n    if (isUndef(props[key])) {\\n      elm[key] = '';\\n    }\\n  }\\n  for (key in props) {\\n    cur = props[key];\\n    // ignore children if the node has textContent or innerHTML,\\n    // as these will throw away existing DOM nodes and cause removal errors\\n    // on subsequent patches (#3360)\\n    if (key === 'textContent' || key === 'innerHTML') {\\n      if (vnode.children) { vnode.children.length = 0; }\\n      if (cur === oldProps[key]) { continue }\\n      // #6601 work around Chrome version <= 55 bug where single textNode\\n      // replaced by innerHTML/textContent retains its parentNode property\\n      if (elm.childNodes.length === 1) {\\n        elm.removeChild(elm.childNodes[0]);\\n      }\\n    }\\n\\n    if (key === 'value') {\\n      // store value as _value as well since\\n      // non-string values will be stringified\\n      elm._value = cur;\\n      // avoid resetting cursor position when value is the same\\n      var strCur = isUndef(cur) ? '' : String(cur);\\n      if (shouldUpdateValue(elm, strCur)) {\\n        elm.value = strCur;\\n      }\\n    } else {\\n      elm[key] = cur;\\n    }\\n  }\\n}\\n\\n// check platforms/web/util/attrs.js acceptValue\\n\\n\\nfunction shouldUpdateValue (elm, checkVal) {\\n  return (!elm.composing && (\\n    elm.tagName === 'OPTION' ||\\n    isNotInFocusAndDirty(elm, checkVal) ||\\n    isDirtyWithModifiers(elm, checkVal)\\n  ))\\n}\\n\\nfunction isNotInFocusAndDirty (elm, checkVal) {\\n  // return true when textbox (.number and .trim) loses focus and its value is\\n  // not equal to the updated value\\n  var notInFocus = true;\\n  // #6157\\n  // work around IE bug when accessing document.activeElement in an iframe\\n  try { notInFocus = document.activeElement !== elm; } catch (e) {}\\n  return notInFocus && elm.value !== checkVal\\n}\\n\\nfunction isDirtyWithModifiers (elm, newVal) {\\n  var value = elm.value;\\n  var modifiers = elm._vModifiers; // injected by v-model runtime\\n  if (isDef(modifiers)) {\\n    if (modifiers.lazy) {\\n      // inputs with lazy should only be updated when not in focus\\n      return false\\n    }\\n    if (modifiers.number) {\\n      return toNumber(value) !== toNumber(newVal)\\n    }\\n    if (modifiers.trim) {\\n      return value.trim() !== newVal.trim()\\n    }\\n  }\\n  return value !== newVal\\n}\\n\\nvar domProps = {\\n  create: updateDOMProps,\\n  update: updateDOMProps\\n}\\n\\n/*  */\\n\\nvar parseStyleText = cached(function (cssText) {\\n  var res = {};\\n  var listDelimiter = /;(?![^(]*\\\\))/g;\\n  var propertyDelimiter = /:(.+)/;\\n  cssText.split(listDelimiter).forEach(function (item) {\\n    if (item) {\\n      var tmp = item.split(propertyDelimiter);\\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\\n    }\\n  });\\n  return res\\n});\\n\\n// merge static and dynamic style data on the same vnode\\nfunction normalizeStyleData (data) {\\n  var style = normalizeStyleBinding(data.style);\\n  // static style is pre-processed into an object during compilation\\n  // and is always a fresh object, so it's safe to merge into it\\n  return data.staticStyle\\n    ? extend(data.staticStyle, style)\\n    : style\\n}\\n\\n// normalize possible array / string values into Object\\nfunction normalizeStyleBinding (bindingStyle) {\\n  if (Array.isArray(bindingStyle)) {\\n    return toObject(bindingStyle)\\n  }\\n  if (typeof bindingStyle === 'string') {\\n    return parseStyleText(bindingStyle)\\n  }\\n  return bindingStyle\\n}\\n\\n/**\\n * parent component style should be after child's\\n * so that parent component's style could override it\\n */\\nfunction getStyle (vnode, checkChild) {\\n  var res = {};\\n  var styleData;\\n\\n  if (checkChild) {\\n    var childNode = vnode;\\n    while (childNode.componentInstance) {\\n      childNode = childNode.componentInstance._vnode;\\n      if (\\n        childNode && childNode.data &&\\n        (styleData = normalizeStyleData(childNode.data))\\n      ) {\\n        extend(res, styleData);\\n      }\\n    }\\n  }\\n\\n  if ((styleData = normalizeStyleData(vnode.data))) {\\n    extend(res, styleData);\\n  }\\n\\n  var parentNode = vnode;\\n  while ((parentNode = parentNode.parent)) {\\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\\n      extend(res, styleData);\\n    }\\n  }\\n  return res\\n}\\n\\n/*  */\\n\\nvar cssVarRE = /^--/;\\nvar importantRE = /\\\\s*!important$/;\\nvar setProp = function (el, name, val) {\\n  /* istanbul ignore if */\\n  if (cssVarRE.test(name)) {\\n    el.style.setProperty(name, val);\\n  } else if (importantRE.test(val)) {\\n    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\\n  } else {\\n    var normalizedName = normalize(name);\\n    if (Array.isArray(val)) {\\n      // Support values array created by autoprefixer, e.g.\\n      // {display: [\\\"-webkit-box\\\", \\\"-ms-flexbox\\\", \\\"flex\\\"]}\\n      // Set them one by one, and the browser will only set those it can recognize\\n      for (var i = 0, len = val.length; i < len; i++) {\\n        el.style[normalizedName] = val[i];\\n      }\\n    } else {\\n      el.style[normalizedName] = val;\\n    }\\n  }\\n};\\n\\nvar vendorNames = ['Webkit', 'Moz', 'ms'];\\n\\nvar emptyStyle;\\nvar normalize = cached(function (prop) {\\n  emptyStyle = emptyStyle || document.createElement('div').style;\\n  prop = camelize(prop);\\n  if (prop !== 'filter' && (prop in emptyStyle)) {\\n    return prop\\n  }\\n  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\\n  for (var i = 0; i < vendorNames.length; i++) {\\n    var name = vendorNames[i] + capName;\\n    if (name in emptyStyle) {\\n      return name\\n    }\\n  }\\n});\\n\\nfunction updateStyle (oldVnode, vnode) {\\n  var data = vnode.data;\\n  var oldData = oldVnode.data;\\n\\n  if (isUndef(data.staticStyle) && isUndef(data.style) &&\\n    isUndef(oldData.staticStyle) && isUndef(oldData.style)\\n  ) {\\n    return\\n  }\\n\\n  var cur, name;\\n  var el = vnode.elm;\\n  var oldStaticStyle = oldData.staticStyle;\\n  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\\n\\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\\n  var oldStyle = oldStaticStyle || oldStyleBinding;\\n\\n  var style = normalizeStyleBinding(vnode.data.style) || {};\\n\\n  // store normalized style under a different key for next diff\\n  // make sure to clone it if it's reactive, since the user likely wants\\n  // to mutate it.\\n  vnode.data.normalizedStyle = isDef(style.__ob__)\\n    ? extend({}, style)\\n    : style;\\n\\n  var newStyle = getStyle(vnode, true);\\n\\n  for (name in oldStyle) {\\n    if (isUndef(newStyle[name])) {\\n      setProp(el, name, '');\\n    }\\n  }\\n  for (name in newStyle) {\\n    cur = newStyle[name];\\n    if (cur !== oldStyle[name]) {\\n      // ie9 setting to null has no effect, must use empty string\\n      setProp(el, name, cur == null ? '' : cur);\\n    }\\n  }\\n}\\n\\nvar style = {\\n  create: updateStyle,\\n  update: updateStyle\\n}\\n\\n/*  */\\n\\n/**\\n * Add class with compatibility for SVG since classList is not supported on\\n * SVG elements in IE\\n */\\nfunction addClass (el, cls) {\\n  /* istanbul ignore if */\\n  if (!cls || !(cls = cls.trim())) {\\n    return\\n  }\\n\\n  /* istanbul ignore else */\\n  if (el.classList) {\\n    if (cls.indexOf(' ') > -1) {\\n      cls.split(/\\\\s+/).forEach(function (c) { return el.classList.add(c); });\\n    } else {\\n      el.classList.add(cls);\\n    }\\n  } else {\\n    var cur = \\\" \\\" + (el.getAttribute('class') || '') + \\\" \\\";\\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\\n      el.setAttribute('class', (cur + cls).trim());\\n    }\\n  }\\n}\\n\\n/**\\n * Remove class with compatibility for SVG since classList is not supported on\\n * SVG elements in IE\\n */\\nfunction removeClass (el, cls) {\\n  /* istanbul ignore if */\\n  if (!cls || !(cls = cls.trim())) {\\n    return\\n  }\\n\\n  /* istanbul ignore else */\\n  if (el.classList) {\\n    if (cls.indexOf(' ') > -1) {\\n      cls.split(/\\\\s+/).forEach(function (c) { return el.classList.remove(c); });\\n    } else {\\n      el.classList.remove(cls);\\n    }\\n    if (!el.classList.length) {\\n      el.removeAttribute('class');\\n    }\\n  } else {\\n    var cur = \\\" \\\" + (el.getAttribute('class') || '') + \\\" \\\";\\n    var tar = ' ' + cls + ' ';\\n    while (cur.indexOf(tar) >= 0) {\\n      cur = cur.replace(tar, ' ');\\n    }\\n    cur = cur.trim();\\n    if (cur) {\\n      el.setAttribute('class', cur);\\n    } else {\\n      el.removeAttribute('class');\\n    }\\n  }\\n}\\n\\n/*  */\\n\\nfunction resolveTransition (def) {\\n  if (!def) {\\n    return\\n  }\\n  /* istanbul ignore else */\\n  if (typeof def === 'object') {\\n    var res = {};\\n    if (def.css !== false) {\\n      extend(res, autoCssTransition(def.name || 'v'));\\n    }\\n    extend(res, def);\\n    return res\\n  } else if (typeof def === 'string') {\\n    return autoCssTransition(def)\\n  }\\n}\\n\\nvar autoCssTransition = cached(function (name) {\\n  return {\\n    enterClass: (name + \\\"-enter\\\"),\\n    enterToClass: (name + \\\"-enter-to\\\"),\\n    enterActiveClass: (name + \\\"-enter-active\\\"),\\n    leaveClass: (name + \\\"-leave\\\"),\\n    leaveToClass: (name + \\\"-leave-to\\\"),\\n    leaveActiveClass: (name + \\\"-leave-active\\\")\\n  }\\n});\\n\\nvar hasTransition = inBrowser && !isIE9;\\nvar TRANSITION = 'transition';\\nvar ANIMATION = 'animation';\\n\\n// Transition property/event sniffing\\nvar transitionProp = 'transition';\\nvar transitionEndEvent = 'transitionend';\\nvar animationProp = 'animation';\\nvar animationEndEvent = 'animationend';\\nif (hasTransition) {\\n  /* istanbul ignore if */\\n  if (window.ontransitionend === undefined &&\\n    window.onwebkittransitionend !== undefined\\n  ) {\\n    transitionProp = 'WebkitTransition';\\n    transitionEndEvent = 'webkitTransitionEnd';\\n  }\\n  if (window.onanimationend === undefined &&\\n    window.onwebkitanimationend !== undefined\\n  ) {\\n    animationProp = 'WebkitAnimation';\\n    animationEndEvent = 'webkitAnimationEnd';\\n  }\\n}\\n\\n// binding to window is necessary to make hot reload work in IE in strict mode\\nvar raf = inBrowser\\n  ? window.requestAnimationFrame\\n    ? window.requestAnimationFrame.bind(window)\\n    : setTimeout\\n  : /* istanbul ignore next */ function (fn) { return fn(); };\\n\\nfunction nextFrame (fn) {\\n  raf(function () {\\n    raf(fn);\\n  });\\n}\\n\\nfunction addTransitionClass (el, cls) {\\n  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\\n  if (transitionClasses.indexOf(cls) < 0) {\\n    transitionClasses.push(cls);\\n    addClass(el, cls);\\n  }\\n}\\n\\nfunction removeTransitionClass (el, cls) {\\n  if (el._transitionClasses) {\\n    remove(el._transitionClasses, cls);\\n  }\\n  removeClass(el, cls);\\n}\\n\\nfunction whenTransitionEnds (\\n  el,\\n  expectedType,\\n  cb\\n) {\\n  var ref = getTransitionInfo(el, expectedType);\\n  var type = ref.type;\\n  var timeout = ref.timeout;\\n  var propCount = ref.propCount;\\n  if (!type) { return cb() }\\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\\n  var ended = 0;\\n  var end = function () {\\n    el.removeEventListener(event, onEnd);\\n    cb();\\n  };\\n  var onEnd = function (e) {\\n    if (e.target === el) {\\n      if (++ended >= propCount) {\\n        end();\\n      }\\n    }\\n  };\\n  setTimeout(function () {\\n    if (ended < propCount) {\\n      end();\\n    }\\n  }, timeout + 1);\\n  el.addEventListener(event, onEnd);\\n}\\n\\nvar transformRE = /\\\\b(transform|all)(,|$)/;\\n\\nfunction getTransitionInfo (el, expectedType) {\\n  var styles = window.getComputedStyle(el);\\n  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');\\n  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\\n  var animationDelays = styles[animationProp + 'Delay'].split(', ');\\n  var animationDurations = styles[animationProp + 'Duration'].split(', ');\\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\\n\\n  var type;\\n  var timeout = 0;\\n  var propCount = 0;\\n  /* istanbul ignore if */\\n  if (expectedType === TRANSITION) {\\n    if (transitionTimeout > 0) {\\n      type = TRANSITION;\\n      timeout = transitionTimeout;\\n      propCount = transitionDurations.length;\\n    }\\n  } else if (expectedType === ANIMATION) {\\n    if (animationTimeout > 0) {\\n      type = ANIMATION;\\n      timeout = animationTimeout;\\n      propCount = animationDurations.length;\\n    }\\n  } else {\\n    timeout = Math.max(transitionTimeout, animationTimeout);\\n    type = timeout > 0\\n      ? transitionTimeout > animationTimeout\\n        ? TRANSITION\\n        : ANIMATION\\n      : null;\\n    propCount = type\\n      ? type === TRANSITION\\n        ? transitionDurations.length\\n        : animationDurations.length\\n      : 0;\\n  }\\n  var hasTransform =\\n    type === TRANSITION &&\\n    transformRE.test(styles[transitionProp + 'Property']);\\n  return {\\n    type: type,\\n    timeout: timeout,\\n    propCount: propCount,\\n    hasTransform: hasTransform\\n  }\\n}\\n\\nfunction getTimeout (delays, durations) {\\n  /* istanbul ignore next */\\n  while (delays.length < durations.length) {\\n    delays = delays.concat(delays);\\n  }\\n\\n  return Math.max.apply(null, durations.map(function (d, i) {\\n    return toMs(d) + toMs(delays[i])\\n  }))\\n}\\n\\nfunction toMs (s) {\\n  return Number(s.slice(0, -1)) * 1000\\n}\\n\\n/*  */\\n\\nfunction enter (vnode, toggleDisplay) {\\n  var el = vnode.elm;\\n\\n  // call leave callback now\\n  if (isDef(el._leaveCb)) {\\n    el._leaveCb.cancelled = true;\\n    el._leaveCb();\\n  }\\n\\n  var data = resolveTransition(vnode.data.transition);\\n  if (isUndef(data)) {\\n    return\\n  }\\n\\n  /* istanbul ignore if */\\n  if (isDef(el._enterCb) || el.nodeType !== 1) {\\n    return\\n  }\\n\\n  var css = data.css;\\n  var type = data.type;\\n  var enterClass = data.enterClass;\\n  var enterToClass = data.enterToClass;\\n  var enterActiveClass = data.enterActiveClass;\\n  var appearClass = data.appearClass;\\n  var appearToClass = data.appearToClass;\\n  var appearActiveClass = data.appearActiveClass;\\n  var beforeEnter = data.beforeEnter;\\n  var enter = data.enter;\\n  var afterEnter = data.afterEnter;\\n  var enterCancelled = data.enterCancelled;\\n  var beforeAppear = data.beforeAppear;\\n  var appear = data.appear;\\n  var afterAppear = data.afterAppear;\\n  var appearCancelled = data.appearCancelled;\\n  var duration = data.duration;\\n\\n  // activeInstance will always be the <transition> component managing this\\n  // transition. One edge case to check is when the <transition> is placed\\n  // as the root node of a child component. In that case we need to check\\n  // <transition>'s parent for appear check.\\n  var context = activeInstance;\\n  var transitionNode = activeInstance.$vnode;\\n  while (transitionNode && transitionNode.parent) {\\n    transitionNode = transitionNode.parent;\\n    context = transitionNode.context;\\n  }\\n\\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\\n\\n  if (isAppear && !appear && appear !== '') {\\n    return\\n  }\\n\\n  var startClass = isAppear && appearClass\\n    ? appearClass\\n    : enterClass;\\n  var activeClass = isAppear && appearActiveClass\\n    ? appearActiveClass\\n    : enterActiveClass;\\n  var toClass = isAppear && appearToClass\\n    ? appearToClass\\n    : enterToClass;\\n\\n  var beforeEnterHook = isAppear\\n    ? (beforeAppear || beforeEnter)\\n    : beforeEnter;\\n  var enterHook = isAppear\\n    ? (typeof appear === 'function' ? appear : enter)\\n    : enter;\\n  var afterEnterHook = isAppear\\n    ? (afterAppear || afterEnter)\\n    : afterEnter;\\n  var enterCancelledHook = isAppear\\n    ? (appearCancelled || enterCancelled)\\n    : enterCancelled;\\n\\n  var explicitEnterDuration = toNumber(\\n    isObject(duration)\\n      ? duration.enter\\n      : duration\\n  );\\n\\n  if (\\\"development\\\" !== 'production' && explicitEnterDuration != null) {\\n    checkDuration(explicitEnterDuration, 'enter', vnode);\\n  }\\n\\n  var expectsCSS = css !== false && !isIE9;\\n  var userWantsControl = getHookArgumentsLength(enterHook);\\n\\n  var cb = el._enterCb = once(function () {\\n    if (expectsCSS) {\\n      removeTransitionClass(el, toClass);\\n      removeTransitionClass(el, activeClass);\\n    }\\n    if (cb.cancelled) {\\n      if (expectsCSS) {\\n        removeTransitionClass(el, startClass);\\n      }\\n      enterCancelledHook && enterCancelledHook(el);\\n    } else {\\n      afterEnterHook && afterEnterHook(el);\\n    }\\n    el._enterCb = null;\\n  });\\n\\n  if (!vnode.data.show) {\\n    // remove pending leave element on enter by injecting an insert hook\\n    mergeVNodeHook(vnode, 'insert', function () {\\n      var parent = el.parentNode;\\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\\n      if (pendingNode &&\\n        pendingNode.tag === vnode.tag &&\\n        pendingNode.elm._leaveCb\\n      ) {\\n        pendingNode.elm._leaveCb();\\n      }\\n      enterHook && enterHook(el, cb);\\n    });\\n  }\\n\\n  // start enter transition\\n  beforeEnterHook && beforeEnterHook(el);\\n  if (expectsCSS) {\\n    addTransitionClass(el, startClass);\\n    addTransitionClass(el, activeClass);\\n    nextFrame(function () {\\n      removeTransitionClass(el, startClass);\\n      if (!cb.cancelled) {\\n        addTransitionClass(el, toClass);\\n        if (!userWantsControl) {\\n          if (isValidDuration(explicitEnterDuration)) {\\n            setTimeout(cb, explicitEnterDuration);\\n          } else {\\n            whenTransitionEnds(el, type, cb);\\n          }\\n        }\\n      }\\n    });\\n  }\\n\\n  if (vnode.data.show) {\\n    toggleDisplay && toggleDisplay();\\n    enterHook && enterHook(el, cb);\\n  }\\n\\n  if (!expectsCSS && !userWantsControl) {\\n    cb();\\n  }\\n}\\n\\nfunction leave (vnode, rm) {\\n  var el = vnode.elm;\\n\\n  // call enter callback now\\n  if (isDef(el._enterCb)) {\\n    el._enterCb.cancelled = true;\\n    el._enterCb();\\n  }\\n\\n  var data = resolveTransition(vnode.data.transition);\\n  if (isUndef(data) || el.nodeType !== 1) {\\n    return rm()\\n  }\\n\\n  /* istanbul ignore if */\\n  if (isDef(el._leaveCb)) {\\n    return\\n  }\\n\\n  var css = data.css;\\n  var type = data.type;\\n  var leaveClass = data.leaveClass;\\n  var leaveToClass = data.leaveToClass;\\n  var leaveActiveClass = data.leaveActiveClass;\\n  var beforeLeave = data.beforeLeave;\\n  var leave = data.leave;\\n  var afterLeave = data.afterLeave;\\n  var leaveCancelled = data.leaveCancelled;\\n  var delayLeave = data.delayLeave;\\n  var duration = data.duration;\\n\\n  var expectsCSS = css !== false && !isIE9;\\n  var userWantsControl = getHookArgumentsLength(leave);\\n\\n  var explicitLeaveDuration = toNumber(\\n    isObject(duration)\\n      ? duration.leave\\n      : duration\\n  );\\n\\n  if (\\\"development\\\" !== 'production' && isDef(explicitLeaveDuration)) {\\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\\n  }\\n\\n  var cb = el._leaveCb = once(function () {\\n    if (el.parentNode && el.parentNode._pending) {\\n      el.parentNode._pending[vnode.key] = null;\\n    }\\n    if (expectsCSS) {\\n      removeTransitionClass(el, leaveToClass);\\n      removeTransitionClass(el, leaveActiveClass);\\n    }\\n    if (cb.cancelled) {\\n      if (expectsCSS) {\\n        removeTransitionClass(el, leaveClass);\\n      }\\n      leaveCancelled && leaveCancelled(el);\\n    } else {\\n      rm();\\n      afterLeave && afterLeave(el);\\n    }\\n    el._leaveCb = null;\\n  });\\n\\n  if (delayLeave) {\\n    delayLeave(performLeave);\\n  } else {\\n    performLeave();\\n  }\\n\\n  function performLeave () {\\n    // the delayed leave may have already been cancelled\\n    if (cb.cancelled) {\\n      return\\n    }\\n    // record leaving element\\n    if (!vnode.data.show) {\\n      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;\\n    }\\n    beforeLeave && beforeLeave(el);\\n    if (expectsCSS) {\\n      addTransitionClass(el, leaveClass);\\n      addTransitionClass(el, leaveActiveClass);\\n      nextFrame(function () {\\n        removeTransitionClass(el, leaveClass);\\n        if (!cb.cancelled) {\\n          addTransitionClass(el, leaveToClass);\\n          if (!userWantsControl) {\\n            if (isValidDuration(explicitLeaveDuration)) {\\n              setTimeout(cb, explicitLeaveDuration);\\n            } else {\\n              whenTransitionEnds(el, type, cb);\\n            }\\n          }\\n        }\\n      });\\n    }\\n    leave && leave(el, cb);\\n    if (!expectsCSS && !userWantsControl) {\\n      cb();\\n    }\\n  }\\n}\\n\\n// only used in dev mode\\nfunction checkDuration (val, name, vnode) {\\n  if (typeof val !== 'number') {\\n    warn(\\n      \\\"<transition> explicit \\\" + name + \\\" duration is not a valid number - \\\" +\\n      \\\"got \\\" + (JSON.stringify(val)) + \\\".\\\",\\n      vnode.context\\n    );\\n  } else if (isNaN(val)) {\\n    warn(\\n      \\\"<transition> explicit \\\" + name + \\\" duration is NaN - \\\" +\\n      'the duration expression might be incorrect.',\\n      vnode.context\\n    );\\n  }\\n}\\n\\nfunction isValidDuration (val) {\\n  return typeof val === 'number' && !isNaN(val)\\n}\\n\\n/**\\n * Normalize a transition hook's argument length. The hook may be:\\n * - a merged hook (invoker) with the original in .fns\\n * - a wrapped component method (check ._length)\\n * - a plain function (.length)\\n */\\nfunction getHookArgumentsLength (fn) {\\n  if (isUndef(fn)) {\\n    return false\\n  }\\n  var invokerFns = fn.fns;\\n  if (isDef(invokerFns)) {\\n    // invoker\\n    return getHookArgumentsLength(\\n      Array.isArray(invokerFns)\\n        ? invokerFns[0]\\n        : invokerFns\\n    )\\n  } else {\\n    return (fn._length || fn.length) > 1\\n  }\\n}\\n\\nfunction _enter (_, vnode) {\\n  if (vnode.data.show !== true) {\\n    enter(vnode);\\n  }\\n}\\n\\nvar transition = inBrowser ? {\\n  create: _enter,\\n  activate: _enter,\\n  remove: function remove$$1 (vnode, rm) {\\n    /* istanbul ignore else */\\n    if (vnode.data.show !== true) {\\n      leave(vnode, rm);\\n    } else {\\n      rm();\\n    }\\n  }\\n} : {}\\n\\nvar platformModules = [\\n  attrs,\\n  klass,\\n  events,\\n  domProps,\\n  style,\\n  transition\\n]\\n\\n/*  */\\n\\n// the directive module should be applied last, after all\\n// built-in modules have been applied.\\nvar modules = platformModules.concat(baseModules);\\n\\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\\n\\n/**\\n * Not type checking this file because flow doesn't like attaching\\n * properties to Elements.\\n */\\n\\n/* istanbul ignore if */\\nif (isIE9) {\\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\\n  document.addEventListener('selectionchange', function () {\\n    var el = document.activeElement;\\n    if (el && el.vmodel) {\\n      trigger(el, 'input');\\n    }\\n  });\\n}\\n\\nvar directive = {\\n  inserted: function inserted (el, binding, vnode, oldVnode) {\\n    if (vnode.tag === 'select') {\\n      // #6903\\n      if (oldVnode.elm && !oldVnode.elm._vOptions) {\\n        mergeVNodeHook(vnode, 'postpatch', function () {\\n          directive.componentUpdated(el, binding, vnode);\\n        });\\n      } else {\\n        setSelected(el, binding, vnode.context);\\n      }\\n      el._vOptions = [].map.call(el.options, getValue);\\n    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\\n      el._vModifiers = binding.modifiers;\\n      if (!binding.modifiers.lazy) {\\n        el.addEventListener('compositionstart', onCompositionStart);\\n        el.addEventListener('compositionend', onCompositionEnd);\\n        // Safari < 10.2 & UIWebView doesn't fire compositionend when\\n        // switching focus before confirming composition choice\\n        // this also fixes the issue where some browsers e.g. iOS Chrome\\n        // fires \\\"change\\\" instead of \\\"input\\\" on autocomplete.\\n        el.addEventListener('change', onCompositionEnd);\\n        /* istanbul ignore if */\\n        if (isIE9) {\\n          el.vmodel = true;\\n        }\\n      }\\n    }\\n  },\\n\\n  componentUpdated: function componentUpdated (el, binding, vnode) {\\n    if (vnode.tag === 'select') {\\n      setSelected(el, binding, vnode.context);\\n      // in case the options rendered by v-for have changed,\\n      // it's possible that the value is out-of-sync with the rendered options.\\n      // detect such cases and filter out values that no longer has a matching\\n      // option in the DOM.\\n      var prevOptions = el._vOptions;\\n      var curOptions = el._vOptions = [].map.call(el.options, getValue);\\n      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {\\n        // trigger change event if\\n        // no matching option found for at least one value\\n        var needReset = el.multiple\\n          ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })\\n          : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\\n        if (needReset) {\\n          trigger(el, 'change');\\n        }\\n      }\\n    }\\n  }\\n};\\n\\nfunction setSelected (el, binding, vm) {\\n  actuallySetSelected(el, binding, vm);\\n  /* istanbul ignore if */\\n  if (isIE || isEdge) {\\n    setTimeout(function () {\\n      actuallySetSelected(el, binding, vm);\\n    }, 0);\\n  }\\n}\\n\\nfunction actuallySetSelected (el, binding, vm) {\\n  var value = binding.value;\\n  var isMultiple = el.multiple;\\n  if (isMultiple && !Array.isArray(value)) {\\n    \\\"development\\\" !== 'production' && warn(\\n      \\\"<select multiple v-model=\\\\\\\"\\\" + (binding.expression) + \\\"\\\\\\\"> \\\" +\\n      \\\"expects an Array value for its binding, but got \\\" + (Object.prototype.toString.call(value).slice(8, -1)),\\n      vm\\n    );\\n    return\\n  }\\n  var selected, option;\\n  for (var i = 0, l = el.options.length; i < l; i++) {\\n    option = el.options[i];\\n    if (isMultiple) {\\n      selected = looseIndexOf(value, getValue(option)) > -1;\\n      if (option.selected !== selected) {\\n        option.selected = selected;\\n      }\\n    } else {\\n      if (looseEqual(getValue(option), value)) {\\n        if (el.selectedIndex !== i) {\\n          el.selectedIndex = i;\\n        }\\n        return\\n      }\\n    }\\n  }\\n  if (!isMultiple) {\\n    el.selectedIndex = -1;\\n  }\\n}\\n\\nfunction hasNoMatchingOption (value, options) {\\n  return options.every(function (o) { return !looseEqual(o, value); })\\n}\\n\\nfunction getValue (option) {\\n  return '_value' in option\\n    ? option._value\\n    : option.value\\n}\\n\\nfunction onCompositionStart (e) {\\n  e.target.composing = true;\\n}\\n\\nfunction onCompositionEnd (e) {\\n  // prevent triggering an input event for no reason\\n  if (!e.target.composing) { return }\\n  e.target.composing = false;\\n  trigger(e.target, 'input');\\n}\\n\\nfunction trigger (el, type) {\\n  var e = document.createEvent('HTMLEvents');\\n  e.initEvent(type, true, true);\\n  el.dispatchEvent(e);\\n}\\n\\n/*  */\\n\\n// recursively search for possible transition defined inside the component root\\nfunction locateNode (vnode) {\\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\\n    ? locateNode(vnode.componentInstance._vnode)\\n    : vnode\\n}\\n\\nvar show = {\\n  bind: function bind (el, ref, vnode) {\\n    var value = ref.value;\\n\\n    vnode = locateNode(vnode);\\n    var transition$$1 = vnode.data && vnode.data.transition;\\n    var originalDisplay = el.__vOriginalDisplay =\\n      el.style.display === 'none' ? '' : el.style.display;\\n    if (value && transition$$1) {\\n      vnode.data.show = true;\\n      enter(vnode, function () {\\n        el.style.display = originalDisplay;\\n      });\\n    } else {\\n      el.style.display = value ? originalDisplay : 'none';\\n    }\\n  },\\n\\n  update: function update (el, ref, vnode) {\\n    var value = ref.value;\\n    var oldValue = ref.oldValue;\\n\\n    /* istanbul ignore if */\\n    if (!value === !oldValue) { return }\\n    vnode = locateNode(vnode);\\n    var transition$$1 = vnode.data && vnode.data.transition;\\n    if (transition$$1) {\\n      vnode.data.show = true;\\n      if (value) {\\n        enter(vnode, function () {\\n          el.style.display = el.__vOriginalDisplay;\\n        });\\n      } else {\\n        leave(vnode, function () {\\n          el.style.display = 'none';\\n        });\\n      }\\n    } else {\\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\\n    }\\n  },\\n\\n  unbind: function unbind (\\n    el,\\n    binding,\\n    vnode,\\n    oldVnode,\\n    isDestroy\\n  ) {\\n    if (!isDestroy) {\\n      el.style.display = el.__vOriginalDisplay;\\n    }\\n  }\\n}\\n\\nvar platformDirectives = {\\n  model: directive,\\n  show: show\\n}\\n\\n/*  */\\n\\n// Provides transition support for a single element/component.\\n// supports transition mode (out-in / in-out)\\n\\nvar transitionProps = {\\n  name: String,\\n  appear: Boolean,\\n  css: Boolean,\\n  mode: String,\\n  type: String,\\n  enterClass: String,\\n  leaveClass: String,\\n  enterToClass: String,\\n  leaveToClass: String,\\n  enterActiveClass: String,\\n  leaveActiveClass: String,\\n  appearClass: String,\\n  appearActiveClass: String,\\n  appearToClass: String,\\n  duration: [Number, String, Object]\\n};\\n\\n// in case the child is also an abstract component, e.g. <keep-alive>\\n// we want to recursively retrieve the real component to be rendered\\nfunction getRealChild (vnode) {\\n  var compOptions = vnode && vnode.componentOptions;\\n  if (compOptions && compOptions.Ctor.options.abstract) {\\n    return getRealChild(getFirstComponentChild(compOptions.children))\\n  } else {\\n    return vnode\\n  }\\n}\\n\\nfunction extractTransitionData (comp) {\\n  var data = {};\\n  var options = comp.$options;\\n  // props\\n  for (var key in options.propsData) {\\n    data[key] = comp[key];\\n  }\\n  // events.\\n  // extract listeners and pass them directly to the transition methods\\n  var listeners = options._parentListeners;\\n  for (var key$1 in listeners) {\\n    data[camelize(key$1)] = listeners[key$1];\\n  }\\n  return data\\n}\\n\\nfunction placeholder (h, rawChild) {\\n  if (/\\\\d-keep-alive$/.test(rawChild.tag)) {\\n    return h('keep-alive', {\\n      props: rawChild.componentOptions.propsData\\n    })\\n  }\\n}\\n\\nfunction hasParentTransition (vnode) {\\n  while ((vnode = vnode.parent)) {\\n    if (vnode.data.transition) {\\n      return true\\n    }\\n  }\\n}\\n\\nfunction isSameChild (child, oldChild) {\\n  return oldChild.key === child.key && oldChild.tag === child.tag\\n}\\n\\nvar Transition = {\\n  name: 'transition',\\n  props: transitionProps,\\n  abstract: true,\\n\\n  render: function render (h) {\\n    var this$1 = this;\\n\\n    var children = this.$slots.default;\\n    if (!children) {\\n      return\\n    }\\n\\n    // filter out text nodes (possible whitespaces)\\n    children = children.filter(function (c) { return c.tag || isAsyncPlaceholder(c); });\\n    /* istanbul ignore if */\\n    if (!children.length) {\\n      return\\n    }\\n\\n    // warn multiple elements\\n    if (\\\"development\\\" !== 'production' && children.length > 1) {\\n      warn(\\n        '<transition> can only be used on a single element. Use ' +\\n        '<transition-group> for lists.',\\n        this.$parent\\n      );\\n    }\\n\\n    var mode = this.mode;\\n\\n    // warn invalid mode\\n    if (\\\"development\\\" !== 'production' &&\\n      mode && mode !== 'in-out' && mode !== 'out-in'\\n    ) {\\n      warn(\\n        'invalid <transition> mode: ' + mode,\\n        this.$parent\\n      );\\n    }\\n\\n    var rawChild = children[0];\\n\\n    // if this is a component root node and the component's\\n    // parent container node also has transition, skip.\\n    if (hasParentTransition(this.$vnode)) {\\n      return rawChild\\n    }\\n\\n    // apply transition data to child\\n    // use getRealChild() to ignore abstract components e.g. keep-alive\\n    var child = getRealChild(rawChild);\\n    /* istanbul ignore if */\\n    if (!child) {\\n      return rawChild\\n    }\\n\\n    if (this._leaving) {\\n      return placeholder(h, rawChild)\\n    }\\n\\n    // ensure a key that is unique to the vnode type and to this transition\\n    // component instance. This key will be used to remove pending leaving nodes\\n    // during entering.\\n    var id = \\\"__transition-\\\" + (this._uid) + \\\"-\\\";\\n    child.key = child.key == null\\n      ? child.isComment\\n        ? id + 'comment'\\n        : id + child.tag\\n      : isPrimitive(child.key)\\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\\n        : child.key;\\n\\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\\n    var oldRawChild = this._vnode;\\n    var oldChild = getRealChild(oldRawChild);\\n\\n    // mark v-show\\n    // so that the transition module can hand over the control to the directive\\n    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {\\n      child.data.show = true;\\n    }\\n\\n    if (\\n      oldChild &&\\n      oldChild.data &&\\n      !isSameChild(child, oldChild) &&\\n      !isAsyncPlaceholder(oldChild) &&\\n      // #6687 component root is a comment node\\n      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)\\n    ) {\\n      // replace old child transition data with fresh one\\n      // important for dynamic transitions!\\n      var oldData = oldChild.data.transition = extend({}, data);\\n      // handle transition mode\\n      if (mode === 'out-in') {\\n        // return placeholder node and queue update when leave finishes\\n        this._leaving = true;\\n        mergeVNodeHook(oldData, 'afterLeave', function () {\\n          this$1._leaving = false;\\n          this$1.$forceUpdate();\\n        });\\n        return placeholder(h, rawChild)\\n      } else if (mode === 'in-out') {\\n        if (isAsyncPlaceholder(child)) {\\n          return oldRawChild\\n        }\\n        var delayedLeave;\\n        var performLeave = function () { delayedLeave(); };\\n        mergeVNodeHook(data, 'afterEnter', performLeave);\\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\\n      }\\n    }\\n\\n    return rawChild\\n  }\\n}\\n\\n/*  */\\n\\n// Provides transition support for list items.\\n// supports move transitions using the FLIP technique.\\n\\n// Because the vdom's children update algorithm is \\\"unstable\\\" - i.e.\\n// it doesn't guarantee the relative positioning of removed elements,\\n// we force transition-group to update its children into two passes:\\n// in the first pass, we remove all nodes that need to be removed,\\n// triggering their leaving transition; in the second pass, we insert/move\\n// into the final desired state. This way in the second pass removed\\n// nodes will remain where they should be.\\n\\nvar props = extend({\\n  tag: String,\\n  moveClass: String\\n}, transitionProps);\\n\\ndelete props.mode;\\n\\nvar TransitionGroup = {\\n  props: props,\\n\\n  render: function render (h) {\\n    var tag = this.tag || this.$vnode.data.tag || 'span';\\n    var map = Object.create(null);\\n    var prevChildren = this.prevChildren = this.children;\\n    var rawChildren = this.$slots.default || [];\\n    var children = this.children = [];\\n    var transitionData = extractTransitionData(this);\\n\\n    for (var i = 0; i < rawChildren.length; i++) {\\n      var c = rawChildren[i];\\n      if (c.tag) {\\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\\n          children.push(c);\\n          map[c.key] = c\\n          ;(c.data || (c.data = {})).transition = transitionData;\\n        } else if (true) {\\n          var opts = c.componentOptions;\\n          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\\n          warn((\\\"<transition-group> children must be keyed: <\\\" + name + \\\">\\\"));\\n        }\\n      }\\n    }\\n\\n    if (prevChildren) {\\n      var kept = [];\\n      var removed = [];\\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\\n        var c$1 = prevChildren[i$1];\\n        c$1.data.transition = transitionData;\\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\\n        if (map[c$1.key]) {\\n          kept.push(c$1);\\n        } else {\\n          removed.push(c$1);\\n        }\\n      }\\n      this.kept = h(tag, null, kept);\\n      this.removed = removed;\\n    }\\n\\n    return h(tag, null, children)\\n  },\\n\\n  beforeUpdate: function beforeUpdate () {\\n    // force removing pass\\n    this.__patch__(\\n      this._vnode,\\n      this.kept,\\n      false, // hydrating\\n      true // removeOnly (!important, avoids unnecessary moves)\\n    );\\n    this._vnode = this.kept;\\n  },\\n\\n  updated: function updated () {\\n    var children = this.prevChildren;\\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\\n      return\\n    }\\n\\n    // we divide the work into three loops to avoid mixing DOM reads and writes\\n    // in each iteration - which helps prevent layout thrashing.\\n    children.forEach(callPendingCbs);\\n    children.forEach(recordPosition);\\n    children.forEach(applyTranslation);\\n\\n    // force reflow to put everything in position\\n    // assign to this to avoid being removed in tree-shaking\\n    // $flow-disable-line\\n    this._reflow = document.body.offsetHeight;\\n\\n    children.forEach(function (c) {\\n      if (c.data.moved) {\\n        var el = c.elm;\\n        var s = el.style;\\n        addTransitionClass(el, moveClass);\\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\\n          if (!e || /transform$/.test(e.propertyName)) {\\n            el.removeEventListener(transitionEndEvent, cb);\\n            el._moveCb = null;\\n            removeTransitionClass(el, moveClass);\\n          }\\n        });\\n      }\\n    });\\n  },\\n\\n  methods: {\\n    hasMove: function hasMove (el, moveClass) {\\n      /* istanbul ignore if */\\n      if (!hasTransition) {\\n        return false\\n      }\\n      /* istanbul ignore if */\\n      if (this._hasMove) {\\n        return this._hasMove\\n      }\\n      // Detect whether an element with the move class applied has\\n      // CSS transitions. Since the element may be inside an entering\\n      // transition at this very moment, we make a clone of it and remove\\n      // all other transition classes applied to ensure only the move class\\n      // is applied.\\n      var clone = el.cloneNode();\\n      if (el._transitionClasses) {\\n        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\\n      }\\n      addClass(clone, moveClass);\\n      clone.style.display = 'none';\\n      this.$el.appendChild(clone);\\n      var info = getTransitionInfo(clone);\\n      this.$el.removeChild(clone);\\n      return (this._hasMove = info.hasTransform)\\n    }\\n  }\\n}\\n\\nfunction callPendingCbs (c) {\\n  /* istanbul ignore if */\\n  if (c.elm._moveCb) {\\n    c.elm._moveCb();\\n  }\\n  /* istanbul ignore if */\\n  if (c.elm._enterCb) {\\n    c.elm._enterCb();\\n  }\\n}\\n\\nfunction recordPosition (c) {\\n  c.data.newPos = c.elm.getBoundingClientRect();\\n}\\n\\nfunction applyTranslation (c) {\\n  var oldPos = c.data.pos;\\n  var newPos = c.data.newPos;\\n  var dx = oldPos.left - newPos.left;\\n  var dy = oldPos.top - newPos.top;\\n  if (dx || dy) {\\n    c.data.moved = true;\\n    var s = c.elm.style;\\n    s.transform = s.WebkitTransform = \\\"translate(\\\" + dx + \\\"px,\\\" + dy + \\\"px)\\\";\\n    s.transitionDuration = '0s';\\n  }\\n}\\n\\nvar platformComponents = {\\n  Transition: Transition,\\n  TransitionGroup: TransitionGroup\\n}\\n\\n/*  */\\n\\n// install platform specific utils\\nVue.config.mustUseProp = mustUseProp;\\nVue.config.isReservedTag = isReservedTag;\\nVue.config.isReservedAttr = isReservedAttr;\\nVue.config.getTagNamespace = getTagNamespace;\\nVue.config.isUnknownElement = isUnknownElement;\\n\\n// install platform runtime directives & components\\nextend(Vue.options.directives, platformDirectives);\\nextend(Vue.options.components, platformComponents);\\n\\n// install platform patch function\\nVue.prototype.__patch__ = inBrowser ? patch : noop;\\n\\n// public mount method\\nVue.prototype.$mount = function (\\n  el,\\n  hydrating\\n) {\\n  el = el && inBrowser ? query(el) : undefined;\\n  return mountComponent(this, el, hydrating)\\n};\\n\\n// devtools global hook\\n/* istanbul ignore next */\\nif (inBrowser) {\\n  setTimeout(function () {\\n    if (config.devtools) {\\n      if (devtools) {\\n        devtools.emit('init', Vue);\\n      } else if (\\n        \\\"development\\\" !== 'production' &&\\n        \\\"development\\\" !== 'test' &&\\n        isChrome\\n      ) {\\n        console[console.info ? 'info' : 'log'](\\n          'Download the Vue Devtools extension for a better development experience:\\\\n' +\\n          'https://github.com/vuejs/vue-devtools'\\n        );\\n      }\\n    }\\n    if (\\\"development\\\" !== 'production' &&\\n      \\\"development\\\" !== 'test' &&\\n      config.productionTip !== false &&\\n      typeof console !== 'undefined'\\n    ) {\\n      console[console.info ? 'info' : 'log'](\\n        \\\"You are running Vue in development mode.\\\\n\\\" +\\n        \\\"Make sure to turn on production mode when deploying for production.\\\\n\\\" +\\n        \\\"See more tips at https://vuejs.org/guide/deployment.html\\\"\\n      );\\n    }\\n  }, 0);\\n}\\n\\n/*  */\\n\\n/* harmony default export */ __webpack_exports__[\\\"default\\\"] = (Vue);\\n\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(0), __webpack_require__(27).setImmediate))//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLnJ1bnRpbWUuZXNtLmpzPzJiMGUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsK0JBQStCO0FBQ3JELHNCQUFzQixpQkFBaUI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsaUNBQWlDLEVBQUU7QUFDckYsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsY0FBYzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFVBQVU7O0FBRXZDO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakMsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHO0FBQ1I7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsdUNBQXVDLHdCQUF3QixFQUFFO0FBQ2pFLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQyxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSx3Q0FBd0MsRUFBRTtBQUMxQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsOEJBQThCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixTQUFTLHFCQUFxQjs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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LEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDLEdBQUc7QUFDSDtBQUNBO0FBQ0EsaUJBQWlCLCtCQUErQjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQztBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjs7QUFFMUIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0JBQW9CLEVBQUU7O0FBRXBEO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDLHFCQUFxQiwrQkFBK0I7QUFDcEQ7QUFDQTtBQUNBLEdBQUc7QUFDSCx5QkFBeUI7QUFDekI7QUFDQSxzQkFBc0IsaUNBQWlDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUssUUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0JBQW9CO0FBQ3pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU8sUUFFUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU87QUFDdEM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDLGVBQWU7QUFDM0QsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRCw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVDQUF1Qzs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gscUNBQXFDLGdFQUFnRTtB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QUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTyxRQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLFFBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLDJCQUEyQixFQUFFO0FBQ3ZFLEtBQUs7QUFDTDtBQUNBLDBDQUEwQyw0QkFBNEIsRUFBRTtBQUN4RSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGVBQWU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDOztBQUVoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0EscUJBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJEQUEyRDtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5QkFB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0RUFBNEU7QUFDNUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7Ozs7OztBQVVBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0RBQXNEO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJCQUEyQjtBQUN0RCxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyw2Q0FBNkMsRUFBRTtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNEJBQTRCLEVBQUU7QUFDM0UsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsK0JBQStCLEVBQUU7QUFDOUUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxhQUFhOztBQUUzRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMscUNBQXFDOztBQUV0RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsdUNBQXVDLEVBQUU7QUFDcEY7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDJDQUEyQyxFQUFFO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyw4QkFBOEIsRUFBRTtBQUNyRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2Qyx1Q0FBdUMsRUFBRTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQSwwRUFBMEUsMEJBQTBCLEVBQUU7QUFDdEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxnQkFBZ0I7QUFDeEQ7QUFDQTtBQUNBLGdFQUFnRSxzQkFBc0IsRUFBRTtBQUN4RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDJCQUEyQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHlCQUF5QixFQUFFO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBIiwiZmlsZSI6IjI4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBWdWUuanMgdjIuNS4xNlxuICogKGMpIDIwMTQtMjAxOCBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4vKiAgKi9cblxudmFyIGVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG5cbi8vIHRoZXNlIGhlbHBlcnMgcHJvZHVjZXMgYmV0dGVyIHZtIGNvZGUgaW4gSlMgZW5naW5lcyBkdWUgdG8gdGhlaXJcbi8vIGV4cGxpY2l0bmVzcyBhbmQgZnVuY3Rpb24gaW5saW5pbmdcbmZ1bmN0aW9uIGlzVW5kZWYgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzRGVmICh2KSB7XG4gIHJldHVybiB2ICE9PSB1bmRlZmluZWQgJiYgdiAhPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc1RydWUgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHRydWVcbn1cblxuZnVuY3Rpb24gaXNGYWxzZSAodikge1xuICByZXR1cm4gdiA9PT0gZmFsc2Vcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBwcmltaXRpdmVcbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmUgKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHxcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnIHx8XG4gICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbidcbiAgKVxufVxuXG4vKipcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHJhdyB0eXBlIHN0cmluZyBvZiBhIHZhbHVlIGUuZy4gW29iamVjdCBPYmplY3RdXG4gKi9cbnZhciBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiB0b1Jhd1R5cGUgKHZhbHVlKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpXG59XG5cbi8qKlxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAob2JqKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJ1xufVxuXG5mdW5jdGlvbiBpc1JlZ0V4cCAodikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsIGlzIGEgdmFsaWQgYXJyYXkgaW5kZXguXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRBcnJheUluZGV4ICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KFN0cmluZyh2YWwpKTtcbiAgcmV0dXJuIG4gPj0gMCAmJiBNYXRoLmZsb29yKG4pID09PSBuICYmIGlzRmluaXRlKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBpcyBhY3R1YWxseSByZW5kZXJlZC5cbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcgKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGxcbiAgICA/ICcnXG4gICAgOiB0eXBlb2YgdmFsID09PSAnb2JqZWN0J1xuICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIG51bGwsIDIpXG4gICAgICA6IFN0cmluZyh2YWwpXG59XG5cbi8qKlxuICogQ29udmVydCBhIGlucHV0IHZhbHVlIHRvIGEgbnVtYmVyIGZvciBwZXJzaXN0ZW5jZS5cbiAqIElmIHRoZSBjb252ZXJzaW9uIGZhaWxzLCByZXR1cm4gb3JpZ2luYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB0b051bWJlciAodmFsKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuXG59XG5cbi8qKlxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XG4gKiBpcyBpbiB0aGF0IG1hcC5cbiAqL1xuZnVuY3Rpb24gbWFrZU1hcCAoXG4gIHN0cixcbiAgZXhwZWN0c0xvd2VyQ2FzZVxuKSB7XG4gIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgbGlzdCA9IHN0ci5zcGxpdCgnLCcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xuICB9XG4gIHJldHVybiBleHBlY3RzTG93ZXJDYXNlXG4gICAgPyBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsLnRvTG93ZXJDYXNlKCldOyB9XG4gICAgOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsXTsgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdGFnIGlzIGEgYnVpbHQtaW4gdGFnLlxuICovXG52YXIgaXNCdWlsdEluVGFnID0gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnLCB0cnVlKTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIGF0dHJpYnV0ZSBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZS5cbiAqL1xudmFyIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUgPSBtYWtlTWFwKCdrZXkscmVmLHNsb3Qsc2xvdC1zY29wZSxpcycpO1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gYXJyYXlcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlIChhcnIsIGl0ZW0pIHtcbiAgaWYgKGFyci5sZW5ndGgpIHtcbiAgICB2YXIgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgb2JqZWN0IGhhcyB0aGUgcHJvcGVydHkuXG4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBoYXNPd24gKG9iaiwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGNhY2hlZCB2ZXJzaW9uIG9mIGEgcHVyZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FjaGVkIChmbikge1xuICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKGZ1bmN0aW9uIGNhY2hlZEZuIChzdHIpIHtcbiAgICB2YXIgaGl0ID0gY2FjaGVbc3RyXTtcbiAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSlcbiAgfSlcbn1cblxuLyoqXG4gKiBDYW1lbGl6ZSBhIGh5cGhlbi1kZWxpbWl0ZWQgc3RyaW5nLlxuICovXG52YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcbnZhciBjYW1lbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCBmdW5jdGlvbiAoXywgYykgeyByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnOyB9KVxufSk7XG5cbi8qKlxuICogQ2FwaXRhbGl6ZSBhIHN0cmluZy5cbiAqL1xudmFyIGNhcGl0YWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpXG59KTtcblxuLyoqXG4gKiBIeXBoZW5hdGUgYSBjYW1lbENhc2Ugc3RyaW5nLlxuICovXG52YXIgaHlwaGVuYXRlUkUgPSAvXFxCKFtBLVpdKS9nO1xudmFyIGh5cGhlbmF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJy0kMScpLnRvTG93ZXJDYXNlKClcbn0pO1xuXG4vKipcbiAqIFNpbXBsZSBiaW5kIHBvbHlmaWxsIGZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3Qgc3VwcG9ydCBpdC4uLiBlLmcuXG4gKiBQaGFudG9tSlMgMS54LiBUZWNobmljYWxseSB3ZSBkb24ndCBuZWVkIHRoaXMgYW55bW9yZSBzaW5jZSBuYXRpdmUgYmluZCBpc1xuICogbm93IG1vcmUgcGVyZm9ybWFudCBpbiBtb3N0IGJyb3dzZXJzLCBidXQgcmVtb3ZpbmcgaXQgd291bGQgYmUgYnJlYWtpbmcgZm9yXG4gKiBjb2RlIHRoYXQgd2FzIGFibGUgdG8gcnVuIGluIFBoYW50b21KUyAxLngsIHNvIHRoaXMgbXVzdCBiZSBrZXB0IGZvclxuICogYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIHBvbHlmaWxsQmluZCAoZm4sIGN0eCkge1xuICBmdW5jdGlvbiBib3VuZEZuIChhKSB7XG4gICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHJldHVybiBsXG4gICAgICA/IGwgPiAxXG4gICAgICAgID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpXG4gICAgICAgIDogZm4uY2FsbChjdHgsIGEpXG4gICAgICA6IGZuLmNhbGwoY3R4KVxuICB9XG5cbiAgYm91bmRGbi5fbGVuZ3RoID0gZm4ubGVuZ3RoO1xuICByZXR1cm4gYm91bmRGblxufVxuXG5mdW5jdGlvbiBuYXRpdmVCaW5kIChmbiwgY3R4KSB7XG4gIHJldHVybiBmbi5iaW5kKGN0eClcbn1cblxudmFyIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuICA/IG5hdGl2ZUJpbmRcbiAgOiBwb2x5ZmlsbEJpbmQ7XG5cbi8qKlxuICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkgKGxpc3QsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgdmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyoqXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZCAodG8sIF9mcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBfZnJvbSkge1xuICAgIHRvW2tleV0gPSBfZnJvbVtrZXldO1xuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIE1lcmdlIGFuIEFycmF5IG9mIE9iamVjdHMgaW50byBhIHNpbmdsZSBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHRvT2JqZWN0IChhcnIpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJbaV0pIHtcbiAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyoqXG4gKiBQZXJmb3JtIG5vIG9wZXJhdGlvbi5cbiAqIFN0dWJiaW5nIGFyZ3MgdG8gbWFrZSBGbG93IGhhcHB5IHdpdGhvdXQgbGVhdmluZyB1c2VsZXNzIHRyYW5zcGlsZWQgY29kZVxuICogd2l0aCAuLi5yZXN0IChodHRwczovL2Zsb3cub3JnL2Jsb2cvMjAxNy8wNS8wNy9TdHJpY3QtRnVuY3Rpb24tQ2FsbC1Bcml0eS8pXG4gKi9cbmZ1bmN0aW9uIG5vb3AgKGEsIGIsIGMpIHt9XG5cbi8qKlxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cbiAqL1xudmFyIG5vID0gZnVuY3Rpb24gKGEsIGIsIGMpIHsgcmV0dXJuIGZhbHNlOyB9O1xuXG4vKipcbiAqIFJldHVybiBzYW1lIHZhbHVlXG4gKi9cbnZhciBpZGVudGl0eSA9IGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgc3RhdGljIGtleXMgc3RyaW5nIGZyb20gY29tcGlsZXIgbW9kdWxlcy5cbiAqL1xuXG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgbG9vc2VseSBlcXVhbCAtIHRoYXQgaXMsXG4gKiBpZiB0aGV5IGFyZSBwbGFpbiBvYmplY3RzLCBkbyB0aGV5IGhhdmUgdGhlIHNhbWUgc2hhcGU/XG4gKi9cbmZ1bmN0aW9uIGxvb3NlRXF1YWwgKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgaXNPYmplY3RBID0gaXNPYmplY3QoYSk7XG4gIHZhciBpc09iamVjdEIgPSBpc09iamVjdChiKTtcbiAgaWYgKGlzT2JqZWN0QSAmJiBpc09iamVjdEIpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGlzQXJyYXlBID0gQXJyYXkuaXNBcnJheShhKTtcbiAgICAgIHZhciBpc0FycmF5QiA9IEFycmF5LmlzQXJyYXkoYik7XG4gICAgICBpZiAoaXNBcnJheUEgJiYgaXNBcnJheUIpIHtcbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoZSwgYltpXSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoIWlzQXJyYXlBICYmICFpc0FycmF5Qikge1xuICAgICAgICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMoYik7XG4gICAgICAgIHJldHVybiBrZXlzQS5sZW5ndGggPT09IGtleXNCLmxlbmd0aCAmJiBrZXlzQS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9IGVsc2UgaWYgKCFpc09iamVjdEEgJiYgIWlzT2JqZWN0Qikge1xuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZiAoYXJyLCB2YWwpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobG9vc2VFcXVhbChhcnJbaV0sIHZhbCkpIHsgcmV0dXJuIGkgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG4vKipcbiAqIEVuc3VyZSBhIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmx5IG9uY2UuXG4gKi9cbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBTU1JfQVRUUiA9ICdkYXRhLXNlcnZlci1yZW5kZXJlZCc7XG5cbnZhciBBU1NFVF9UWVBFUyA9IFtcbiAgJ2NvbXBvbmVudCcsXG4gICdkaXJlY3RpdmUnLFxuICAnZmlsdGVyJ1xuXTtcblxudmFyIExJRkVDWUNMRV9IT09LUyA9IFtcbiAgJ2JlZm9yZUNyZWF0ZScsXG4gICdjcmVhdGVkJyxcbiAgJ2JlZm9yZU1vdW50JyxcbiAgJ21vdW50ZWQnLFxuICAnYmVmb3JlVXBkYXRlJyxcbiAgJ3VwZGF0ZWQnLFxuICAnYmVmb3JlRGVzdHJveScsXG4gICdkZXN0cm95ZWQnLFxuICAnYWN0aXZhdGVkJyxcbiAgJ2RlYWN0aXZhdGVkJyxcbiAgJ2Vycm9yQ2FwdHVyZWQnXG5dO1xuXG4vKiAgKi9cblxudmFyIGNvbmZpZyA9ICh7XG4gIC8qKlxuICAgKiBPcHRpb24gbWVyZ2Ugc3RyYXRlZ2llcyAodXNlZCBpbiBjb3JlL3V0aWwvb3B0aW9ucylcbiAgICovXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG4gICAqL1xuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBTaG93IHByb2R1Y3Rpb24gbW9kZSB0aXAgbWVzc2FnZSBvbiBib290P1xuICAgKi9cbiAgcHJvZHVjdGlvblRpcDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byBlbmFibGUgZGV2dG9vbHNcbiAgICovXG4gIGRldnRvb2xzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHJlY29yZCBwZXJmXG4gICAqL1xuICBwZXJmb3JtYW5jZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEVycm9yIGhhbmRsZXIgZm9yIHdhdGNoZXIgZXJyb3JzXG4gICAqL1xuICBlcnJvckhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIFdhcm4gaGFuZGxlciBmb3Igd2F0Y2hlciB3YXJuc1xuICAgKi9cbiAgd2FybkhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIElnbm9yZSBjZXJ0YWluIGN1c3RvbSBlbGVtZW50c1xuICAgKi9cbiAgaWdub3JlZEVsZW1lbnRzOiBbXSxcblxuICAvKipcbiAgICogQ3VzdG9tIHVzZXIga2V5IGFsaWFzZXMgZm9yIHYtb25cbiAgICovXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBrZXlDb2RlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgcmVnaXN0ZXJlZCBhcyBhXG4gICAqIGNvbXBvbmVudC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRUYWc6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgdXNlZCBhcyBhIGNvbXBvbmVudFxuICAgKiBwcm9wLiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZEF0dHI6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhbiB1bmtub3duIGVsZW1lbnQuXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIGlzVW5rbm93bkVsZW1lbnQ6IG5vLFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5hbWVzcGFjZSBvZiBhbiBlbGVtZW50XG4gICAqL1xuICBnZXRUYWdOYW1lc3BhY2U6IG5vb3AsXG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSByZWFsIHRhZyBuYW1lIGZvciB0aGUgc3BlY2lmaWMgcGxhdGZvcm0uXG4gICAqL1xuICBwYXJzZVBsYXRmb3JtVGFnTmFtZTogaWRlbnRpdHksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBtdXN0IGJlIGJvdW5kIHVzaW5nIHByb3BlcnR5LCBlLmcuIHZhbHVlXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIG11c3RVc2VQcm9wOiBubyxcblxuICAvKipcbiAgICogRXhwb3NlZCBmb3IgbGVnYWN5IHJlYXNvbnNcbiAgICovXG4gIF9saWZlY3ljbGVIb29rczogTElGRUNZQ0xFX0hPT0tTXG59KVxuXG4vKiAgKi9cblxuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cbiAqL1xuZnVuY3Rpb24gaXNSZXNlcnZlZCAoc3RyKSB7XG4gIHZhciBjID0gKHN0ciArICcnKS5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gYyA9PT0gMHgyNCB8fCBjID09PSAweDVGXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGRlZiAob2JqLCBrZXksIHZhbCwgZW51bWVyYWJsZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICB2YWx1ZTogdmFsLFxuICAgIGVudW1lcmFibGU6ICEhZW51bWVyYWJsZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogUGFyc2Ugc2ltcGxlIHBhdGguXG4gKi9cbnZhciBiYWlsUkUgPSAvW15cXHcuJF0vO1xuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gIGlmIChiYWlsUkUudGVzdChwYXRoKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIW9iaikgeyByZXR1cm4gfVxuICAgICAgb2JqID0gb2JqW3NlZ21lbnRzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIG9ialxuICB9XG59XG5cbi8qICAqL1xuXG4vLyBjYW4gd2UgdXNlIF9fcHJvdG9fXz9cbnZhciBoYXNQcm90byA9ICdfX3Byb3RvX18nIGluIHt9O1xuXG4vLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgaW5XZWV4ID0gdHlwZW9mIFdYRW52aXJvbm1lbnQgIT09ICd1bmRlZmluZWQnICYmICEhV1hFbnZpcm9ubWVudC5wbGF0Zm9ybTtcbnZhciB3ZWV4UGxhdGZvcm0gPSBpbldlZXggJiYgV1hFbnZpcm9ubWVudC5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpO1xudmFyIFVBID0gaW5Ccm93c2VyICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG52YXIgaXNJRSA9IFVBICYmIC9tc2llfHRyaWRlbnQvLnRlc3QoVUEpO1xudmFyIGlzSUU5ID0gVUEgJiYgVUEuaW5kZXhPZignbXNpZSA5LjAnKSA+IDA7XG52YXIgaXNFZGdlID0gVUEgJiYgVUEuaW5kZXhPZignZWRnZS8nKSA+IDA7XG52YXIgaXNBbmRyb2lkID0gKFVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDApIHx8ICh3ZWV4UGxhdGZvcm0gPT09ICdhbmRyb2lkJyk7XG52YXIgaXNJT1MgPSAoVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKSkgfHwgKHdlZXhQbGF0Zm9ybSA9PT0gJ2lvcycpO1xudmFyIGlzQ2hyb21lID0gVUEgJiYgL2Nocm9tZVxcL1xcZCsvLnRlc3QoVUEpICYmICFpc0VkZ2U7XG5cbi8vIEZpcmVmb3ggaGFzIGEgXCJ3YXRjaFwiIGZ1bmN0aW9uIG9uIE9iamVjdC5wcm90b3R5cGUuLi5cbnZhciBuYXRpdmVXYXRjaCA9ICh7fSkud2F0Y2g7XG5cbnZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbmlmIChpbkJyb3dzZXIpIHtcbiAgdHJ5IHtcbiAgICB2YXIgb3B0cyA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRzLCAncGFzc2l2ZScsICh7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjg1XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QtcGFzc2l2ZScsIG51bGwsIG9wdHMpO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG4vLyB0aGlzIG5lZWRzIHRvIGJlIGxhenktZXZhbGVkIGJlY2F1c2UgdnVlIG1heSBiZSByZXF1aXJlZCBiZWZvcmVcbi8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXG52YXIgX2lzU2VydmVyO1xudmFyIGlzU2VydmVyUmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWluQnJvd3NlciAmJiAhaW5XZWV4ICYmIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBkZXRlY3QgcHJlc2VuY2Ugb2YgdnVlLXNlcnZlci1yZW5kZXJlciBhbmQgYXZvaWRcbiAgICAgIC8vIFdlYnBhY2sgc2hpbW1pbmcgdGhlIHByb2Nlc3NcbiAgICAgIF9pc1NlcnZlciA9IGdsb2JhbFsncHJvY2VzcyddLmVudi5WVUVfRU5WID09PSAnc2VydmVyJztcbiAgICB9IGVsc2Uge1xuICAgICAgX2lzU2VydmVyID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBfaXNTZXJ2ZXJcbn07XG5cbi8vIGRldGVjdCBkZXZ0b29sc1xudmFyIGRldnRvb2xzID0gaW5Ccm93c2VyICYmIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gaXNOYXRpdmUgKEN0b3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09PSAnZnVuY3Rpb24nICYmIC9uYXRpdmUgY29kZS8udGVzdChDdG9yLnRvU3RyaW5nKCkpXG59XG5cbnZhciBoYXNTeW1ib2wgPVxuICB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTeW1ib2wpICYmXG4gIHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShSZWZsZWN0Lm93bktleXMpO1xuXG52YXIgX1NldDtcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqLyAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbmlmICh0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTZXQpKSB7XG4gIC8vIHVzZSBuYXRpdmUgU2V0IHdoZW4gYXZhaWxhYmxlLlxuICBfU2V0ID0gU2V0O1xufSBlbHNlIHtcbiAgLy8gYSBub24tc3RhbmRhcmQgU2V0IHBvbHlmaWxsIHRoYXQgb25seSB3b3JrcyB3aXRoIHByaW1pdGl2ZSBrZXlzLlxuICBfU2V0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXQgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRba2V5XSA9PT0gdHJ1ZVxuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGtleSkge1xuICAgICAgdGhpcy5zZXRba2V5XSA9IHRydWU7XG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2V0O1xuICB9KCkpO1xufVxuXG4vKiAgKi9cblxudmFyIHdhcm4gPSBub29wO1xudmFyIHRpcCA9IG5vb3A7XG52YXIgZ2VuZXJhdGVDb21wb25lbnRUcmFjZSA9IChub29wKTsgLy8gd29yayBhcm91bmQgZmxvdyBjaGVja1xudmFyIGZvcm1hdENvbXBvbmVudE5hbWUgPSAobm9vcCk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuICB2YXIgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcdykvZztcbiAgdmFyIGNsYXNzaWZ5ID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyXG4gICAgLnJlcGxhY2UoY2xhc3NpZnlSRSwgZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudG9VcHBlckNhc2UoKTsgfSlcbiAgICAucmVwbGFjZSgvWy1fXS9nLCAnJyk7IH07XG5cbiAgd2FybiA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgdmFyIHRyYWNlID0gdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnO1xuXG4gICAgaWYgKGNvbmZpZy53YXJuSGFuZGxlcikge1xuICAgICAgY29uZmlnLndhcm5IYW5kbGVyLmNhbGwobnVsbCwgbXNnLCB2bSwgdHJhY2UpO1xuICAgIH0gZWxzZSBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKChcIltWdWUgd2Fybl06IFwiICsgbXNnICsgdHJhY2UpKTtcbiAgICB9XG4gIH07XG5cbiAgdGlwID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbVnVlIHRpcF06IFwiICsgbXNnICsgKFxuICAgICAgICB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJydcbiAgICAgICkpO1xuICAgIH1cbiAgfTtcblxuICBmb3JtYXRDb21wb25lbnROYW1lID0gZnVuY3Rpb24gKHZtLCBpbmNsdWRlRmlsZSkge1xuICAgIGlmICh2bS4kcm9vdCA9PT0gdm0pIHtcbiAgICAgIHJldHVybiAnPFJvb3Q+J1xuICAgIH1cbiAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiB2bSA9PT0gJ2Z1bmN0aW9uJyAmJiB2bS5jaWQgIT0gbnVsbFxuICAgICAgPyB2bS5vcHRpb25zXG4gICAgICA6IHZtLl9pc1Z1ZVxuICAgICAgICA/IHZtLiRvcHRpb25zIHx8IHZtLmNvbnN0cnVjdG9yLm9wdGlvbnNcbiAgICAgICAgOiB2bSB8fCB7fTtcbiAgICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZSB8fCBvcHRpb25zLl9jb21wb25lbnRUYWc7XG4gICAgdmFyIGZpbGUgPSBvcHRpb25zLl9fZmlsZTtcbiAgICBpZiAoIW5hbWUgJiYgZmlsZSkge1xuICAgICAgdmFyIG1hdGNoID0gZmlsZS5tYXRjaCgvKFteL1xcXFxdKylcXC52dWUkLyk7XG4gICAgICBuYW1lID0gbWF0Y2ggJiYgbWF0Y2hbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIChuYW1lID8gKFwiPFwiICsgKGNsYXNzaWZ5KG5hbWUpKSArIFwiPlwiKSA6IFwiPEFub255bW91cz5cIikgK1xuICAgICAgKGZpbGUgJiYgaW5jbHVkZUZpbGUgIT09IGZhbHNlID8gKFwiIGF0IFwiICsgZmlsZSkgOiAnJylcbiAgICApXG4gIH07XG5cbiAgdmFyIHJlcGVhdCA9IGZ1bmN0aW9uIChzdHIsIG4pIHtcbiAgICB2YXIgcmVzID0gJyc7XG4gICAgd2hpbGUgKG4pIHtcbiAgICAgIGlmIChuICUgMiA9PT0gMSkgeyByZXMgKz0gc3RyOyB9XG4gICAgICBpZiAobiA+IDEpIHsgc3RyICs9IHN0cjsgfVxuICAgICAgbiA+Pj0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9O1xuXG4gIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSBmdW5jdGlvbiAodm0pIHtcbiAgICBpZiAodm0uX2lzVnVlICYmIHZtLiRwYXJlbnQpIHtcbiAgICAgIHZhciB0cmVlID0gW107XG4gICAgICB2YXIgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgIHdoaWxlICh2bSkge1xuICAgICAgICBpZiAodHJlZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIGxhc3QgPSB0cmVlW3RyZWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKGxhc3QuY29uc3RydWN0b3IgPT09IHZtLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UrKztcbiAgICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPiAwKSB7XG4gICAgICAgICAgICB0cmVlW3RyZWUubGVuZ3RoIC0gMV0gPSBbbGFzdCwgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlXTtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyZWUucHVzaCh2bSk7XG4gICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnXFxuXFxuZm91bmQgaW5cXG5cXG4nICsgdHJlZVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh2bSwgaSkgeyByZXR1cm4gKFwiXCIgKyAoaSA9PT0gMCA/ICctLS0+ICcgOiByZXBlYXQoJyAnLCA1ICsgaSAqIDIpKSArIChBcnJheS5pc0FycmF5KHZtKVxuICAgICAgICAgICAgPyAoKGZvcm1hdENvbXBvbmVudE5hbWUodm1bMF0pKSArIFwiLi4uIChcIiArICh2bVsxXSkgKyBcIiByZWN1cnNpdmUgY2FsbHMpXCIpXG4gICAgICAgICAgICA6IGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSk7IH0pXG4gICAgICAgIC5qb2luKCdcXG4nKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKFwiXFxuXFxuKGZvdW5kIGluIFwiICsgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiKVwiKVxuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cblxudmFyIHVpZCA9IDA7XG5cbi8qKlxuICogQSBkZXAgaXMgYW4gb2JzZXJ2YWJsZSB0aGF0IGNhbiBoYXZlIG11bHRpcGxlXG4gKiBkaXJlY3RpdmVzIHN1YnNjcmliaW5nIHRvIGl0LlxuICovXG52YXIgRGVwID0gZnVuY3Rpb24gRGVwICgpIHtcbiAgdGhpcy5pZCA9IHVpZCsrO1xuICB0aGlzLnN1YnMgPSBbXTtcbn07XG5cbkRlcC5wcm90b3R5cGUuYWRkU3ViID0gZnVuY3Rpb24gYWRkU3ViIChzdWIpIHtcbiAgdGhpcy5zdWJzLnB1c2goc3ViKTtcbn07XG5cbkRlcC5wcm90b3R5cGUucmVtb3ZlU3ViID0gZnVuY3Rpb24gcmVtb3ZlU3ViIChzdWIpIHtcbiAgcmVtb3ZlKHRoaXMuc3Vicywgc3ViKTtcbn07XG5cbkRlcC5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgaWYgKERlcC50YXJnZXQpIHtcbiAgICBEZXAudGFyZ2V0LmFkZERlcCh0aGlzKTtcbiAgfVxufTtcblxuRGVwLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiBub3RpZnkgKCkge1xuICAvLyBzdGFiaWxpemUgdGhlIHN1YnNjcmliZXIgbGlzdCBmaXJzdFxuICB2YXIgc3VicyA9IHRoaXMuc3Vicy5zbGljZSgpO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHN1YnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgc3Vic1tpXS51cGRhdGUoKTtcbiAgfVxufTtcblxuLy8gdGhlIGN1cnJlbnQgdGFyZ2V0IHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkLlxuLy8gdGhpcyBpcyBnbG9iYWxseSB1bmlxdWUgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvbmx5IG9uZVxuLy8gd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQgYXQgYW55IHRpbWUuXG5EZXAudGFyZ2V0ID0gbnVsbDtcbnZhciB0YXJnZXRTdGFjayA9IFtdO1xuXG5mdW5jdGlvbiBwdXNoVGFyZ2V0IChfdGFyZ2V0KSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7IHRhcmdldFN0YWNrLnB1c2goRGVwLnRhcmdldCk7IH1cbiAgRGVwLnRhcmdldCA9IF90YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIHBvcFRhcmdldCAoKSB7XG4gIERlcC50YXJnZXQgPSB0YXJnZXRTdGFjay5wb3AoKTtcbn1cblxuLyogICovXG5cbnZhciBWTm9kZSA9IGZ1bmN0aW9uIFZOb2RlIChcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgdGV4dCxcbiAgZWxtLFxuICBjb250ZXh0LFxuICBjb21wb25lbnRPcHRpb25zLFxuICBhc3luY0ZhY3Rvcnlcbikge1xuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB0aGlzLnRleHQgPSB0ZXh0O1xuICB0aGlzLmVsbSA9IGVsbTtcbiAgdGhpcy5ucyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5mbkNvbnRleHQgPSB1bmRlZmluZWQ7XG4gIHRoaXMuZm5PcHRpb25zID0gdW5kZWZpbmVkO1xuICB0aGlzLmZuU2NvcGVJZCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5rZXkgPSBkYXRhICYmIGRhdGEua2V5O1xuICB0aGlzLmNvbXBvbmVudE9wdGlvbnMgPSBjb21wb25lbnRPcHRpb25zO1xuICB0aGlzLmNvbXBvbmVudEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5yYXcgPSBmYWxzZTtcbiAgdGhpcy5pc1N0YXRpYyA9IGZhbHNlO1xuICB0aGlzLmlzUm9vdEluc2VydCA9IHRydWU7XG4gIHRoaXMuaXNDb21tZW50ID0gZmFsc2U7XG4gIHRoaXMuaXNDbG9uZWQgPSBmYWxzZTtcbiAgdGhpcy5pc09uY2UgPSBmYWxzZTtcbiAgdGhpcy5hc3luY0ZhY3RvcnkgPSBhc3luY0ZhY3Rvcnk7XG4gIHRoaXMuYXN5bmNNZXRhID0gdW5kZWZpbmVkO1xuICB0aGlzLmlzQXN5bmNQbGFjZWhvbGRlciA9IGZhbHNlO1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgY2hpbGQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuLy8gREVQUkVDQVRFRDogYWxpYXMgZm9yIGNvbXBvbmVudEluc3RhbmNlIGZvciBiYWNrd2FyZHMgY29tcGF0LlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnByb3RvdHlwZUFjY2Vzc29ycy5jaGlsZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVk5vZGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxudmFyIGNyZWF0ZUVtcHR5Vk5vZGUgPSBmdW5jdGlvbiAodGV4dCkge1xuICBpZiAoIHRleHQgPT09IHZvaWQgMCApIHRleHQgPSAnJztcblxuICB2YXIgbm9kZSA9IG5ldyBWTm9kZSgpO1xuICBub2RlLnRleHQgPSB0ZXh0O1xuICBub2RlLmlzQ29tbWVudCA9IHRydWU7XG4gIHJldHVybiBub2RlXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUgKHZhbCkge1xuICByZXR1cm4gbmV3IFZOb2RlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFN0cmluZyh2YWwpKVxufVxuXG4vLyBvcHRpbWl6ZWQgc2hhbGxvdyBjbG9uZVxuLy8gdXNlZCBmb3Igc3RhdGljIG5vZGVzIGFuZCBzbG90IG5vZGVzIGJlY2F1c2UgdGhleSBtYXkgYmUgcmV1c2VkIGFjcm9zc1xuLy8gbXVsdGlwbGUgcmVuZGVycywgY2xvbmluZyB0aGVtIGF2b2lkcyBlcnJvcnMgd2hlbiBET00gbWFuaXB1bGF0aW9ucyByZWx5XG4vLyBvbiB0aGVpciBlbG0gcmVmZXJlbmNlLlxuZnVuY3Rpb24gY2xvbmVWTm9kZSAodm5vZGUpIHtcbiAgdmFyIGNsb25lZCA9IG5ldyBWTm9kZShcbiAgICB2bm9kZS50YWcsXG4gICAgdm5vZGUuZGF0YSxcbiAgICB2bm9kZS5jaGlsZHJlbixcbiAgICB2bm9kZS50ZXh0LFxuICAgIHZub2RlLmVsbSxcbiAgICB2bm9kZS5jb250ZXh0LFxuICAgIHZub2RlLmNvbXBvbmVudE9wdGlvbnMsXG4gICAgdm5vZGUuYXN5bmNGYWN0b3J5XG4gICk7XG4gIGNsb25lZC5ucyA9IHZub2RlLm5zO1xuICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcbiAgY2xvbmVkLmtleSA9IHZub2RlLmtleTtcbiAgY2xvbmVkLmlzQ29tbWVudCA9IHZub2RlLmlzQ29tbWVudDtcbiAgY2xvbmVkLmZuQ29udGV4dCA9IHZub2RlLmZuQ29udGV4dDtcbiAgY2xvbmVkLmZuT3B0aW9ucyA9IHZub2RlLmZuT3B0aW9ucztcbiAgY2xvbmVkLmZuU2NvcGVJZCA9IHZub2RlLmZuU2NvcGVJZDtcbiAgY2xvbmVkLmlzQ2xvbmVkID0gdHJ1ZTtcbiAgcmV0dXJuIGNsb25lZFxufVxuXG4vKlxuICogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoXG4gKiBkeW5hbWljYWxseSBhY2Nlc3NpbmcgbWV0aG9kcyBvbiBBcnJheSBwcm90b3R5cGVcbiAqL1xuXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBhcnJheU1ldGhvZHMgPSBPYmplY3QuY3JlYXRlKGFycmF5UHJvdG8pO1xuXG52YXIgbWV0aG9kc1RvUGF0Y2ggPSBbXG4gICdwdXNoJyxcbiAgJ3BvcCcsXG4gICdzaGlmdCcsXG4gICd1bnNoaWZ0JyxcbiAgJ3NwbGljZScsXG4gICdzb3J0JyxcbiAgJ3JldmVyc2UnXG5dO1xuXG4vKipcbiAqIEludGVyY2VwdCBtdXRhdGluZyBtZXRob2RzIGFuZCBlbWl0IGV2ZW50c1xuICovXG5tZXRob2RzVG9QYXRjaC5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgLy8gY2FjaGUgb3JpZ2luYWwgbWV0aG9kXG4gIHZhciBvcmlnaW5hbCA9IGFycmF5UHJvdG9bbWV0aG9kXTtcbiAgZGVmKGFycmF5TWV0aG9kcywgbWV0aG9kLCBmdW5jdGlvbiBtdXRhdG9yICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICB2YXIgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgdmFyIG9iID0gdGhpcy5fX29iX187XG4gICAgdmFyIGluc2VydGVkO1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICBjYXNlICdwdXNoJzpcbiAgICAgIGNhc2UgJ3Vuc2hpZnQnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzcGxpY2UnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3Muc2xpY2UoMik7XG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChpbnNlcnRlZCkgeyBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpOyB9XG4gICAgLy8gbm90aWZ5IGNoYW5nZVxuICAgIG9iLmRlcC5ub3RpZnkoKTtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pO1xufSk7XG5cbi8qICAqL1xuXG52YXIgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcblxuLyoqXG4gKiBJbiBzb21lIGNhc2VzIHdlIG1heSB3YW50IHRvIGRpc2FibGUgb2JzZXJ2YXRpb24gaW5zaWRlIGEgY29tcG9uZW50J3NcbiAqIHVwZGF0ZSBjb21wdXRhdGlvbi5cbiAqL1xudmFyIHNob3VsZE9ic2VydmUgPSB0cnVlO1xuXG5mdW5jdGlvbiB0b2dnbGVPYnNlcnZpbmcgKHZhbHVlKSB7XG4gIHNob3VsZE9ic2VydmUgPSB2YWx1ZTtcbn1cblxuLyoqXG4gKiBPYnNlcnZlciBjbGFzcyB0aGF0IGlzIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRoZSB0YXJnZXRcbiAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XG4gKiBjb2xsZWN0IGRlcGVuZGVuY2llcyBhbmQgZGlzcGF0Y2ggdXBkYXRlcy5cbiAqL1xudmFyIE9ic2VydmVyID0gZnVuY3Rpb24gT2JzZXJ2ZXIgKHZhbHVlKSB7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgdGhpcy5kZXAgPSBuZXcgRGVwKCk7XG4gIHRoaXMudm1Db3VudCA9IDA7XG4gIGRlZih2YWx1ZSwgJ19fb2JfXycsIHRoaXMpO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2YXIgYXVnbWVudCA9IGhhc1Byb3RvXG4gICAgICA/IHByb3RvQXVnbWVudFxuICAgICAgOiBjb3B5QXVnbWVudDtcbiAgICBhdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMsIGFycmF5S2V5cyk7XG4gICAgdGhpcy5vYnNlcnZlQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMud2Fsayh2YWx1ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogV2FsayB0aHJvdWdoIGVhY2ggcHJvcGVydHkgYW5kIGNvbnZlcnQgdGhlbSBpbnRvXG4gKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIHdhbGsgKG9iaikge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGRlZmluZVJlYWN0aXZlKG9iaiwga2V5c1tpXSk7XG4gIH1cbn07XG5cbi8qKlxuICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiBvYnNlcnZlQXJyYXkgKGl0ZW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG4gIH1cbn07XG5cbi8vIGhlbHBlcnNcblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuICovXG5mdW5jdGlvbiBwcm90b0F1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbn1cblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxuICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICovXG5mdW5jdGlvbiBvYnNlcnZlICh2YWx1ZSwgYXNSb290RGF0YSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iO1xuICBpZiAoaGFzT3duKHZhbHVlLCAnX19vYl9fJykgJiYgdmFsdWUuX19vYl9fIGluc3RhbmNlb2YgT2JzZXJ2ZXIpIHtcbiAgICBvYiA9IHZhbHVlLl9fb2JfXztcbiAgfSBlbHNlIGlmIChcbiAgICBzaG91bGRPYnNlcnZlICYmXG4gICAgIWlzU2VydmVyUmVuZGVyaW5nKCkgJiZcbiAgICAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXG4gICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiZcbiAgICAhdmFsdWUuX2lzVnVlXG4gICkge1xuICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKTtcbiAgfVxuICBpZiAoYXNSb290RGF0YSAmJiBvYikge1xuICAgIG9iLnZtQ291bnQrKztcbiAgfVxuICByZXR1cm4gb2Jcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlIChcbiAgb2JqLFxuICBrZXksXG4gIHZhbCxcbiAgY3VzdG9tU2V0dGVyLFxuICBzaGFsbG93XG4pIHtcbiAgdmFyIGRlcCA9IG5ldyBEZXAoKTtcblxuICB2YXIgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGNhdGVyIGZvciBwcmUtZGVmaW5lZCBnZXR0ZXIvc2V0dGVyc1xuICB2YXIgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xuICBpZiAoIWdldHRlciAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFsID0gb2JqW2tleV07XG4gIH1cbiAgdmFyIHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcblxuICB2YXIgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUodmFsKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlciAoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgZGVwLmRlcGVuZCgpO1xuICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgZGVwZW5kQXJyYXkodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyIChuZXdWYWwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChuZXdWYWwgPT09IHZhbHVlIHx8IChuZXdWYWwgIT09IG5ld1ZhbCAmJiB2YWx1ZSAhPT0gdmFsdWUpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGN1c3RvbVNldHRlcikge1xuICAgICAgICBjdXN0b21TZXR0ZXIoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgc2V0dGVyLmNhbGwob2JqLCBuZXdWYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gbmV3VmFsO1xuICAgICAgfVxuICAgICAgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUobmV3VmFsKTtcbiAgICAgIGRlcC5ub3RpZnkoKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFNldCBhIHByb3BlcnR5IG9uIGFuIG9iamVjdC4gQWRkcyB0aGUgbmV3IHByb3BlcnR5IGFuZFxuICogdHJpZ2dlcnMgY2hhbmdlIG5vdGlmaWNhdGlvbiBpZiB0aGUgcHJvcGVydHkgZG9lc24ndFxuICogYWxyZWFkeSBleGlzdC5cbiAqL1xuZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgKGlzVW5kZWYodGFyZ2V0KSB8fCBpc1ByaW1pdGl2ZSh0YXJnZXQpKVxuICApIHtcbiAgICB3YXJuKChcIkNhbm5vdCBzZXQgcmVhY3RpdmUgcHJvcGVydHkgb24gdW5kZWZpbmVkLCBudWxsLCBvciBwcmltaXRpdmUgdmFsdWU6IFwiICsgKCh0YXJnZXQpKSkpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgIHRhcmdldC5sZW5ndGggPSBNYXRoLm1heCh0YXJnZXQubGVuZ3RoLCBrZXkpO1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxLCB2YWwpO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoa2V5IGluIHRhcmdldCAmJiAhKGtleSBpbiBPYmplY3QucHJvdG90eXBlKSkge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0KS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBhZGRpbmcgcmVhY3RpdmUgcHJvcGVydGllcyB0byBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICdhdCBydW50aW1lIC0gZGVjbGFyZSBpdCB1cGZyb250IGluIHRoZSBkYXRhIG9wdGlvbi4nXG4gICAgKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKCFvYikge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBkZWZpbmVSZWFjdGl2ZShvYi52YWx1ZSwga2V5LCB2YWwpO1xuICBvYi5kZXAubm90aWZ5KCk7XG4gIHJldHVybiB2YWxcbn1cblxuLyoqXG4gKiBEZWxldGUgYSBwcm9wZXJ0eSBhbmQgdHJpZ2dlciBjaGFuZ2UgaWYgbmVjZXNzYXJ5LlxuICovXG5mdW5jdGlvbiBkZWwgKHRhcmdldCwga2V5KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgKGlzVW5kZWYodGFyZ2V0KSB8fCBpc1ByaW1pdGl2ZSh0YXJnZXQpKVxuICApIHtcbiAgICB3YXJuKChcIkNhbm5vdCBkZWxldGUgcmVhY3RpdmUgcHJvcGVydHkgb24gdW5kZWZpbmVkLCBudWxsLCBvciBwcmltaXRpdmUgdmFsdWU6IFwiICsgKCh0YXJnZXQpKSkpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0KS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBkZWxldGluZyBwcm9wZXJ0aWVzIG9uIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJy0ganVzdCBzZXQgaXQgdG8gbnVsbC4nXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBkZWxldGUgdGFyZ2V0W2tleV07XG4gIGlmICghb2IpIHtcbiAgICByZXR1cm5cbiAgfVxuICBvYi5kZXAubm90aWZ5KCk7XG59XG5cbi8qKlxuICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2VcbiAqIHdlIGNhbm5vdCBpbnRlcmNlcHQgYXJyYXkgZWxlbWVudCBhY2Nlc3MgbGlrZSBwcm9wZXJ0eSBnZXR0ZXJzLlxuICovXG5mdW5jdGlvbiBkZXBlbmRBcnJheSAodmFsdWUpIHtcbiAgZm9yICh2YXIgZSA9ICh2b2lkIDApLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGUgPSB2YWx1ZVtpXTtcbiAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgZGVwZW5kQXJyYXkoZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cbiAqL1xudmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG5cbi8qKlxuICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xuICovXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBzdHJhdHMuZWwgPSBzdHJhdHMucHJvcHNEYXRhID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQsIHZtLCBrZXkpIHtcbiAgICBpZiAoIXZtKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIm9wdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgaW5zdGFuY2UgXCIgK1xuICAgICAgICAnY3JlYXRpb24gd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFN0cmF0KHBhcmVudCwgY2hpbGQpXG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YSAodG8sIGZyb20pIHtcbiAgaWYgKCFmcm9tKSB7IHJldHVybiB0byB9XG4gIHZhciBrZXksIHRvVmFsLCBmcm9tVmFsO1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyb20pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIHRvVmFsID0gdG9ba2V5XTtcbiAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XG4gICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHRvVmFsKSAmJiBpc1BsYWluT2JqZWN0KGZyb21WYWwpKSB7XG4gICAgICBtZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBEYXRhXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YU9yRm4gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICAvLyBpbiBhIFZ1ZS5leHRlbmQgbWVyZ2UsIGJvdGggc2hvdWxkIGJlIGZ1bmN0aW9uc1xuICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICAgIHJldHVybiBjaGlsZFZhbFxuICAgIH1cbiAgICAvLyB3aGVuIHBhcmVudFZhbCAmIGNoaWxkVmFsIGFyZSBib3RoIHByZXNlbnQsXG4gICAgLy8gd2UgbmVlZCB0byByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gICAgLy8gbWVyZ2VkIHJlc3VsdCBvZiBib3RoIGZ1bmN0aW9ucy4uLiBubyBuZWVkIHRvXG4gICAgLy8gY2hlY2sgaWYgcGFyZW50VmFsIGlzIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlXG4gICAgLy8gaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb24gdG8gcGFzcyBwcmV2aW91cyBtZXJnZXMuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbiAoKSB7XG4gICAgICByZXR1cm4gbWVyZ2VEYXRhKFxuICAgICAgICB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbicgPyBjaGlsZFZhbC5jYWxsKHRoaXMsIHRoaXMpIDogY2hpbGRWYWwsXG4gICAgICAgIHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbicgPyBwYXJlbnRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IHBhcmVudFZhbFxuICAgICAgKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkSW5zdGFuY2VEYXRhRm4gKCkge1xuICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcbiAgICAgIHZhciBpbnN0YW5jZURhdGEgPSB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBjaGlsZFZhbC5jYWxsKHZtLCB2bSlcbiAgICAgICAgOiBjaGlsZFZhbDtcbiAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBwYXJlbnRWYWwuY2FsbCh2bSwgdm0pXG4gICAgICAgIDogcGFyZW50VmFsO1xuICAgICAgaWYgKGluc3RhbmNlRGF0YSkge1xuICAgICAgICByZXR1cm4gbWVyZ2VEYXRhKGluc3RhbmNlRGF0YSwgZGVmYXVsdERhdGEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGVmYXVsdERhdGFcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuc3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtXG4pIHtcbiAgaWYgKCF2bSkge1xuICAgIGlmIChjaGlsZFZhbCAmJiB0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArXG4gICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgICAnZGVmaW5pdGlvbnMuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbClcbiAgfVxuXG4gIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKVxufTtcblxuLyoqXG4gKiBIb29rcyBhbmQgcHJvcHMgYXJlIG1lcmdlZCBhcyBhcnJheXMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSG9vayAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWxcbikge1xuICByZXR1cm4gY2hpbGRWYWxcbiAgICA/IHBhcmVudFZhbFxuICAgICAgPyBwYXJlbnRWYWwuY29uY2F0KGNoaWxkVmFsKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkVmFsKVxuICAgICAgICA/IGNoaWxkVmFsXG4gICAgICAgIDogW2NoaWxkVmFsXVxuICAgIDogcGFyZW50VmFsXG59XG5cbkxJRkVDWUNMRV9IT09LUy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gIHN0cmF0c1tob29rXSA9IG1lcmdlSG9vaztcbn0pO1xuXG4vKipcbiAqIEFzc2V0c1xuICpcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cbiAqIGEgdGhyZWUtd2F5IG1lcmdlIGJldHdlZW4gY29uc3RydWN0b3Igb3B0aW9ucywgaW5zdGFuY2VcbiAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBtZXJnZUFzc2V0cyAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gIGlmIChjaGlsZFZhbCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gICAgcmV0dXJuIGV4dGVuZChyZXMsIGNoaWxkVmFsKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXNcbiAgfVxufVxuXG5BU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xufSk7XG5cbi8qKlxuICogV2F0Y2hlcnMuXG4gKlxuICogV2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXG4gKi9cbnN0cmF0cy53YXRjaCA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIC8vIHdvcmsgYXJvdW5kIEZpcmVmb3gncyBPYmplY3QucHJvdG90eXBlLndhdGNoLi4uXG4gIGlmIChwYXJlbnRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IHBhcmVudFZhbCA9IHVuZGVmaW5lZDsgfVxuICBpZiAoY2hpbGRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IGNoaWxkVmFsID0gdW5kZWZpbmVkOyB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKSB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IHt9O1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBmb3IgKHZhciBrZXkkMSBpbiBjaGlsZFZhbCkge1xuICAgIHZhciBwYXJlbnQgPSByZXRba2V5JDFdO1xuICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleSQxXTtcbiAgICBpZiAocGFyZW50ICYmICFBcnJheS5pc0FycmF5KHBhcmVudCkpIHtcbiAgICAgIHBhcmVudCA9IFtwYXJlbnRdO1xuICAgIH1cbiAgICByZXRba2V5JDFdID0gcGFyZW50XG4gICAgICA/IHBhcmVudC5jb25jYXQoY2hpbGQpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGQpID8gY2hpbGQgOiBbY2hpbGRdO1xuICB9XG4gIHJldHVybiByZXRcbn07XG5cbi8qKlxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cbiAqL1xuc3RyYXRzLnByb3BzID1cbnN0cmF0cy5tZXRob2RzID1cbnN0cmF0cy5pbmplY3QgPVxuc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgaWYgKGNoaWxkVmFsICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgaWYgKGNoaWxkVmFsKSB7IGV4dGVuZChyZXQsIGNoaWxkVmFsKTsgfVxuICByZXR1cm4gcmV0XG59O1xuc3RyYXRzLnByb3ZpZGUgPSBtZXJnZURhdGFPckZuO1xuXG4vKipcbiAqIERlZmF1bHQgc3RyYXRlZ3kuXG4gKi9cbnZhciBkZWZhdWx0U3RyYXQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICByZXR1cm4gY2hpbGRWYWwgPT09IHVuZGVmaW5lZFxuICAgID8gcGFyZW50VmFsXG4gICAgOiBjaGlsZFZhbFxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBjb21wb25lbnQgbmFtZXNcbiAqL1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnRzIChvcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLmNvbXBvbmVudHMpIHtcbiAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoa2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbXBvbmVudE5hbWUgKG5hbWUpIHtcbiAgaWYgKCEvXlthLXpBLVpdW1xcdy1dKiQvLnRlc3QobmFtZSkpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgY29tcG9uZW50IG5hbWU6IFwiJyArIG5hbWUgKyAnXCIuIENvbXBvbmVudCBuYW1lcyAnICtcbiAgICAgICdjYW4gb25seSBjb250YWluIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIGFuZCB0aGUgaHlwaGVuLCAnICtcbiAgICAgICdhbmQgbXVzdCBzdGFydCB3aXRoIGEgbGV0dGVyLidcbiAgICApO1xuICB9XG4gIGlmIChpc0J1aWx0SW5UYWcobmFtZSkgfHwgY29uZmlnLmlzUmVzZXJ2ZWRUYWcobmFtZSkpIHtcbiAgICB3YXJuKFxuICAgICAgJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXG4gICAgICAnaWQ6ICcgKyBuYW1lXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxuICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMgKG9wdGlvbnMsIHZtKSB7XG4gIHZhciBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG4gIGlmICghcHJvcHMpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgaSwgdmFsLCBuYW1lO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhbCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5hbWUgPSBjYW1lbGl6ZSh2YWwpO1xuICAgICAgICByZXNbbmFtZV0gPSB7IHR5cGU6IG51bGwgfTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKCdwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguJyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICB2YWwgPSBwcm9wc1trZXldO1xuICAgICAgbmFtZSA9IGNhbWVsaXplKGtleSk7XG4gICAgICByZXNbbmFtZV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgPyB2YWxcbiAgICAgICAgOiB7IHR5cGU6IHZhbCB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJwcm9wc1xcXCI6IGV4cGVjdGVkIGFuIEFycmF5IG9yIGFuIE9iamVjdCwgXCIgK1xuICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZShwcm9wcykpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgb3B0aW9ucy5wcm9wcyA9IHJlcztcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYWxsIGluamVjdGlvbnMgaW50byBPYmplY3QtYmFzZWQgZm9ybWF0XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUluamVjdCAob3B0aW9ucywgdm0pIHtcbiAgdmFyIGluamVjdCA9IG9wdGlvbnMuaW5qZWN0O1xuICBpZiAoIWluamVjdCkgeyByZXR1cm4gfVxuICB2YXIgbm9ybWFsaXplZCA9IG9wdGlvbnMuaW5qZWN0ID0ge307XG4gIGlmIChBcnJheS5pc0FycmF5KGluamVjdCkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluamVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgbm9ybWFsaXplZFtpbmplY3RbaV1dID0geyBmcm9tOiBpbmplY3RbaV0gfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChpbmplY3QpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGluamVjdCkge1xuICAgICAgdmFyIHZhbCA9IGluamVjdFtrZXldO1xuICAgICAgbm9ybWFsaXplZFtrZXldID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gZXh0ZW5kKHsgZnJvbToga2V5IH0sIHZhbClcbiAgICAgICAgOiB7IGZyb206IHZhbCB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJpbmplY3RcXFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIFwiICtcbiAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUoaW5qZWN0KSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSByYXcgZnVuY3Rpb24gZGlyZWN0aXZlcyBpbnRvIG9iamVjdCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMgKG9wdGlvbnMpIHtcbiAgdmFyIGRpcnMgPSBvcHRpb25zLmRpcmVjdGl2ZXM7XG4gIGlmIChkaXJzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGRpcnMpIHtcbiAgICAgIHZhciBkZWYgPSBkaXJzW2tleV07XG4gICAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkaXJzW2tleV0gPSB7IGJpbmQ6IGRlZiwgdXBkYXRlOiBkZWYgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0VHlwZSAobmFtZSwgdmFsdWUsIHZtKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcIlwiICsgbmFtZSArIFwiXFxcIjogZXhwZWN0ZWQgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKHZhbHVlKSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyAoXG4gIHBhcmVudCxcbiAgY2hpbGQsXG4gIHZtXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaGVja0NvbXBvbmVudHMoY2hpbGQpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNoaWxkID0gY2hpbGQub3B0aW9ucztcbiAgfVxuXG4gIG5vcm1hbGl6ZVByb3BzKGNoaWxkLCB2bSk7XG4gIG5vcm1hbGl6ZUluamVjdChjaGlsZCwgdm0pO1xuICBub3JtYWxpemVEaXJlY3RpdmVzKGNoaWxkKTtcbiAgdmFyIGV4dGVuZHNGcm9tID0gY2hpbGQuZXh0ZW5kcztcbiAgaWYgKGV4dGVuZHNGcm9tKSB7XG4gICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgZXh0ZW5kc0Zyb20sIHZtKTtcbiAgfVxuICBpZiAoY2hpbGQubWl4aW5zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5taXhpbnNbaV0sIHZtKTtcbiAgICB9XG4gIH1cbiAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgbWVyZ2VGaWVsZChrZXkpO1xuICB9XG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1lcmdlRmllbGQgKGtleSkge1xuICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICBvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVBc3NldCAoXG4gIG9wdGlvbnMsXG4gIHR5cGUsXG4gIGlkLFxuICB3YXJuTWlzc2luZ1xuKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBhc3NldHMgPSBvcHRpb25zW3R5cGVdO1xuICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxuICBpZiAoaGFzT3duKGFzc2V0cywgaWQpKSB7IHJldHVybiBhc3NldHNbaWRdIH1cbiAgdmFyIGNhbWVsaXplZElkID0gY2FtZWxpemUoaWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKSB7IHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdIH1cbiAgdmFyIFBhc2NhbENhc2VJZCA9IGNhcGl0YWxpemUoY2FtZWxpemVkSWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgUGFzY2FsQ2FzZUlkKSkgeyByZXR1cm4gYXNzZXRzW1Bhc2NhbENhc2VJZF0gfVxuICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cbiAgdmFyIHJlcyA9IGFzc2V0c1tpZF0gfHwgYXNzZXRzW2NhbWVsaXplZElkXSB8fCBhc3NldHNbUGFzY2FsQ2FzZUlkXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybk1pc3NpbmcgJiYgIXJlcykge1xuICAgIHdhcm4oXG4gICAgICAnRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wIChcbiAga2V5LFxuICBwcm9wT3B0aW9ucyxcbiAgcHJvcHNEYXRhLFxuICB2bVxuKSB7XG4gIHZhciBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcbiAgdmFyIGFic2VudCA9ICFoYXNPd24ocHJvcHNEYXRhLCBrZXkpO1xuICB2YXIgdmFsdWUgPSBwcm9wc0RhdGFba2V5XTtcbiAgLy8gYm9vbGVhbiBjYXN0aW5nXG4gIHZhciBib29sZWFuSW5kZXggPSBnZXRUeXBlSW5kZXgoQm9vbGVhbiwgcHJvcC50eXBlKTtcbiAgaWYgKGJvb2xlYW5JbmRleCA+IC0xKSB7XG4gICAgaWYgKGFic2VudCAmJiAhaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSB7XG4gICAgICAvLyBvbmx5IGNhc3QgZW1wdHkgc3RyaW5nIC8gc2FtZSBuYW1lIHRvIGJvb2xlYW4gaWZcbiAgICAgIC8vIGJvb2xlYW4gaGFzIGhpZ2hlciBwcmlvcml0eVxuICAgICAgdmFyIHN0cmluZ0luZGV4ID0gZ2V0VHlwZUluZGV4KFN0cmluZywgcHJvcC50eXBlKTtcbiAgICAgIGlmIChzdHJpbmdJbmRleCA8IDAgfHwgYm9vbGVhbkluZGV4IDwgc3RyaW5nSW5kZXgpIHtcbiAgICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBjaGVjayBkZWZhdWx0IHZhbHVlXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsdWUgPSBnZXRQcm9wRGVmYXVsdFZhbHVlKHZtLCBwcm9wLCBrZXkpO1xuICAgIC8vIHNpbmNlIHRoZSBkZWZhdWx0IHZhbHVlIGlzIGEgZnJlc2ggY29weSxcbiAgICAvLyBtYWtlIHN1cmUgdG8gb2JzZXJ2ZSBpdC5cbiAgICB2YXIgcHJldlNob3VsZE9ic2VydmUgPSBzaG91bGRPYnNlcnZlO1xuICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgICBvYnNlcnZlKHZhbHVlKTtcbiAgICB0b2dnbGVPYnNlcnZpbmcocHJldlNob3VsZE9ic2VydmUpO1xuICB9XG4gIGlmIChcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgLy8gc2tpcCB2YWxpZGF0aW9uIGZvciB3ZWV4IHJlY3ljbGUtbGlzdCBjaGlsZCBjb21wb25lbnQgcHJvcHNcbiAgICAhKGZhbHNlICYmIGlzT2JqZWN0KHZhbHVlKSAmJiAoJ0BiaW5kaW5nJyBpbiB2YWx1ZSkpXG4gICkge1xuICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSAodm0sIHByb3AsIGtleSkge1xuICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXG4gIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbiAgdmFyIGRlZiA9IHByb3AuZGVmYXVsdDtcbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc09iamVjdChkZWYpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsga2V5ICsgJ1wiOiAnICtcbiAgICAgICdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcbiAgICAgICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyB0aGUgcmF3IHByb3AgdmFsdWUgd2FzIGFsc28gdW5kZWZpbmVkIGZyb20gcHJldmlvdXMgcmVuZGVyLFxuICAvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcbiAgaWYgKHZtICYmIHZtLiRvcHRpb25zLnByb3BzRGF0YSAmJlxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YVtrZXldID09PSB1bmRlZmluZWQgJiZcbiAgICB2bS5fcHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHJldHVybiB2bS5fcHJvcHNba2V5XVxuICB9XG4gIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gIC8vIGEgdmFsdWUgaXMgRnVuY3Rpb24gaWYgaXRzIHByb3RvdHlwZSBpcyBmdW5jdGlvbiBldmVuIGFjcm9zcyBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRcbiAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXG4gICAgPyBkZWYuY2FsbCh2bSlcbiAgICA6IGRlZlxufVxuXG4vKipcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UHJvcCAoXG4gIHByb3AsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICB2bSxcbiAgYWJzZW50XG4pIHtcbiAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgd2FybihcbiAgICAgICdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XG4gIHZhciB2YWxpZCA9ICF0eXBlIHx8IHR5cGUgPT09IHRydWU7XG4gIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlID0gW3R5cGVdO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoICYmICF2YWxpZDsgaSsrKSB7XG4gICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSk7XG4gICAgICBleHBlY3RlZFR5cGVzLnB1c2goYXNzZXJ0ZWRUeXBlLmV4cGVjdGVkVHlwZSB8fCAnJyk7XG4gICAgICB2YWxpZCA9IGFzc2VydGVkVHlwZS52YWxpZDtcbiAgICB9XG4gIH1cbiAgaWYgKCF2YWxpZCkge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXFxcIlwiICsgbmFtZSArIFwiXFxcIi5cIiArXG4gICAgICBcIiBFeHBlY3RlZCBcIiArIChleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKCcsICcpKSArXG4gICAgICBcIiwgZ290IFwiICsgKHRvUmF3VHlwZSh2YWx1ZSkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHZhbGlkYXRvciA9IHByb3AudmFsaWRhdG9yO1xuICBpZiAodmFsaWRhdG9yKSB7XG4gICAgaWYgKCF2YWxpZGF0b3IodmFsdWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc2ltcGxlQ2hlY2tSRSA9IC9eKFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbnxGdW5jdGlvbnxTeW1ib2wpJC87XG5cbmZ1bmN0aW9uIGFzc2VydFR5cGUgKHZhbHVlLCB0eXBlKSB7XG4gIHZhciB2YWxpZDtcbiAgdmFyIGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG4gIGlmIChzaW1wbGVDaGVja1JFLnRlc3QoZXhwZWN0ZWRUeXBlKSkge1xuICAgIHZhciB0ID0gdHlwZW9mIHZhbHVlO1xuICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gZm9yIHByaW1pdGl2ZSB3cmFwcGVyIG9iamVjdHNcbiAgICBpZiAoIXZhbGlkICYmIHQgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnT2JqZWN0Jykge1xuICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XG4gICAgdmFsaWQgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbGlkOiB2YWxpZCxcbiAgICBleHBlY3RlZFR5cGU6IGV4cGVjdGVkVHlwZVxuICB9XG59XG5cbi8qKlxuICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxuICogYmVjYXVzZSBhIHNpbXBsZSBlcXVhbGl0eSBjaGVjayB3aWxsIGZhaWwgd2hlbiBydW5uaW5nXG4gKiBhY3Jvc3MgZGlmZmVyZW50IHZtcyAvIGlmcmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFR5cGUgKGZuKSB7XG4gIHZhciBtYXRjaCA9IGZuICYmIGZuLnRvU3RyaW5nKCkubWF0Y2goL15cXHMqZnVuY3Rpb24gKFxcdyspLyk7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJydcbn1cblxuZnVuY3Rpb24gaXNTYW1lVHlwZSAoYSwgYikge1xuICByZXR1cm4gZ2V0VHlwZShhKSA9PT0gZ2V0VHlwZShiKVxufVxuXG5mdW5jdGlvbiBnZXRUeXBlSW5kZXggKHR5cGUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVHlwZXMpKSB7XG4gICAgcmV0dXJuIGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlcywgdHlwZSkgPyAwIDogLTFcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZXhwZWN0ZWRUeXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXNbaV0sIHR5cGUpKSB7XG4gICAgICByZXR1cm4gaVxuICAgIH1cbiAgfVxuICByZXR1cm4gLTFcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmICh2bSkge1xuICAgIHZhciBjdXIgPSB2bTtcbiAgICB3aGlsZSAoKGN1ciA9IGN1ci4kcGFyZW50KSkge1xuICAgICAgdmFyIGhvb2tzID0gY3VyLiRvcHRpb25zLmVycm9yQ2FwdHVyZWQ7XG4gICAgICBpZiAoaG9va3MpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgY2FwdHVyZSA9IGhvb2tzW2ldLmNhbGwoY3VyLCBlcnIsIHZtLCBpbmZvKSA9PT0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoY2FwdHVyZSkgeyByZXR1cm4gfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGdsb2JhbEhhbmRsZUVycm9yKGUsIGN1ciwgJ2Vycm9yQ2FwdHVyZWQgaG9vaycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBnbG9iYWxIYW5kbGVFcnJvcihlcnIsIHZtLCBpbmZvKTtcbn1cblxuZnVuY3Rpb24gZ2xvYmFsSGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ0Vycm9yKGUsIG51bGwsICdjb25maWcuZXJyb3JIYW5kbGVyJyk7XG4gICAgfVxuICB9XG4gIGxvZ0Vycm9yKGVyciwgdm0sIGluZm8pO1xufVxuXG5mdW5jdGlvbiBsb2dFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oKFwiRXJyb3IgaW4gXCIgKyBpbmZvICsgXCI6IFxcXCJcIiArIChlcnIudG9TdHJpbmcoKSkgKyBcIlxcXCJcIiksIHZtKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoKGluQnJvd3NlciB8fCBpbldlZXgpICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vKiAgKi9cbi8qIGdsb2JhbHMgTWVzc2FnZUNoYW5uZWwgKi9cblxudmFyIGNhbGxiYWNrcyA9IFtdO1xudmFyIHBlbmRpbmcgPSBmYWxzZTtcblxuZnVuY3Rpb24gZmx1c2hDYWxsYmFja3MgKCkge1xuICBwZW5kaW5nID0gZmFsc2U7XG4gIHZhciBjb3BpZXMgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvcGllcy5sZW5ndGg7IGkrKykge1xuICAgIGNvcGllc1tpXSgpO1xuICB9XG59XG5cbi8vIEhlcmUgd2UgaGF2ZSBhc3luYyBkZWZlcnJpbmcgd3JhcHBlcnMgdXNpbmcgYm90aCBtaWNyb3Rhc2tzIGFuZCAobWFjcm8pIHRhc2tzLlxuLy8gSW4gPCAyLjQgd2UgdXNlZCBtaWNyb3Rhc2tzIGV2ZXJ5d2hlcmUsIGJ1dCB0aGVyZSBhcmUgc29tZSBzY2VuYXJpb3Mgd2hlcmVcbi8vIG1pY3JvdGFza3MgaGF2ZSB0b28gaGlnaCBhIHByaW9yaXR5IGFuZCBmaXJlIGluIGJldHdlZW4gc3VwcG9zZWRseVxuLy8gc2VxdWVudGlhbCBldmVudHMgKGUuZy4gIzQ1MjEsICM2NjkwKSBvciBldmVuIGJldHdlZW4gYnViYmxpbmcgb2YgdGhlIHNhbWVcbi8vIGV2ZW50ICgjNjU2NikuIEhvd2V2ZXIsIHVzaW5nIChtYWNybykgdGFza3MgZXZlcnl3aGVyZSBhbHNvIGhhcyBzdWJ0bGUgcHJvYmxlbXNcbi8vIHdoZW4gc3RhdGUgaXMgY2hhbmdlZCByaWdodCBiZWZvcmUgcmVwYWludCAoZS5nLiAjNjgxMywgb3V0LWluIHRyYW5zaXRpb25zKS5cbi8vIEhlcmUgd2UgdXNlIG1pY3JvdGFzayBieSBkZWZhdWx0LCBidXQgZXhwb3NlIGEgd2F5IHRvIGZvcmNlIChtYWNybykgdGFzayB3aGVuXG4vLyBuZWVkZWQgKGUuZy4gaW4gZXZlbnQgaGFuZGxlcnMgYXR0YWNoZWQgYnkgdi1vbikuXG52YXIgbWljcm9UaW1lckZ1bmM7XG52YXIgbWFjcm9UaW1lckZ1bmM7XG52YXIgdXNlTWFjcm9UYXNrID0gZmFsc2U7XG5cbi8vIERldGVybWluZSAobWFjcm8pIHRhc2sgZGVmZXIgaW1wbGVtZW50YXRpb24uXG4vLyBUZWNobmljYWxseSBzZXRJbW1lZGlhdGUgc2hvdWxkIGJlIHRoZSBpZGVhbCBjaG9pY2UsIGJ1dCBpdCdzIG9ubHkgYXZhaWxhYmxlXG4vLyBpbiBJRS4gVGhlIG9ubHkgcG9seWZpbGwgdGhhdCBjb25zaXN0ZW50bHkgcXVldWVzIHRoZSBjYWxsYmFjayBhZnRlciBhbGwgRE9NXG4vLyBldmVudHMgdHJpZ2dlcmVkIGluIHRoZSBzYW1lIGxvb3AgaXMgYnkgdXNpbmcgTWVzc2FnZUNoYW5uZWwuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShzZXRJbW1lZGlhdGUpKSB7XG4gIG1hY3JvVGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHNldEltbWVkaWF0ZShmbHVzaENhbGxiYWNrcyk7XG4gIH07XG59IGVsc2UgaWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICBpc05hdGl2ZShNZXNzYWdlQ2hhbm5lbCkgfHxcbiAgLy8gUGhhbnRvbUpTXG4gIE1lc3NhZ2VDaGFubmVsLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE1lc3NhZ2VDaGFubmVsQ29uc3RydWN0b3JdJ1xuKSkge1xuICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICB2YXIgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZmx1c2hDYWxsYmFja3M7XG4gIG1hY3JvVGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHBvcnQucG9zdE1lc3NhZ2UoMSk7XG4gIH07XG59IGVsc2Uge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBtYWNyb1RpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZXRUaW1lb3V0KGZsdXNoQ2FsbGJhY2tzLCAwKTtcbiAgfTtcbn1cblxuLy8gRGV0ZXJtaW5lIG1pY3JvdGFzayBkZWZlciBpbXBsZW1lbnRhdGlvbi5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0LCAkZmxvdy1kaXNhYmxlLWxpbmUgKi9cbmlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJvbWlzZSkpIHtcbiAgdmFyIHAgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgbWljcm9UaW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcC50aGVuKGZsdXNoQ2FsbGJhY2tzKTtcbiAgICAvLyBpbiBwcm9ibGVtYXRpYyBVSVdlYlZpZXdzLCBQcm9taXNlLnRoZW4gZG9lc24ndCBjb21wbGV0ZWx5IGJyZWFrLCBidXRcbiAgICAvLyBpdCBjYW4gZ2V0IHN0dWNrIGluIGEgd2VpcmQgc3RhdGUgd2hlcmUgY2FsbGJhY2tzIGFyZSBwdXNoZWQgaW50byB0aGVcbiAgICAvLyBtaWNyb3Rhc2sgcXVldWUgYnV0IHRoZSBxdWV1ZSBpc24ndCBiZWluZyBmbHVzaGVkLCB1bnRpbCB0aGUgYnJvd3NlclxuICAgIC8vIG5lZWRzIHRvIGRvIHNvbWUgb3RoZXIgd29yaywgZS5nLiBoYW5kbGUgYSB0aW1lci4gVGhlcmVmb3JlIHdlIGNhblxuICAgIC8vIFwiZm9yY2VcIiB0aGUgbWljcm90YXNrIHF1ZXVlIHRvIGJlIGZsdXNoZWQgYnkgYWRkaW5nIGFuIGVtcHR5IHRpbWVyLlxuICAgIGlmIChpc0lPUykgeyBzZXRUaW1lb3V0KG5vb3ApOyB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBmYWxsYmFjayB0byBtYWNyb1xuICBtaWNyb1RpbWVyRnVuYyA9IG1hY3JvVGltZXJGdW5jO1xufVxuXG4vKipcbiAqIFdyYXAgYSBmdW5jdGlvbiBzbyB0aGF0IGlmIGFueSBjb2RlIGluc2lkZSB0cmlnZ2VycyBzdGF0ZSBjaGFuZ2UsXG4gKiB0aGUgY2hhbmdlcyBhcmUgcXVldWVkIHVzaW5nIGEgKG1hY3JvKSB0YXNrIGluc3RlYWQgb2YgYSBtaWNyb3Rhc2suXG4gKi9cbmZ1bmN0aW9uIHdpdGhNYWNyb1Rhc2sgKGZuKSB7XG4gIHJldHVybiBmbi5fd2l0aFRhc2sgfHwgKGZuLl93aXRoVGFzayA9IGZ1bmN0aW9uICgpIHtcbiAgICB1c2VNYWNyb1Rhc2sgPSB0cnVlO1xuICAgIHZhciByZXMgPSBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIHVzZU1hY3JvVGFzayA9IGZhbHNlO1xuICAgIHJldHVybiByZXNcbiAgfSlcbn1cblxuZnVuY3Rpb24gbmV4dFRpY2sgKGNiLCBjdHgpIHtcbiAgdmFyIF9yZXNvbHZlO1xuICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjYi5jYWxsKGN0eCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGUsIGN0eCwgJ25leHRUaWNrJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChfcmVzb2x2ZSkge1xuICAgICAgX3Jlc29sdmUoY3R4KTtcbiAgICB9XG4gIH0pO1xuICBpZiAoIXBlbmRpbmcpIHtcbiAgICBwZW5kaW5nID0gdHJ1ZTtcbiAgICBpZiAodXNlTWFjcm9UYXNrKSB7XG4gICAgICBtYWNyb1RpbWVyRnVuYygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtaWNyb1RpbWVyRnVuYygpO1xuICAgIH1cbiAgfVxuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgaWYgKCFjYiAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB9KVxuICB9XG59XG5cbi8qICAqL1xuXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cblxudmFyIGluaXRQcm94eTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGFsbG93ZWRHbG9iYWxzID0gbWFrZU1hcChcbiAgICAnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTiwnICtcbiAgICAncGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsJyArXG4gICAgJ01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCwnICtcbiAgICAncmVxdWlyZScgLy8gZm9yIFdlYnBhY2svQnJvd3NlcmlmeVxuICApO1xuXG4gIHZhciB3YXJuTm9uUHJlc2VudCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgIHdhcm4oXG4gICAgICBcIlByb3BlcnR5IG9yIG1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQgb24gdGhlIGluc3RhbmNlIGJ1dCBcIiArXG4gICAgICAncmVmZXJlbmNlZCBkdXJpbmcgcmVuZGVyLiBNYWtlIHN1cmUgdGhhdCB0aGlzIHByb3BlcnR5IGlzIHJlYWN0aXZlLCAnICtcbiAgICAgICdlaXRoZXIgaW4gdGhlIGRhdGEgb3B0aW9uLCBvciBmb3IgY2xhc3MtYmFzZWQgY29tcG9uZW50cywgYnkgJyArXG4gICAgICAnaW5pdGlhbGl6aW5nIHRoZSBwcm9wZXJ0eS4gJyArXG4gICAgICAnU2VlOiBodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9yZWFjdGl2aXR5Lmh0bWwjRGVjbGFyaW5nLVJlYWN0aXZlLVByb3BlcnRpZXMuJyxcbiAgICAgIHRhcmdldFxuICAgICk7XG4gIH07XG5cbiAgdmFyIGhhc1Byb3h5ID1cbiAgICB0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb3h5KTtcblxuICBpZiAoaGFzUHJveHkpIHtcbiAgICB2YXIgaXNCdWlsdEluTW9kaWZpZXIgPSBtYWtlTWFwKCdzdG9wLHByZXZlbnQsc2VsZixjdHJsLHNoaWZ0LGFsdCxtZXRhLGV4YWN0Jyk7XG4gICAgY29uZmlnLmtleUNvZGVzID0gbmV3IFByb3h5KGNvbmZpZy5rZXlDb2Rlcywge1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNCdWlsdEluTW9kaWZpZXIoa2V5KSkge1xuICAgICAgICAgIHdhcm4oKFwiQXZvaWQgb3ZlcndyaXRpbmcgYnVpbHQtaW4gbW9kaWZpZXIgaW4gY29uZmlnLmtleUNvZGVzOiAuXCIgKyBrZXkpKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciBoYXNIYW5kbGVyID0ge1xuICAgIGhhczogZnVuY3Rpb24gaGFzICh0YXJnZXQsIGtleSkge1xuICAgICAgdmFyIGhhcyA9IGtleSBpbiB0YXJnZXQ7XG4gICAgICB2YXIgaXNBbGxvd2VkID0gYWxsb3dlZEdsb2JhbHMoa2V5KSB8fCBrZXkuY2hhckF0KDApID09PSAnXyc7XG4gICAgICBpZiAoIWhhcyAmJiAhaXNBbGxvd2VkKSB7XG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXMgfHwgIWlzQWxsb3dlZFxuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0SGFuZGxlciA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiAhKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXRba2V5XVxuICAgIH1cbiAgfTtcblxuICBpbml0UHJveHkgPSBmdW5jdGlvbiBpbml0UHJveHkgKHZtKSB7XG4gICAgaWYgKGhhc1Byb3h5KSB7XG4gICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggcHJveHkgaGFuZGxlciB0byB1c2VcbiAgICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgICB2YXIgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkXG4gICAgICAgID8gZ2V0SGFuZGxlclxuICAgICAgICA6IGhhc0hhbmRsZXI7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIGhhbmRsZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIHNlZW5PYmplY3RzID0gbmV3IF9TZXQoKTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlICh2YWwpIHtcbiAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xuICBzZWVuT2JqZWN0cy5jbGVhcigpO1xufVxuXG5mdW5jdGlvbiBfdHJhdmVyc2UgKHZhbCwgc2Vlbikge1xuICB2YXIgaSwga2V5cztcbiAgdmFyIGlzQSA9IEFycmF5LmlzQXJyYXkodmFsKTtcbiAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fCBPYmplY3QuaXNGcm96ZW4odmFsKSB8fCB2YWwgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWwuX19vYl9fKSB7XG4gICAgdmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgfVxuICBpZiAoaXNBKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTsgfVxuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pOyB9XG4gIH1cbn1cblxudmFyIG1hcms7XG52YXIgbWVhc3VyZTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHBlcmYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHBlcmYgJiZcbiAgICBwZXJmLm1hcmsgJiZcbiAgICBwZXJmLm1lYXN1cmUgJiZcbiAgICBwZXJmLmNsZWFyTWFya3MgJiZcbiAgICBwZXJmLmNsZWFyTWVhc3VyZXNcbiAgKSB7XG4gICAgbWFyayA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHBlcmYubWFyayh0YWcpOyB9O1xuICAgIG1lYXN1cmUgPSBmdW5jdGlvbiAobmFtZSwgc3RhcnRUYWcsIGVuZFRhZykge1xuICAgICAgcGVyZi5tZWFzdXJlKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1lYXN1cmVzKG5hbWUpO1xuICAgIH07XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBub3JtYWxpemVFdmVudCA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgcGFzc2l2ZSA9IG5hbWUuY2hhckF0KDApID09PSAnJic7XG4gIG5hbWUgPSBwYXNzaXZlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBvbmNlJCQxID0gbmFtZS5jaGFyQXQoMCkgPT09ICd+JzsgLy8gUHJlZml4ZWQgbGFzdCwgY2hlY2tlZCBmaXJzdFxuICBuYW1lID0gb25jZSQkMSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICB2YXIgY2FwdHVyZSA9IG5hbWUuY2hhckF0KDApID09PSAnISc7XG4gIG5hbWUgPSBjYXB0dXJlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBvbmNlOiBvbmNlJCQxLFxuICAgIGNhcHR1cmU6IGNhcHR1cmUsXG4gICAgcGFzc2l2ZTogcGFzc2l2ZVxuICB9XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlRm5JbnZva2VyIChmbnMpIHtcbiAgZnVuY3Rpb24gaW52b2tlciAoKSB7XG4gICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgdmFyIGZucyA9IGludm9rZXIuZm5zO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZucykpIHtcbiAgICAgIHZhciBjbG9uZWQgPSBmbnMuc2xpY2UoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xvbmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNsb25lZFtpXS5hcHBseShudWxsLCBhcmd1bWVudHMkMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJldHVybiBoYW5kbGVyIHJldHVybiB2YWx1ZSBmb3Igc2luZ2xlIGhhbmRsZXJzXG4gICAgICByZXR1cm4gZm5zLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbiAgICB9XG4gIH1cbiAgaW52b2tlci5mbnMgPSBmbnM7XG4gIHJldHVybiBpbnZva2VyXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpc3RlbmVycyAoXG4gIG9uLFxuICBvbGRPbixcbiAgYWRkLFxuICByZW1vdmUkJDEsXG4gIHZtXG4pIHtcbiAgdmFyIG5hbWUsIGRlZiwgY3VyLCBvbGQsIGV2ZW50O1xuICBmb3IgKG5hbWUgaW4gb24pIHtcbiAgICBkZWYgPSBjdXIgPSBvbltuYW1lXTtcbiAgICBvbGQgPSBvbGRPbltuYW1lXTtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc1VuZGVmKGN1cikpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFxcXCJcIiArIChldmVudC5uYW1lKSArIFwiXFxcIjogZ290IFwiICsgU3RyaW5nKGN1ciksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGQpKSB7XG4gICAgICBpZiAoaXNVbmRlZihjdXIuZm5zKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZUZuSW52b2tlcihjdXIpO1xuICAgICAgfVxuICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQub25jZSwgZXZlbnQuY2FwdHVyZSwgZXZlbnQucGFzc2l2ZSwgZXZlbnQucGFyYW1zKTtcbiAgICB9IGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XG4gICAgICBvbGQuZm5zID0gY3VyO1xuICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgIGlmIChpc1VuZGVmKG9uW25hbWVdKSkge1xuICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rKSB7XG4gIGlmIChkZWYgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIGRlZiA9IGRlZi5kYXRhLmhvb2sgfHwgKGRlZi5kYXRhLmhvb2sgPSB7fSk7XG4gIH1cbiAgdmFyIGludm9rZXI7XG4gIHZhciBvbGRIb29rID0gZGVmW2hvb2tLZXldO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZWRIb29rICgpIHtcbiAgICBob29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgLy8gaW1wb3J0YW50OiByZW1vdmUgbWVyZ2VkIGhvb2sgdG8gZW5zdXJlIGl0J3MgY2FsbGVkIG9ubHkgb25jZVxuICAgIC8vIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrXG4gICAgcmVtb3ZlKGludm9rZXIuZm5zLCB3cmFwcGVkSG9vayk7XG4gIH1cblxuICBpZiAoaXNVbmRlZihvbGRIb29rKSkge1xuICAgIC8vIG5vIGV4aXN0aW5nIGhvb2tcbiAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFt3cmFwcGVkSG9va10pO1xuICB9IGVsc2Uge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc0RlZihvbGRIb29rLmZucykgJiYgaXNUcnVlKG9sZEhvb2subWVyZ2VkKSkge1xuICAgICAgLy8gYWxyZWFkeSBhIG1lcmdlZCBpbnZva2VyXG4gICAgICBpbnZva2VyID0gb2xkSG9vaztcbiAgICAgIGludm9rZXIuZm5zLnB1c2god3JhcHBlZEhvb2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBwbGFpbiBob29rXG4gICAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFtvbGRIb29rLCB3cmFwcGVkSG9va10pO1xuICAgIH1cbiAgfVxuXG4gIGludm9rZXIubWVyZ2VkID0gdHJ1ZTtcbiAgZGVmW2hvb2tLZXldID0gaW52b2tlcjtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEgKFxuICBkYXRhLFxuICBDdG9yLFxuICB0YWdcbikge1xuICAvLyB3ZSBhcmUgb25seSBleHRyYWN0aW5nIHJhdyB2YWx1ZXMgaGVyZS5cbiAgLy8gdmFsaWRhdGlvbiBhbmQgZGVmYXVsdCB2YWx1ZXMgYXJlIGhhbmRsZWQgaW4gdGhlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCBpdHNlbGYuXG4gIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzVW5kZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xuICB2YXIgcHJvcHMgPSBkYXRhLnByb3BzO1xuICBpZiAoaXNEZWYoYXR0cnMpIHx8IGlzRGVmKHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgdmFyIGFsdEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIGtleUluTG93ZXJDYXNlID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgIT09IGtleUluTG93ZXJDYXNlICYmXG4gICAgICAgICAgYXR0cnMgJiYgaGFzT3duKGF0dHJzLCBrZXlJbkxvd2VyQ2FzZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGlwKFxuICAgICAgICAgICAgXCJQcm9wIFxcXCJcIiArIGtleUluTG93ZXJDYXNlICsgXCJcXFwiIGlzIHBhc3NlZCB0byBjb21wb25lbnQgXCIgK1xuICAgICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodGFnIHx8IEN0b3IpKSArIFwiLCBidXQgdGhlIGRlY2xhcmVkIHByb3AgbmFtZSBpc1wiICtcbiAgICAgICAgICAgIFwiIFxcXCJcIiArIGtleSArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCBjYW1lbENhc2VkIFwiICtcbiAgICAgICAgICAgIFwicHJvcHMgbmVlZCB0byB1c2UgdGhlaXIga2ViYWItY2FzZSBlcXVpdmFsZW50cyB3aGVuIHVzaW5nIGluLURPTSBcIiArXG4gICAgICAgICAgICBcInRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgYWx0S2V5ICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hlY2tQcm9wKHJlcywgcHJvcHMsIGtleSwgYWx0S2V5LCB0cnVlKSB8fFxuICAgICAgY2hlY2tQcm9wKHJlcywgYXR0cnMsIGtleSwgYWx0S2V5LCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wIChcbiAgcmVzLFxuICBoYXNoLFxuICBrZXksXG4gIGFsdEtleSxcbiAgcHJlc2VydmVcbikge1xuICBpZiAoaXNEZWYoaGFzaCkpIHtcbiAgICBpZiAoaGFzT3duKGhhc2gsIGtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFtrZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgaWYgKGhhc093bihoYXNoLCBhbHRLZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hbYWx0S2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hbYWx0S2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxuLy8gVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGF0dGVtcHRzIHRvIG1pbmltaXplIHRoZSBuZWVkIGZvciBub3JtYWxpemF0aW9uIGJ5XG4vLyBzdGF0aWNhbGx5IGFuYWx5emluZyB0aGUgdGVtcGxhdGUgYXQgY29tcGlsZSB0aW1lLlxuLy9cbi8vIEZvciBwbGFpbiBIVE1MIG1hcmt1cCwgbm9ybWFsaXphdGlvbiBjYW4gYmUgY29tcGxldGVseSBza2lwcGVkIGJlY2F1c2UgdGhlXG4vLyBnZW5lcmF0ZWQgcmVuZGVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIEFycmF5PFZOb2RlPi4gVGhlcmUgYXJlXG4vLyB0d28gY2FzZXMgd2hlcmUgZXh0cmEgbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQ6XG5cbi8vIDEuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbXBvbmVudHMgLSBiZWNhdXNlIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbi8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcbi8vIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkIC0gaWYgYW55IGNoaWxkIGlzIGFuIEFycmF5LCB3ZSBmbGF0dGVuIHRoZSB3aG9sZVxuLy8gdGhpbmcgd2l0aCBBcnJheS5wcm90b3R5cGUuY29uY2F0LiBJdCBpcyBndWFyYW50ZWVkIHRvIGJlIG9ubHkgMS1sZXZlbCBkZWVwXG4vLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXG5mdW5jdGlvbiBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuW2ldKSkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGNoaWxkcmVuKVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hpbGRyZW5cbn1cblxuLy8gMi4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29uc3RydWN0cyB0aGF0IGFsd2F5cyBnZW5lcmF0ZWQgbmVzdGVkIEFycmF5cyxcbi8vIGUuZy4gPHRlbXBsYXRlPiwgPHNsb3Q+LCB2LWZvciwgb3Igd2hlbiB0aGUgY2hpbGRyZW4gaXMgcHJvdmlkZWQgYnkgdXNlclxuLy8gd2l0aCBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucyAvIEpTWC4gSW4gc3VjaCBjYXNlcyBhIGZ1bGwgbm9ybWFsaXphdGlvblxuLy8gaXMgbmVlZGVkIHRvIGNhdGVyIHRvIGFsbCBwb3NzaWJsZSB0eXBlcyBvZiBjaGlsZHJlbiB2YWx1ZXMuXG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGlzUHJpbWl0aXZlKGNoaWxkcmVuKVxuICAgID8gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildXG4gICAgOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKVxuICAgICAgPyBub3JtYWxpemVBcnJheUNoaWxkcmVuKGNoaWxkcmVuKVxuICAgICAgOiB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gaXNUZXh0Tm9kZSAobm9kZSkge1xuICByZXR1cm4gaXNEZWYobm9kZSkgJiYgaXNEZWYobm9kZS50ZXh0KSAmJiBpc0ZhbHNlKG5vZGUuaXNDb21tZW50KVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheUNoaWxkcmVuIChjaGlsZHJlbiwgbmVzdGVkSW5kZXgpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICB2YXIgaSwgYywgbGFzdEluZGV4LCBsYXN0O1xuICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGlzVW5kZWYoYykgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJykgeyBjb250aW51ZSB9XG4gICAgbGFzdEluZGV4ID0gcmVzLmxlbmd0aCAtIDE7XG4gICAgbGFzdCA9IHJlc1tsYXN0SW5kZXhdO1xuICAgIC8vICBuZXN0ZWRcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSkge1xuICAgICAgaWYgKGMubGVuZ3RoID4gMCkge1xuICAgICAgICBjID0gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjLCAoKG5lc3RlZEluZGV4IHx8ICcnKSArIFwiX1wiICsgaSkpO1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIGlmIChpc1RleHROb2RlKGNbMF0pICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyAoY1swXSkudGV4dCk7XG4gICAgICAgICAgYy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgYyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuICAgICAgaWYgKGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgU1NSIGh5ZHJhdGlvbiBiZWNhdXNlIHRleHQgbm9kZXMgYXJlXG4gICAgICAgIC8vIGVzc2VudGlhbGx5IG1lcmdlZCB3aGVuIHJlbmRlcmVkIHRvIEhUTUwgc3RyaW5nc1xuICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjKTtcbiAgICAgIH0gZWxzZSBpZiAoYyAhPT0gJycpIHtcbiAgICAgICAgLy8gY29udmVydCBwcmltaXRpdmUgdG8gdm5vZGVcbiAgICAgICAgcmVzLnB1c2goY3JlYXRlVGV4dFZOb2RlKGMpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzVGV4dE5vZGUoYykgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMudGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxuICAgICAgICBpZiAoaXNUcnVlKGNoaWxkcmVuLl9pc1ZMaXN0KSAmJlxuICAgICAgICAgIGlzRGVmKGMudGFnKSAmJlxuICAgICAgICAgIGlzVW5kZWYoYy5rZXkpICYmXG4gICAgICAgICAgaXNEZWYobmVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgYy5rZXkgPSBcIl9fdmxpc3RcIiArIG5lc3RlZEluZGV4ICsgXCJfXCIgKyBpICsgXCJfX1wiO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnN1cmVDdG9yIChjb21wLCBiYXNlKSB7XG4gIGlmIChcbiAgICBjb21wLl9fZXNNb2R1bGUgfHxcbiAgICAoaGFzU3ltYm9sICYmIGNvbXBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ01vZHVsZScpXG4gICkge1xuICAgIGNvbXAgPSBjb21wLmRlZmF1bHQ7XG4gIH1cbiAgcmV0dXJuIGlzT2JqZWN0KGNvbXApXG4gICAgPyBiYXNlLmV4dGVuZChjb21wKVxuICAgIDogY29tcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyIChcbiAgZmFjdG9yeSxcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIHZhciBub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICBub2RlLmFzeW5jRmFjdG9yeSA9IGZhY3Rvcnk7XG4gIG5vZGUuYXN5bmNNZXRhID0geyBkYXRhOiBkYXRhLCBjb250ZXh0OiBjb250ZXh0LCBjaGlsZHJlbjogY2hpbGRyZW4sIHRhZzogdGFnIH07XG4gIHJldHVybiBub2RlXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudCAoXG4gIGZhY3RvcnksXG4gIGJhc2VDdG9yLFxuICBjb250ZXh0XG4pIHtcbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmVycm9yKSAmJiBpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5lcnJvckNvbXBcbiAgfVxuXG4gIGlmIChpc0RlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgIHJldHVybiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cblxuICBpZiAoaXNUcnVlKGZhY3RvcnkubG9hZGluZykgJiYgaXNEZWYoZmFjdG9yeS5sb2FkaW5nQ29tcCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICB9XG5cbiAgaWYgKGlzRGVmKGZhY3RvcnkuY29udGV4dHMpKSB7XG4gICAgLy8gYWxyZWFkeSBwZW5kaW5nXG4gICAgZmFjdG9yeS5jb250ZXh0cy5wdXNoKGNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjb250ZXh0cyA9IGZhY3RvcnkuY29udGV4dHMgPSBbY29udGV4dF07XG4gICAgdmFyIHN5bmMgPSB0cnVlO1xuXG4gICAgdmFyIGZvcmNlUmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjb250ZXh0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29udGV4dHNbaV0uJGZvcmNlVXBkYXRlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZXNvbHZlID0gb25jZShmdW5jdGlvbiAocmVzKSB7XG4gICAgICAvLyBjYWNoZSByZXNvbHZlZFxuICAgICAgZmFjdG9yeS5yZXNvbHZlZCA9IGVuc3VyZUN0b3IocmVzLCBiYXNlQ3Rvcik7XG4gICAgICAvLyBpbnZva2UgY2FsbGJhY2tzIG9ubHkgaWYgdGhpcyBpcyBub3QgYSBzeW5jaHJvbm91cyByZXNvbHZlXG4gICAgICAvLyAoYXN5bmMgcmVzb2x2ZXMgYXJlIHNoaW1tZWQgYXMgc3luY2hyb25vdXMgZHVyaW5nIFNTUilcbiAgICAgIGlmICghc3luYykge1xuICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlamVjdCA9IG9uY2UoZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudDogXCIgKyAoU3RyaW5nKGZhY3RvcnkpKSArXG4gICAgICAgIChyZWFzb24gPyAoXCJcXG5SZWFzb246IFwiICsgcmVhc29uKSA6ICcnKVxuICAgICAgKTtcbiAgICAgIGlmIChpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICAgICAgZmFjdG9yeS5lcnJvciA9IHRydWU7XG4gICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVzID0gZmFjdG9yeShyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gKCkgPT4gUHJvbWlzZVxuICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYocmVzLmNvbXBvbmVudCkgJiYgdHlwZW9mIHJlcy5jb21wb25lbnQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXMuY29tcG9uZW50LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgICAgICBpZiAoaXNEZWYocmVzLmVycm9yKSkge1xuICAgICAgICAgIGZhY3RvcnkuZXJyb3JDb21wID0gZW5zdXJlQ3RvcihyZXMuZXJyb3IsIGJhc2VDdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMubG9hZGluZykpIHtcbiAgICAgICAgICBmYWN0b3J5LmxvYWRpbmdDb21wID0gZW5zdXJlQ3RvcihyZXMubG9hZGluZywgYmFzZUN0b3IpO1xuICAgICAgICAgIGlmIChyZXMuZGVsYXkgPT09IDApIHtcbiAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSAmJiBpc1VuZGVmKGZhY3RvcnkuZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCByZXMuZGVsYXkgfHwgMjAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocmVzLnRpbWVvdXQpKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgICAgICAgICAgICAgICAgPyAoXCJ0aW1lb3V0IChcIiArIChyZXMudGltZW91dCkgKyBcIm1zKVwiKVxuICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVzLnRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3luYyA9IGZhbHNlO1xuICAgIC8vIHJldHVybiBpbiBjYXNlIHJlc29sdmVkIHN5bmNocm9ub3VzbHlcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nXG4gICAgICA/IGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgICAgIDogZmFjdG9yeS5yZXNvbHZlZFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpc0FzeW5jUGxhY2Vob2xkZXIgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuaXNDb21tZW50ICYmIG5vZGUuYXN5bmNGYWN0b3J5XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZXRGaXJzdENvbXBvbmVudENoaWxkIChjaGlsZHJlbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGMpICYmIChpc0RlZihjLmNvbXBvbmVudE9wdGlvbnMpIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKSkpIHtcbiAgICAgICAgcmV0dXJuIGNcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXZlbnRzICh2bSkge1xuICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdm0uX2hhc0hvb2tFdmVudCA9IGZhbHNlO1xuICAvLyBpbml0IHBhcmVudCBhdHRhY2hlZCBldmVudHNcbiAgdmFyIGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycyk7XG4gIH1cbn1cblxudmFyIHRhcmdldDtcblxuZnVuY3Rpb24gYWRkIChldmVudCwgZm4sIG9uY2UpIHtcbiAgaWYgKG9uY2UpIHtcbiAgICB0YXJnZXQuJG9uY2UoZXZlbnQsIGZuKTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuJG9uKGV2ZW50LCBmbik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDEgKGV2ZW50LCBmbikge1xuICB0YXJnZXQuJG9mZihldmVudCwgZm4pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMgKFxuICB2bSxcbiAgbGlzdGVuZXJzLFxuICBvbGRMaXN0ZW5lcnNcbikge1xuICB0YXJnZXQgPSB2bTtcbiAgdXBkYXRlTGlzdGVuZXJzKGxpc3RlbmVycywgb2xkTGlzdGVuZXJzIHx8IHt9LCBhZGQsIHJlbW92ZSQxLCB2bSk7XG4gIHRhcmdldCA9IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZXZlbnRzTWl4aW4gKFZ1ZSkge1xuICB2YXIgaG9va1JFID0gL15ob29rOi87XG4gIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMkMS4kb24oZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XG4gICAgICAvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxuICAgICAgLy8gaW5zdGVhZCBvZiBhIGhhc2ggbG9va3VwXG4gICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgZnVuY3Rpb24gb24gKCkge1xuICAgICAgdm0uJG9mZihldmVudCwgb24pO1xuICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIG9uLmZuID0gZm47XG4gICAgdm0uJG9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhbGxcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIGFycmF5IG9mIGV2ZW50c1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcyQxLiRvZmYoZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoIWNicykge1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIGlmICghZm4pIHtcbiAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICBpZiAoZm4pIHtcbiAgICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICAgIHZhciBjYjtcbiAgICAgIHZhciBpJDEgPSBjYnMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGkkMS0tKSB7XG4gICAgICAgIGNiID0gY2JzW2kkMV07XG4gICAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgICAgY2JzLnNwbGljZShpJDEsIDEpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHZtLl9ldmVudHNbbG93ZXJDYXNlRXZlbnRdKSB7XG4gICAgICAgIHRpcChcbiAgICAgICAgICBcIkV2ZW50IFxcXCJcIiArIGxvd2VyQ2FzZUV2ZW50ICsgXCJcXFwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIgYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBcIiArXG4gICAgICAgICAgXCJ2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gXCIgK1xuICAgICAgICAgIFwiWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgKGh5cGhlbmF0ZShldmVudCkpICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjYnNbaV0uYXBwbHkodm0sIGFyZ3MpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChcImV2ZW50IGhhbmRsZXIgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcbn1cblxuLyogICovXG5cblxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgcmF3IGNoaWxkcmVuIFZOb2RlcyBpbnRvIGEgc2xvdCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTbG90cyAoXG4gIGNoaWxkcmVuLFxuICBjb250ZXh0XG4pIHtcbiAgdmFyIHNsb3RzID0ge307XG4gIGlmICghY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gc2xvdHNcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIHZhciBkYXRhID0gY2hpbGQuZGF0YTtcbiAgICAvLyByZW1vdmUgc2xvdCBhdHRyaWJ1dGUgaWYgdGhlIG5vZGUgaXMgcmVzb2x2ZWQgYXMgYSBWdWUgc2xvdCBub2RlXG4gICAgaWYgKGRhdGEgJiYgZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnNsb3QpIHtcbiAgICAgIGRlbGV0ZSBkYXRhLmF0dHJzLnNsb3Q7XG4gICAgfVxuICAgIC8vIG5hbWVkIHNsb3RzIHNob3VsZCBvbmx5IGJlIHJlc3BlY3RlZCBpZiB0aGUgdm5vZGUgd2FzIHJlbmRlcmVkIGluIHRoZVxuICAgIC8vIHNhbWUgY29udGV4dC5cbiAgICBpZiAoKGNoaWxkLmNvbnRleHQgPT09IGNvbnRleHQgfHwgY2hpbGQuZm5Db250ZXh0ID09PSBjb250ZXh0KSAmJlxuICAgICAgZGF0YSAmJiBkYXRhLnNsb3QgIT0gbnVsbFxuICAgICkge1xuICAgICAgdmFyIG5hbWUgPSBkYXRhLnNsb3Q7XG4gICAgICB2YXIgc2xvdCA9IChzbG90c1tuYW1lXSB8fCAoc2xvdHNbbmFtZV0gPSBbXSkpO1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICBzbG90LnB1c2guYXBwbHkoc2xvdCwgY2hpbGQuY2hpbGRyZW4gfHwgW10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xvdC5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHNsb3RzLmRlZmF1bHQgfHwgKHNsb3RzLmRlZmF1bHQgPSBbXSkpLnB1c2goY2hpbGQpO1xuICAgIH1cbiAgfVxuICAvLyBpZ25vcmUgc2xvdHMgdGhhdCBjb250YWlucyBvbmx5IHdoaXRlc3BhY2VcbiAgZm9yICh2YXIgbmFtZSQxIGluIHNsb3RzKSB7XG4gICAgaWYgKHNsb3RzW25hbWUkMV0uZXZlcnkoaXNXaGl0ZXNwYWNlKSkge1xuICAgICAgZGVsZXRlIHNsb3RzW25hbWUkMV07XG4gICAgfVxuICB9XG4gIHJldHVybiBzbG90c1xufVxuXG5mdW5jdGlvbiBpc1doaXRlc3BhY2UgKG5vZGUpIHtcbiAgcmV0dXJuIChub2RlLmlzQ29tbWVudCAmJiAhbm9kZS5hc3luY0ZhY3RvcnkpIHx8IG5vZGUudGV4dCA9PT0gJyAnXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVTY29wZWRTbG90cyAoXG4gIGZucywgLy8gc2VlIGZsb3cvdm5vZGVcbiAgcmVzXG4pIHtcbiAgcmVzID0gcmVzIHx8IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZuc1tpXSkpIHtcbiAgICAgIHJlc29sdmVTY29wZWRTbG90cyhmbnNbaV0sIHJlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc1tmbnNbaV0ua2V5XSA9IGZuc1tpXS5mbjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIGFjdGl2ZUluc3RhbmNlID0gbnVsbDtcbnZhciBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcblxuZnVuY3Rpb24gaW5pdExpZmVjeWNsZSAodm0pIHtcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcblxuICAvLyBsb2NhdGUgZmlyc3Qgbm9uLWFic3RyYWN0IHBhcmVudFxuICB2YXIgcGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIGlmIChwYXJlbnQgJiYgIW9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICB3aGlsZSAocGFyZW50LiRvcHRpb25zLmFic3RyYWN0ICYmIHBhcmVudC4kcGFyZW50KSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICB9XG4gICAgcGFyZW50LiRjaGlsZHJlbi5wdXNoKHZtKTtcbiAgfVxuXG4gIHZtLiRwYXJlbnQgPSBwYXJlbnQ7XG4gIHZtLiRyb290ID0gcGFyZW50ID8gcGFyZW50LiRyb290IDogdm07XG5cbiAgdm0uJGNoaWxkcmVuID0gW107XG4gIHZtLiRyZWZzID0ge307XG5cbiAgdm0uX3dhdGNoZXIgPSBudWxsO1xuICB2bS5faW5hY3RpdmUgPSBudWxsO1xuICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgdm0uX2lzTW91bnRlZCA9IGZhbHNlO1xuICB2bS5faXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbGlmZWN5Y2xlTWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlVXBkYXRlJyk7XG4gICAgfVxuICAgIHZhciBwcmV2RWwgPSB2bS4kZWw7XG4gICAgdmFyIHByZXZWbm9kZSA9IHZtLl92bm9kZTtcbiAgICB2YXIgcHJldkFjdGl2ZUluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2U7XG4gICAgYWN0aXZlSW5zdGFuY2UgPSB2bTtcbiAgICB2bS5fdm5vZGUgPSB2bm9kZTtcbiAgICAvLyBWdWUucHJvdG90eXBlLl9fcGF0Y2hfXyBpcyBpbmplY3RlZCBpbiBlbnRyeSBwb2ludHNcbiAgICAvLyBiYXNlZCBvbiB0aGUgcmVuZGVyaW5nIGJhY2tlbmQgdXNlZC5cbiAgICBpZiAoIXByZXZWbm9kZSkge1xuICAgICAgLy8gaW5pdGlhbCByZW5kZXJcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhcbiAgICAgICAgdm0uJGVsLCB2bm9kZSwgaHlkcmF0aW5nLCBmYWxzZSAvKiByZW1vdmVPbmx5ICovLFxuICAgICAgICB2bS4kb3B0aW9ucy5fcGFyZW50RWxtLFxuICAgICAgICB2bS4kb3B0aW9ucy5fcmVmRWxtXG4gICAgICApO1xuICAgICAgLy8gbm8gbmVlZCBmb3IgdGhlIHJlZiBub2RlcyBhZnRlciBpbml0aWFsIHBhdGNoXG4gICAgICAvLyB0aGlzIHByZXZlbnRzIGtlZXBpbmcgYSBkZXRhY2hlZCBET00gdHJlZSBpbiBtZW1vcnkgKCM1ODUxKVxuICAgICAgdm0uJG9wdGlvbnMuX3BhcmVudEVsbSA9IHZtLiRvcHRpb25zLl9yZWZFbG0gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1cGRhdGVzXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18ocHJldlZub2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGFjdGl2ZUluc3RhbmNlID0gcHJldkFjdGl2ZUluc3RhbmNlO1xuICAgIC8vIHVwZGF0ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmIChwcmV2RWwpIHtcbiAgICAgIHByZXZFbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSB2bTtcbiAgICB9XG4gICAgLy8gaWYgcGFyZW50IGlzIGFuIEhPQywgdXBkYXRlIGl0cyAkZWwgYXMgd2VsbFxuICAgIGlmICh2bS4kdm5vZGUgJiYgdm0uJHBhcmVudCAmJiB2bS4kdm5vZGUgPT09IHZtLiRwYXJlbnQuX3Zub2RlKSB7XG4gICAgICB2bS4kcGFyZW50LiRlbCA9IHZtLiRlbDtcbiAgICB9XG4gICAgLy8gdXBkYXRlZCBob29rIGlzIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyIHRvIGVuc3VyZSB0aGF0IGNoaWxkcmVuIGFyZVxuICAgIC8vIHVwZGF0ZWQgaW4gYSBwYXJlbnQncyB1cGRhdGVkIGhvb2suXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnVwZGF0ZSgpO1xuICAgIH1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRkZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVEZXN0cm95Jyk7XG4gICAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50XG4gICAgdmFyIHBhcmVudCA9IHZtLiRwYXJlbnQ7XG4gICAgaWYgKHBhcmVudCAmJiAhcGFyZW50Ll9pc0JlaW5nRGVzdHJveWVkICYmICF2bS4kb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgICAgcmVtb3ZlKHBhcmVudC4kY2hpbGRyZW4sIHZtKTtcbiAgICB9XG4gICAgLy8gdGVhcmRvd24gd2F0Y2hlcnNcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIHZhciBpID0gdm0uX3dhdGNoZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2bS5fd2F0Y2hlcnNbaV0udGVhcmRvd24oKTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSBmcm9tIGRhdGEgb2JcbiAgICAvLyBmcm96ZW4gb2JqZWN0IG1heSBub3QgaGF2ZSBvYnNlcnZlci5cbiAgICBpZiAodm0uX2RhdGEuX19vYl9fKSB7XG4gICAgICB2bS5fZGF0YS5fX29iX18udm1Db3VudC0tO1xuICAgIH1cbiAgICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cbiAgICB2bS5faXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIGludm9rZSBkZXN0cm95IGhvb2tzIG9uIGN1cnJlbnQgcmVuZGVyZWQgdHJlZVxuICAgIHZtLl9fcGF0Y2hfXyh2bS5fdm5vZGUsIG51bGwpO1xuICAgIC8vIGZpcmUgZGVzdHJveWVkIGhvb2tcbiAgICBjYWxsSG9vayh2bSwgJ2Rlc3Ryb3llZCcpO1xuICAgIC8vIHR1cm4gb2ZmIGFsbCBpbnN0YW5jZSBsaXN0ZW5lcnMuXG4gICAgdm0uJG9mZigpO1xuICAgIC8vIHJlbW92ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgLy8gcmVsZWFzZSBjaXJjdWxhciByZWZlcmVuY2UgKCM2NzU5KVxuICAgIGlmICh2bS4kdm5vZGUpIHtcbiAgICAgIHZtLiR2bm9kZS5wYXJlbnQgPSBudWxsO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gbW91bnRDb21wb25lbnQgKFxuICB2bSxcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIHZtLiRlbCA9IGVsO1xuICBpZiAoIXZtLiRvcHRpb25zLnJlbmRlcikge1xuICAgIHZtLiRvcHRpb25zLnJlbmRlciA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCh2bS4kb3B0aW9ucy50ZW1wbGF0ZSAmJiB2bS4kb3B0aW9ucy50ZW1wbGF0ZS5jaGFyQXQoMCkgIT09ICcjJykgfHxcbiAgICAgICAgdm0uJG9wdGlvbnMuZWwgfHwgZWwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnWW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkIG9mIFZ1ZSB3aGVyZSB0aGUgdGVtcGxhdGUgJyArXG4gICAgICAgICAgJ2NvbXBpbGVyIGlzIG5vdCBhdmFpbGFibGUuIEVpdGhlciBwcmUtY29tcGlsZSB0aGUgdGVtcGxhdGVzIGludG8gJyArXG4gICAgICAgICAgJ3JlbmRlciBmdW5jdGlvbnMsIG9yIHVzZSB0aGUgY29tcGlsZXItaW5jbHVkZWQgYnVpbGQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnRmFpbGVkIHRvIG1vdW50IGNvbXBvbmVudDogdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uIG5vdCBkZWZpbmVkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2FsbEhvb2sodm0sICdiZWZvcmVNb3VudCcpO1xuXG4gIHZhciB1cGRhdGVDb21wb25lbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBuYW1lID0gdm0uX25hbWU7XG4gICAgICB2YXIgaWQgPSB2bS5fdWlkO1xuICAgICAgdmFyIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArIGlkO1xuICAgICAgdmFyIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgaWQ7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdmFyIHZub2RlID0gdm0uX3JlbmRlcigpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyBuYW1lICsgXCIgcmVuZGVyXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2bS5fdXBkYXRlKHZub2RlLCBoeWRyYXRpbmcpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyBuYW1lICsgXCIgcGF0Y2hcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdm0uX3VwZGF0ZSh2bS5fcmVuZGVyKCksIGh5ZHJhdGluZyk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIHdlIHNldCB0aGlzIHRvIHZtLl93YXRjaGVyIGluc2lkZSB0aGUgd2F0Y2hlcidzIGNvbnN0cnVjdG9yXG4gIC8vIHNpbmNlIHRoZSB3YXRjaGVyJ3MgaW5pdGlhbCBwYXRjaCBtYXkgY2FsbCAkZm9yY2VVcGRhdGUgKGUuZy4gaW5zaWRlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCdzIG1vdW50ZWQgaG9vayksIHdoaWNoIHJlbGllcyBvbiB2bS5fd2F0Y2hlciBiZWluZyBhbHJlYWR5IGRlZmluZWRcbiAgbmV3IFdhdGNoZXIodm0sIHVwZGF0ZUNvbXBvbmVudCwgbm9vcCwgbnVsbCwgdHJ1ZSAvKiBpc1JlbmRlcldhdGNoZXIgKi8pO1xuICBoeWRyYXRpbmcgPSBmYWxzZTtcblxuICAvLyBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlLCBjYWxsIG1vdW50ZWQgb24gc2VsZlxuICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xuICBpZiAodm0uJHZub2RlID09IG51bGwpIHtcbiAgICB2bS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICBjYWxsSG9vayh2bSwgJ21vdW50ZWQnKTtcbiAgfVxuICByZXR1cm4gdm1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2hpbGRDb21wb25lbnQgKFxuICB2bSxcbiAgcHJvcHNEYXRhLFxuICBsaXN0ZW5lcnMsXG4gIHBhcmVudFZub2RlLFxuICByZW5kZXJDaGlsZHJlblxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGRldGVybWluZSB3aGV0aGVyIGNvbXBvbmVudCBoYXMgc2xvdCBjaGlsZHJlblxuICAvLyB3ZSBuZWVkIHRvIGRvIHRoaXMgYmVmb3JlIG92ZXJ3cml0aW5nICRvcHRpb25zLl9yZW5kZXJDaGlsZHJlblxuICB2YXIgaGFzQ2hpbGRyZW4gPSAhIShcbiAgICByZW5kZXJDaGlsZHJlbiB8fCAgICAgICAgICAgICAgIC8vIGhhcyBuZXcgc3RhdGljIHNsb3RzXG4gICAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuIHx8ICAvLyBoYXMgb2xkIHN0YXRpYyBzbG90c1xuICAgIHBhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMgfHwgLy8gaGFzIG5ldyBzY29wZWQgc2xvdHNcbiAgICB2bS4kc2NvcGVkU2xvdHMgIT09IGVtcHR5T2JqZWN0IC8vIGhhcyBvbGQgc2NvcGVkIHNsb3RzXG4gICk7XG5cbiAgdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG4gIHZtLiR2bm9kZSA9IHBhcmVudFZub2RlOyAvLyB1cGRhdGUgdm0ncyBwbGFjZWhvbGRlciBub2RlIHdpdGhvdXQgcmUtcmVuZGVyXG5cbiAgaWYgKHZtLl92bm9kZSkgeyAvLyB1cGRhdGUgY2hpbGQgdHJlZSdzIHBhcmVudFxuICAgIHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcbiAgfVxuICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gPSByZW5kZXJDaGlsZHJlbjtcblxuICAvLyB1cGRhdGUgJGF0dHJzIGFuZCAkbGlzdGVuZXJzIGhhc2hcbiAgLy8gdGhlc2UgYXJlIGFsc28gcmVhY3RpdmUgc28gdGhleSBtYXkgdHJpZ2dlciBjaGlsZCB1cGRhdGUgaWYgdGhlIGNoaWxkXG4gIC8vIHVzZWQgdGhlbSBkdXJpbmcgcmVuZGVyXG4gIHZtLiRhdHRycyA9IHBhcmVudFZub2RlLmRhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3Q7XG4gIHZtLiRsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3Q7XG5cbiAgLy8gdXBkYXRlIHByb3BzXG4gIGlmIChwcm9wc0RhdGEgJiYgdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICAgIHZhciBwcm9wcyA9IHZtLl9wcm9wcztcbiAgICB2YXIgcHJvcEtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgfHwgW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IHByb3BLZXlzW2ldO1xuICAgICAgdmFyIHByb3BPcHRpb25zID0gdm0uJG9wdGlvbnMucHJvcHM7IC8vIHd0ZiBmbG93P1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcbiAgICB9XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICAgIC8vIGtlZXAgYSBjb3B5IG9mIHJhdyBwcm9wc0RhdGFcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgPSBwcm9wc0RhdGE7XG4gIH1cblxuICAvLyB1cGRhdGUgbGlzdGVuZXJzXG4gIGxpc3RlbmVycyA9IGxpc3RlbmVycyB8fCBlbXB0eU9iamVjdDtcbiAgdmFyIG9sZExpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMpO1xuXG4gIC8vIHJlc29sdmUgc2xvdHMgKyBmb3JjZSB1cGRhdGUgaWYgaGFzIGNoaWxkcmVuXG4gIGlmIChoYXNDaGlsZHJlbikge1xuICAgIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhyZW5kZXJDaGlsZHJlbiwgcGFyZW50Vm5vZGUuY29udGV4dCk7XG4gICAgdm0uJGZvcmNlVXBkYXRlKCk7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUgKHZtKSB7XG4gIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xuICAgIGlmICh2bS5faW5hY3RpdmUpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfSBlbHNlIGlmICh2bS5fZGlyZWN0SW5hY3RpdmUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodm0uX2luYWN0aXZlIHx8IHZtLl9pbmFjdGl2ZSA9PT0gbnVsbCkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSB0cnVlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIGlmICghdm0uX2luYWN0aXZlKSB7XG4gICAgdm0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnZGVhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayAodm0sIGhvb2spIHtcbiAgLy8gIzc1NzMgZGlzYWJsZSBkZXAgY29sbGVjdGlvbiB3aGVuIGludm9raW5nIGxpZmVjeWNsZSBob29rc1xuICBwdXNoVGFyZ2V0KCk7XG4gIHZhciBoYW5kbGVycyA9IHZtLiRvcHRpb25zW2hvb2tdO1xuICBpZiAoaGFuZGxlcnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaGFuZGxlcnNbaV0uY2FsbCh2bSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoaG9vayArIFwiIGhvb2tcIikpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodm0uX2hhc0hvb2tFdmVudCkge1xuICAgIHZtLiRlbWl0KCdob29rOicgKyBob29rKTtcbiAgfVxuICBwb3BUYXJnZXQoKTtcbn1cblxuLyogICovXG5cblxudmFyIE1BWF9VUERBVEVfQ09VTlQgPSAxMDA7XG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGFjdGl2YXRlZENoaWxkcmVuID0gW107XG52YXIgaGFzID0ge307XG52YXIgY2lyY3VsYXIgPSB7fTtcbnZhciB3YWl0aW5nID0gZmFsc2U7XG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbnZhciBpbmRleCA9IDA7XG5cbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgaW5kZXggPSBxdWV1ZS5sZW5ndGggPSBhY3RpdmF0ZWRDaGlsZHJlbi5sZW5ndGggPSAwO1xuICBoYXMgPSB7fTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaXJjdWxhciA9IHt9O1xuICB9XG4gIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcbiAgZmx1c2hpbmcgPSB0cnVlO1xuICB2YXIgd2F0Y2hlciwgaWQ7XG5cbiAgLy8gU29ydCBxdWV1ZSBiZWZvcmUgZmx1c2guXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxuICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXG4gIC8vICAgIGNyZWF0ZWQgYmVmb3JlIHRoZSBjaGlsZClcbiAgLy8gMi4gQSBjb21wb25lbnQncyB1c2VyIHdhdGNoZXJzIGFyZSBydW4gYmVmb3JlIGl0cyByZW5kZXIgd2F0Y2hlciAoYmVjYXVzZVxuICAvLyAgICB1c2VyIHdhdGNoZXJzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGUgcmVuZGVyIHdhdGNoZXIpXG4gIC8vIDMuIElmIGEgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBkdXJpbmcgYSBwYXJlbnQgY29tcG9uZW50J3Mgd2F0Y2hlciBydW4sXG4gIC8vICAgIGl0cyB3YXRjaGVycyBjYW4gYmUgc2tpcHBlZC5cbiAgcXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5pZCAtIGIuaWQ7IH0pO1xuXG4gIC8vIGRvIG5vdCBjYWNoZSBsZW5ndGggYmVjYXVzZSBtb3JlIHdhdGNoZXJzIG1pZ2h0IGJlIHB1c2hlZFxuICAvLyBhcyB3ZSBydW4gZXhpc3Rpbmcgd2F0Y2hlcnNcbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcXVldWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgd2F0Y2hlciA9IHF1ZXVlW2luZGV4XTtcbiAgICBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaGFzW2lkXSA9IG51bGw7XG4gICAgd2F0Y2hlci5ydW4oKTtcbiAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBNQVhfVVBEQVRFX0NPVU5UKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICsgKFxuICAgICAgICAgICAgd2F0Y2hlci51c2VyXG4gICAgICAgICAgICAgID8gKFwiaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIilcbiAgICAgICAgICAgICAgOiBcImluIGEgY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbi5cIlxuICAgICAgICAgICksXG4gICAgICAgICAgd2F0Y2hlci52bVxuICAgICAgICApO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGtlZXAgY29waWVzIG9mIHBvc3QgcXVldWVzIGJlZm9yZSByZXNldHRpbmcgc3RhdGVcbiAgdmFyIGFjdGl2YXRlZFF1ZXVlID0gYWN0aXZhdGVkQ2hpbGRyZW4uc2xpY2UoKTtcbiAgdmFyIHVwZGF0ZWRRdWV1ZSA9IHF1ZXVlLnNsaWNlKCk7XG5cbiAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xuXG4gIC8vIGNhbGwgY29tcG9uZW50IHVwZGF0ZWQgYW5kIGFjdGl2YXRlZCBob29rc1xuICBjYWxsQWN0aXZhdGVkSG9va3MoYWN0aXZhdGVkUXVldWUpO1xuICBjYWxsVXBkYXRlZEhvb2tzKHVwZGF0ZWRRdWV1ZSk7XG5cbiAgLy8gZGV2dG9vbCBob29rXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsVXBkYXRlZEhvb2tzIChxdWV1ZSkge1xuICB2YXIgaSA9IHF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciB3YXRjaGVyID0gcXVldWVbaV07XG4gICAgdmFyIHZtID0gd2F0Y2hlci52bTtcbiAgICBpZiAodm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICd1cGRhdGVkJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUXVldWUgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCB0aGF0IHdhcyBhY3RpdmF0ZWQgZHVyaW5nIHBhdGNoLlxuICogVGhlIHF1ZXVlIHdpbGwgYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSBlbnRpcmUgdHJlZSBoYXMgYmVlbiBwYXRjaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCAodm0pIHtcbiAgLy8gc2V0dGluZyBfaW5hY3RpdmUgdG8gZmFsc2UgaGVyZSBzbyB0aGF0IGEgcmVuZGVyIGZ1bmN0aW9uIGNhblxuICAvLyByZWx5IG9uIGNoZWNraW5nIHdoZXRoZXIgaXQncyBpbiBhbiBpbmFjdGl2ZSB0cmVlIChlLmcuIHJvdXRlci12aWV3KVxuICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgYWN0aXZhdGVkQ2hpbGRyZW4ucHVzaCh2bSk7XG59XG5cbmZ1bmN0aW9uIGNhbGxBY3RpdmF0ZWRIb29rcyAocXVldWUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHF1ZXVlW2ldLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChxdWV1ZVtpXSwgdHJ1ZSAvKiB0cnVlICovKTtcbiAgfVxufVxuXG4vKipcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcbiAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgIHF1ZXVlLnB1c2god2F0Y2hlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcbiAgICAgIC8vIGlmIGFscmVhZHkgcGFzdCBpdHMgaWQsIGl0IHdpbGwgYmUgcnVuIG5leHQgaW1tZWRpYXRlbHkuXG4gICAgICB2YXIgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaSA+IGluZGV4ICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgICBxdWV1ZS5zcGxpY2UoaSArIDEsIDAsIHdhdGNoZXIpO1xuICAgIH1cbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xuICAgICAgbmV4dFRpY2soZmx1c2hTY2hlZHVsZXJRdWV1ZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgdWlkJDEgPSAwO1xuXG4vKipcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxuICogYW5kIGZpcmVzIGNhbGxiYWNrIHdoZW4gdGhlIGV4cHJlc3Npb24gdmFsdWUgY2hhbmdlcy5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICovXG52YXIgV2F0Y2hlciA9IGZ1bmN0aW9uIFdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgY2IsXG4gIG9wdGlvbnMsXG4gIGlzUmVuZGVyV2F0Y2hlclxuKSB7XG4gIHRoaXMudm0gPSB2bTtcbiAgaWYgKGlzUmVuZGVyV2F0Y2hlcikge1xuICAgIHZtLl93YXRjaGVyID0gdGhpcztcbiAgfVxuICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcbiAgLy8gb3B0aW9uc1xuICBpZiAob3B0aW9ucykge1xuICAgIHRoaXMuZGVlcCA9ICEhb3B0aW9ucy5kZWVwO1xuICAgIHRoaXMudXNlciA9ICEhb3B0aW9ucy51c2VyO1xuICAgIHRoaXMubGF6eSA9ICEhb3B0aW9ucy5sYXp5O1xuICAgIHRoaXMuc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZGVlcCA9IHRoaXMudXNlciA9IHRoaXMubGF6eSA9IHRoaXMuc3luYyA9IGZhbHNlO1xuICB9XG4gIHRoaXMuY2IgPSBjYjtcbiAgdGhpcy5pZCA9ICsrdWlkJDE7IC8vIHVpZCBmb3IgYmF0Y2hpbmdcbiAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICB0aGlzLmRpcnR5ID0gdGhpcy5sYXp5OyAvLyBmb3IgbGF6eSB3YXRjaGVyc1xuICB0aGlzLmRlcHMgPSBbXTtcbiAgdGhpcy5uZXdEZXBzID0gW107XG4gIHRoaXMuZGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5uZXdEZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLmV4cHJlc3Npb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXG4gICAgPyBleHBPckZuLnRvU3RyaW5nKClcbiAgICA6ICcnO1xuICAvLyBwYXJzZSBleHByZXNzaW9uIGZvciBnZXR0ZXJcbiAgaWYgKHR5cGVvZiBleHBPckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBleHBPckZuO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZ2V0dGVyID0gcGFyc2VQYXRoKGV4cE9yRm4pO1xuICAgIGlmICghdGhpcy5nZXR0ZXIpIHtcbiAgICAgIHRoaXMuZ2V0dGVyID0gZnVuY3Rpb24gKCkge307XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHdhdGNoaW5nIHBhdGg6IFxcXCJcIiArIGV4cE9yRm4gKyBcIlxcXCIgXCIgK1xuICAgICAgICAnV2F0Y2hlciBvbmx5IGFjY2VwdHMgc2ltcGxlIGRvdC1kZWxpbWl0ZWQgcGF0aHMuICcgK1xuICAgICAgICAnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgdGhpcy52YWx1ZSA9IHRoaXMubGF6eVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiB0aGlzLmdldCgpO1xufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgZ2V0dGVyLCBhbmQgcmUtY29sbGVjdCBkZXBlbmRlbmNpZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoKSB7XG4gIHB1c2hUYXJnZXQodGhpcyk7XG4gIHZhciB2YWx1ZTtcbiAgdmFyIHZtID0gdGhpcy52bTtcbiAgdHJ5IHtcbiAgICB2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwodm0sIHZtKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoXCJnZXR0ZXIgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlXG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIC8vIFwidG91Y2hcIiBldmVyeSBwcm9wZXJ0eSBzbyB0aGV5IGFyZSBhbGwgdHJhY2tlZCBhc1xuICAgIC8vIGRlcGVuZGVuY2llcyBmb3IgZGVlcCB3YXRjaGluZ1xuICAgIGlmICh0aGlzLmRlZXApIHtcbiAgICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgICB9XG4gICAgcG9wVGFyZ2V0KCk7XG4gICAgdGhpcy5jbGVhbnVwRGVwcygpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufTtcblxuLyoqXG4gKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5hZGREZXAgPSBmdW5jdGlvbiBhZGREZXAgKGRlcCkge1xuICB2YXIgaWQgPSBkZXAuaWQ7XG4gIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGlkKSkge1xuICAgIHRoaXMubmV3RGVwSWRzLmFkZChpZCk7XG4gICAgdGhpcy5uZXdEZXBzLnB1c2goZGVwKTtcbiAgICBpZiAoIXRoaXMuZGVwSWRzLmhhcyhpZCkpIHtcbiAgICAgIGRlcC5hZGRTdWIodGhpcyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmNsZWFudXBEZXBzID0gZnVuY3Rpb24gY2xlYW51cERlcHMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBkZXAgPSB0aGlzJDEuZGVwc1tpXTtcbiAgICBpZiAoIXRoaXMkMS5uZXdEZXBJZHMuaGFzKGRlcC5pZCkpIHtcbiAgICAgIGRlcC5yZW1vdmVTdWIodGhpcyQxKTtcbiAgICB9XG4gIH1cbiAgdmFyIHRtcCA9IHRoaXMuZGVwSWRzO1xuICB0aGlzLmRlcElkcyA9IHRoaXMubmV3RGVwSWRzO1xuICB0aGlzLm5ld0RlcElkcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBJZHMuY2xlYXIoKTtcbiAgdG1wID0gdGhpcy5kZXBzO1xuICB0aGlzLmRlcHMgPSB0aGlzLm5ld0RlcHM7XG4gIHRoaXMubmV3RGVwcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBzLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIFN1YnNjcmliZXIgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlICgpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHRoaXMubGF6eSkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRoaXMuc3luYykge1xuICAgIHRoaXMucnVuKCk7XG4gIH0gZWxzZSB7XG4gICAgcXVldWVXYXRjaGVyKHRoaXMpO1xuICB9XG59O1xuXG4vKipcbiAqIFNjaGVkdWxlciBqb2IgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gcnVuICgpIHtcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxuICAgICAgLy8gRGVlcCB3YXRjaGVycyBhbmQgd2F0Y2hlcnMgb24gT2JqZWN0L0FycmF5cyBzaG91bGQgZmlyZSBldmVuXG4gICAgICAvLyB3aGVuIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSwgYmVjYXVzZSB0aGUgdmFsdWUgbWF5XG4gICAgICAvLyBoYXZlIG11dGF0ZWQuXG4gICAgICBpc09iamVjdCh2YWx1ZSkgfHxcbiAgICAgIHRoaXMuZGVlcFxuICAgICkge1xuICAgICAgLy8gc2V0IG5ldyB2YWx1ZVxuICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHRoaXMudm0sIChcImNhbGxiYWNrIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cbiAqIFRoaXMgb25seSBnZXRzIGNhbGxlZCBmb3IgbGF6eSB3YXRjaGVycy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZSAoKSB7XG4gIHRoaXMudmFsdWUgPSB0aGlzLmdldCgpO1xuICB0aGlzLmRpcnR5ID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHRoaXMkMS5kZXBzW2ldLmRlcGVuZCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBzZWxmIGZyb20gYWxsIGRlcGVuZGVuY2llcycgc3Vic2NyaWJlciBsaXN0LlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS50ZWFyZG93biA9IGZ1bmN0aW9uIHRlYXJkb3duICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XG4gICAgLy8gdGhpcyBpcyBhIHNvbWV3aGF0IGV4cGVuc2l2ZSBvcGVyYXRpb24gc28gd2Ugc2tpcCBpdFxuICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBkZXN0cm95ZWQuXG4gICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZW1vdmUodGhpcy52bS5fd2F0Y2hlcnMsIHRoaXMpO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcyQxLmRlcHNbaV0ucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gIH1cbn07XG5cbi8qICAqL1xuXG52YXIgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uID0ge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogbm9vcCxcbiAgc2V0OiBub29wXG59O1xuXG5mdW5jdGlvbiBwcm94eSAodGFyZ2V0LCBzb3VyY2VLZXksIGtleSkge1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gZnVuY3Rpb24gcHJveHlHZXR0ZXIgKCkge1xuICAgIHJldHVybiB0aGlzW3NvdXJjZUtleV1ba2V5XVxuICB9O1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gcHJveHlTZXR0ZXIgKHZhbCkge1xuICAgIHRoaXNbc291cmNlS2V5XVtrZXldID0gdmFsO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGluaXRTdGF0ZSAodm0pIHtcbiAgdm0uX3dhdGNoZXJzID0gW107XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnM7XG4gIGlmIChvcHRzLnByb3BzKSB7IGluaXRQcm9wcyh2bSwgb3B0cy5wcm9wcyk7IH1cbiAgaWYgKG9wdHMubWV0aG9kcykgeyBpbml0TWV0aG9kcyh2bSwgb3B0cy5tZXRob2RzKTsgfVxuICBpZiAob3B0cy5kYXRhKSB7XG4gICAgaW5pdERhdGEodm0pO1xuICB9IGVsc2Uge1xuICAgIG9ic2VydmUodm0uX2RhdGEgPSB7fSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbiAgfVxuICBpZiAob3B0cy5jb21wdXRlZCkgeyBpbml0Q29tcHV0ZWQodm0sIG9wdHMuY29tcHV0ZWQpOyB9XG4gIGlmIChvcHRzLndhdGNoICYmIG9wdHMud2F0Y2ggIT09IG5hdGl2ZVdhdGNoKSB7XG4gICAgaW5pdFdhdGNoKHZtLCBvcHRzLndhdGNoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMgKHZtLCBwcm9wc09wdGlvbnMpIHtcbiAgdmFyIHByb3BzRGF0YSA9IHZtLiRvcHRpb25zLnByb3BzRGF0YSB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm0uX3Byb3BzID0ge307XG4gIC8vIGNhY2hlIHByb3Aga2V5cyBzbyB0aGF0IGZ1dHVyZSBwcm9wcyB1cGRhdGVzIGNhbiBpdGVyYXRlIHVzaW5nIEFycmF5XG4gIC8vIGluc3RlYWQgb2YgZHluYW1pYyBvYmplY3Qga2V5IGVudW1lcmF0aW9uLlxuICB2YXIga2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyA9IFtdO1xuICB2YXIgaXNSb290ID0gIXZtLiRwYXJlbnQ7XG4gIC8vIHJvb3QgaW5zdGFuY2UgcHJvcHMgc2hvdWxkIGJlIGNvbnZlcnRlZFxuICBpZiAoIWlzUm9vdCkge1xuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gIH1cbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB2YXIgdmFsdWUgPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wc09wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBoeXBoZW5hdGVkS2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICBpZiAoaXNSZXNlcnZlZEF0dHJpYnV0ZShoeXBoZW5hdGVkS2V5KSB8fFxuICAgICAgICAgIGNvbmZpZy5pc1Jlc2VydmVkQXR0cihoeXBoZW5hdGVkS2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIlxcXCJcIiArIGh5cGhlbmF0ZWRLZXkgKyBcIlxcXCIgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUgYW5kIGNhbm5vdCBiZSB1c2VkIGFzIGNvbXBvbmVudCBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZGVmaW5lUmVhY3RpdmUocHJvcHMsIGtleSwgdmFsdWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHZtLiRwYXJlbnQgJiYgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGEgcHJvcCBkaXJlY3RseSBzaW5jZSB0aGUgdmFsdWUgd2lsbCBiZSBcIiArXG4gICAgICAgICAgICBcIm92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwYXJlbnQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgIFwiSW5zdGVhZCwgdXNlIGEgZGF0YSBvciBjb21wdXRlZCBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcHJvcCdzIFwiICtcbiAgICAgICAgICAgIFwidmFsdWUuIFByb3AgYmVpbmcgbXV0YXRlZDogXFxcIlwiICsga2V5ICsgXCJcXFwiXCIsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWZpbmVSZWFjdGl2ZShwcm9wcywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIC8vIHN0YXRpYyBwcm9wcyBhcmUgYWxyZWFkeSBwcm94aWVkIG9uIHRoZSBjb21wb25lbnQncyBwcm90b3R5cGVcbiAgICAvLyBkdXJpbmcgVnVlLmV4dGVuZCgpLiBXZSBvbmx5IG5lZWQgdG8gcHJveHkgcHJvcHMgZGVmaW5lZCBhdFxuICAgIC8vIGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBwcm94eSh2bSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgICB9XG4gIH07XG5cbiAgZm9yICh2YXIga2V5IGluIHByb3BzT3B0aW9ucykgbG9vcCgga2V5ICk7XG4gIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbn1cblxuZnVuY3Rpb24gaW5pdERhdGEgKHZtKSB7XG4gIHZhciBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcbiAgZGF0YSA9IHZtLl9kYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbidcbiAgICA/IGdldERhdGEoZGF0YSwgdm0pXG4gICAgOiBkYXRhIHx8IHt9O1xuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICBkYXRhID0ge307XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgJ2h0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgdmFyIG1ldGhvZHMgPSB2bS4kb3B0aW9ucy5tZXRob2RzO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChtZXRob2RzICYmIGhhc093bihtZXRob2RzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBkYXRhIHByb3BlcnR5LlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiVGhlIGRhdGEgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVjbGFyZWQgYXMgYSBwcm9wLiBcIiArXG4gICAgICAgIFwiVXNlIHByb3AgZGVmYXVsdCB2YWx1ZSBpbnN0ZWFkLlwiLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9kYXRhXCIsIGtleSk7XG4gICAgfVxuICB9XG4gIC8vIG9ic2VydmUgZGF0YVxuICBvYnNlcnZlKGRhdGEsIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEgKGRhdGEsIHZtKSB7XG4gIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBkYXRhIGdldHRlcnNcbiAgcHVzaFRhcmdldCgpO1xuICB0cnkge1xuICAgIHJldHVybiBkYXRhLmNhbGwodm0sIHZtKVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwiZGF0YSgpXCIpO1xuICAgIHJldHVybiB7fVxuICB9IGZpbmFsbHkge1xuICAgIHBvcFRhcmdldCgpO1xuICB9XG59XG5cbnZhciBjb21wdXRlZFdhdGNoZXJPcHRpb25zID0geyBsYXp5OiB0cnVlIH07XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCAodm0sIGNvbXB1dGVkKSB7XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICB2YXIgd2F0Y2hlcnMgPSB2bS5fY29tcHV0ZWRXYXRjaGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIC8vIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGp1c3QgZ2V0dGVycyBkdXJpbmcgU1NSXG4gIHZhciBpc1NTUiA9IGlzU2VydmVyUmVuZGVyaW5nKCk7XG5cbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgdmFyIHVzZXJEZWYgPSBjb21wdXRlZFtrZXldO1xuICAgIHZhciBnZXR0ZXIgPSB0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJyA/IHVzZXJEZWYgOiB1c2VyRGVmLmdldDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBnZXR0ZXIgPT0gbnVsbCkge1xuICAgICAgd2FybihcbiAgICAgICAgKFwiR2V0dGVyIGlzIG1pc3NpbmcgZm9yIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIi5cIiksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghaXNTU1IpIHtcbiAgICAgIC8vIGNyZWF0ZSBpbnRlcm5hbCB3YXRjaGVyIGZvciB0aGUgY29tcHV0ZWQgcHJvcGVydHkuXG4gICAgICB3YXRjaGVyc1trZXldID0gbmV3IFdhdGNoZXIoXG4gICAgICAgIHZtLFxuICAgICAgICBnZXR0ZXIgfHwgbm9vcCxcbiAgICAgICAgbm9vcCxcbiAgICAgICAgY29tcHV0ZWRXYXRjaGVyT3B0aW9uc1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBjb21wb25lbnQtZGVmaW5lZCBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBhbHJlYWR5IGRlZmluZWQgb24gdGhlXG4gICAgLy8gY29tcG9uZW50IHByb3RvdHlwZS4gV2Ugb25seSBuZWVkIHRvIGRlZmluZSBjb21wdXRlZCBwcm9wZXJ0aWVzIGRlZmluZWRcbiAgICAvLyBhdCBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgZGVmaW5lQ29tcHV0ZWQodm0sIGtleSwgdXNlckRlZik7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoa2V5IGluIHZtLiRkYXRhKSB7XG4gICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gZGF0YS5cIiksIHZtKTtcbiAgICAgIH0gZWxzZSBpZiAodm0uJG9wdGlvbnMucHJvcHMgJiYga2V5IGluIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgYXMgYSBwcm9wLlwiKSwgdm0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVDb21wdXRlZCAoXG4gIHRhcmdldCxcbiAga2V5LFxuICB1c2VyRGVmXG4pIHtcbiAgdmFyIHNob3VsZENhY2hlID0gIWlzU2VydmVyUmVuZGVyaW5nKCk7XG4gIGlmICh0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBzaG91bGRDYWNoZVxuICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICA6IHVzZXJEZWY7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IG5vb3A7XG4gIH0gZWxzZSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHVzZXJEZWYuZ2V0XG4gICAgICA/IHNob3VsZENhY2hlICYmIHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlXG4gICAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgICA6IHVzZXJEZWYuZ2V0XG4gICAgICA6IG5vb3A7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IHVzZXJEZWYuc2V0XG4gICAgICA/IHVzZXJEZWYuc2V0XG4gICAgICA6IG5vb3A7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPT09IG5vb3ApIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgKFwiQ29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIHdhcyBhc3NpZ25lZCB0byBidXQgaXQgaGFzIG5vIHNldHRlci5cIiksXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkR2V0dGVyIChrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnMgJiYgdGhpcy5fY29tcHV0ZWRXYXRjaGVyc1trZXldO1xuICAgIGlmICh3YXRjaGVyKSB7XG4gICAgICBpZiAod2F0Y2hlci5kaXJ0eSkge1xuICAgICAgICB3YXRjaGVyLmV2YWx1YXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICB3YXRjaGVyLmRlcGVuZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdhdGNoZXIudmFsdWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdE1ldGhvZHMgKHZtLCBtZXRob2RzKSB7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAobWV0aG9kc1trZXldID09IG51bGwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFuIHVuZGVmaW5lZCB2YWx1ZSBpbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb24uIFwiICtcbiAgICAgICAgICBcIkRpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/XCIsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoKGtleSBpbiB2bSkgJiYgaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGNvbmZsaWN0cyB3aXRoIGFuIGV4aXN0aW5nIFZ1ZSBpbnN0YW5jZSBtZXRob2QuIFwiICtcbiAgICAgICAgICBcIkF2b2lkIGRlZmluaW5nIGNvbXBvbmVudCBtZXRob2RzIHRoYXQgc3RhcnQgd2l0aCBfIG9yICQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdm1ba2V5XSA9IG1ldGhvZHNba2V5XSA9PSBudWxsID8gbm9vcCA6IGJpbmQobWV0aG9kc1trZXldLCB2bSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFdhdGNoICh2bSwgd2F0Y2gpIHtcbiAgZm9yICh2YXIga2V5IGluIHdhdGNoKSB7XG4gICAgdmFyIGhhbmRsZXIgPSB3YXRjaFtrZXldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlciAoXG4gIHZtLFxuICBleHBPckZuLFxuICBoYW5kbGVyLFxuICBvcHRpb25zXG4pIHtcbiAgaWYgKGlzUGxhaW5PYmplY3QoaGFuZGxlcikpIHtcbiAgICBvcHRpb25zID0gaGFuZGxlcjtcbiAgICBoYW5kbGVyID0gaGFuZGxlci5oYW5kbGVyO1xuICB9XG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZycpIHtcbiAgICBoYW5kbGVyID0gdm1baGFuZGxlcl07XG4gIH1cbiAgcmV0dXJuIHZtLiR3YXRjaChleHBPckZuLCBoYW5kbGVyLCBvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBzdGF0ZU1peGluIChWdWUpIHtcbiAgLy8gZmxvdyBzb21laG93IGhhcyBwcm9ibGVtcyB3aXRoIGRpcmVjdGx5IGRlY2xhcmVkIGRlZmluaXRpb24gb2JqZWN0XG4gIC8vIHdoZW4gdXNpbmcgT2JqZWN0LmRlZmluZVByb3BlcnR5LCBzbyB3ZSBoYXZlIHRvIHByb2NlZHVyYWxseSBidWlsZCB1cFxuICAvLyB0aGUgb2JqZWN0IGhlcmUuXG4gIHZhciBkYXRhRGVmID0ge307XG4gIGRhdGFEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGF0YSB9O1xuICB2YXIgcHJvcHNEZWYgPSB7fTtcbiAgcHJvcHNEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJvcHMgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBkYXRhRGVmLnNldCA9IGZ1bmN0aW9uIChuZXdEYXRhKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgcmVwbGFjaW5nIGluc3RhbmNlIHJvb3QgJGRhdGEuICcgK1xuICAgICAgICAnVXNlIG5lc3RlZCBkYXRhIHByb3BlcnRpZXMgaW5zdGVhZC4nLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gICAgcHJvcHNEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcIiRwcm9wcyBpcyByZWFkb25seS5cIiwgdGhpcyk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywgZGF0YURlZik7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHByb3BzJywgcHJvcHNEZWYpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHNldCA9IHNldDtcbiAgVnVlLnByb3RvdHlwZS4kZGVsZXRlID0gZGVsO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHdhdGNoID0gZnVuY3Rpb24gKFxuICAgIGV4cE9yRm4sXG4gICAgY2IsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChpc1BsYWluT2JqZWN0KGNiKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKVxuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnVzZXIgPSB0cnVlO1xuICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5pbW1lZGlhdGUpIHtcbiAgICAgIGNiLmNhbGwodm0sIHdhdGNoZXIudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gdW53YXRjaEZuICgpIHtcbiAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UHJvdmlkZSAodm0pIHtcbiAgdmFyIHByb3ZpZGUgPSB2bS4kb3B0aW9ucy5wcm92aWRlO1xuICBpZiAocHJvdmlkZSkge1xuICAgIHZtLl9wcm92aWRlZCA9IHR5cGVvZiBwcm92aWRlID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHByb3ZpZGUuY2FsbCh2bSlcbiAgICAgIDogcHJvdmlkZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0SW5qZWN0aW9ucyAodm0pIHtcbiAgdmFyIHJlc3VsdCA9IHJlc29sdmVJbmplY3Qodm0uJG9wdGlvbnMuaW5qZWN0LCB2bSk7XG4gIGlmIChyZXN1bHQpIHtcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUodm0sIGtleSwgcmVzdWx0W2tleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhbiBpbmplY3RlZCB2YWx1ZSBkaXJlY3RseSBzaW5jZSB0aGUgY2hhbmdlcyB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcImluamVjdGlvbiBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSh2bSwga2V5LCByZXN1bHRba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVJbmplY3QgKGluamVjdCwgdm0pIHtcbiAgaWYgKGluamVjdCkge1xuICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXG4gICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIGtleXMgPSBoYXNTeW1ib2xcbiAgICAgID8gUmVmbGVjdC5vd25LZXlzKGluamVjdCkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaW5qZWN0LCBrZXkpLmVudW1lcmFibGVcbiAgICAgIH0pXG4gICAgICA6IE9iamVjdC5rZXlzKGluamVjdCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHByb3ZpZGVLZXkgPSBpbmplY3Rba2V5XS5mcm9tO1xuICAgICAgdmFyIHNvdXJjZSA9IHZtO1xuICAgICAgd2hpbGUgKHNvdXJjZSkge1xuICAgICAgICBpZiAoc291cmNlLl9wcm92aWRlZCAmJiBoYXNPd24oc291cmNlLl9wcm92aWRlZCwgcHJvdmlkZUtleSkpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHNvdXJjZS5fcHJvdmlkZWRbcHJvdmlkZUtleV07XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2UgPSBzb3VyY2UuJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIGlmICgnZGVmYXVsdCcgaW4gaW5qZWN0W2tleV0pIHtcbiAgICAgICAgICB2YXIgcHJvdmlkZURlZmF1bHQgPSBpbmplY3Rba2V5XS5kZWZhdWx0O1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdHlwZW9mIHByb3ZpZGVEZWZhdWx0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IHByb3ZpZGVEZWZhdWx0LmNhbGwodm0pXG4gICAgICAgICAgICA6IHByb3ZpZGVEZWZhdWx0O1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3YXJuKChcIkluamVjdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgbm90IGZvdW5kXCIpLCB2bSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgdi1mb3IgbGlzdHMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckxpc3QgKFxuICB2YWwsXG4gIHJlbmRlclxuKSB7XG4gIHZhciByZXQsIGksIGwsIGtleXMsIGtleTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSB8fCB0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdmFsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtpXSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbCk7XG4gICAgZm9yIChpID0gMDsgaSA8IHZhbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIoaSArIDEsIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2tleV0sIGtleSwgaSk7XG4gICAgfVxuICB9XG4gIGlmIChpc0RlZihyZXQpKSB7XG4gICAgKHJldCkuX2lzVkxpc3QgPSB0cnVlO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyA8c2xvdD5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU2xvdCAoXG4gIG5hbWUsXG4gIGZhbGxiYWNrLFxuICBwcm9wcyxcbiAgYmluZE9iamVjdFxuKSB7XG4gIHZhciBzY29wZWRTbG90Rm4gPSB0aGlzLiRzY29wZWRTbG90c1tuYW1lXTtcbiAgdmFyIG5vZGVzO1xuICBpZiAoc2NvcGVkU2xvdEZuKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICBpZiAoYmluZE9iamVjdCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWlzT2JqZWN0KGJpbmRPYmplY3QpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ3Nsb3Qgdi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QnLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHByb3BzID0gZXh0ZW5kKGV4dGVuZCh7fSwgYmluZE9iamVjdCksIHByb3BzKTtcbiAgICB9XG4gICAgbm9kZXMgPSBzY29wZWRTbG90Rm4ocHJvcHMpIHx8IGZhbGxiYWNrO1xuICB9IGVsc2Uge1xuICAgIHZhciBzbG90Tm9kZXMgPSB0aGlzLiRzbG90c1tuYW1lXTtcbiAgICAvLyB3YXJuIGR1cGxpY2F0ZSBzbG90IHVzYWdlXG4gICAgaWYgKHNsb3ROb2Rlcykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc2xvdE5vZGVzLl9yZW5kZXJlZCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiRHVwbGljYXRlIHByZXNlbmNlIG9mIHNsb3QgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBmb3VuZCBpbiB0aGUgc2FtZSByZW5kZXIgdHJlZSBcIiArXG4gICAgICAgICAgXCItIHRoaXMgd2lsbCBsaWtlbHkgY2F1c2UgcmVuZGVyIGVycm9ycy5cIixcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBzbG90Tm9kZXMuX3JlbmRlcmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgbm9kZXMgPSBzbG90Tm9kZXMgfHwgZmFsbGJhY2s7XG4gIH1cblxuICB2YXIgdGFyZ2V0ID0gcHJvcHMgJiYgcHJvcHMuc2xvdDtcbiAgaWYgKHRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScsIHsgc2xvdDogdGFyZ2V0IH0sIG5vZGVzKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBub2Rlc1xuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgZmlsdGVyc1xuICovXG5mdW5jdGlvbiByZXNvbHZlRmlsdGVyIChpZCkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgaWQsIHRydWUpIHx8IGlkZW50aXR5XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpc0tleU5vdE1hdGNoIChleHBlY3QsIGFjdHVhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3QpKSB7XG4gICAgcmV0dXJuIGV4cGVjdC5pbmRleE9mKGFjdHVhbCkgPT09IC0xXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGV4cGVjdCAhPT0gYWN0dWFsXG4gIH1cbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXG4gKiBleHBvc2VkIGFzIFZ1ZS5wcm90b3R5cGUuX2tcbiAqIHBhc3NpbmcgaW4gZXZlbnRLZXlOYW1lIGFzIGxhc3QgYXJndW1lbnQgc2VwYXJhdGVseSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICovXG5mdW5jdGlvbiBjaGVja0tleUNvZGVzIChcbiAgZXZlbnRLZXlDb2RlLFxuICBrZXksXG4gIGJ1aWx0SW5LZXlDb2RlLFxuICBldmVudEtleU5hbWUsXG4gIGJ1aWx0SW5LZXlOYW1lXG4pIHtcbiAgdmFyIG1hcHBlZEtleUNvZGUgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluS2V5Q29kZTtcbiAgaWYgKGJ1aWx0SW5LZXlOYW1lICYmIGV2ZW50S2V5TmFtZSAmJiAhY29uZmlnLmtleUNvZGVzW2tleV0pIHtcbiAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChidWlsdEluS2V5TmFtZSwgZXZlbnRLZXlOYW1lKVxuICB9IGVsc2UgaWYgKG1hcHBlZEtleUNvZGUpIHtcbiAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChtYXBwZWRLZXlDb2RlLCBldmVudEtleUNvZGUpXG4gIH0gZWxzZSBpZiAoZXZlbnRLZXlOYW1lKSB7XG4gICAgcmV0dXJuIGh5cGhlbmF0ZShldmVudEtleU5hbWUpICE9PSBrZXlcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgbWVyZ2luZyB2LWJpbmQ9XCJvYmplY3RcIiBpbnRvIGEgVk5vZGUncyBkYXRhLlxuICovXG5mdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMgKFxuICBkYXRhLFxuICB0YWcsXG4gIHZhbHVlLFxuICBhc1Byb3AsXG4gIGlzU3luY1xuKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCBvciBBcnJheSB2YWx1ZScsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHRvT2JqZWN0KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHZhciBoYXNoO1xuICAgICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSA9PT0gJ2NsYXNzJyB8fFxuICAgICAgICAgIGtleSA9PT0gJ3N0eWxlJyB8fFxuICAgICAgICAgIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoa2V5KVxuICAgICAgICApIHtcbiAgICAgICAgICBoYXNoID0gZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy50eXBlO1xuICAgICAgICAgIGhhc2ggPSBhc1Byb3AgfHwgY29uZmlnLm11c3RVc2VQcm9wKHRhZywgdHlwZSwga2V5KVxuICAgICAgICAgICAgPyBkYXRhLmRvbVByb3BzIHx8IChkYXRhLmRvbVByb3BzID0ge30pXG4gICAgICAgICAgICA6IGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoa2V5IGluIGhhc2gpKSB7XG4gICAgICAgICAgaGFzaFtrZXldID0gdmFsdWVba2V5XTtcblxuICAgICAgICAgIGlmIChpc1N5bmMpIHtcbiAgICAgICAgICAgIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gICAgICAgICAgICBvblsoXCJ1cGRhdGU6XCIgKyBrZXkpXSA9IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgICAgdmFsdWVba2V5XSA9ICRldmVudDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIGxvb3AoIGtleSApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHN0YXRpYyB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU3RhdGljIChcbiAgaW5kZXgsXG4gIGlzSW5Gb3Jcbikge1xuICB2YXIgY2FjaGVkID0gdGhpcy5fc3RhdGljVHJlZXMgfHwgKHRoaXMuX3N0YXRpY1RyZWVzID0gW10pO1xuICB2YXIgdHJlZSA9IGNhY2hlZFtpbmRleF07XG4gIC8vIGlmIGhhcyBhbHJlYWR5LXJlbmRlcmVkIHN0YXRpYyB0cmVlIGFuZCBub3QgaW5zaWRlIHYtZm9yLFxuICAvLyB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdHJlZS5cbiAgaWYgKHRyZWUgJiYgIWlzSW5Gb3IpIHtcbiAgICByZXR1cm4gdHJlZVxuICB9XG4gIC8vIG90aGVyd2lzZSwgcmVuZGVyIGEgZnJlc2ggdHJlZS5cbiAgdHJlZSA9IGNhY2hlZFtpbmRleF0gPSB0aGlzLiRvcHRpb25zLnN0YXRpY1JlbmRlckZuc1tpbmRleF0uY2FsbChcbiAgICB0aGlzLl9yZW5kZXJQcm94eSxcbiAgICBudWxsLFxuICAgIHRoaXMgLy8gZm9yIHJlbmRlciBmbnMgZ2VuZXJhdGVkIGZvciBmdW5jdGlvbmFsIGNvbXBvbmVudCB0ZW1wbGF0ZXNcbiAgKTtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX3N0YXRpY19fXCIgKyBpbmRleCksIGZhbHNlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3Igdi1vbmNlLlxuICogRWZmZWN0aXZlbHkgaXQgbWVhbnMgbWFya2luZyB0aGUgbm9kZSBhcyBzdGF0aWMgd2l0aCBhIHVuaXF1ZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIG1hcmtPbmNlIChcbiAgdHJlZSxcbiAgaW5kZXgsXG4gIGtleVxuKSB7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19vbmNlX19cIiArIGluZGV4ICsgKGtleSA/IChcIl9cIiArIGtleSkgOiBcIlwiKSksIHRydWUpO1xuICByZXR1cm4gdHJlZVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljIChcbiAgdHJlZSxcbiAga2V5LFxuICBpc09uY2Vcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0cmVlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRyZWVbaV0gJiYgdHlwZW9mIHRyZWVbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWVbaV0sIChrZXkgKyBcIl9cIiArIGkpLCBpc09uY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtYXJrU3RhdGljTm9kZSh0cmVlLCBrZXksIGlzT25jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY05vZGUgKG5vZGUsIGtleSwgaXNPbmNlKSB7XG4gIG5vZGUuaXNTdGF0aWMgPSB0cnVlO1xuICBub2RlLmtleSA9IGtleTtcbiAgbm9kZS5pc09uY2UgPSBpc09uY2U7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kT2JqZWN0TGlzdGVuZXJzIChkYXRhLCB2YWx1ZSkge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LW9uIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb24gPSBkYXRhLm9uID0gZGF0YS5vbiA/IGV4dGVuZCh7fSwgZGF0YS5vbikgOiB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSBvbltrZXldO1xuICAgICAgICB2YXIgb3VycyA9IHZhbHVlW2tleV07XG4gICAgICAgIG9uW2tleV0gPSBleGlzdGluZyA/IFtdLmNvbmNhdChleGlzdGluZywgb3VycykgOiBvdXJzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5zdGFsbFJlbmRlckhlbHBlcnMgKHRhcmdldCkge1xuICB0YXJnZXQuX28gPSBtYXJrT25jZTtcbiAgdGFyZ2V0Ll9uID0gdG9OdW1iZXI7XG4gIHRhcmdldC5fcyA9IHRvU3RyaW5nO1xuICB0YXJnZXQuX2wgPSByZW5kZXJMaXN0O1xuICB0YXJnZXQuX3QgPSByZW5kZXJTbG90O1xuICB0YXJnZXQuX3EgPSBsb29zZUVxdWFsO1xuICB0YXJnZXQuX2kgPSBsb29zZUluZGV4T2Y7XG4gIHRhcmdldC5fbSA9IHJlbmRlclN0YXRpYztcbiAgdGFyZ2V0Ll9mID0gcmVzb2x2ZUZpbHRlcjtcbiAgdGFyZ2V0Ll9rID0gY2hlY2tLZXlDb2RlcztcbiAgdGFyZ2V0Ll9iID0gYmluZE9iamVjdFByb3BzO1xuICB0YXJnZXQuX3YgPSBjcmVhdGVUZXh0Vk5vZGU7XG4gIHRhcmdldC5fZSA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gIHRhcmdldC5fdSA9IHJlc29sdmVTY29wZWRTbG90cztcbiAgdGFyZ2V0Ll9nID0gYmluZE9iamVjdExpc3RlbmVycztcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IChcbiAgZGF0YSxcbiAgcHJvcHMsXG4gIGNoaWxkcmVuLFxuICBwYXJlbnQsXG4gIEN0b3Jcbikge1xuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgLy8gZW5zdXJlIHRoZSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9uIGluIGZ1bmN0aW9uYWwgY29tcG9uZW50c1xuICAvLyBnZXRzIGEgdW5pcXVlIGNvbnRleHQgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29ycmVjdCBuYW1lZCBzbG90IGNoZWNrXG4gIHZhciBjb250ZXh0Vm07XG4gIGlmIChoYXNPd24ocGFyZW50LCAnX3VpZCcpKSB7XG4gICAgY29udGV4dFZtID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQpO1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIGNvbnRleHRWbS5fb3JpZ2luYWwgPSBwYXJlbnQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNvbnRleHQgdm0gcGFzc2VkIGluIGlzIGEgZnVuY3Rpb25hbCBjb250ZXh0IGFzIHdlbGwuXG4gICAgLy8gaW4gdGhpcyBjYXNlIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIGFyZSBhYmxlIHRvIGdldCBhIGhvbGQgdG8gdGhlXG4gICAgLy8gcmVhbCBjb250ZXh0IGluc3RhbmNlLlxuICAgIGNvbnRleHRWbSA9IHBhcmVudDtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBwYXJlbnQgPSBwYXJlbnQuX29yaWdpbmFsO1xuICB9XG4gIHZhciBpc0NvbXBpbGVkID0gaXNUcnVlKG9wdGlvbnMuX2NvbXBpbGVkKTtcbiAgdmFyIG5lZWROb3JtYWxpemF0aW9uID0gIWlzQ29tcGlsZWQ7XG5cbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB0aGlzLmxpc3RlbmVycyA9IGRhdGEub24gfHwgZW1wdHlPYmplY3Q7XG4gIHRoaXMuaW5qZWN0aW9ucyA9IHJlc29sdmVJbmplY3Qob3B0aW9ucy5pbmplY3QsIHBhcmVudCk7XG4gIHRoaXMuc2xvdHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIHBhcmVudCk7IH07XG5cbiAgLy8gc3VwcG9ydCBmb3IgY29tcGlsZWQgZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoaXNDb21waWxlZCkge1xuICAgIC8vIGV4cG9zaW5nICRvcHRpb25zIGZvciByZW5kZXJTdGF0aWMoKVxuICAgIHRoaXMuJG9wdGlvbnMgPSBvcHRpb25zO1xuICAgIC8vIHByZS1yZXNvbHZlIHNsb3RzIGZvciByZW5kZXJTbG90KClcbiAgICB0aGlzLiRzbG90cyA9IHRoaXMuc2xvdHMoKTtcbiAgICB0aGlzLiRzY29wZWRTbG90cyA9IGRhdGEuc2NvcGVkU2xvdHMgfHwgZW1wdHlPYmplY3Q7XG4gIH1cblxuICBpZiAob3B0aW9ucy5fc2NvcGVJZCkge1xuICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgICAgdmFyIHZub2RlID0gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTtcbiAgICAgIGlmICh2bm9kZSAmJiAhQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgdm5vZGUuZm5TY29wZUlkID0gb3B0aW9ucy5fc2NvcGVJZDtcbiAgICAgICAgdm5vZGUuZm5Db250ZXh0ID0gcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZub2RlXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7IH07XG4gIH1cbn1cblxuaW5zdGFsbFJlbmRlckhlbHBlcnMoRnVuY3Rpb25hbFJlbmRlckNvbnRleHQucHJvdG90eXBlKTtcblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCAoXG4gIEN0b3IsXG4gIHByb3BzRGF0YSxcbiAgZGF0YSxcbiAgY29udGV4dFZtLFxuICBjaGlsZHJlblxuKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIHByb3BPcHRpb25zID0gb3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzRGVmKHByb3BPcHRpb25zKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEgfHwgZW1wdHlPYmplY3QpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNEZWYoZGF0YS5hdHRycykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5hdHRycyk7IH1cbiAgICBpZiAoaXNEZWYoZGF0YS5wcm9wcykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5wcm9wcyk7IH1cbiAgfVxuXG4gIHZhciByZW5kZXJDb250ZXh0ID0gbmV3IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0KFxuICAgIGRhdGEsXG4gICAgcHJvcHMsXG4gICAgY2hpbGRyZW4sXG4gICAgY29udGV4dFZtLFxuICAgIEN0b3JcbiAgKTtcblxuICB2YXIgdm5vZGUgPSBvcHRpb25zLnJlbmRlci5jYWxsKG51bGwsIHJlbmRlckNvbnRleHQuX2MsIHJlbmRlckNvbnRleHQpO1xuXG4gIGlmICh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuIGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGUsIGRhdGEsIHJlbmRlckNvbnRleHQucGFyZW50LCBvcHRpb25zKVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgdmFyIHZub2RlcyA9IG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlKSB8fCBbXTtcbiAgICB2YXIgcmVzID0gbmV3IEFycmF5KHZub2Rlcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXNbaV0gPSBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0KHZub2Rlc1tpXSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuZnVuY3Rpb24gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCAodm5vZGUsIGRhdGEsIGNvbnRleHRWbSwgb3B0aW9ucykge1xuICAvLyAjNzgxNyBjbG9uZSBub2RlIGJlZm9yZSBzZXR0aW5nIGZuQ29udGV4dCwgb3RoZXJ3aXNlIGlmIHRoZSBub2RlIGlzIHJldXNlZFxuICAvLyAoZS5nLiBpdCB3YXMgZnJvbSBhIGNhY2hlZCBub3JtYWwgc2xvdCkgdGhlIGZuQ29udGV4dCBjYXVzZXMgbmFtZWQgc2xvdHNcbiAgLy8gdGhhdCBzaG91bGQgbm90IGJlIG1hdGNoZWQgdG8gbWF0Y2guXG4gIHZhciBjbG9uZSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICBjbG9uZS5mbkNvbnRleHQgPSBjb250ZXh0Vm07XG4gIGNsb25lLmZuT3B0aW9ucyA9IG9wdGlvbnM7XG4gIGlmIChkYXRhLnNsb3QpIHtcbiAgICAoY2xvbmUuZGF0YSB8fCAoY2xvbmUuZGF0YSA9IHt9KSkuc2xvdCA9IGRhdGEuc2xvdDtcbiAgfVxuICByZXR1cm4gY2xvbmVcbn1cblxuZnVuY3Rpb24gbWVyZ2VQcm9wcyAodG8sIGZyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICB0b1tjYW1lbGl6ZShrZXkpXSA9IGZyb21ba2V5XTtcbiAgfVxufVxuXG4vKiAgKi9cblxuXG5cblxuLy8gUmVnaXN0ZXIgdGhlIGNvbXBvbmVudCBob29rIHRvIHdlZXggbmF0aXZlIHJlbmRlciBlbmdpbmUuXG4vLyBUaGUgaG9vayB3aWxsIGJlIHRyaWdnZXJlZCBieSBuYXRpdmUsIG5vdCBqYXZhc2NyaXB0LlxuXG5cbi8vIFVwZGF0ZXMgdGhlIHN0YXRlIG9mIHRoZSBjb21wb25lbnQgdG8gd2VleCBuYXRpdmUgcmVuZGVyIGVuZ2luZS5cblxuLyogICovXG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9IYW5rczEwMTAwL3dlZXgtbmF0aXZlLWRpcmVjdGl2ZS90cmVlL21hc3Rlci9jb21wb25lbnRcblxuLy8gbGlzdGVuaW5nIG9uIG5hdGl2ZSBjYWxsYmFja1xuXG4vKiAgKi9cblxuLyogICovXG5cbi8vIGlubGluZSBob29rcyB0byBiZSBpbnZva2VkIG9uIGNvbXBvbmVudCBWTm9kZXMgZHVyaW5nIHBhdGNoXG52YXIgY29tcG9uZW50Vk5vZGVIb29rcyA9IHtcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCAoXG4gICAgdm5vZGUsXG4gICAgaHlkcmF0aW5nLFxuICAgIHBhcmVudEVsbSxcbiAgICByZWZFbG1cbiAgKSB7XG4gICAgaWYgKFxuICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiZcbiAgICAgICF2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQgJiZcbiAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlXG4gICAgKSB7XG4gICAgICAvLyBrZXB0LWFsaXZlIGNvbXBvbmVudHMsIHRyZWF0IGFzIGEgcGF0Y2hcbiAgICAgIHZhciBtb3VudGVkTm9kZSA9IHZub2RlOyAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgICBjb21wb25lbnRWTm9kZUhvb2tzLnByZXBhdGNoKG1vdW50ZWROb2RlLCBtb3VudGVkTm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZShcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIGFjdGl2ZUluc3RhbmNlLFxuICAgICAgICBwYXJlbnRFbG0sXG4gICAgICAgIHJlZkVsbVxuICAgICAgKTtcbiAgICAgIGNoaWxkLiRtb3VudChoeWRyYXRpbmcgPyB2bm9kZS5lbG0gOiB1bmRlZmluZWQsIGh5ZHJhdGluZyk7XG4gICAgfVxuICB9LFxuXG4gIHByZXBhdGNoOiBmdW5jdGlvbiBwcmVwYXRjaCAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgdXBkYXRlQ2hpbGRDb21wb25lbnQoXG4gICAgICBjaGlsZCxcbiAgICAgIG9wdGlvbnMucHJvcHNEYXRhLCAvLyB1cGRhdGVkIHByb3BzXG4gICAgICBvcHRpb25zLmxpc3RlbmVycywgLy8gdXBkYXRlZCBsaXN0ZW5lcnNcbiAgICAgIHZub2RlLCAvLyBuZXcgcGFyZW50IHZub2RlXG4gICAgICBvcHRpb25zLmNoaWxkcmVuIC8vIG5ldyBjaGlsZHJlblxuICAgICk7XG4gIH0sXG5cbiAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQgKHZub2RlKSB7XG4gICAgdmFyIGNvbnRleHQgPSB2bm9kZS5jb250ZXh0O1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCkge1xuICAgICAgY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCA9IHRydWU7XG4gICAgICBjYWxsSG9vayhjb21wb25lbnRJbnN0YW5jZSwgJ21vdW50ZWQnKTtcbiAgICB9XG4gICAgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICBpZiAoY29udGV4dC5faXNNb3VudGVkKSB7XG4gICAgICAgIC8vIHZ1ZS1yb3V0ZXIjMTIxMlxuICAgICAgICAvLyBEdXJpbmcgdXBkYXRlcywgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCdzIGNoaWxkIGNvbXBvbmVudHMgbWF5XG4gICAgICAgIC8vIGNoYW5nZSwgc28gZGlyZWN0bHkgd2Fsa2luZyB0aGUgdHJlZSBoZXJlIG1heSBjYWxsIGFjdGl2YXRlZCBob29rc1xuICAgICAgICAvLyBvbiBpbmNvcnJlY3QgY2hpbGRyZW4uIEluc3RlYWQgd2UgcHVzaCB0aGVtIGludG8gYSBxdWV1ZSB3aGljaCB3aWxsXG4gICAgICAgIC8vIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgd2hvbGUgcGF0Y2ggcHJvY2VzcyBlbmRlZC5cbiAgICAgICAgcXVldWVBY3RpdmF0ZWRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICBpZiAoIXZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAgIGNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBob29rc1RvTWVyZ2UgPSBPYmplY3Qua2V5cyhjb21wb25lbnRWTm9kZUhvb2tzKTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIGlmIChpc1VuZGVmKEN0b3IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgYmFzZUN0b3IgPSBjb250ZXh0LiRvcHRpb25zLl9iYXNlO1xuXG4gIC8vIHBsYWluIG9wdGlvbnMgb2JqZWN0OiB0dXJuIGl0IGludG8gYSBjb25zdHJ1Y3RvclxuICBpZiAoaXNPYmplY3QoQ3RvcikpIHtcbiAgICBDdG9yID0gYmFzZUN0b3IuZXh0ZW5kKEN0b3IpO1xuICB9XG5cbiAgLy8gaWYgYXQgdGhpcyBzdGFnZSBpdCdzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIGFuIGFzeW5jIGNvbXBvbmVudCBmYWN0b3J5LFxuICAvLyByZWplY3QuXG4gIGlmICh0eXBlb2YgQ3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKChcIkludmFsaWQgQ29tcG9uZW50IGRlZmluaXRpb246IFwiICsgKFN0cmluZyhDdG9yKSkpLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBhc3luYyBjb21wb25lbnRcbiAgdmFyIGFzeW5jRmFjdG9yeTtcbiAgaWYgKGlzVW5kZWYoQ3Rvci5jaWQpKSB7XG4gICAgYXN5bmNGYWN0b3J5ID0gQ3RvcjtcbiAgICBDdG9yID0gcmVzb2x2ZUFzeW5jQ29tcG9uZW50KGFzeW5jRmFjdG9yeSwgYmFzZUN0b3IsIGNvbnRleHQpO1xuICAgIGlmIChDdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIG5vZGUgZm9yIGFzeW5jIGNvbXBvbmVudCwgd2hpY2ggaXMgcmVuZGVyZWRcbiAgICAgIC8vIGFzIGEgY29tbWVudCBub2RlIGJ1dCBwcmVzZXJ2ZXMgYWxsIHRoZSByYXcgaW5mb3JtYXRpb24gZm9yIHRoZSBub2RlLlxuICAgICAgLy8gdGhlIGluZm9ybWF0aW9uIHdpbGwgYmUgdXNlZCBmb3IgYXN5bmMgc2VydmVyLXJlbmRlcmluZyBhbmQgaHlkcmF0aW9uLlxuICAgICAgcmV0dXJuIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIoXG4gICAgICAgIGFzeW5jRmFjdG9yeSxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHRhZ1xuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGRhdGEgPSBkYXRhIHx8IHt9O1xuXG4gIC8vIHJlc29sdmUgY29uc3RydWN0b3Igb3B0aW9ucyBpbiBjYXNlIGdsb2JhbCBtaXhpbnMgYXJlIGFwcGxpZWQgYWZ0ZXJcbiAgLy8gY29tcG9uZW50IGNvbnN0cnVjdG9yIGNyZWF0aW9uXG4gIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvcik7XG5cbiAgLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGRhdGEgaW50byBwcm9wcyAmIGV2ZW50c1xuICBpZiAoaXNEZWYoZGF0YS5tb2RlbCkpIHtcbiAgICB0cmFuc2Zvcm1Nb2RlbChDdG9yLm9wdGlvbnMsIGRhdGEpO1xuICB9XG5cbiAgLy8gZXh0cmFjdCBwcm9wc1xuICB2YXIgcHJvcHNEYXRhID0gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YShkYXRhLCBDdG9yLCB0YWcpO1xuXG4gIC8vIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmZ1bmN0aW9uYWwpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoQ3RvciwgcHJvcHNEYXRhLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbilcbiAgfVxuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzLCBzaW5jZSB0aGVzZSBuZWVkcyB0byBiZSB0cmVhdGVkIGFzXG4gIC8vIGNoaWxkIGNvbXBvbmVudCBsaXN0ZW5lcnMgaW5zdGVhZCBvZiBET00gbGlzdGVuZXJzXG4gIHZhciBsaXN0ZW5lcnMgPSBkYXRhLm9uO1xuICAvLyByZXBsYWNlIHdpdGggbGlzdGVuZXJzIHdpdGggLm5hdGl2ZSBtb2RpZmllclxuICAvLyBzbyBpdCBnZXRzIHByb2Nlc3NlZCBkdXJpbmcgcGFyZW50IGNvbXBvbmVudCBwYXRjaC5cbiAgZGF0YS5vbiA9IGRhdGEubmF0aXZlT247XG5cbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuYWJzdHJhY3QpKSB7XG4gICAgLy8gYWJzdHJhY3QgY29tcG9uZW50cyBkbyBub3Qga2VlcCBhbnl0aGluZ1xuICAgIC8vIG90aGVyIHRoYW4gcHJvcHMgJiBsaXN0ZW5lcnMgJiBzbG90XG5cbiAgICAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgdmFyIHNsb3QgPSBkYXRhLnNsb3Q7XG4gICAgZGF0YSA9IHt9O1xuICAgIGlmIChzbG90KSB7XG4gICAgICBkYXRhLnNsb3QgPSBzbG90O1xuICAgIH1cbiAgfVxuXG4gIC8vIGluc3RhbGwgY29tcG9uZW50IG1hbmFnZW1lbnQgaG9va3Mgb250byB0aGUgcGxhY2Vob2xkZXIgbm9kZVxuICBpbnN0YWxsQ29tcG9uZW50SG9va3MoZGF0YSk7XG5cbiAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgdm5vZGVcbiAgdmFyIG5hbWUgPSBDdG9yLm9wdGlvbnMubmFtZSB8fCB0YWc7XG4gIHZhciB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAoXCJ2dWUtY29tcG9uZW50LVwiICsgKEN0b3IuY2lkKSArIChuYW1lID8gKFwiLVwiICsgbmFtZSkgOiAnJykpLFxuICAgIGRhdGEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHQsXG4gICAgeyBDdG9yOiBDdG9yLCBwcm9wc0RhdGE6IHByb3BzRGF0YSwgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsIHRhZzogdGFnLCBjaGlsZHJlbjogY2hpbGRyZW4gfSxcbiAgICBhc3luY0ZhY3RvcnlcbiAgKTtcblxuICAvLyBXZWV4IHNwZWNpZmljOiBpbnZva2UgcmVjeWNsZS1saXN0IG9wdGltaXplZCBAcmVuZGVyIGZ1bmN0aW9uIGZvclxuICAvLyBleHRyYWN0aW5nIGNlbGwtc2xvdCB0ZW1wbGF0ZS5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0hhbmtzMTAxMDAvd2VleC1uYXRpdmUtZGlyZWN0aXZlL3RyZWUvbWFzdGVyL2NvbXBvbmVudFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUgKFxuICB2bm9kZSwgLy8gd2Uga25vdyBpdCdzIE1vdW50ZWRDb21wb25lbnRWTm9kZSBidXQgZmxvdyBkb2Vzbid0XG4gIHBhcmVudCwgLy8gYWN0aXZlSW5zdGFuY2UgaW4gbGlmZWN5Y2xlIHN0YXRlXG4gIHBhcmVudEVsbSxcbiAgcmVmRWxtXG4pIHtcbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgX2lzQ29tcG9uZW50OiB0cnVlLFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIF9wYXJlbnRWbm9kZTogdm5vZGUsXG4gICAgX3BhcmVudEVsbTogcGFyZW50RWxtIHx8IG51bGwsXG4gICAgX3JlZkVsbTogcmVmRWxtIHx8IG51bGxcbiAgfTtcbiAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlIHJlbmRlciBmdW5jdGlvbnNcbiAgdmFyIGlubGluZVRlbXBsYXRlID0gdm5vZGUuZGF0YS5pbmxpbmVUZW1wbGF0ZTtcbiAgaWYgKGlzRGVmKGlubGluZVRlbXBsYXRlKSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gaW5saW5lVGVtcGxhdGUucmVuZGVyO1xuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gaW5saW5lVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zO1xuICB9XG4gIHJldHVybiBuZXcgdm5vZGUuY29tcG9uZW50T3B0aW9ucy5DdG9yKG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIGluc3RhbGxDb21wb25lbnRIb29rcyAoZGF0YSkge1xuICB2YXIgaG9va3MgPSBkYXRhLmhvb2sgfHwgKGRhdGEuaG9vayA9IHt9KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rc1RvTWVyZ2UubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gaG9va3NUb01lcmdlW2ldO1xuICAgIGhvb2tzW2tleV0gPSBjb21wb25lbnRWTm9kZUhvb2tzW2tleV07XG4gIH1cbn1cblxuLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGluZm8gKHZhbHVlIGFuZCBjYWxsYmFjaykgaW50b1xuLy8gcHJvcCBhbmQgZXZlbnQgaGFuZGxlciByZXNwZWN0aXZlbHkuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Nb2RlbCAob3B0aW9ucywgZGF0YSkge1xuICB2YXIgcHJvcCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwucHJvcCkgfHwgJ3ZhbHVlJztcbiAgdmFyIGV2ZW50ID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5ldmVudCkgfHwgJ2lucHV0JzsoZGF0YS5wcm9wcyB8fCAoZGF0YS5wcm9wcyA9IHt9KSlbcHJvcF0gPSBkYXRhLm1vZGVsLnZhbHVlO1xuICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICBpZiAoaXNEZWYob25bZXZlbnRdKSkge1xuICAgIG9uW2V2ZW50XSA9IFtkYXRhLm1vZGVsLmNhbGxiYWNrXS5jb25jYXQob25bZXZlbnRdKTtcbiAgfSBlbHNlIHtcbiAgICBvbltldmVudF0gPSBkYXRhLm1vZGVsLmNhbGxiYWNrO1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgU0lNUExFX05PUk1BTElaRSA9IDE7XG52YXIgQUxXQVlTX05PUk1BTElaRSA9IDI7XG5cbi8vIHdyYXBwZXIgZnVuY3Rpb24gZm9yIHByb3ZpZGluZyBhIG1vcmUgZmxleGlibGUgaW50ZXJmYWNlXG4vLyB3aXRob3V0IGdldHRpbmcgeWVsbGVkIGF0IGJ5IGZsb3dcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZSxcbiAgYWx3YXlzTm9ybWFsaXplXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgaXNQcmltaXRpdmUoZGF0YSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IGNoaWxkcmVuO1xuICAgIGNoaWxkcmVuID0gZGF0YTtcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChpc1RydWUoYWx3YXlzTm9ybWFsaXplKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gQUxXQVlTX05PUk1BTElaRTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUVsZW1lbnQoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUpXG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGVcbikge1xuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoKGRhdGEpLl9fb2JfXykpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIkF2b2lkIHVzaW5nIG9ic2VydmVkIGRhdGEgb2JqZWN0IGFzIHZub2RlIGRhdGE6IFwiICsgKEpTT04uc3RyaW5naWZ5KGRhdGEpKSArIFwiXFxuXCIgK1xuICAgICAgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gb2JqZWN0IHN5bnRheCBpbiB2LWJpbmRcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEuaXMpKSB7XG4gICAgdGFnID0gZGF0YS5pcztcbiAgfVxuICBpZiAoIXRhZykge1xuICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1wcmltaXRpdmUga2V5XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5rZXkpICYmICFpc1ByaW1pdGl2ZShkYXRhLmtleSlcbiAgKSB7XG4gICAge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIHVzaW5nIG5vbi1wcmltaXRpdmUgdmFsdWUgYXMga2V5LCAnICtcbiAgICAgICAgJ3VzZSBzdHJpbmcvbnVtYmVyIHZhbHVlIGluc3RlYWQuJyxcbiAgICAgICAgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiZcbiAgICB0eXBlb2YgY2hpbGRyZW5bMF0gPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgZGF0YS5zY29wZWRTbG90cyA9IHsgZGVmYXVsdDogY2hpbGRyZW5bMF0gfTtcbiAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICB9XG4gIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gQUxXQVlTX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9IGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH1cbiAgdmFyIHZub2RlLCBucztcbiAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIEN0b3I7XG4gICAgbnMgPSAoY29udGV4dC4kdm5vZGUgJiYgY29udGV4dC4kdm5vZGUubnMpIHx8IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcbiAgICBpZiAoY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgLy8gcGxhdGZvcm0gYnVpbHQtaW4gZWxlbWVudHNcbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICBjb25maWcucGFyc2VQbGF0Zm9ybVRhZ05hbWUodGFnKSwgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNEZWYoQ3RvciA9IHJlc29sdmVBc3NldChjb250ZXh0LiRvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpKSB7XG4gICAgICAvLyBjb21wb25lbnRcbiAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcbiAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIHRhZywgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgIHJldHVybiB2bm9kZVxuICB9IGVsc2UgaWYgKGlzRGVmKHZub2RlKSkge1xuICAgIGlmIChpc0RlZihucykpIHsgYXBwbHlOUyh2bm9kZSwgbnMpOyB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7IHJlZ2lzdGVyRGVlcEJpbmRpbmdzKGRhdGEpOyB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucywgZm9yY2UpIHtcbiAgdm5vZGUubnMgPSBucztcbiAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG4gICAgbnMgPSB1bmRlZmluZWQ7XG4gICAgZm9yY2UgPSB0cnVlO1xuICB9XG4gIGlmIChpc0RlZih2bm9kZS5jaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoY2hpbGQudGFnKSAmJiAoXG4gICAgICAgIGlzVW5kZWYoY2hpbGQubnMpIHx8IChpc1RydWUoZm9yY2UpICYmIGNoaWxkLnRhZyAhPT0gJ3N2ZycpKSkge1xuICAgICAgICBhcHBseU5TKGNoaWxkLCBucywgZm9yY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyByZWYgIzUzMThcbi8vIG5lY2Vzc2FyeSB0byBlbnN1cmUgcGFyZW50IHJlLXJlbmRlciB3aGVuIGRlZXAgYmluZGluZ3MgbGlrZSA6c3R5bGUgYW5kXG4vLyA6Y2xhc3MgYXJlIHVzZWQgb24gc2xvdCBub2Rlc1xuZnVuY3Rpb24gcmVnaXN0ZXJEZWVwQmluZGluZ3MgKGRhdGEpIHtcbiAgaWYgKGlzT2JqZWN0KGRhdGEuc3R5bGUpKSB7XG4gICAgdHJhdmVyc2UoZGF0YS5zdHlsZSk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KGRhdGEuY2xhc3MpKSB7XG4gICAgdHJhdmVyc2UoZGF0YS5jbGFzcyk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRSZW5kZXIgKHZtKSB7XG4gIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXG4gIHZtLl9zdGF0aWNUcmVlcyA9IG51bGw7IC8vIHYtb25jZSBjYWNoZWQgdHJlZXNcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgdmFyIHBhcmVudFZub2RlID0gdm0uJHZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gIHZhciByZW5kZXJDb250ZXh0ID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuY29udGV4dDtcbiAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLCByZW5kZXJDb250ZXh0KTtcbiAgdm0uJHNjb3BlZFNsb3RzID0gZW1wdHlPYmplY3Q7XG4gIC8vIGJpbmQgdGhlIGNyZWF0ZUVsZW1lbnQgZm4gdG8gdGhpcyBpbnN0YW5jZVxuICAvLyBzbyB0aGF0IHdlIGdldCBwcm9wZXIgcmVuZGVyIGNvbnRleHQgaW5zaWRlIGl0LlxuICAvLyBhcmdzIG9yZGVyOiB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplXG4gIC8vIGludGVybmFsIHZlcnNpb24gaXMgdXNlZCBieSByZW5kZXIgZnVuY3Rpb25zIGNvbXBpbGVkIGZyb20gdGVtcGxhdGVzXG4gIHZtLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIGZhbHNlKTsgfTtcbiAgLy8gbm9ybWFsaXphdGlvbiBpcyBhbHdheXMgYXBwbGllZCBmb3IgdGhlIHB1YmxpYyB2ZXJzaW9uLCB1c2VkIGluXG4gIC8vIHVzZXItd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zLlxuICB2bS4kY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcblxuICAvLyAkYXR0cnMgJiAkbGlzdGVuZXJzIGFyZSBleHBvc2VkIGZvciBlYXNpZXIgSE9DIGNyZWF0aW9uLlxuICAvLyB0aGV5IG5lZWQgdG8gYmUgcmVhY3RpdmUgc28gdGhhdCBIT0NzIHVzaW5nIHRoZW0gYXJlIGFsd2F5cyB1cGRhdGVkXG4gIHZhciBwYXJlbnREYXRhID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuZGF0YTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRlZmluZVJlYWN0aXZlKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oXCIkYXR0cnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcbiAgICB9LCB0cnVlKTtcbiAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgJyRsaXN0ZW5lcnMnLCBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRsaXN0ZW5lcnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcbiAgICB9LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgJyRhdHRycycsIHBhcmVudERhdGEgJiYgcGFyZW50RGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdCwgbnVsbCwgdHJ1ZSk7XG4gICAgZGVmaW5lUmVhY3RpdmUodm0sICckbGlzdGVuZXJzJywgb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCBudWxsLCB0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJNaXhpbiAoVnVlKSB7XG4gIC8vIGluc3RhbGwgcnVudGltZSBjb252ZW5pZW5jZSBoZWxwZXJzXG4gIGluc3RhbGxSZW5kZXJIZWxwZXJzKFZ1ZS5wcm90b3R5cGUpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciByZWYgPSB2bS4kb3B0aW9ucztcbiAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICB2YXIgX3BhcmVudFZub2RlID0gcmVmLl9wYXJlbnRWbm9kZTtcblxuICAgIC8vIHJlc2V0IF9yZW5kZXJlZCBmbGFnIG9uIHNsb3RzIGZvciBkdXBsaWNhdGUgc2xvdCBjaGVja1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdm0uJHNsb3RzKSB7XG4gICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICB2bS4kc2xvdHNba2V5XS5fcmVuZGVyZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoX3BhcmVudFZub2RlKSB7XG4gICAgICB2bS4kc2NvcGVkU2xvdHMgPSBfcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cyB8fCBlbXB0eU9iamVjdDtcbiAgICB9XG5cbiAgICAvLyBzZXQgcGFyZW50IHZub2RlLiB0aGlzIGFsbG93cyByZW5kZXIgZnVuY3Rpb25zIHRvIGhhdmUgYWNjZXNzXG4gICAgLy8gdG8gdGhlIGRhdGEgb24gdGhlIHBsYWNlaG9sZGVyIG5vZGUuXG4gICAgdm0uJHZub2RlID0gX3BhcmVudFZub2RlO1xuICAgIC8vIHJlbmRlciBzZWxmXG4gICAgdmFyIHZub2RlO1xuICAgIHRyeSB7XG4gICAgICB2bm9kZSA9IHJlbmRlci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlclwiKTtcbiAgICAgIC8vIHJldHVybiBlcnJvciByZW5kZXIgcmVzdWx0LFxuICAgICAgLy8gb3IgcHJldmlvdXMgdm5vZGUgdG8gcHJldmVudCByZW5kZXIgZXJyb3IgY2F1c2luZyBibGFuayBjb21wb25lbnRcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodm0uJG9wdGlvbnMucmVuZGVyRXJyb3IpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdm5vZGUgPSB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlckVycm9yXCIpO1xuICAgICAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcmV0dXJuIGVtcHR5IHZub2RlIGluIGNhc2UgdGhlIHJlbmRlciBmdW5jdGlvbiBlcnJvcmVkIG91dFxuICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXG4gICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50XG4gICAgdm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xuICAgIHJldHVybiB2bm9kZVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIHVpZCQzID0gMDtcblxuZnVuY3Rpb24gaW5pdE1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhIHVpZFxuICAgIHZtLl91aWQgPSB1aWQkMysrO1xuXG4gICAgdmFyIHN0YXJ0VGFnLCBlbmRUYWc7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArICh2bS5fdWlkKTtcbiAgICAgIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgKHZtLl91aWQpO1xuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgfVxuXG4gICAgLy8gYSBmbGFnIHRvIGF2b2lkIHRoaXMgYmVpbmcgb2JzZXJ2ZWRcbiAgICB2bS5faXNWdWUgPSB0cnVlO1xuICAgIC8vIG1lcmdlIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9pc0NvbXBvbmVudCkge1xuICAgICAgLy8gb3B0aW1pemUgaW50ZXJuYWwgY29tcG9uZW50IGluc3RhbnRpYXRpb25cbiAgICAgIC8vIHNpbmNlIGR5bmFtaWMgb3B0aW9ucyBtZXJnaW5nIGlzIHByZXR0eSBzbG93LCBhbmQgbm9uZSBvZiB0aGVcbiAgICAgIC8vIGludGVybmFsIGNvbXBvbmVudCBvcHRpb25zIG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50LlxuICAgICAgaW5pdEludGVybmFsQ29tcG9uZW50KHZtLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICAgIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnModm0uY29uc3RydWN0b3IpLFxuICAgICAgICBvcHRpb25zIHx8IHt9LFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaW5pdFByb3h5KHZtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICAgIC8vIGV4cG9zZSByZWFsIHNlbGZcbiAgICB2bS5fc2VsZiA9IHZtO1xuICAgIGluaXRMaWZlY3ljbGUodm0pO1xuICAgIGluaXRFdmVudHModm0pO1xuICAgIGluaXRSZW5kZXIodm0pO1xuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlQ3JlYXRlJyk7XG4gICAgaW5pdEluamVjdGlvbnModm0pOyAvLyByZXNvbHZlIGluamVjdGlvbnMgYmVmb3JlIGRhdGEvcHJvcHNcbiAgICBpbml0U3RhdGUodm0pO1xuICAgIGluaXRQcm92aWRlKHZtKTsgLy8gcmVzb2x2ZSBwcm92aWRlIGFmdGVyIGRhdGEvcHJvcHNcbiAgICBjYWxsSG9vayh2bSwgJ2NyZWF0ZWQnKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICB2bS5fbmFtZSA9IGZvcm1hdENvbXBvbmVudE5hbWUodm0sIGZhbHNlKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgKHZtLl9uYW1lKSArIFwiIGluaXRcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH1cblxuICAgIGlmICh2bS4kb3B0aW9ucy5lbCkge1xuICAgICAgdm0uJG1vdW50KHZtLiRvcHRpb25zLmVsKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRJbnRlcm5hbENvbXBvbmVudCAodm0sIG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUodm0uY29uc3RydWN0b3Iub3B0aW9ucyk7XG4gIC8vIGRvaW5nIHRoaXMgYmVjYXVzZSBpdCdzIGZhc3RlciB0aGFuIGR5bmFtaWMgZW51bWVyYXRpb24uXG4gIHZhciBwYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICBvcHRzLnBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBvcHRzLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuICBvcHRzLl9wYXJlbnRFbG0gPSBvcHRpb25zLl9wYXJlbnRFbG07XG4gIG9wdHMuX3JlZkVsbSA9IG9wdGlvbnMuX3JlZkVsbTtcblxuICB2YXIgdm5vZGVDb21wb25lbnRPcHRpb25zID0gcGFyZW50Vm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgb3B0cy5wcm9wc0RhdGEgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhO1xuICBvcHRzLl9wYXJlbnRMaXN0ZW5lcnMgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzO1xuICBvcHRzLl9yZW5kZXJDaGlsZHJlbiA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbjtcbiAgb3B0cy5fY29tcG9uZW50VGFnID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnRhZztcblxuICBpZiAob3B0aW9ucy5yZW5kZXIpIHtcbiAgICBvcHRzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xuICAgIG9wdHMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgaWYgKEN0b3Iuc3VwZXIpIHtcbiAgICB2YXIgc3VwZXJPcHRpb25zID0gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yLnN1cGVyKTtcbiAgICB2YXIgY2FjaGVkU3VwZXJPcHRpb25zID0gQ3Rvci5zdXBlck9wdGlvbnM7XG4gICAgaWYgKHN1cGVyT3B0aW9ucyAhPT0gY2FjaGVkU3VwZXJPcHRpb25zKSB7XG4gICAgICAvLyBzdXBlciBvcHRpb24gY2hhbmdlZCxcbiAgICAgIC8vIG5lZWQgdG8gcmVzb2x2ZSBuZXcgb3B0aW9ucy5cbiAgICAgIEN0b3Iuc3VwZXJPcHRpb25zID0gc3VwZXJPcHRpb25zO1xuICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBsYXRlLW1vZGlmaWVkL2F0dGFjaGVkIG9wdGlvbnMgKCM0OTc2KVxuICAgICAgdmFyIG1vZGlmaWVkT3B0aW9ucyA9IHJlc29sdmVNb2RpZmllZE9wdGlvbnMoQ3Rvcik7XG4gICAgICAvLyB1cGRhdGUgYmFzZSBleHRlbmQgb3B0aW9uc1xuICAgICAgaWYgKG1vZGlmaWVkT3B0aW9ucykge1xuICAgICAgICBleHRlbmQoQ3Rvci5leHRlbmRPcHRpb25zLCBtb2RpZmllZE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhzdXBlck9wdGlvbnMsIEN0b3IuZXh0ZW5kT3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIG9wdGlvbnMuY29tcG9uZW50c1tvcHRpb25zLm5hbWVdID0gQ3RvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgbW9kaWZpZWQ7XG4gIHZhciBsYXRlc3QgPSBDdG9yLm9wdGlvbnM7XG4gIHZhciBleHRlbmRlZCA9IEN0b3IuZXh0ZW5kT3B0aW9ucztcbiAgdmFyIHNlYWxlZCA9IEN0b3Iuc2VhbGVkT3B0aW9ucztcbiAgZm9yICh2YXIga2V5IGluIGxhdGVzdCkge1xuICAgIGlmIChsYXRlc3Rba2V5XSAhPT0gc2VhbGVkW2tleV0pIHtcbiAgICAgIGlmICghbW9kaWZpZWQpIHsgbW9kaWZpZWQgPSB7fTsgfVxuICAgICAgbW9kaWZpZWRba2V5XSA9IGRlZHVwZShsYXRlc3Rba2V5XSwgZXh0ZW5kZWRba2V5XSwgc2VhbGVkW2tleV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbW9kaWZpZWRcbn1cblxuZnVuY3Rpb24gZGVkdXBlIChsYXRlc3QsIGV4dGVuZGVkLCBzZWFsZWQpIHtcbiAgLy8gY29tcGFyZSBsYXRlc3QgYW5kIHNlYWxlZCB0byBlbnN1cmUgbGlmZWN5Y2xlIGhvb2tzIHdvbid0IGJlIGR1cGxpY2F0ZWRcbiAgLy8gYmV0d2VlbiBtZXJnZXNcbiAgaWYgKEFycmF5LmlzQXJyYXkobGF0ZXN0KSkge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBzZWFsZWQgPSBBcnJheS5pc0FycmF5KHNlYWxlZCkgPyBzZWFsZWQgOiBbc2VhbGVkXTtcbiAgICBleHRlbmRlZCA9IEFycmF5LmlzQXJyYXkoZXh0ZW5kZWQpID8gZXh0ZW5kZWQgOiBbZXh0ZW5kZWRdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF0ZXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBwdXNoIG9yaWdpbmFsIG9wdGlvbnMgYW5kIG5vdCBzZWFsZWQgb3B0aW9ucyB0byBleGNsdWRlIGR1cGxpY2F0ZWQgb3B0aW9uc1xuICAgICAgaWYgKGV4dGVuZGVkLmluZGV4T2YobGF0ZXN0W2ldKSA+PSAwIHx8IHNlYWxlZC5pbmRleE9mKGxhdGVzdFtpXSkgPCAwKSB7XG4gICAgICAgIHJlcy5wdXNoKGxhdGVzdFtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGF0ZXN0XG4gIH1cbn1cblxuZnVuY3Rpb24gVnVlIChvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgISh0aGlzIGluc3RhbmNlb2YgVnVlKVxuICApIHtcbiAgICB3YXJuKCdWdWUgaXMgYSBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkJyk7XG4gIH1cbiAgdGhpcy5faW5pdChvcHRpb25zKTtcbn1cblxuaW5pdE1peGluKFZ1ZSk7XG5zdGF0ZU1peGluKFZ1ZSk7XG5ldmVudHNNaXhpbihWdWUpO1xubGlmZWN5Y2xlTWl4aW4oVnVlKTtcbnJlbmRlck1peGluKFZ1ZSk7XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0VXNlIChWdWUpIHtcbiAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICB2YXIgaW5zdGFsbGVkUGx1Z2lucyA9ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zIHx8ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zID0gW10pKTtcbiAgICBpZiAoaW5zdGFsbGVkUGx1Z2lucy5pbmRleE9mKHBsdWdpbikgPiAtMSkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgaWYgKHR5cGVvZiBwbHVnaW4uaW5zdGFsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG4gICAgaW5zdGFsbGVkUGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRNaXhpbiQxIChWdWUpIHtcbiAgVnVlLm1peGluID0gZnVuY3Rpb24gKG1peGluKSB7XG4gICAgdGhpcy5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgbWl4aW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXh0ZW5kIChWdWUpIHtcbiAgLyoqXG4gICAqIEVhY2ggaW5zdGFuY2UgY29uc3RydWN0b3IsIGluY2x1ZGluZyBWdWUsIGhhcyBhIHVuaXF1ZVxuICAgKiBjaWQuIFRoaXMgZW5hYmxlcyB1cyB0byBjcmVhdGUgd3JhcHBlZCBcImNoaWxkXG4gICAqIGNvbnN0cnVjdG9yc1wiIGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGFuZCBjYWNoZSB0aGVtLlxuICAgKi9cbiAgVnVlLmNpZCA9IDA7XG4gIHZhciBjaWQgPSAxO1xuXG4gIC8qKlxuICAgKiBDbGFzcyBpbmhlcml0YW5jZVxuICAgKi9cbiAgVnVlLmV4dGVuZCA9IGZ1bmN0aW9uIChleHRlbmRPcHRpb25zKSB7XG4gICAgZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnMgfHwge307XG4gICAgdmFyIFN1cGVyID0gdGhpcztcbiAgICB2YXIgU3VwZXJJZCA9IFN1cGVyLmNpZDtcbiAgICB2YXIgY2FjaGVkQ3RvcnMgPSBleHRlbmRPcHRpb25zLl9DdG9yIHx8IChleHRlbmRPcHRpb25zLl9DdG9yID0ge30pO1xuICAgIGlmIChjYWNoZWRDdG9yc1tTdXBlcklkXSkge1xuICAgICAgcmV0dXJuIGNhY2hlZEN0b3JzW1N1cGVySWRdXG4gICAgfVxuXG4gICAgdmFyIG5hbWUgPSBleHRlbmRPcHRpb25zLm5hbWUgfHwgU3VwZXIub3B0aW9ucy5uYW1lO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG5hbWUpIHtcbiAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgU3ViID0gZnVuY3Rpb24gVnVlQ29tcG9uZW50IChvcHRpb25zKSB7XG4gICAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xuICAgIH07XG4gICAgU3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViO1xuICAgIFN1Yi5jaWQgPSBjaWQrKztcbiAgICBTdWIub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgIFN1cGVyLm9wdGlvbnMsXG4gICAgICBleHRlbmRPcHRpb25zXG4gICAgKTtcbiAgICBTdWJbJ3N1cGVyJ10gPSBTdXBlcjtcblxuICAgIC8vIEZvciBwcm9wcyBhbmQgY29tcHV0ZWQgcHJvcGVydGllcywgd2UgZGVmaW5lIHRoZSBwcm94eSBnZXR0ZXJzIG9uXG4gICAgLy8gdGhlIFZ1ZSBpbnN0YW5jZXMgYXQgZXh0ZW5zaW9uIHRpbWUsIG9uIHRoZSBleHRlbmRlZCBwcm90b3R5cGUuIFRoaXNcbiAgICAvLyBhdm9pZHMgT2JqZWN0LmRlZmluZVByb3BlcnR5IGNhbGxzIGZvciBlYWNoIGluc3RhbmNlIGNyZWF0ZWQuXG4gICAgaWYgKFN1Yi5vcHRpb25zLnByb3BzKSB7XG4gICAgICBpbml0UHJvcHMkMShTdWIpO1xuICAgIH1cbiAgICBpZiAoU3ViLm9wdGlvbnMuY29tcHV0ZWQpIHtcbiAgICAgIGluaXRDb21wdXRlZCQxKFN1Yik7XG4gICAgfVxuXG4gICAgLy8gYWxsb3cgZnVydGhlciBleHRlbnNpb24vbWl4aW4vcGx1Z2luIHVzYWdlXG4gICAgU3ViLmV4dGVuZCA9IFN1cGVyLmV4dGVuZDtcbiAgICBTdWIubWl4aW4gPSBTdXBlci5taXhpbjtcbiAgICBTdWIudXNlID0gU3VwZXIudXNlO1xuXG4gICAgLy8gY3JlYXRlIGFzc2V0IHJlZ2lzdGVycywgc28gZXh0ZW5kZWQgY2xhc3Nlc1xuICAgIC8vIGNhbiBoYXZlIHRoZWlyIHByaXZhdGUgYXNzZXRzIHRvby5cbiAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBTdWJbdHlwZV0gPSBTdXBlclt0eXBlXTtcbiAgICB9KTtcbiAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XG4gICAgfVxuXG4gICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgc3VwZXIgb3B0aW9ucyBhdCBleHRlbnNpb24gdGltZS5cbiAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxuICAgIC8vIGJlZW4gdXBkYXRlZC5cbiAgICBTdWIuc3VwZXJPcHRpb25zID0gU3VwZXIub3B0aW9ucztcbiAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XG4gICAgU3ViLnNlYWxlZE9wdGlvbnMgPSBleHRlbmQoe30sIFN1Yi5vcHRpb25zKTtcblxuICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXG4gICAgY2FjaGVkQ3RvcnNbU3VwZXJJZF0gPSBTdWI7XG4gICAgcmV0dXJuIFN1YlxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMkMSAoQ29tcCkge1xuICB2YXIgcHJvcHMgPSBDb21wLm9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHByb3h5KENvbXAucHJvdG90eXBlLCBcIl9wcm9wc1wiLCBrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCQxIChDb21wKSB7XG4gIHZhciBjb21wdXRlZCA9IENvbXAub3B0aW9ucy5jb21wdXRlZDtcbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgZGVmaW5lQ29tcHV0ZWQoQ29tcC5wcm90b3R5cGUsIGtleSwgY29tcHV0ZWRba2V5XSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRBc3NldFJlZ2lzdGVycyAoVnVlKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYXNzZXQgcmVnaXN0cmF0aW9uIG1ldGhvZHMuXG4gICAqL1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlW3R5cGVdID0gZnVuY3Rpb24gKFxuICAgICAgaWQsXG4gICAgICBkZWZpbml0aW9uXG4gICAgKSB7XG4gICAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlID09PSAnY29tcG9uZW50Jykge1xuICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGlzUGxhaW5PYmplY3QoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICBkZWZpbml0aW9uLm5hbWUgPSBkZWZpbml0aW9uLm5hbWUgfHwgaWQ7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHRoaXMub3B0aW9ucy5fYmFzZS5leHRlbmQoZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdkaXJlY3RpdmUnICYmIHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHsgYmluZDogZGVmaW5pdGlvbiwgdXBkYXRlOiBkZWZpbml0aW9uIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXSA9IGRlZmluaXRpb247XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uXG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lIChvcHRzKSB7XG4gIHJldHVybiBvcHRzICYmIChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnKVxufVxuXG5mdW5jdGlvbiBtYXRjaGVzIChwYXR0ZXJuLCBuYW1lKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoJywnKS5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmIChpc1JlZ0V4cChwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZSAoa2VlcEFsaXZlSW5zdGFuY2UsIGZpbHRlcikge1xuICB2YXIgY2FjaGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5jYWNoZTtcbiAgdmFyIGtleXMgPSBrZWVwQWxpdmVJbnN0YW5jZS5rZXlzO1xuICB2YXIgX3Zub2RlID0ga2VlcEFsaXZlSW5zdGFuY2UuX3Zub2RlO1xuICBmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcbiAgICB2YXIgY2FjaGVkTm9kZSA9IGNhY2hlW2tleV07XG4gICAgaWYgKGNhY2hlZE5vZGUpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjYWNoZWROb2RlLmNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xuICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleSwga2V5cywgX3Zub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5IChcbiAgY2FjaGUsXG4gIGtleSxcbiAga2V5cyxcbiAgY3VycmVudFxuKSB7XG4gIHZhciBjYWNoZWQkJDEgPSBjYWNoZVtrZXldO1xuICBpZiAoY2FjaGVkJCQxICYmICghY3VycmVudCB8fCBjYWNoZWQkJDEudGFnICE9PSBjdXJyZW50LnRhZykpIHtcbiAgICBjYWNoZWQkJDEuY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgfVxuICBjYWNoZVtrZXldID0gbnVsbDtcbiAgcmVtb3ZlKGtleXMsIGtleSk7XG59XG5cbnZhciBwYXR0ZXJuVHlwZXMgPSBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XTtcblxudmFyIEtlZXBBbGl2ZSA9IHtcbiAgbmFtZTogJ2tlZXAtYWxpdmUnLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICBwcm9wczoge1xuICAgIGluY2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICBleGNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgbWF4OiBbU3RyaW5nLCBOdW1iZXJdXG4gIH0sXG5cbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCAoKSB7XG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5rZXlzID0gW107XG4gIH0sXG5cbiAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMkMS5jYWNoZSkge1xuICAgICAgcHJ1bmVDYWNoZUVudHJ5KHRoaXMkMS5jYWNoZSwga2V5LCB0aGlzJDEua2V5cyk7XG4gICAgfVxuICB9LFxuXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy4kd2F0Y2goJ2luY2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMkMSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfSk7XG4gICAgdGhpcy4kd2F0Y2goJ2V4Y2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMkMSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuICFtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgICB2YXIgc2xvdCA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgdmFyIHZub2RlID0gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChzbG90KTtcbiAgICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgaWYgKGNvbXBvbmVudE9wdGlvbnMpIHtcbiAgICAgIC8vIGNoZWNrIHBhdHRlcm5cbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcbiAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgdmFyIGluY2x1ZGUgPSByZWYuaW5jbHVkZTtcbiAgICAgIHZhciBleGNsdWRlID0gcmVmLmV4Y2x1ZGU7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIG5vdCBpbmNsdWRlZFxuICAgICAgICAoaW5jbHVkZSAmJiAoIW5hbWUgfHwgIW1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpKSB8fFxuICAgICAgICAvLyBleGNsdWRlZFxuICAgICAgICAoZXhjbHVkZSAmJiBuYW1lICYmIG1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHZub2RlXG4gICAgICB9XG5cbiAgICAgIHZhciByZWYkMSA9IHRoaXM7XG4gICAgICB2YXIgY2FjaGUgPSByZWYkMS5jYWNoZTtcbiAgICAgIHZhciBrZXlzID0gcmVmJDEua2V5cztcbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxuICAgICAgICAvLyBzYW1lIGNvbnN0cnVjdG9yIG1heSBnZXQgcmVnaXN0ZXJlZCBhcyBkaWZmZXJlbnQgbG9jYWwgY29tcG9uZW50c1xuICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG4gICAgICAgID8gY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArIChjb21wb25lbnRPcHRpb25zLnRhZyA/IChcIjo6XCIgKyAoY29tcG9uZW50T3B0aW9ucy50YWcpKSA6ICcnKVxuICAgICAgICA6IHZub2RlLmtleTtcbiAgICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY2FjaGVba2V5XS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgICAgLy8gbWFrZSBjdXJyZW50IGtleSBmcmVzaGVzdFxuICAgICAgICByZW1vdmUoa2V5cywga2V5KTtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWNoZVtrZXldID0gdm5vZGU7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAvLyBwcnVuZSBvbGRlc3QgZW50cnlcbiAgICAgICAgaWYgKHRoaXMubWF4ICYmIGtleXMubGVuZ3RoID4gcGFyc2VJbnQodGhpcy5tYXgpKSB7XG4gICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXlzWzBdLCBrZXlzLCB0aGlzLl92bm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGUgfHwgKHNsb3QgJiYgc2xvdFswXSlcbiAgfVxufVxuXG52YXIgYnVpbHRJbkNvbXBvbmVudHMgPSB7XG4gIEtlZXBBbGl2ZTogS2VlcEFsaXZlXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0R2xvYmFsQVBJIChWdWUpIHtcbiAgLy8gY29uZmlnXG4gIHZhciBjb25maWdEZWYgPSB7fTtcbiAgY29uZmlnRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZzsgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25maWdEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCByZXBsYWNlIHRoZSBWdWUuY29uZmlnIG9iamVjdCwgc2V0IGluZGl2aWR1YWwgZmllbGRzIGluc3RlYWQuJ1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdjb25maWcnLCBjb25maWdEZWYpO1xuXG4gIC8vIGV4cG9zZWQgdXRpbCBtZXRob2RzLlxuICAvLyBOT1RFOiB0aGVzZSBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgcHVibGljIEFQSSAtIGF2b2lkIHJlbHlpbmcgb25cbiAgLy8gdGhlbSB1bmxlc3MgeW91IGFyZSBhd2FyZSBvZiB0aGUgcmlzay5cbiAgVnVlLnV0aWwgPSB7XG4gICAgd2Fybjogd2FybixcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBtZXJnZU9wdGlvbnM6IG1lcmdlT3B0aW9ucyxcbiAgICBkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmVcbiAgfTtcblxuICBWdWUuc2V0ID0gc2V0O1xuICBWdWUuZGVsZXRlID0gZGVsO1xuICBWdWUubmV4dFRpY2sgPSBuZXh0VGljaztcblxuICBWdWUub3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWUub3B0aW9uc1t0eXBlICsgJ3MnXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH0pO1xuXG4gIC8vIHRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgXCJiYXNlXCIgY29uc3RydWN0b3IgdG8gZXh0ZW5kIGFsbCBwbGFpbi1vYmplY3RcbiAgLy8gY29tcG9uZW50cyB3aXRoIGluIFdlZXgncyBtdWx0aS1pbnN0YW5jZSBzY2VuYXJpb3MuXG4gIFZ1ZS5vcHRpb25zLl9iYXNlID0gVnVlO1xuXG4gIGV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBidWlsdEluQ29tcG9uZW50cyk7XG5cbiAgaW5pdFVzZShWdWUpO1xuICBpbml0TWl4aW4kMShWdWUpO1xuICBpbml0RXh0ZW5kKFZ1ZSk7XG4gIGluaXRBc3NldFJlZ2lzdGVycyhWdWUpO1xufVxuXG5pbml0R2xvYmFsQVBJKFZ1ZSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGlzU2VydmVyJywge1xuICBnZXQ6IGlzU2VydmVyUmVuZGVyaW5nXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckc3NyQ29udGV4dCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHRcbiAgfVxufSk7XG5cbi8vIGV4cG9zZSBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCBmb3Igc3NyIHJ1bnRpbWUgaGVscGVyIGluc3RhbGxhdGlvblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ0Z1bmN0aW9uYWxSZW5kZXJDb250ZXh0Jywge1xuICB2YWx1ZTogRnVuY3Rpb25hbFJlbmRlckNvbnRleHRcbn0pO1xuXG5WdWUudmVyc2lvbiA9ICcyLjUuMTYnO1xuXG4vKiAgKi9cblxuLy8gdGhlc2UgYXJlIHJlc2VydmVkIGZvciB3ZWIgYmVjYXVzZSB0aGV5IGFyZSBkaXJlY3RseSBjb21waWxlZCBhd2F5XG4vLyBkdXJpbmcgdGVtcGxhdGUgY29tcGlsYXRpb25cbnZhciBpc1Jlc2VydmVkQXR0ciA9IG1ha2VNYXAoJ3N0eWxlLGNsYXNzJyk7XG5cbi8vIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgdXNpbmcgcHJvcHMgZm9yIGJpbmRpbmdcbnZhciBhY2NlcHRWYWx1ZSA9IG1ha2VNYXAoJ2lucHV0LHRleHRhcmVhLG9wdGlvbixzZWxlY3QscHJvZ3Jlc3MnKTtcbnZhciBtdXN0VXNlUHJvcCA9IGZ1bmN0aW9uICh0YWcsIHR5cGUsIGF0dHIpIHtcbiAgcmV0dXJuIChcbiAgICAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBhY2NlcHRWYWx1ZSh0YWcpKSAmJiB0eXBlICE9PSAnYnV0dG9uJyB8fFxuICAgIChhdHRyID09PSAnc2VsZWN0ZWQnICYmIHRhZyA9PT0gJ29wdGlvbicpIHx8XG4gICAgKGF0dHIgPT09ICdjaGVja2VkJyAmJiB0YWcgPT09ICdpbnB1dCcpIHx8XG4gICAgKGF0dHIgPT09ICdtdXRlZCcgJiYgdGFnID09PSAndmlkZW8nKVxuICApXG59O1xuXG52YXIgaXNFbnVtZXJhdGVkQXR0ciA9IG1ha2VNYXAoJ2NvbnRlbnRlZGl0YWJsZSxkcmFnZ2FibGUsc3BlbGxjaGVjaycpO1xuXG52YXIgaXNCb29sZWFuQXR0ciA9IG1ha2VNYXAoXG4gICdhbGxvd2Z1bGxzY3JlZW4sYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNoZWNrZWQsY29tcGFjdCxjb250cm9scyxkZWNsYXJlLCcgK1xuICAnZGVmYXVsdCxkZWZhdWx0Y2hlY2tlZCxkZWZhdWx0bXV0ZWQsZGVmYXVsdHNlbGVjdGVkLGRlZmVyLGRpc2FibGVkLCcgK1xuICAnZW5hYmxlZCxmb3Jtbm92YWxpZGF0ZSxoaWRkZW4saW5kZXRlcm1pbmF0ZSxpbmVydCxpc21hcCxpdGVtc2NvcGUsbG9vcCxtdWx0aXBsZSwnICtcbiAgJ211dGVkLG5vaHJlZixub3Jlc2l6ZSxub3NoYWRlLG5vdmFsaWRhdGUsbm93cmFwLG9wZW4scGF1c2VvbmV4aXQscmVhZG9ubHksJyArXG4gICdyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3Msc2VsZWN0ZWQsc29ydGFibGUsdHJhbnNsYXRlLCcgK1xuICAndHJ1ZXNwZWVkLHR5cGVtdXN0bWF0Y2gsdmlzaWJsZSdcbik7XG5cbnZhciB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuXG52YXIgaXNYbGluayA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBuYW1lLmNoYXJBdCg1KSA9PT0gJzonICYmIG5hbWUuc2xpY2UoMCwgNSkgPT09ICd4bGluaydcbn07XG5cbnZhciBnZXRYbGlua1Byb3AgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gaXNYbGluayhuYW1lKSA/IG5hbWUuc2xpY2UoNiwgbmFtZS5sZW5ndGgpIDogJydcbn07XG5cbnZhciBpc0ZhbHN5QXR0clZhbHVlID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSBmYWxzZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGdlbkNsYXNzRm9yVm5vZGUgKHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICB3aGlsZSAoaXNEZWYoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgaWYgKGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGNoaWxkTm9kZS5kYXRhLCBkYXRhKTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKGlzRGVmKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZSAmJiBwYXJlbnROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShkYXRhLCBwYXJlbnROb2RlLmRhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVuZGVyQ2xhc3MoZGF0YS5zdGF0aWNDbGFzcywgZGF0YS5jbGFzcylcbn1cblxuZnVuY3Rpb24gbWVyZ2VDbGFzc0RhdGEgKGNoaWxkLCBwYXJlbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0aWNDbGFzczogY29uY2F0KGNoaWxkLnN0YXRpY0NsYXNzLCBwYXJlbnQuc3RhdGljQ2xhc3MpLFxuICAgIGNsYXNzOiBpc0RlZihjaGlsZC5jbGFzcylcbiAgICAgID8gW2NoaWxkLmNsYXNzLCBwYXJlbnQuY2xhc3NdXG4gICAgICA6IHBhcmVudC5jbGFzc1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNsYXNzIChcbiAgc3RhdGljQ2xhc3MsXG4gIGR5bmFtaWNDbGFzc1xuKSB7XG4gIGlmIChpc0RlZihzdGF0aWNDbGFzcykgfHwgaXNEZWYoZHluYW1pY0NsYXNzKSkge1xuICAgIHJldHVybiBjb25jYXQoc3RhdGljQ2xhc3MsIHN0cmluZ2lmeUNsYXNzKGR5bmFtaWNDbGFzcykpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIGNvbmNhdCAoYSwgYikge1xuICByZXR1cm4gYSA/IGIgPyAoYSArICcgJyArIGIpIDogYSA6IChiIHx8ICcnKVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlDbGFzcyAodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeUFycmF5KHZhbHVlKVxuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5T2JqZWN0KHZhbHVlKVxuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUFycmF5ICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIHZhciBzdHJpbmdpZmllZDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoaXNEZWYoc3RyaW5naWZpZWQgPSBzdHJpbmdpZnlDbGFzcyh2YWx1ZVtpXSkpICYmIHN0cmluZ2lmaWVkICE9PSAnJykge1xuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICByZXMgKz0gc3RyaW5naWZpZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5T2JqZWN0ICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZVtrZXldKSB7XG4gICAgICBpZiAocmVzKSB7IHJlcyArPSAnICc7IH1cbiAgICAgIHJlcyArPSBrZXk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBuYW1lc3BhY2VNYXAgPSB7XG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgbWF0aDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnXG59O1xuXG52YXIgaXNIVE1MVGFnID0gbWFrZU1hcChcbiAgJ2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLCcgK1xuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLCcgK1xuICAnZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsJyArXG4gICdhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnRjLHJ1YnksJyArXG4gICdzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbywnICtcbiAgJ2VtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLCcgK1xuICAnY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsJyArXG4gICdidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLCcgK1xuICAnb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSwnICtcbiAgJ2RldGFpbHMsZGlhbG9nLG1lbnUsbWVudWl0ZW0sc3VtbWFyeSwnICtcbiAgJ2NvbnRlbnQsZWxlbWVudCxzaGFkb3csdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3QnXG4pO1xuXG4vLyB0aGlzIG1hcCBpcyBpbnRlbnRpb25hbGx5IHNlbGVjdGl2ZSwgb25seSBjb3ZlcmluZyBTVkcgZWxlbWVudHMgdGhhdCBtYXlcbi8vIGNvbnRhaW4gY2hpbGQgZWxlbWVudHMuXG52YXIgaXNTVkcgPSBtYWtlTWFwKFxuICAnc3ZnLGFuaW1hdGUsY2lyY2xlLGNsaXBwYXRoLGN1cnNvcixkZWZzLGRlc2MsZWxsaXBzZSxmaWx0ZXIsZm9udC1mYWNlLCcgK1xuICAnZm9yZWlnbk9iamVjdCxnLGdseXBoLGltYWdlLGxpbmUsbWFya2VyLG1hc2ssbWlzc2luZy1nbHlwaCxwYXRoLHBhdHRlcm4sJyArXG4gICdwb2x5Z29uLHBvbHlsaW5lLHJlY3Qsc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRwYXRoLHRzcGFuLHVzZSx2aWV3JyxcbiAgdHJ1ZVxuKTtcblxuXG5cbnZhciBpc1Jlc2VydmVkVGFnID0gZnVuY3Rpb24gKHRhZykge1xuICByZXR1cm4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkcodGFnKVxufTtcblxuZnVuY3Rpb24gZ2V0VGFnTmFtZXNwYWNlICh0YWcpIHtcbiAgaWYgKGlzU1ZHKHRhZykpIHtcbiAgICByZXR1cm4gJ3N2ZydcbiAgfVxuICAvLyBiYXNpYyBzdXBwb3J0IGZvciBNYXRoTUxcbiAgLy8gbm90ZSBpdCBkb2Vzbid0IHN1cHBvcnQgb3RoZXIgTWF0aE1MIGVsZW1lbnRzIGJlaW5nIGNvbXBvbmVudCByb290c1xuICBpZiAodGFnID09PSAnbWF0aCcpIHtcbiAgICByZXR1cm4gJ21hdGgnXG4gIH1cbn1cblxudmFyIHVua25vd25FbGVtZW50Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCAodGFnKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWluQnJvd3Nlcikge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHVua25vd25FbGVtZW50Q2FjaGVbdGFnXVxuICB9XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgaWYgKHRhZy5pbmRleE9mKCctJykgPiAtMSkge1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI4MjEwMzY0LzEwNzAyNDRcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IChcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTFVua25vd25FbGVtZW50IHx8XG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxFbGVtZW50XG4gICAgKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IC9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZWwudG9TdHJpbmcoKSkpXG4gIH1cbn1cblxudmFyIGlzVGV4dElucHV0VHlwZSA9IG1ha2VNYXAoJ3RleHQsbnVtYmVyLHBhc3N3b3JkLHNlYXJjaCxlbWFpbCx0ZWwsdXJsJyk7XG5cbi8qICAqL1xuXG4vKipcbiAqIFF1ZXJ5IGFuIGVsZW1lbnQgc2VsZWN0b3IgaWYgaXQncyBub3QgYW4gZWxlbWVudCBhbHJlYWR5LlxuICovXG5mdW5jdGlvbiBxdWVyeSAoZWwpIHtcbiAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgZWxcbiAgICAgICk7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGVkXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQkMSAodGFnTmFtZSwgdm5vZGUpIHtcbiAgdmFyIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gIGlmICh0YWdOYW1lICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybiBlbG1cbiAgfVxuICAvLyBmYWxzZSBvciBudWxsIHdpbGwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgYnV0IHVuZGVmaW5lZCB3aWxsIG5vdFxuICBpZiAodm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLmF0dHJzICYmIHZub2RlLmRhdGEuYXR0cnMubXVsdGlwbGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJ211bHRpcGxlJyk7XG4gIH1cbiAgcmV0dXJuIGVsbVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMgKG5hbWVzcGFjZSwgdGFnTmFtZSkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZU1hcFtuYW1lc3BhY2VdLCB0YWdOYW1lKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dClcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudCAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KVxufVxuXG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUgKHBhcmVudE5vZGUsIG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBwYXJlbnROb2RlIChub2RlKSB7XG4gIHJldHVybiBub2RlLnBhcmVudE5vZGVcbn1cblxuZnVuY3Rpb24gbmV4dFNpYmxpbmcgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmdcbn1cblxuZnVuY3Rpb24gdGFnTmFtZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lXG59XG5cbmZ1bmN0aW9uIHNldFRleHRDb250ZW50IChub2RlLCB0ZXh0KSB7XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufVxuXG5mdW5jdGlvbiBzZXRTdHlsZVNjb3BlIChub2RlLCBzY29wZUlkKSB7XG4gIG5vZGUuc2V0QXR0cmlidXRlKHNjb3BlSWQsICcnKTtcbn1cblxuXG52YXIgbm9kZU9wcyA9IE9iamVjdC5mcmVlemUoe1xuXHRjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50JDEsXG5cdGNyZWF0ZUVsZW1lbnROUzogY3JlYXRlRWxlbWVudE5TLFxuXHRjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUsXG5cdGNyZWF0ZUNvbW1lbnQ6IGNyZWF0ZUNvbW1lbnQsXG5cdGluc2VydEJlZm9yZTogaW5zZXJ0QmVmb3JlLFxuXHRyZW1vdmVDaGlsZDogcmVtb3ZlQ2hpbGQsXG5cdGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZCxcblx0cGFyZW50Tm9kZTogcGFyZW50Tm9kZSxcblx0bmV4dFNpYmxpbmc6IG5leHRTaWJsaW5nLFxuXHR0YWdOYW1lOiB0YWdOYW1lLFxuXHRzZXRUZXh0Q29udGVudDogc2V0VGV4dENvbnRlbnQsXG5cdHNldFN0eWxlU2NvcGU6IHNldFN0eWxlU2NvcGVcbn0pO1xuXG4vKiAgKi9cblxudmFyIHJlZiA9IHtcbiAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUgKF8sIHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgaWYgKG9sZFZub2RlLmRhdGEucmVmICE9PSB2bm9kZS5kYXRhLnJlZikge1xuICAgICAgcmVnaXN0ZXJSZWYob2xkVm5vZGUsIHRydWUpO1xuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgIH1cbiAgfSxcbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSwgdHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJSZWYgKHZub2RlLCBpc1JlbW92YWwpIHtcbiAgdmFyIGtleSA9IHZub2RlLmRhdGEucmVmO1xuICBpZiAoIWlzRGVmKGtleSkpIHsgcmV0dXJuIH1cblxuICB2YXIgdm0gPSB2bm9kZS5jb250ZXh0O1xuICB2YXIgcmVmID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuZWxtO1xuICB2YXIgcmVmcyA9IHZtLiRyZWZzO1xuICBpZiAoaXNSZW1vdmFsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgcmVtb3ZlKHJlZnNba2V5XSwgcmVmKTtcbiAgICB9IGVsc2UgaWYgKHJlZnNba2V5XSA9PT0gcmVmKSB7XG4gICAgICByZWZzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2bm9kZS5kYXRhLnJlZkluRm9yKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgICByZWZzW2tleV0gPSBbcmVmXTtcbiAgICAgIH0gZWxzZSBpZiAocmVmc1trZXldLmluZGV4T2YocmVmKSA8IDApIHtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIHJlZnNba2V5XS5wdXNoKHJlZik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cblxudmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxudmFyIGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5cbmZ1bmN0aW9uIHNhbWVWbm9kZSAoYSwgYikge1xuICByZXR1cm4gKFxuICAgIGEua2V5ID09PSBiLmtleSAmJiAoXG4gICAgICAoXG4gICAgICAgIGEudGFnID09PSBiLnRhZyAmJlxuICAgICAgICBhLmlzQ29tbWVudCA9PT0gYi5pc0NvbW1lbnQgJiZcbiAgICAgICAgaXNEZWYoYS5kYXRhKSA9PT0gaXNEZWYoYi5kYXRhKSAmJlxuICAgICAgICBzYW1lSW5wdXRUeXBlKGEsIGIpXG4gICAgICApIHx8IChcbiAgICAgICAgaXNUcnVlKGEuaXNBc3luY1BsYWNlaG9sZGVyKSAmJlxuICAgICAgICBhLmFzeW5jRmFjdG9yeSA9PT0gYi5hc3luY0ZhY3RvcnkgJiZcbiAgICAgICAgaXNVbmRlZihiLmFzeW5jRmFjdG9yeS5lcnJvcilcbiAgICAgIClcbiAgICApXG4gIClcbn1cblxuZnVuY3Rpb24gc2FtZUlucHV0VHlwZSAoYSwgYikge1xuICBpZiAoYS50YWcgIT09ICdpbnB1dCcpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgaTtcbiAgdmFyIHR5cGVBID0gaXNEZWYoaSA9IGEuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgdmFyIHR5cGVCID0gaXNEZWYoaSA9IGIuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgcmV0dXJuIHR5cGVBID09PSB0eXBlQiB8fCBpc1RleHRJbnB1dFR5cGUodHlwZUEpICYmIGlzVGV4dElucHV0VHlwZSh0eXBlQilcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHggKGNoaWxkcmVuLCBiZWdpbklkeCwgZW5kSWR4KSB7XG4gIHZhciBpLCBrZXk7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yIChpID0gYmVnaW5JZHg7IGkgPD0gZW5kSWR4OyArK2kpIHtcbiAgICBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XG4gICAgaWYgKGlzRGVmKGtleSkpIHsgbWFwW2tleV0gPSBpOyB9XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uIChiYWNrZW5kKSB7XG4gIHZhciBpLCBqO1xuICB2YXIgY2JzID0ge307XG5cbiAgdmFyIG1vZHVsZXMgPSBiYWNrZW5kLm1vZHVsZXM7XG4gIHZhciBub2RlT3BzID0gYmFja2VuZC5ub2RlT3BzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xuICAgIGNic1tob29rc1tpXV0gPSBbXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbW9kdWxlcy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKGlzRGVmKG1vZHVsZXNbal1baG9va3NbaV1dKSkge1xuICAgICAgICBjYnNbaG9va3NbaV1dLnB1c2gobW9kdWxlc1tqXVtob29rc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0IChlbG0pIHtcbiAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGVPcHMudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSbUNiIChjaGlsZEVsbSwgbGlzdGVuZXJzKSB7XG4gICAgZnVuY3Rpb24gcmVtb3ZlICgpIHtcbiAgICAgIGlmICgtLXJlbW92ZS5saXN0ZW5lcnMgPT09IDApIHtcbiAgICAgICAgcmVtb3ZlTm9kZShjaGlsZEVsbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlbW92ZS5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgcmV0dXJuIHJlbW92ZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTm9kZSAoZWwpIHtcbiAgICB2YXIgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcbiAgICAvLyBlbGVtZW50IG1heSBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkIGR1ZSB0byB2LWh0bWwgLyB2LXRleHRcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1Vua25vd25FbGVtZW50JCQxICh2bm9kZSwgaW5WUHJlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICFpblZQcmUgJiZcbiAgICAgICF2bm9kZS5ucyAmJlxuICAgICAgIShcbiAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5sZW5ndGggJiZcbiAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5zb21lKGZ1bmN0aW9uIChpZ25vcmUpIHtcbiAgICAgICAgICByZXR1cm4gaXNSZWdFeHAoaWdub3JlKVxuICAgICAgICAgICAgPyBpZ25vcmUudGVzdCh2bm9kZS50YWcpXG4gICAgICAgICAgICA6IGlnbm9yZSA9PT0gdm5vZGUudGFnXG4gICAgICAgIH0pXG4gICAgICApICYmXG4gICAgICBjb25maWcuaXNVbmtub3duRWxlbWVudCh2bm9kZS50YWcpXG4gICAgKVxuICB9XG5cbiAgdmFyIGNyZWF0aW5nRWxtSW5WUHJlID0gMDtcblxuICBmdW5jdGlvbiBjcmVhdGVFbG0gKFxuICAgIHZub2RlLFxuICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICBwYXJlbnRFbG0sXG4gICAgcmVmRWxtLFxuICAgIG5lc3RlZCxcbiAgICBvd25lckFycmF5LFxuICAgIGluZGV4XG4gICkge1xuICAgIGlmIChpc0RlZih2bm9kZS5lbG0pICYmIGlzRGVmKG93bmVyQXJyYXkpKSB7XG4gICAgICAvLyBUaGlzIHZub2RlIHdhcyB1c2VkIGluIGEgcHJldmlvdXMgcmVuZGVyIVxuICAgICAgLy8gbm93IGl0J3MgdXNlZCBhcyBhIG5ldyBub2RlLCBvdmVyd3JpdGluZyBpdHMgZWxtIHdvdWxkIGNhdXNlXG4gICAgICAvLyBwb3RlbnRpYWwgcGF0Y2ggZXJyb3JzIGRvd24gdGhlIHJvYWQgd2hlbiBpdCdzIHVzZWQgYXMgYW4gaW5zZXJ0aW9uXG4gICAgICAvLyByZWZlcmVuY2Ugbm9kZS4gSW5zdGVhZCwgd2UgY2xvbmUgdGhlIG5vZGUgb24tZGVtYW5kIGJlZm9yZSBjcmVhdGluZ1xuICAgICAgLy8gYXNzb2NpYXRlZCBET00gZWxlbWVudCBmb3IgaXQuXG4gICAgICB2bm9kZSA9IG93bmVyQXJyYXlbaW5kZXhdID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgfVxuXG4gICAgdm5vZGUuaXNSb290SW5zZXJ0ID0gIW5lc3RlZDsgLy8gZm9yIHRyYW5zaXRpb24gZW50ZXIgY2hlY2tcbiAgICBpZiAoY3JlYXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVbmtub3duRWxlbWVudCQkMSh2bm9kZSwgY3JlYXRpbmdFbG1JblZQcmUpKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArIHRhZyArICc+IC0gZGlkIHlvdSAnICtcbiAgICAgICAgICAgICdyZWdpc3RlciB0aGUgY29tcG9uZW50IGNvcnJlY3RseT8gRm9yIHJlY3Vyc2l2ZSBjb21wb25lbnRzLCAnICtcbiAgICAgICAgICAgICdtYWtlIHN1cmUgdG8gcHJvdmlkZSB0aGUgXCJuYW1lXCIgb3B0aW9uLicsXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xuICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG4gICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUtLTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpKSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZUNvbW1lbnQodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIHZhciBpc1JlYWN0aXZhdGVkID0gaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGkua2VlcEFsaXZlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7XG4gICAgICAgIGkodm5vZGUsIGZhbHNlIC8qIGh5ZHJhdGluZyAqLywgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgfVxuICAgICAgLy8gYWZ0ZXIgY2FsbGluZyB0aGUgaW5pdCBob29rLCBpZiB0aGUgdm5vZGUgaXMgYSBjaGlsZCBjb21wb25lbnRcbiAgICAgIC8vIGl0IHNob3VsZCd2ZSBjcmVhdGVkIGEgY2hpbGQgaW5zdGFuY2UgYW5kIG1vdW50ZWQgaXQuIHRoZSBjaGlsZFxuICAgICAgLy8gY29tcG9uZW50IGFsc28gaGFzIHNldCB0aGUgcGxhY2Vob2xkZXIgdm5vZGUncyBlbG0uXG4gICAgICAvLyBpbiB0aGF0IGNhc2Ugd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBlbGVtZW50IGFuZCBiZSBkb25lLlxuICAgICAgaWYgKGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNUcnVlKGlzUmVhY3RpdmF0ZWQpKSB7XG4gICAgICAgICAgcmVhY3RpdmF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0Q29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkpIHtcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoLmFwcGx5KGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KTtcbiAgICAgIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCA9IG51bGw7XG4gICAgfVxuICAgIHZub2RlLmVsbSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRlbDtcbiAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZW1wdHkgY29tcG9uZW50IHJvb3QuXG4gICAgICAvLyBza2lwIGFsbCBlbGVtZW50LXJlbGF0ZWQgbW9kdWxlcyBleGNlcHQgZm9yIHJlZiAoIzM0NTUpXG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgICAvLyBtYWtlIHN1cmUgdG8gaW52b2tlIHRoZSBpbnNlcnQgaG9va1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGk7XG4gICAgLy8gaGFjayBmb3IgIzQzMzk6IGEgcmVhY3RpdmF0ZWQgY29tcG9uZW50IHdpdGggaW5uZXIgdHJhbnNpdGlvblxuICAgIC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcbiAgICAvLyBhZ2Fpbi4gSXQncyBub3QgaWRlYWwgdG8gaW52b2x2ZSBtb2R1bGUtc3BlY2lmaWMgbG9naWMgaW4gaGVyZSBidXRcbiAgICAvLyB0aGVyZSBkb2Vzbid0IHNlZW0gdG8gYmUgYSBiZXR0ZXIgd2F5IHRvIGRvIGl0LlxuICAgIHZhciBpbm5lck5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBpbm5lck5vZGUgPSBpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpbm5lck5vZGUuZGF0YSkgJiYgaXNEZWYoaSA9IGkudHJhbnNpdGlvbikpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5hY3RpdmF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNicy5hY3RpdmF0ZVtpXShlbXB0eU5vZGUsIGlubmVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2goaW5uZXJOb2RlKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdW5saWtlIGEgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQsXG4gICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcbiAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnQgKHBhcmVudCwgZWxtLCByZWYkJDEpIHtcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgaWYgKGlzRGVmKHJlZiQkMSkpIHtcbiAgICAgICAgaWYgKHJlZiQkMS5wYXJlbnROb2RlID09PSBwYXJlbnQpIHtcbiAgICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnQsIGVsbSwgcmVmJCQxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZChwYXJlbnQsIGVsbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4gKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2hpbGRyZW4pO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBjcmVhdGVFbG0oY2hpbGRyZW5baV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZWxtLCBudWxsLCB0cnVlLCBjaGlsZHJlbiwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xuICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZCh2bm9kZS5lbG0sIG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKHZub2RlLnRleHQpKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNQYXRjaGFibGUgKHZub2RlKSB7XG4gICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRGVmKHZub2RlLnRhZylcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7IC8vIFJldXNlIHZhcmlhYmxlXG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICBpZiAoaXNEZWYoaS5jcmVhdGUpKSB7IGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaS5pbnNlcnQpKSB7IGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXG4gIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG4gIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgZnVuY3Rpb24gc2V0U2NvcGUgKHZub2RlKSB7XG4gICAgdmFyIGk7XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5mblNjb3BlSWQpKSB7XG4gICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGU7XG4gICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgaWYgKGlzRGVmKGkgPSBhbmNlc3Rvci5jb250ZXh0KSAmJiBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICAgICAgfVxuICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZm9yIHNsb3QgY29udGVudCB0aGV5IHNob3VsZCBhbHNvIGdldCB0aGUgc2NvcGVJZCBmcm9tIHRoZSBob3N0IGluc3RhbmNlLlxuICAgIGlmIChpc0RlZihpID0gYWN0aXZlSW5zdGFuY2UpICYmXG4gICAgICBpICE9PSB2bm9kZS5jb250ZXh0ICYmXG4gICAgICBpICE9PSB2bm9kZS5mbkNvbnRleHQgJiZcbiAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKVxuICAgICkge1xuICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkVm5vZGVzIChwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSwgZmFsc2UsIHZub2Rlcywgc3RhcnRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZURlc3Ryb3lIb29rICh2bm9kZSkge1xuICAgIHZhciBpLCBqO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5kZXN0cm95KSkgeyBpKHZub2RlKTsgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7IGNicy5kZXN0cm95W2ldKHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGludm9rZURlc3Ryb3lIb29rKHZub2RlLmNoaWxkcmVuW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVWbm9kZXMgKHBhcmVudEVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4KSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgdmFyIGNoID0gdm5vZGVzW3N0YXJ0SWR4XTtcbiAgICAgIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKGNoLnRhZykpIHtcbiAgICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGNoKTtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhjaCk7XG4gICAgICAgIH0gZWxzZSB7IC8vIFRleHQgbm9kZVxuICAgICAgICAgIHJlbW92ZU5vZGUoY2guZWxtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2sgKHZub2RlLCBybSkge1xuICAgIGlmIChpc0RlZihybSkgfHwgaXNEZWYodm5vZGUuZGF0YSkpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcbiAgICAgIGlmIChpc0RlZihybSkpIHtcbiAgICAgICAgLy8gd2UgaGF2ZSBhIHJlY3Vyc2l2ZWx5IHBhc3NlZCBkb3duIHJtIGNhbGxiYWNrXG4gICAgICAgIC8vIGluY3JlYXNlIHRoZSBsaXN0ZW5lcnMgY291bnRcbiAgICAgICAgcm0ubGlzdGVuZXJzICs9IGxpc3RlbmVycztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRpcmVjdGx5IHJlbW92aW5nXG4gICAgICAgIHJtID0gY3JlYXRlUm1DYih2bm9kZS5lbG0sIGxpc3RlbmVycyk7XG4gICAgICB9XG4gICAgICAvLyByZWN1cnNpdmVseSBpbnZva2UgaG9va3Mgb24gY2hpbGQgY29tcG9uZW50IHJvb3Qgbm9kZVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaXNEZWYoaSA9IGkuX3Zub2RlKSAmJiBpc0RlZihpLmRhdGEpKSB7XG4gICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soaSwgcm0pO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2JzLnJlbW92ZVtpXSh2bm9kZSwgcm0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5kYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnJlbW92ZSkpIHtcbiAgICAgICAgaSh2bm9kZSwgcm0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm0oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlTm9kZSh2bm9kZS5lbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuIChwYXJlbnRFbG0sIG9sZENoLCBuZXdDaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgdmFyIG9sZFN0YXJ0SWR4ID0gMDtcbiAgICB2YXIgbmV3U3RhcnRJZHggPSAwO1xuICAgIHZhciBvbGRFbmRJZHggPSBvbGRDaC5sZW5ndGggLSAxO1xuICAgIHZhciBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XG4gICAgdmFyIG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcbiAgICB2YXIgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xuICAgIHZhciBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG4gICAgdmFyIG9sZEtleVRvSWR4LCBpZHhJbk9sZCwgdm5vZGVUb01vdmUsIHJlZkVsbTtcblxuICAgIC8vIHJlbW92ZU9ubHkgaXMgYSBzcGVjaWFsIGZsYWcgdXNlZCBvbmx5IGJ5IDx0cmFuc2l0aW9uLWdyb3VwPlxuICAgIC8vIHRvIGVuc3VyZSByZW1vdmVkIGVsZW1lbnRzIHN0YXkgaW4gY29ycmVjdCByZWxhdGl2ZSBwb3NpdGlvbnNcbiAgICAvLyBkdXJpbmcgbGVhdmluZyB0cmFuc2l0aW9uc1xuICAgIHZhciBjYW5Nb3ZlID0gIXJlbW92ZU9ubHk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKG5ld0NoKTtcbiAgICB9XG5cbiAgICB3aGlsZSAob2xkU3RhcnRJZHggPD0gb2xkRW5kSWR4ICYmIG5ld1N0YXJ0SWR4IDw9IG5ld0VuZElkeCkge1xuICAgICAgaWYgKGlzVW5kZWYob2xkU3RhcnRWbm9kZSkpIHtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdOyAvLyBWbm9kZSBoYXMgYmVlbiBtb3ZlZCBsZWZ0XG4gICAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkRW5kVm5vZGUpKSB7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCByaWdodFxuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRW5kVm5vZGUuZWxtKSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgbGVmdFxuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkRW5kVm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNVbmRlZihvbGRLZXlUb0lkeCkpIHsgb2xkS2V5VG9JZHggPSBjcmVhdGVLZXlUb09sZElkeChvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7IH1cbiAgICAgICAgaWR4SW5PbGQgPSBpc0RlZihuZXdTdGFydFZub2RlLmtleSlcbiAgICAgICAgICA/IG9sZEtleVRvSWR4W25ld1N0YXJ0Vm5vZGUua2V5XVxuICAgICAgICAgIDogZmluZElkeEluT2xkKG5ld1N0YXJ0Vm5vZGUsIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICAgICAgaWYgKGlzVW5kZWYoaWR4SW5PbGQpKSB7IC8vIE5ldyBlbGVtZW50XG4gICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgZmFsc2UsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdm5vZGVUb01vdmUgPSBvbGRDaFtpZHhJbk9sZF07XG4gICAgICAgICAgaWYgKHNhbWVWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGNoVm5vZGUodm5vZGVUb01vdmUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBvbGRDaFtpZHhJbk9sZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgdm5vZGVUb01vdmUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNhbWUga2V5IGJ1dCBkaWZmZXJlbnQgZWxlbWVudC4gdHJlYXQgYXMgbmV3IGVsZW1lbnRcbiAgICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGZhbHNlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgcmVmRWxtID0gaXNVbmRlZihuZXdDaFtuZXdFbmRJZHggKyAxXSkgPyBudWxsIDogbmV3Q2hbbmV3RW5kSWR4ICsgMV0uZWxtO1xuICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tEdXBsaWNhdGVLZXlzIChjaGlsZHJlbikge1xuICAgIHZhciBzZWVuS2V5cyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2bm9kZSA9IGNoaWxkcmVuW2ldO1xuICAgICAgdmFyIGtleSA9IHZub2RlLmtleTtcbiAgICAgIGlmIChpc0RlZihrZXkpKSB7XG4gICAgICAgIGlmIChzZWVuS2V5c1trZXldKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIChcIkR1cGxpY2F0ZSBrZXlzIGRldGVjdGVkOiAnXCIgKyBrZXkgKyBcIicuIFRoaXMgbWF5IGNhdXNlIGFuIHVwZGF0ZSBlcnJvci5cIiksXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWVuS2V5c1trZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRJZHhJbk9sZCAobm9kZSwgb2xkQ2gsIHN0YXJ0LCBlbmQpIHtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdmFyIGMgPSBvbGRDaFtpXTtcbiAgICAgIGlmIChpc0RlZihjKSAmJiBzYW1lVm5vZGUobm9kZSwgYykpIHsgcmV0dXJuIGkgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGNoVm5vZGUgKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgaWYgKG9sZFZub2RlID09PSB2bm9kZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGVsbSA9IHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbTtcblxuICAgIGlmIChpc1RydWUob2xkVm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyKSkge1xuICAgICAgaWYgKGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgaHlkcmF0ZShvbGRWbm9kZS5lbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHJldXNlIGVsZW1lbnQgZm9yIHN0YXRpYyB0cmVlcy5cbiAgICAvLyBub3RlIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIC1cbiAgICAvLyBpZiB0aGUgbmV3IG5vZGUgaXMgbm90IGNsb25lZCBpdCBtZWFucyB0aGUgcmVuZGVyIGZ1bmN0aW9ucyBoYXZlIGJlZW5cbiAgICAvLyByZXNldCBieSB0aGUgaG90LXJlbG9hZC1hcGkgYW5kIHdlIG5lZWQgdG8gZG8gYSBwcm9wZXIgcmUtcmVuZGVyLlxuICAgIGlmIChpc1RydWUodm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICBpc1RydWUob2xkVm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICB2bm9kZS5rZXkgPT09IG9sZFZub2RlLmtleSAmJlxuICAgICAgKGlzVHJ1ZSh2bm9kZS5pc0Nsb25lZCkgfHwgaXNUcnVlKHZub2RlLmlzT25jZSkpXG4gICAgKSB7XG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wcmVwYXRjaCkpIHtcbiAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICB9XG5cbiAgICB2YXIgb2xkQ2ggPSBvbGRWbm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgY2ggPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnVwZGF0ZS5sZW5ndGg7ICsraSkgeyBjYnMudXBkYXRlW2ldKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS51cGRhdGUpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNVbmRlZih2bm9kZS50ZXh0KSkge1xuICAgICAgaWYgKGlzRGVmKG9sZENoKSAmJiBpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKG9sZENoICE9PSBjaCkgeyB1cGRhdGVDaGlsZHJlbihlbG0sIG9sZENoLCBjaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTsgfVxuICAgICAgfSBlbHNlIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7IG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7IH1cbiAgICAgICAgYWRkVm5vZGVzKGVsbSwgbnVsbCwgY2gsIDAsIGNoLmxlbmd0aCAtIDEsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZENoKSkge1xuICAgICAgICByZW1vdmVWbm9kZXMoZWxtLCBvbGRDaCwgMCwgb2xkQ2gubGVuZ3RoIC0gMSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvbGRWbm9kZS50ZXh0ICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgdm5vZGUudGV4dCk7XG4gICAgfVxuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnBvc3RwYXRjaCkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlSW5zZXJ0SG9vayAodm5vZGUsIHF1ZXVlLCBpbml0aWFsKSB7XG4gICAgLy8gZGVsYXkgaW5zZXJ0IGhvb2tzIGZvciBjb21wb25lbnQgcm9vdCBub2RlcywgaW52b2tlIHRoZW0gYWZ0ZXIgdGhlXG4gICAgLy8gZWxlbWVudCBpcyByZWFsbHkgaW5zZXJ0ZWRcbiAgICBpZiAoaXNUcnVlKGluaXRpYWwpICYmIGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgIHZub2RlLnBhcmVudC5kYXRhLnBlbmRpbmdJbnNlcnQgPSBxdWV1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBxdWV1ZVtpXS5kYXRhLmhvb2suaW5zZXJ0KHF1ZXVlW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgaHlkcmF0aW9uQmFpbGVkID0gZmFsc2U7XG4gIC8vIGxpc3Qgb2YgbW9kdWxlcyB0aGF0IGNhbiBza2lwIGNyZWF0ZSBob29rIGR1cmluZyBoeWRyYXRpb24gYmVjYXVzZSB0aGV5XG4gIC8vIGFyZSBhbHJlYWR5IHJlbmRlcmVkIG9uIHRoZSBjbGllbnQgb3IgaGFzIG5vIG5lZWQgZm9yIGluaXRpYWxpemF0aW9uXG4gIC8vIE5vdGU6IHN0eWxlIGlzIGV4Y2x1ZGVkIGJlY2F1c2UgaXQgcmVsaWVzIG9uIGluaXRpYWwgY2xvbmUgZm9yIGZ1dHVyZVxuICAvLyBkZWVwIHVwZGF0ZXMgKCM3MDYzKS5cbiAgdmFyIGlzUmVuZGVyZWRNb2R1bGUgPSBtYWtlTWFwKCdhdHRycyxjbGFzcyxzdGF0aWNDbGFzcyxzdGF0aWNTdHlsZSxrZXknKTtcblxuICAvLyBOb3RlOiB0aGlzIGlzIGEgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uIHNvIHdlIGNhbiBhc3N1bWUgZWxtcyBhcmUgRE9NIG5vZGVzLlxuICBmdW5jdGlvbiBoeWRyYXRlIChlbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkge1xuICAgIHZhciBpO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGluVlByZSA9IGluVlByZSB8fCAoZGF0YSAmJiBkYXRhLnByZSk7XG4gICAgdm5vZGUuZWxtID0gZWxtO1xuXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpICYmIGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeSkpIHtcbiAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICAvLyBhc3NlcnQgbm9kZSBtYXRjaFxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIWFzc2VydE5vZGVNYXRjaChlbG0sIHZub2RlLCBpblZQcmUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkgeyBpKHZub2RlLCB0cnVlIC8qIGh5ZHJhdGluZyAqLyk7IH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIC8vIGNoaWxkIGNvbXBvbmVudC4gaXQgc2hvdWxkIGhhdmUgaHlkcmF0ZWQgaXRzIG93biB0cmVlLlxuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKGlzRGVmKGNoaWxkcmVuKSkge1xuICAgICAgICAvLyBlbXB0eSBlbGVtZW50LCBhbGxvdyBjbGllbnQgdG8gcGljayB1cCBhbmQgcG9wdWxhdGUgY2hpbGRyZW5cbiAgICAgICAgaWYgKCFlbG0uaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHYtaHRtbCBhbmQgZG9tUHJvcHM6IGlubmVySFRNTFxuICAgICAgICAgIGlmIChpc0RlZihpID0gZGF0YSkgJiYgaXNEZWYoaSA9IGkuZG9tUHJvcHMpICYmIGlzRGVmKGkgPSBpLmlubmVySFRNTCkpIHtcbiAgICAgICAgICAgIGlmIChpICE9PSBlbG0uaW5uZXJIVE1MKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3NlcnZlciBpbm5lckhUTUw6ICcsIGkpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignY2xpZW50IGlubmVySFRNTDogJywgZWxtLmlubmVySFRNTCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGl0ZXJhdGUgYW5kIGNvbXBhcmUgY2hpbGRyZW4gbGlzdHNcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbk1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBlbG0uZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICAgICAgaWYgKCFjaGlsZE5vZGUgfHwgIWh5ZHJhdGUoY2hpbGROb2RlLCBjaGlsZHJlbltpJDFdLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbk1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBjaGlsZE5vZGUgaXMgbm90IG51bGwsIGl0IG1lYW5zIHRoZSBhY3R1YWwgY2hpbGROb2RlcyBsaXN0IGlzXG4gICAgICAgICAgICAvLyBsb25nZXIgdGhhbiB0aGUgdmlydHVhbCBjaGlsZHJlbiBsaXN0LlxuICAgICAgICAgICAgaWYgKCFjaGlsZHJlbk1hdGNoIHx8IGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAhaHlkcmF0aW9uQmFpbGVkXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdNaXNtYXRjaGluZyBjaGlsZE5vZGVzIHZzLiBWTm9kZXM6ICcsIGVsbS5jaGlsZE5vZGVzLCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgdmFyIGZ1bGxJbnZva2UgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICBpZiAoIWlzUmVuZGVyZWRNb2R1bGUoa2V5KSkge1xuICAgICAgICAgICAgZnVsbEludm9rZSA9IHRydWU7XG4gICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZnVsbEludm9rZSAmJiBkYXRhWydjbGFzcyddKSB7XG4gICAgICAgICAgLy8gZW5zdXJlIGNvbGxlY3RpbmcgZGVwcyBmb3IgZGVlcCBjbGFzcyBiaW5kaW5ncyBmb3IgZnV0dXJlIHVwZGF0ZXNcbiAgICAgICAgICB0cmF2ZXJzZShkYXRhWydjbGFzcyddKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWxtLmRhdGEgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIGVsbS5kYXRhID0gdm5vZGUudGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydE5vZGVNYXRjaCAobm9kZSwgdm5vZGUsIGluVlByZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS50YWcpKSB7XG4gICAgICByZXR1cm4gdm5vZGUudGFnLmluZGV4T2YoJ3Z1ZS1jb21wb25lbnQnKSA9PT0gMCB8fCAoXG4gICAgICAgICFpc1Vua25vd25FbGVtZW50JCQxKHZub2RlLCBpblZQcmUpICYmXG4gICAgICAgIHZub2RlLnRhZy50b0xvd2VyQ2FzZSgpID09PSAobm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gKHZub2RlLmlzQ29tbWVudCA/IDggOiAzKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBwYXRjaCAob2xkVm5vZGUsIHZub2RlLCBoeWRyYXRpbmcsIHJlbW92ZU9ubHksIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgaWYgKGlzVW5kZWYodm5vZGUpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkVm5vZGUpKSB7IGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTsgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGlzSW5pdGlhbFBhdGNoID0gZmFsc2U7XG4gICAgdmFyIGluc2VydGVkVm5vZGVRdWV1ZSA9IFtdO1xuXG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUpKSB7XG4gICAgICAvLyBlbXB0eSBtb3VudCAobGlrZWx5IGFzIGNvbXBvbmVudCksIGNyZWF0ZSBuZXcgcm9vdCBlbGVtZW50XG4gICAgICBpc0luaXRpYWxQYXRjaCA9IHRydWU7XG4gICAgICBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXNSZWFsRWxlbWVudCA9IGlzRGVmKG9sZFZub2RlLm5vZGVUeXBlKTtcbiAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xuICAgICAgICAvLyBwYXRjaCBleGlzdGluZyByb290IG5vZGVcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNSZWFsRWxlbWVudCkge1xuICAgICAgICAgIC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCBhbmQgaWYgd2UgY2FuIHBlcmZvcm1cbiAgICAgICAgICAvLyBhIHN1Y2Nlc3NmdWwgaHlkcmF0aW9uLlxuICAgICAgICAgIGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoU1NSX0FUVFIpKSB7XG4gICAgICAgICAgICBvbGRWbm9kZS5yZW1vdmVBdHRyaWJ1dGUoU1NSX0FUVFIpO1xuICAgICAgICAgICAgaHlkcmF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzVHJ1ZShoeWRyYXRpbmcpKSB7XG4gICAgICAgICAgICBpZiAoaHlkcmF0ZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG9sZFZub2RlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAnVGhlIGNsaWVudC1zaWRlIHJlbmRlcmVkIHZpcnR1YWwgRE9NIHRyZWUgaXMgbm90IG1hdGNoaW5nICcgK1xuICAgICAgICAgICAgICAgICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICtcbiAgICAgICAgICAgICAgICAnSFRNTCBtYXJrdXAsIGZvciBleGFtcGxlIG5lc3RpbmcgYmxvY2stbGV2ZWwgZWxlbWVudHMgaW5zaWRlICcgK1xuICAgICAgICAgICAgICAgICc8cD4sIG9yIG1pc3NpbmcgPHRib2R5Pi4gQmFpbGluZyBoeWRyYXRpb24gYW5kIHBlcmZvcm1pbmcgJyArXG4gICAgICAgICAgICAgICAgJ2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZWl0aGVyIG5vdCBzZXJ2ZXItcmVuZGVyZWQsIG9yIGh5ZHJhdGlvbiBmYWlsZWQuXG4gICAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IG5vZGUgYW5kIHJlcGxhY2UgaXRcbiAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlcGxhY2luZyBleGlzdGluZyBlbGVtZW50XG4gICAgICAgIHZhciBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICAgIHZhciBwYXJlbnRFbG0kMSA9IG5vZGVPcHMucGFyZW50Tm9kZShvbGRFbG0pO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgbm9kZVxuICAgICAgICBjcmVhdGVFbG0oXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgICAgICAgIC8vIGV4dHJlbWVseSByYXJlIGVkZ2UgY2FzZTogZG8gbm90IGluc2VydCBpZiBvbGQgZWxlbWVudCBpcyBpbiBhXG4gICAgICAgICAgLy8gbGVhdmluZyB0cmFuc2l0aW9uLiBPbmx5IGhhcHBlbnMgd2hlbiBjb21iaW5pbmcgdHJhbnNpdGlvbiArXG4gICAgICAgICAgLy8ga2VlcC1hbGl2ZSArIEhPQ3MuICgjNDU5MClcbiAgICAgICAgICBvbGRFbG0uX2xlYXZlQ2IgPyBudWxsIDogcGFyZW50RWxtJDEsXG4gICAgICAgICAgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbG0pXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHBhcmVudCBwbGFjZWhvbGRlciBub2RlIGVsZW1lbnQsIHJlY3Vyc2l2ZWx5XG4gICAgICAgIGlmIChpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGUucGFyZW50O1xuICAgICAgICAgIHZhciBwYXRjaGFibGUgPSBpc1BhdGNoYWJsZSh2bm9kZSk7XG4gICAgICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGNicy5kZXN0cm95W2ldKGFuY2VzdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuY2VzdG9yLmVsbSA9IHZub2RlLmVsbTtcbiAgICAgICAgICAgIGlmIChwYXRjaGFibGUpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICAgICAgICAgICAgY2JzLmNyZWF0ZVtpJDFdKGVtcHR5Tm9kZSwgYW5jZXN0b3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vICM2NTEzXG4gICAgICAgICAgICAgIC8vIGludm9rZSBpbnNlcnQgaG9va3MgdGhhdCBtYXkgaGF2ZSBiZWVuIG1lcmdlZCBieSBjcmVhdGUgaG9va3MuXG4gICAgICAgICAgICAgIC8vIGUuZy4gZm9yIGRpcmVjdGl2ZXMgdGhhdCB1c2VzIHRoZSBcImluc2VydGVkXCIgaG9vay5cbiAgICAgICAgICAgICAgdmFyIGluc2VydCA9IGFuY2VzdG9yLmRhdGEuaG9vay5pbnNlcnQ7XG4gICAgICAgICAgICAgIGlmIChpbnNlcnQubWVyZ2VkKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgYXQgaW5kZXggMSB0byBhdm9pZCByZS1pbnZva2luZyBjb21wb25lbnQgbW91bnRlZCBob29rXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSQyID0gMTsgaSQyIDwgaW5zZXJ0LmZucy5sZW5ndGg7IGkkMisrKSB7XG4gICAgICAgICAgICAgICAgICBpbnNlcnQuZm5zW2kkMl0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlZ2lzdGVyUmVmKGFuY2VzdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRlc3Ryb3kgb2xkIG5vZGVcbiAgICAgICAgaWYgKGlzRGVmKHBhcmVudEVsbSQxKSkge1xuICAgICAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0kMSwgW29sZFZub2RlXSwgMCwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGFnKSkge1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaXNJbml0aWFsUGF0Y2gpO1xuICAgIHJldHVybiB2bm9kZS5lbG1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGRpcmVjdGl2ZXMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgdXBkYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICBkZXN0cm95OiBmdW5jdGlvbiB1bmJpbmREaXJlY3RpdmVzICh2bm9kZSkge1xuICAgIHVwZGF0ZURpcmVjdGl2ZXModm5vZGUsIGVtcHR5Tm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlRGlyZWN0aXZlcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMgfHwgdm5vZGUuZGF0YS5kaXJlY3RpdmVzKSB7XG4gICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF91cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgaXNEZXN0cm95ID0gdm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIG9sZERpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcbiAgdmFyIG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcblxuICB2YXIgZGlyc1dpdGhJbnNlcnQgPSBbXTtcbiAgdmFyIGRpcnNXaXRoUG9zdHBhdGNoID0gW107XG5cbiAgdmFyIGtleSwgb2xkRGlyLCBkaXI7XG4gIGZvciAoa2V5IGluIG5ld0RpcnMpIHtcbiAgICBvbGREaXIgPSBvbGREaXJzW2tleV07XG4gICAgZGlyID0gbmV3RGlyc1trZXldO1xuICAgIGlmICghb2xkRGlyKSB7XG4gICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG4gICAgICBjYWxsSG9vayQxKGRpciwgJ2JpbmQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5pbnNlcnRlZCkge1xuICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXG4gICAgICBkaXIub2xkVmFsdWUgPSBvbGREaXIudmFsdWU7XG4gICAgICBjYWxsSG9vayQxKGRpciwgJ3VwZGF0ZScsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmNvbXBvbmVudFVwZGF0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhQb3N0cGF0Y2gucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aEluc2VydC5sZW5ndGgpIHtcbiAgICB2YXIgY2FsbEluc2VydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhJbnNlcnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aEluc2VydFtpXSwgJ2luc2VydGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpc0NyZWF0ZSkge1xuICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCBjYWxsSW5zZXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbEluc2VydCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGgpIHtcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aFBvc3RwYXRjaFtpXSwgJ2NvbXBvbmVudFVwZGF0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKCFpc0NyZWF0ZSkge1xuICAgIGZvciAoa2V5IGluIG9sZERpcnMpIHtcbiAgICAgIGlmICghbmV3RGlyc1trZXldKSB7XG4gICAgICAgIC8vIG5vIGxvbmdlciBwcmVzZW50LCB1bmJpbmRcbiAgICAgICAgY2FsbEhvb2skMShvbGREaXJzW2tleV0sICd1bmJpbmQnLCBvbGRWbm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBlbXB0eU1vZGlmaWVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSAoXG4gIGRpcnMsXG4gIHZtXG4pIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmICghZGlycykge1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHJldHVybiByZXNcbiAgfVxuICB2YXIgaSwgZGlyO1xuICBmb3IgKGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgaWYgKCFkaXIubW9kaWZpZXJzKSB7XG4gICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgIGRpci5tb2RpZmllcnMgPSBlbXB0eU1vZGlmaWVycztcbiAgICB9XG4gICAgcmVzW2dldFJhd0Rpck5hbWUoZGlyKV0gPSBkaXI7XG4gICAgZGlyLmRlZiA9IHJlc29sdmVBc3NldCh2bS4kb3B0aW9ucywgJ2RpcmVjdGl2ZXMnLCBkaXIubmFtZSwgdHJ1ZSk7XG4gIH1cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2V0UmF3RGlyTmFtZSAoZGlyKSB7XG4gIHJldHVybiBkaXIucmF3TmFtZSB8fCAoKGRpci5uYW1lKSArIFwiLlwiICsgKE9iamVjdC5rZXlzKGRpci5tb2RpZmllcnMgfHwge30pLmpvaW4oJy4nKSkpXG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rJDEgKGRpciwgaG9vaywgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpIHtcbiAgdmFyIGZuID0gZGlyLmRlZiAmJiBkaXIuZGVmW2hvb2tdO1xuICBpZiAoZm4pIHtcbiAgICB0cnkge1xuICAgICAgZm4odm5vZGUuZWxtLCBkaXIsIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bm9kZS5jb250ZXh0LCAoXCJkaXJlY3RpdmUgXCIgKyAoZGlyLm5hbWUpICsgXCIgXCIgKyBob29rICsgXCIgaG9va1wiKSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBiYXNlTW9kdWxlcyA9IFtcbiAgcmVmLFxuICBkaXJlY3RpdmVzXG5dXG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVBdHRycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBvcHRzID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGlzRGVmKG9wdHMpICYmIG9wdHMuQ3Rvci5vcHRpb25zLmluaGVyaXRBdHRycyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmF0dHJzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuYXR0cnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyLCBvbGQ7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRBdHRycyA9IG9sZFZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIHZhciBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYoYXR0cnMuX19vYl9fKSkge1xuICAgIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYXR0cnMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gYXR0cnMpIHtcbiAgICBjdXIgPSBhdHRyc1trZXldO1xuICAgIG9sZCA9IG9sZEF0dHJzW2tleV07XG4gICAgaWYgKG9sZCAhPT0gY3VyKSB7XG4gICAgICBzZXRBdHRyKGVsbSwga2V5LCBjdXIpO1xuICAgIH1cbiAgfVxuICAvLyAjNDM5MTogaW4gSUU5LCBzZXR0aW5nIHR5cGUgY2FuIHJlc2V0IHZhbHVlIGZvciBpbnB1dFt0eXBlPXJhZGlvXVxuICAvLyAjNjY2NjogSUUvRWRnZSBmb3JjZXMgcHJvZ3Jlc3MgdmFsdWUgZG93biB0byAxIGJlZm9yZSBzZXR0aW5nIGEgbWF4XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoKGlzSUUgfHwgaXNFZGdlKSAmJiBhdHRycy52YWx1ZSAhPT0gb2xkQXR0cnMudmFsdWUpIHtcbiAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xuICB9XG4gIGZvciAoa2V5IGluIG9sZEF0dHJzKSB7XG4gICAgaWYgKGlzVW5kZWYoYXR0cnNba2V5XSkpIHtcbiAgICAgIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gIGlmIChlbC50YWdOYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzQm9vbGVhbkF0dHIoa2V5KSkge1xuICAgIC8vIHNldCBhdHRyaWJ1dGUgZm9yIGJsYW5rIHZhbHVlXG4gICAgLy8gZS5nLiA8b3B0aW9uIGRpc2FibGVkPlNlbGVjdCBvbmU8L29wdGlvbj5cbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0ZWNobmljYWxseSBhbGxvd2Z1bGxzY3JlZW4gaXMgYSBib29sZWFuIGF0dHJpYnV0ZSBmb3IgPGlmcmFtZT4sXG4gICAgICAvLyBidXQgRmxhc2ggZXhwZWN0cyBhIHZhbHVlIG9mIFwidHJ1ZVwiIHdoZW4gdXNlZCBvbiA8ZW1iZWQ+IHRhZ1xuICAgICAgdmFsdWUgPSBrZXkgPT09ICdhbGxvd2Z1bGxzY3JlZW4nICYmIGVsLnRhZ05hbWUgPT09ICdFTUJFRCdcbiAgICAgICAgPyAndHJ1ZSdcbiAgICAgICAgOiBrZXk7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpIHx8IHZhbHVlID09PSAnZmFsc2UnID8gJ2ZhbHNlJyA6ICd0cnVlJyk7XG4gIH0gZWxzZSBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBiYXNlU2V0QXR0cihlbCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZVNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICB9IGVsc2Uge1xuICAgIC8vICM3MTM4OiBJRTEwICYgMTEgZmlyZXMgaW5wdXQgZXZlbnQgd2hlbiBzZXR0aW5nIHBsYWNlaG9sZGVyIG9uXG4gICAgLy8gPHRleHRhcmVhPi4uLiBibG9jayB0aGUgZmlyc3QgaW5wdXQgZXZlbnQgYW5kIHJlbW92ZSB0aGUgYmxvY2tlclxuICAgIC8vIGltbWVkaWF0ZWx5LlxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChcbiAgICAgIGlzSUUgJiYgIWlzSUU5ICYmXG4gICAgICBlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnICYmXG4gICAgICBrZXkgPT09ICdwbGFjZWhvbGRlcicgJiYgIWVsLl9faWVwaFxuICAgICkge1xuICAgICAgdmFyIGJsb2NrZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIGJsb2NrZXIpO1xuICAgICAgfTtcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgYmxvY2tlcik7XG4gICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgIGVsLl9faWVwaCA9IHRydWU7IC8qIElFIHBsYWNlaG9sZGVyIHBhdGNoZWQgKi9cbiAgICB9XG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICB9XG59XG5cbnZhciBhdHRycyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVBdHRycyxcbiAgdXBkYXRlOiB1cGRhdGVBdHRyc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICBpZiAoXG4gICAgaXNVbmRlZihkYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgIGlzVW5kZWYoZGF0YS5jbGFzcykgJiYgKFxuICAgICAgaXNVbmRlZihvbGREYXRhKSB8fCAoXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLmNsYXNzKVxuICAgICAgKVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xuICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xuICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xuICB9XG5cbiAgLy8gc2V0IHRoZSBjbGFzc1xuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgfVxufVxuXG52YXIga2xhc3MgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gIHVwZGF0ZTogdXBkYXRlQ2xhc3Ncbn1cblxuLyogICovXG5cbi8qICAqL1xuXG5cblxuXG5cblxuXG5cblxuLy8gYWRkIGEgcmF3IGF0dHIgKHVzZSB0aGlzIGluIHByZVRyYW5zZm9ybXMpXG5cblxuXG5cblxuXG5cblxuLy8gbm90ZTogdGhpcyBvbmx5IHJlbW92ZXMgdGhlIGF0dHIgZnJvbSB0aGUgQXJyYXkgKGF0dHJzTGlzdCkgc28gdGhhdCBpdFxuLy8gZG9lc24ndCBnZXQgcHJvY2Vzc2VkIGJ5IHByb2Nlc3NBdHRycy5cbi8vIEJ5IGRlZmF1bHQgaXQgZG9lcyBOT1QgcmVtb3ZlIGl0IGZyb20gdGhlIG1hcCAoYXR0cnNNYXApIGJlY2F1c2UgdGhlIG1hcCBpc1xuLy8gbmVlZGVkIGR1cmluZyBjb2RlZ2VuLlxuXG4vKiAgKi9cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlIGdlbmVyYXRpb24gZm9yIGNvbXBvbmVudCB2LW1vZGVsXG4gKi9cblxuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGVnZW4gaGVscGVyIGZvciBnZW5lcmF0aW5nIHYtbW9kZWwgdmFsdWUgYXNzaWdubWVudCBjb2RlLlxuICovXG5cbi8qICAqL1xuXG4vLyBpbiBzb21lIGNhc2VzLCB0aGUgZXZlbnQgdXNlZCBoYXMgdG8gYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lXG4vLyBzbyB3ZSB1c2VkIHNvbWUgcmVzZXJ2ZWQgdG9rZW5zIGR1cmluZyBjb21waWxlLlxudmFyIFJBTkdFX1RPS0VOID0gJ19fcic7XG52YXIgQ0hFQ0tCT1hfUkFESU9fVE9LRU4gPSAnX19jJztcblxuLyogICovXG5cbi8vIG5vcm1hbGl6ZSB2LW1vZGVsIGV2ZW50IHRva2VucyB0aGF0IGNhbiBvbmx5IGJlIGRldGVybWluZWQgYXQgcnVudGltZS5cbi8vIGl0J3MgaW1wb3J0YW50IHRvIHBsYWNlIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgaW4gdGhlIGFycmF5IGJlY2F1c2Vcbi8vIHRoZSB3aG9sZSBwb2ludCBpcyBlbnN1cmluZyB0aGUgdi1tb2RlbCBjYWxsYmFjayBnZXRzIGNhbGxlZCBiZWZvcmVcbi8vIHVzZXItYXR0YWNoZWQgaGFuZGxlcnMuXG5mdW5jdGlvbiBub3JtYWxpemVFdmVudHMgKG9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYob25bUkFOR0VfVE9LRU5dKSkge1xuICAgIC8vIElFIGlucHV0W3R5cGU9cmFuZ2VdIG9ubHkgc3VwcG9ydHMgYGNoYW5nZWAgZXZlbnRcbiAgICB2YXIgZXZlbnQgPSBpc0lFID8gJ2NoYW5nZScgOiAnaW5wdXQnO1xuICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltSQU5HRV9UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW1JBTkdFX1RPS0VOXTtcbiAgfVxuICAvLyBUaGlzIHdhcyBvcmlnaW5hbGx5IGludGVuZGVkIHRvIGZpeCAjNDUyMSBidXQgbm8gbG9uZ2VyIG5lY2Vzc2FyeVxuICAvLyBhZnRlciAyLjUuIEtlZXBpbmcgaXQgZm9yIGJhY2t3YXJkcyBjb21wYXQgd2l0aCBnZW5lcmF0ZWQgY29kZSBmcm9tIDwgMi40XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dKSkge1xuICAgIG9uLmNoYW5nZSA9IFtdLmNvbmNhdChvbltDSEVDS0JPWF9SQURJT19UT0tFTl0sIG9uLmNoYW5nZSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0JDE7XG5cbmZ1bmN0aW9uIGNyZWF0ZU9uY2VIYW5kbGVyIChoYW5kbGVyLCBldmVudCwgY2FwdHVyZSkge1xuICB2YXIgX3RhcmdldCA9IHRhcmdldCQxOyAvLyBzYXZlIGN1cnJlbnQgdGFyZ2V0IGVsZW1lbnQgaW4gY2xvc3VyZVxuICByZXR1cm4gZnVuY3Rpb24gb25jZUhhbmRsZXIgKCkge1xuICAgIHZhciByZXMgPSBoYW5kbGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgICAgcmVtb3ZlJDIoZXZlbnQsIG9uY2VIYW5kbGVyLCBjYXB0dXJlLCBfdGFyZ2V0KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkJDEgKFxuICBldmVudCxcbiAgaGFuZGxlcixcbiAgb25jZSQkMSxcbiAgY2FwdHVyZSxcbiAgcGFzc2l2ZVxuKSB7XG4gIGhhbmRsZXIgPSB3aXRoTWFjcm9UYXNrKGhhbmRsZXIpO1xuICBpZiAob25jZSQkMSkgeyBoYW5kbGVyID0gY3JlYXRlT25jZUhhbmRsZXIoaGFuZGxlciwgZXZlbnQsIGNhcHR1cmUpOyB9XG4gIHRhcmdldCQxLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgZXZlbnQsXG4gICAgaGFuZGxlcixcbiAgICBzdXBwb3J0c1Bhc3NpdmVcbiAgICAgID8geyBjYXB0dXJlOiBjYXB0dXJlLCBwYXNzaXZlOiBwYXNzaXZlIH1cbiAgICAgIDogY2FwdHVyZVxuICApO1xufVxuXG5mdW5jdGlvbiByZW1vdmUkMiAoXG4gIGV2ZW50LFxuICBoYW5kbGVyLFxuICBjYXB0dXJlLFxuICBfdGFyZ2V0XG4pIHtcbiAgKF90YXJnZXQgfHwgdGFyZ2V0JDEpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgZXZlbnQsXG4gICAgaGFuZGxlci5fd2l0aFRhc2sgfHwgaGFuZGxlcixcbiAgICBjYXB0dXJlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTUxpc3RlbmVycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEub24pICYmIGlzVW5kZWYodm5vZGUuZGF0YS5vbikpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb24gPSB2bm9kZS5kYXRhLm9uIHx8IHt9O1xuICB2YXIgb2xkT24gPSBvbGRWbm9kZS5kYXRhLm9uIHx8IHt9O1xuICB0YXJnZXQkMSA9IHZub2RlLmVsbTtcbiAgbm9ybWFsaXplRXZlbnRzKG9uKTtcbiAgdXBkYXRlTGlzdGVuZXJzKG9uLCBvbGRPbiwgYWRkJDEsIHJlbW92ZSQyLCB2bm9kZS5jb250ZXh0KTtcbiAgdGFyZ2V0JDEgPSB1bmRlZmluZWQ7XG59XG5cbnZhciBldmVudHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzLFxuICB1cGRhdGU6IHVwZGF0ZURPTUxpc3RlbmVyc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlRE9NUHJvcHMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmRvbVByb3BzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuZG9tUHJvcHMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKHByb3BzLl9fb2JfXykpIHtcbiAgICBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgPSBleHRlbmQoe30sIHByb3BzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKGlzVW5kZWYocHJvcHNba2V5XSkpIHtcbiAgICAgIGVsbVtrZXldID0gJyc7XG4gICAgfVxuICB9XG4gIGZvciAoa2V5IGluIHByb3BzKSB7XG4gICAgY3VyID0gcHJvcHNba2V5XTtcbiAgICAvLyBpZ25vcmUgY2hpbGRyZW4gaWYgdGhlIG5vZGUgaGFzIHRleHRDb250ZW50IG9yIGlubmVySFRNTCxcbiAgICAvLyBhcyB0aGVzZSB3aWxsIHRocm93IGF3YXkgZXhpc3RpbmcgRE9NIG5vZGVzIGFuZCBjYXVzZSByZW1vdmFsIGVycm9yc1xuICAgIC8vIG9uIHN1YnNlcXVlbnQgcGF0Y2hlcyAoIzMzNjApXG4gICAgaWYgKGtleSA9PT0gJ3RleHRDb250ZW50JyB8fCBrZXkgPT09ICdpbm5lckhUTUwnKSB7XG4gICAgICBpZiAodm5vZGUuY2hpbGRyZW4pIHsgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDsgfVxuICAgICAgaWYgKGN1ciA9PT0gb2xkUHJvcHNba2V5XSkgeyBjb250aW51ZSB9XG4gICAgICAvLyAjNjYwMSB3b3JrIGFyb3VuZCBDaHJvbWUgdmVyc2lvbiA8PSA1NSBidWcgd2hlcmUgc2luZ2xlIHRleHROb2RlXG4gICAgICAvLyByZXBsYWNlZCBieSBpbm5lckhUTUwvdGV4dENvbnRlbnQgcmV0YWlucyBpdHMgcGFyZW50Tm9kZSBwcm9wZXJ0eVxuICAgICAgaWYgKGVsbS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBlbG0ucmVtb3ZlQ2hpbGQoZWxtLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICd2YWx1ZScpIHtcbiAgICAgIC8vIHN0b3JlIHZhbHVlIGFzIF92YWx1ZSBhcyB3ZWxsIHNpbmNlXG4gICAgICAvLyBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkXG4gICAgICBlbG0uX3ZhbHVlID0gY3VyO1xuICAgICAgLy8gYXZvaWQgcmVzZXR0aW5nIGN1cnNvciBwb3NpdGlvbiB3aGVuIHZhbHVlIGlzIHRoZSBzYW1lXG4gICAgICB2YXIgc3RyQ3VyID0gaXNVbmRlZihjdXIpID8gJycgOiBTdHJpbmcoY3VyKTtcbiAgICAgIGlmIChzaG91bGRVcGRhdGVWYWx1ZShlbG0sIHN0ckN1cikpIHtcbiAgICAgICAgZWxtLnZhbHVlID0gc3RyQ3VyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbG1ba2V5XSA9IGN1cjtcbiAgICB9XG4gIH1cbn1cblxuLy8gY2hlY2sgcGxhdGZvcm1zL3dlYi91dGlsL2F0dHJzLmpzIGFjY2VwdFZhbHVlXG5cblxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlVmFsdWUgKGVsbSwgY2hlY2tWYWwpIHtcbiAgcmV0dXJuICghZWxtLmNvbXBvc2luZyAmJiAoXG4gICAgZWxtLnRhZ05hbWUgPT09ICdPUFRJT04nIHx8XG4gICAgaXNOb3RJbkZvY3VzQW5kRGlydHkoZWxtLCBjaGVja1ZhbCkgfHxcbiAgICBpc0RpcnR5V2l0aE1vZGlmaWVycyhlbG0sIGNoZWNrVmFsKVxuICApKVxufVxuXG5mdW5jdGlvbiBpc05vdEluRm9jdXNBbmREaXJ0eSAoZWxtLCBjaGVja1ZhbCkge1xuICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHRleHRib3ggKC5udW1iZXIgYW5kIC50cmltKSBsb3NlcyBmb2N1cyBhbmQgaXRzIHZhbHVlIGlzXG4gIC8vIG5vdCBlcXVhbCB0byB0aGUgdXBkYXRlZCB2YWx1ZVxuICB2YXIgbm90SW5Gb2N1cyA9IHRydWU7XG4gIC8vICM2MTU3XG4gIC8vIHdvcmsgYXJvdW5kIElFIGJ1ZyB3aGVuIGFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGluIGFuIGlmcmFtZVxuICB0cnkgeyBub3RJbkZvY3VzID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZWxtOyB9IGNhdGNoIChlKSB7fVxuICByZXR1cm4gbm90SW5Gb2N1cyAmJiBlbG0udmFsdWUgIT09IGNoZWNrVmFsXG59XG5cbmZ1bmN0aW9uIGlzRGlydHlXaXRoTW9kaWZpZXJzIChlbG0sIG5ld1ZhbCkge1xuICB2YXIgdmFsdWUgPSBlbG0udmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSBlbG0uX3ZNb2RpZmllcnM7IC8vIGluamVjdGVkIGJ5IHYtbW9kZWwgcnVudGltZVxuICBpZiAoaXNEZWYobW9kaWZpZXJzKSkge1xuICAgIGlmIChtb2RpZmllcnMubGF6eSkge1xuICAgICAgLy8gaW5wdXRzIHdpdGggbGF6eSBzaG91bGQgb25seSBiZSB1cGRhdGVkIHdoZW4gbm90IGluIGZvY3VzXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy5udW1iZXIpIHtcbiAgICAgIHJldHVybiB0b051bWJlcih2YWx1ZSkgIT09IHRvTnVtYmVyKG5ld1ZhbClcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy50cmltKSB7XG4gICAgICByZXR1cm4gdmFsdWUudHJpbSgpICE9PSBuZXdWYWwudHJpbSgpXG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsXG59XG5cbnZhciBkb21Qcm9wcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01Qcm9wcyxcbiAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xufVxuXG4vKiAgKi9cblxudmFyIHBhcnNlU3R5bGVUZXh0ID0gY2FjaGVkKGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGxpc3REZWxpbWl0ZXIgPSAvOyg/IVteKF0qXFwpKS9nO1xuICB2YXIgcHJvcGVydHlEZWxpbWl0ZXIgPSAvOiguKykvO1xuICBjc3NUZXh0LnNwbGl0KGxpc3REZWxpbWl0ZXIpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgdmFyIHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXIpO1xuICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJlc1t0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG4vLyBtZXJnZSBzdGF0aWMgYW5kIGR5bmFtaWMgc3R5bGUgZGF0YSBvbiB0aGUgc2FtZSB2bm9kZVxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVEYXRhIChkYXRhKSB7XG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyhkYXRhLnN0eWxlKTtcbiAgLy8gc3RhdGljIHN0eWxlIGlzIHByZS1wcm9jZXNzZWQgaW50byBhbiBvYmplY3QgZHVyaW5nIGNvbXBpbGF0aW9uXG4gIC8vIGFuZCBpcyBhbHdheXMgYSBmcmVzaCBvYmplY3QsIHNvIGl0J3Mgc2FmZSB0byBtZXJnZSBpbnRvIGl0XG4gIHJldHVybiBkYXRhLnN0YXRpY1N0eWxlXG4gICAgPyBleHRlbmQoZGF0YS5zdGF0aWNTdHlsZSwgc3R5bGUpXG4gICAgOiBzdHlsZVxufVxuXG4vLyBub3JtYWxpemUgcG9zc2libGUgYXJyYXkgLyBzdHJpbmcgdmFsdWVzIGludG8gT2JqZWN0XG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZUJpbmRpbmcgKGJpbmRpbmdTdHlsZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShiaW5kaW5nU3R5bGUpKSB7XG4gICAgcmV0dXJuIHRvT2JqZWN0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICBpZiAodHlwZW9mIGJpbmRpbmdTdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGFyc2VTdHlsZVRleHQoYmluZGluZ1N0eWxlKVxuICB9XG4gIHJldHVybiBiaW5kaW5nU3R5bGVcbn1cblxuLyoqXG4gKiBwYXJlbnQgY29tcG9uZW50IHN0eWxlIHNob3VsZCBiZSBhZnRlciBjaGlsZCdzXG4gKiBzbyB0aGF0IHBhcmVudCBjb21wb25lbnQncyBzdHlsZSBjb3VsZCBvdmVycmlkZSBpdFxuICovXG5mdW5jdGlvbiBnZXRTdHlsZSAodm5vZGUsIGNoZWNrQ2hpbGQpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgc3R5bGVEYXRhO1xuXG4gIGlmIChjaGVja0NoaWxkKSB7XG4gICAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoXG4gICAgICAgIGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuZGF0YSAmJlxuICAgICAgICAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKGNoaWxkTm9kZS5kYXRhKSlcbiAgICAgICkge1xuICAgICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICgoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHZub2RlLmRhdGEpKSkge1xuICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gIH1cblxuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB3aGlsZSAoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEocGFyZW50Tm9kZS5kYXRhKSkpIHtcbiAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBjc3NWYXJSRSA9IC9eLS0vO1xudmFyIGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XG52YXIgc2V0UHJvcCA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoY3NzVmFyUkUudGVzdChuYW1lKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gIH0gZWxzZSBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xuICB9IGVsc2Uge1xuICAgIHZhciBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZShuYW1lKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAvLyBTdXBwb3J0IHZhbHVlcyBhcnJheSBjcmVhdGVkIGJ5IGF1dG9wcmVmaXhlciwgZS5nLlxuICAgICAgLy8ge2Rpc3BsYXk6IFtcIi13ZWJraXQtYm94XCIsIFwiLW1zLWZsZXhib3hcIiwgXCJmbGV4XCJdfVxuICAgICAgLy8gU2V0IHRoZW0gb25lIGJ5IG9uZSwgYW5kIHRoZSBicm93c2VyIHdpbGwgb25seSBzZXQgdGhvc2UgaXQgY2FuIHJlY29nbml6ZVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWxbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB2ZW5kb3JOYW1lcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xuXG52YXIgZW1wdHlTdHlsZTtcbnZhciBub3JtYWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHByb3ApIHtcbiAgZW1wdHlTdHlsZSA9IGVtcHR5U3R5bGUgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG4gIHByb3AgPSBjYW1lbGl6ZShwcm9wKTtcbiAgaWYgKHByb3AgIT09ICdmaWx0ZXInICYmIChwcm9wIGluIGVtcHR5U3R5bGUpKSB7XG4gICAgcmV0dXJuIHByb3BcbiAgfVxuICB2YXIgY2FwTmFtZSA9IHByb3AuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnNsaWNlKDEpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSB2ZW5kb3JOYW1lc1tpXSArIGNhcE5hbWU7XG4gICAgaWYgKG5hbWUgaW4gZW1wdHlTdHlsZSkge1xuICAgICAgcmV0dXJuIG5hbWVcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB1cGRhdGVTdHlsZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuXG4gIGlmIChpc1VuZGVmKGRhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYoZGF0YS5zdHlsZSkgJiZcbiAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYob2xkRGF0YS5zdHlsZSlcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3VyLCBuYW1lO1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBvbGRTdGF0aWNTdHlsZSA9IG9sZERhdGEuc3RhdGljU3R5bGU7XG4gIHZhciBvbGRTdHlsZUJpbmRpbmcgPSBvbGREYXRhLm5vcm1hbGl6ZWRTdHlsZSB8fCBvbGREYXRhLnN0eWxlIHx8IHt9O1xuXG4gIC8vIGlmIHN0YXRpYyBzdHlsZSBleGlzdHMsIHN0eWxlYmluZGluZyBhbHJlYWR5IG1lcmdlZCBpbnRvIGl0IHdoZW4gZG9pbmcgbm9ybWFsaXplU3R5bGVEYXRhXG4gIHZhciBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcblxuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcodm5vZGUuZGF0YS5zdHlsZSkgfHwge307XG5cbiAgLy8gc3RvcmUgbm9ybWFsaXplZCBzdHlsZSB1bmRlciBhIGRpZmZlcmVudCBrZXkgZm9yIG5leHQgZGlmZlxuICAvLyBtYWtlIHN1cmUgdG8gY2xvbmUgaXQgaWYgaXQncyByZWFjdGl2ZSwgc2luY2UgdGhlIHVzZXIgbGlrZWx5IHdhbnRzXG4gIC8vIHRvIG11dGF0ZSBpdC5cbiAgdm5vZGUuZGF0YS5ub3JtYWxpemVkU3R5bGUgPSBpc0RlZihzdHlsZS5fX29iX18pXG4gICAgPyBleHRlbmQoe30sIHN0eWxlKVxuICAgIDogc3R5bGU7XG5cbiAgdmFyIG5ld1N0eWxlID0gZ2V0U3R5bGUodm5vZGUsIHRydWUpO1xuXG4gIGZvciAobmFtZSBpbiBvbGRTdHlsZSkge1xuICAgIGlmIChpc1VuZGVmKG5ld1N0eWxlW25hbWVdKSkge1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgJycpO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcbiAgICBjdXIgPSBuZXdTdHlsZVtuYW1lXTtcbiAgICBpZiAoY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xuICAgICAgLy8gaWU5IHNldHRpbmcgdG8gbnVsbCBoYXMgbm8gZWZmZWN0LCBtdXN0IHVzZSBlbXB0eSBzdHJpbmdcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsIGN1ciA9PSBudWxsID8gJycgOiBjdXIpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc3R5bGUgPSB7XG4gIGNyZWF0ZTogdXBkYXRlU3R5bGUsXG4gIHVwZGF0ZTogdXBkYXRlU3R5bGVcbn1cblxuLyogICovXG5cbi8qKlxuICogQWRkIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gYWRkQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QuYWRkKGMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgIGlmIChjdXIuaW5kZXhPZignICcgKyBjbHMgKyAnICcpIDwgMCkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIChjdXIgKyBjbHMpLnRyaW0oKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgIH1cbiAgICBpZiAoIWVsLmNsYXNzTGlzdC5sZW5ndGgpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICB2YXIgdGFyID0gJyAnICsgY2xzICsgJyAnO1xuICAgIHdoaWxlIChjdXIuaW5kZXhPZih0YXIpID49IDApIHtcbiAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKHRhciwgJyAnKTtcbiAgICB9XG4gICAgY3VyID0gY3VyLnRyaW0oKTtcbiAgICBpZiAoY3VyKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY3VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb24gKGRlZikge1xuICBpZiAoIWRlZikge1xuICAgIHJldHVyblxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0eXBlb2YgZGVmID09PSAnb2JqZWN0Jykge1xuICAgIHZhciByZXMgPSB7fTtcbiAgICBpZiAoZGVmLmNzcyAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuZChyZXMsIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZi5uYW1lIHx8ICd2JykpO1xuICAgIH1cbiAgICBleHRlbmQocmVzLCBkZWYpO1xuICAgIHJldHVybiByZXNcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBhdXRvQ3NzVHJhbnNpdGlvbihkZWYpXG4gIH1cbn1cblxudmFyIGF1dG9Dc3NUcmFuc2l0aW9uID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiB7XG4gICAgZW50ZXJDbGFzczogKG5hbWUgKyBcIi1lbnRlclwiKSxcbiAgICBlbnRlclRvQ2xhc3M6IChuYW1lICsgXCItZW50ZXItdG9cIiksXG4gICAgZW50ZXJBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1lbnRlci1hY3RpdmVcIiksXG4gICAgbGVhdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZVwiKSxcbiAgICBsZWF2ZVRvQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtdG9cIiksXG4gICAgbGVhdmVBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZS1hY3RpdmVcIilcbiAgfVxufSk7XG5cbnZhciBoYXNUcmFuc2l0aW9uID0gaW5Ccm93c2VyICYmICFpc0lFOTtcbnZhciBUUkFOU0lUSU9OID0gJ3RyYW5zaXRpb24nO1xudmFyIEFOSU1BVElPTiA9ICdhbmltYXRpb24nO1xuXG4vLyBUcmFuc2l0aW9uIHByb3BlcnR5L2V2ZW50IHNuaWZmaW5nXG52YXIgdHJhbnNpdGlvblByb3AgPSAndHJhbnNpdGlvbic7XG52YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3RyYW5zaXRpb25lbmQnO1xudmFyIGFuaW1hdGlvblByb3AgPSAnYW5pbWF0aW9uJztcbnZhciBhbmltYXRpb25FbmRFdmVudCA9ICdhbmltYXRpb25lbmQnO1xuaWYgKGhhc1RyYW5zaXRpb24pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh3aW5kb3cub250cmFuc2l0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgdHJhbnNpdGlvblByb3AgPSAnV2Via2l0VHJhbnNpdGlvbic7XG4gICAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xuICB9XG4gIGlmICh3aW5kb3cub25hbmltYXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIGFuaW1hdGlvblByb3AgPSAnV2Via2l0QW5pbWF0aW9uJztcbiAgICBhbmltYXRpb25FbmRFdmVudCA9ICd3ZWJraXRBbmltYXRpb25FbmQnO1xuICB9XG59XG5cbi8vIGJpbmRpbmcgdG8gd2luZG93IGlzIG5lY2Vzc2FyeSB0byBtYWtlIGhvdCByZWxvYWQgd29yayBpbiBJRSBpbiBzdHJpY3QgbW9kZVxudmFyIHJhZiA9IGluQnJvd3NlclxuICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpXG4gICAgOiBzZXRUaW1lb3V0XG4gIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9O1xuXG5mdW5jdGlvbiBuZXh0RnJhbWUgKGZuKSB7XG4gIHJhZihmdW5jdGlvbiAoKSB7XG4gICAgcmFmKGZuKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZFRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzZXMgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXMgfHwgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyA9IFtdKTtcbiAgaWYgKHRyYW5zaXRpb25DbGFzc2VzLmluZGV4T2YoY2xzKSA8IDApIHtcbiAgICB0cmFuc2l0aW9uQ2xhc3Nlcy5wdXNoKGNscyk7XG4gICAgYWRkQ2xhc3MoZWwsIGNscyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICByZW1vdmUoZWwuX3RyYW5zaXRpb25DbGFzc2VzLCBjbHMpO1xuICB9XG4gIHJlbW92ZUNsYXNzKGVsLCBjbHMpO1xufVxuXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMgKFxuICBlbCxcbiAgZXhwZWN0ZWRUeXBlLFxuICBjYlxuKSB7XG4gIHZhciByZWYgPSBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKTtcbiAgdmFyIHR5cGUgPSByZWYudHlwZTtcbiAgdmFyIHRpbWVvdXQgPSByZWYudGltZW91dDtcbiAgdmFyIHByb3BDb3VudCA9IHJlZi5wcm9wQ291bnQ7XG4gIGlmICghdHlwZSkgeyByZXR1cm4gY2IoKSB9XG4gIHZhciBldmVudCA9IHR5cGUgPT09IFRSQU5TSVRJT04gPyB0cmFuc2l0aW9uRW5kRXZlbnQgOiBhbmltYXRpb25FbmRFdmVudDtcbiAgdmFyIGVuZGVkID0gMDtcbiAgdmFyIGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG4gICAgY2IoKTtcbiAgfTtcbiAgdmFyIG9uRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGVsKSB7XG4gICAgICBpZiAoKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcbiAgICAgICAgZW5kKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcbiAgICAgIGVuZCgpO1xuICAgIH1cbiAgfSwgdGltZW91dCArIDEpO1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG59XG5cbnZhciB0cmFuc2Zvcm1SRSA9IC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS87XG5cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25JbmZvIChlbCwgZXhwZWN0ZWRUeXBlKSB7XG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIHZhciB0cmFuc2l0aW9uRGVsYXlzID0gc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0RlbGF5J10uc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uRHVyYXRpb25zID0gc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XG4gIHZhciBhbmltYXRpb25EZWxheXMgPSBzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uRHVyYXRpb25zID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcblxuICB2YXIgdHlwZTtcbiAgdmFyIHRpbWVvdXQgPSAwO1xuICB2YXIgcHJvcENvdW50ID0gMDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcbiAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gVFJBTlNJVElPTjtcbiAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xuICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IEFOSU1BVElPTjtcbiAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGltZW91dCA9IE1hdGgubWF4KHRyYW5zaXRpb25UaW1lb3V0LCBhbmltYXRpb25UaW1lb3V0KTtcbiAgICB0eXBlID0gdGltZW91dCA+IDBcbiAgICAgID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0XG4gICAgICAgID8gVFJBTlNJVElPTlxuICAgICAgICA6IEFOSU1BVElPTlxuICAgICAgOiBudWxsO1xuICAgIHByb3BDb3VudCA9IHR5cGVcbiAgICAgID8gdHlwZSA9PT0gVFJBTlNJVElPTlxuICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICAgIDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgOiAwO1xuICB9XG4gIHZhciBoYXNUcmFuc2Zvcm0gPVxuICAgIHR5cGUgPT09IFRSQU5TSVRJT04gJiZcbiAgICB0cmFuc2Zvcm1SRS50ZXN0KHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdQcm9wZXJ0eSddKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgcHJvcENvdW50OiBwcm9wQ291bnQsXG4gICAgaGFzVHJhbnNmb3JtOiBoYXNUcmFuc2Zvcm1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUaW1lb3V0IChkZWxheXMsIGR1cmF0aW9ucykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcbiAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gIH1cblxuICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgZHVyYXRpb25zLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgIHJldHVybiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pXG4gIH0pKVxufVxuXG5mdW5jdGlvbiB0b01zIChzKSB7XG4gIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkpICogMTAwMFxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW50ZXIgKHZub2RlLCB0b2dnbGVEaXNwbGF5KSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgZWwuX2xlYXZlQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fbGVhdmVDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBlbnRlckNsYXNzID0gZGF0YS5lbnRlckNsYXNzO1xuICB2YXIgZW50ZXJUb0NsYXNzID0gZGF0YS5lbnRlclRvQ2xhc3M7XG4gIHZhciBlbnRlckFjdGl2ZUNsYXNzID0gZGF0YS5lbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgYXBwZWFyQ2xhc3MgPSBkYXRhLmFwcGVhckNsYXNzO1xuICB2YXIgYXBwZWFyVG9DbGFzcyA9IGRhdGEuYXBwZWFyVG9DbGFzcztcbiAgdmFyIGFwcGVhckFjdGl2ZUNsYXNzID0gZGF0YS5hcHBlYXJBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUVudGVyID0gZGF0YS5iZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVyID0gZGF0YS5lbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXIgPSBkYXRhLmFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZCA9IGRhdGEuZW50ZXJDYW5jZWxsZWQ7XG4gIHZhciBiZWZvcmVBcHBlYXIgPSBkYXRhLmJlZm9yZUFwcGVhcjtcbiAgdmFyIGFwcGVhciA9IGRhdGEuYXBwZWFyO1xuICB2YXIgYWZ0ZXJBcHBlYXIgPSBkYXRhLmFmdGVyQXBwZWFyO1xuICB2YXIgYXBwZWFyQ2FuY2VsbGVkID0gZGF0YS5hcHBlYXJDYW5jZWxsZWQ7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgLy8gYWN0aXZlSW5zdGFuY2Ugd2lsbCBhbHdheXMgYmUgdGhlIDx0cmFuc2l0aW9uPiBjb21wb25lbnQgbWFuYWdpbmcgdGhpc1xuICAvLyB0cmFuc2l0aW9uLiBPbmUgZWRnZSBjYXNlIHRvIGNoZWNrIGlzIHdoZW4gdGhlIDx0cmFuc2l0aW9uPiBpcyBwbGFjZWRcbiAgLy8gYXMgdGhlIHJvb3Qgbm9kZSBvZiBhIGNoaWxkIGNvbXBvbmVudC4gSW4gdGhhdCBjYXNlIHdlIG5lZWQgdG8gY2hlY2tcbiAgLy8gPHRyYW5zaXRpb24+J3MgcGFyZW50IGZvciBhcHBlYXIgY2hlY2suXG4gIHZhciBjb250ZXh0ID0gYWN0aXZlSW5zdGFuY2U7XG4gIHZhciB0cmFuc2l0aW9uTm9kZSA9IGFjdGl2ZUluc3RhbmNlLiR2bm9kZTtcbiAgd2hpbGUgKHRyYW5zaXRpb25Ob2RlICYmIHRyYW5zaXRpb25Ob2RlLnBhcmVudCkge1xuICAgIHRyYW5zaXRpb25Ob2RlID0gdHJhbnNpdGlvbk5vZGUucGFyZW50O1xuICAgIGNvbnRleHQgPSB0cmFuc2l0aW9uTm9kZS5jb250ZXh0O1xuICB9XG5cbiAgdmFyIGlzQXBwZWFyID0gIWNvbnRleHQuX2lzTW91bnRlZCB8fCAhdm5vZGUuaXNSb290SW5zZXJ0O1xuXG4gIGlmIChpc0FwcGVhciAmJiAhYXBwZWFyICYmIGFwcGVhciAhPT0gJycpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzdGFydENsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQ2xhc3NcbiAgICA/IGFwcGVhckNsYXNzXG4gICAgOiBlbnRlckNsYXNzO1xuICB2YXIgYWN0aXZlQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJBY3RpdmVDbGFzc1xuICAgID8gYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA6IGVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciB0b0NsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyVG9DbGFzc1xuICAgID8gYXBwZWFyVG9DbGFzc1xuICAgIDogZW50ZXJUb0NsYXNzO1xuXG4gIHZhciBiZWZvcmVFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGJlZm9yZUFwcGVhciB8fCBiZWZvcmVFbnRlcilcbiAgICA6IGJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/ICh0eXBlb2YgYXBwZWFyID09PSAnZnVuY3Rpb24nID8gYXBwZWFyIDogZW50ZXIpXG4gICAgOiBlbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChhZnRlckFwcGVhciB8fCBhZnRlckVudGVyKVxuICAgIDogYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkSG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYXBwZWFyQ2FuY2VsbGVkIHx8IGVudGVyQ2FuY2VsbGVkKVxuICAgIDogZW50ZXJDYW5jZWxsZWQ7XG5cbiAgdmFyIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5lbnRlclxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24sICdlbnRlcicsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChlbnRlckhvb2spO1xuXG4gIHZhciBjYiA9IGVsLl9lbnRlckNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIH1cbiAgICAgIGVudGVyQ2FuY2VsbGVkSG9vayAmJiBlbnRlckNhbmNlbGxlZEhvb2soZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlckVudGVySG9vayAmJiBhZnRlckVudGVySG9vayhlbCk7XG4gICAgfVxuICAgIGVsLl9lbnRlckNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuICAgICAgaWYgKHBlbmRpbmdOb2RlICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLnRhZyA9PT0gdm5vZGUudGFnICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYlxuICAgICAgKSB7XG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYigpO1xuICAgICAgfVxuICAgICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gc3RhcnQgZW50ZXIgdHJhbnNpdGlvblxuICBiZWZvcmVFbnRlckhvb2sgJiYgYmVmb3JlRW50ZXJIb29rKGVsKTtcbiAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgICAgaWYgKCF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24pKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2bm9kZS5kYXRhLnNob3cpIHtcbiAgICB0b2dnbGVEaXNwbGF5ICYmIHRvZ2dsZURpc3BsYXkoKTtcbiAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gIH1cblxuICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICBjYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxlYXZlICh2bm9kZSwgcm0pIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgZW50ZXIgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikpIHtcbiAgICBlbC5fZW50ZXJDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9lbnRlckNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuIHJtKClcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgbGVhdmVDbGFzcyA9IGRhdGEubGVhdmVDbGFzcztcbiAgdmFyIGxlYXZlVG9DbGFzcyA9IGRhdGEubGVhdmVUb0NsYXNzO1xuICB2YXIgbGVhdmVBY3RpdmVDbGFzcyA9IGRhdGEubGVhdmVBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUxlYXZlID0gZGF0YS5iZWZvcmVMZWF2ZTtcbiAgdmFyIGxlYXZlID0gZGF0YS5sZWF2ZTtcbiAgdmFyIGFmdGVyTGVhdmUgPSBkYXRhLmFmdGVyTGVhdmU7XG4gIHZhciBsZWF2ZUNhbmNlbGxlZCA9IGRhdGEubGVhdmVDYW5jZWxsZWQ7XG4gIHZhciBkZWxheUxlYXZlID0gZGF0YS5kZWxheUxlYXZlO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChsZWF2ZSk7XG5cbiAgdmFyIGV4cGxpY2l0TGVhdmVEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5sZWF2ZVxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzRGVmKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbiwgJ2xlYXZlJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGNiID0gZWwuX2xlYXZlQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIH1cbiAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XG4gICAgfVxuICAgIGVsLl9sZWF2ZUNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XG4gIH0gZWxzZSB7XG4gICAgcGVyZm9ybUxlYXZlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUgKCkge1xuICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxuICAgIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyB8fCAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyA9IHt9KSlbKHZub2RlLmtleSldID0gdm5vZGU7XG4gICAgfVxuICAgIGJlZm9yZUxlYXZlICYmIGJlZm9yZUxlYXZlKGVsKTtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICBpZiAoIWNiLmNhbmNlbGxlZCkge1xuICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgICBpZiAoIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdExlYXZlRHVyYXRpb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgbGVhdmUgJiYgbGVhdmUoZWwsIGNiKTtcbiAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9XG59XG5cbi8vIG9ubHkgdXNlZCBpbiBkZXYgbW9kZVxuZnVuY3Rpb24gY2hlY2tEdXJhdGlvbiAodmFsLCBuYW1lLCB2bm9kZSkge1xuICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gXCIgK1xuICAgICAgXCJnb3QgXCIgKyAoSlNPTi5zdHJpbmdpZnkodmFsKSkgKyBcIi5cIixcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgTmFOIC0gXCIgK1xuICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWxpZER1cmF0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdHJhbnNpdGlvbiBob29rJ3MgYXJndW1lbnQgbGVuZ3RoLiBUaGUgaG9vayBtYXkgYmU6XG4gKiAtIGEgbWVyZ2VkIGhvb2sgKGludm9rZXIpIHdpdGggdGhlIG9yaWdpbmFsIGluIC5mbnNcbiAqIC0gYSB3cmFwcGVkIGNvbXBvbmVudCBtZXRob2QgKGNoZWNrIC5fbGVuZ3RoKVxuICogLSBhIHBsYWluIGZ1bmN0aW9uICgubGVuZ3RoKVxuICovXG5mdW5jdGlvbiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoIChmbikge1xuICBpZiAoaXNVbmRlZihmbikpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB2YXIgaW52b2tlckZucyA9IGZuLmZucztcbiAgaWYgKGlzRGVmKGludm9rZXJGbnMpKSB7XG4gICAgLy8gaW52b2tlclxuICAgIHJldHVybiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKFxuICAgICAgQXJyYXkuaXNBcnJheShpbnZva2VyRm5zKVxuICAgICAgICA/IGludm9rZXJGbnNbMF1cbiAgICAgICAgOiBpbnZva2VyRm5zXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoZm4uX2xlbmd0aCB8fCBmbi5sZW5ndGgpID4gMVxuICB9XG59XG5cbmZ1bmN0aW9uIF9lbnRlciAoXywgdm5vZGUpIHtcbiAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgIGVudGVyKHZub2RlKTtcbiAgfVxufVxuXG52YXIgdHJhbnNpdGlvbiA9IGluQnJvd3NlciA/IHtcbiAgY3JlYXRlOiBfZW50ZXIsXG4gIGFjdGl2YXRlOiBfZW50ZXIsXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlJCQxICh2bm9kZSwgcm0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICAgIGxlYXZlKHZub2RlLCBybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgfVxuICB9XG59IDoge31cblxudmFyIHBsYXRmb3JtTW9kdWxlcyA9IFtcbiAgYXR0cnMsXG4gIGtsYXNzLFxuICBldmVudHMsXG4gIGRvbVByb3BzLFxuICBzdHlsZSxcbiAgdHJhbnNpdGlvblxuXVxuXG4vKiAgKi9cblxuLy8gdGhlIGRpcmVjdGl2ZSBtb2R1bGUgc2hvdWxkIGJlIGFwcGxpZWQgbGFzdCwgYWZ0ZXIgYWxsXG4vLyBidWlsdC1pbiBtb2R1bGVzIGhhdmUgYmVlbiBhcHBsaWVkLlxudmFyIG1vZHVsZXMgPSBwbGF0Zm9ybU1vZHVsZXMuY29uY2F0KGJhc2VNb2R1bGVzKTtcblxudmFyIHBhdGNoID0gY3JlYXRlUGF0Y2hGdW5jdGlvbih7IG5vZGVPcHM6IG5vZGVPcHMsIG1vZHVsZXM6IG1vZHVsZXMgfSk7XG5cbi8qKlxuICogTm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IGxpa2UgYXR0YWNoaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIEVsZW1lbnRzLlxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKGlzSUU5KSB7XG4gIC8vIGh0dHA6Ly93d3cubWF0dHM0MTEuY29tL3Bvc3QvaW50ZXJuZXQtZXhwbG9yZXItOS1vbmlucHV0L1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAoZWwgJiYgZWwudm1vZGVsKSB7XG4gICAgICB0cmlnZ2VyKGVsLCAnaW5wdXQnKTtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgZGlyZWN0aXZlID0ge1xuICBpbnNlcnRlZDogZnVuY3Rpb24gaW5zZXJ0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSwgb2xkVm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgLy8gIzY5MDNcbiAgICAgIGlmIChvbGRWbm9kZS5lbG0gJiYgIW9sZFZub2RlLmVsbS5fdk9wdGlvbnMpIHtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZGlyZWN0aXZlLmNvbXBvbmVudFVwZGF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICB9XG4gICAgICBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgfSBlbHNlIGlmICh2bm9kZS50YWcgPT09ICd0ZXh0YXJlYScgfHwgaXNUZXh0SW5wdXRUeXBlKGVsLnR5cGUpKSB7XG4gICAgICBlbC5fdk1vZGlmaWVycyA9IGJpbmRpbmcubW9kaWZpZXJzO1xuICAgICAgaWYgKCFiaW5kaW5nLm1vZGlmaWVycy5sYXp5KSB7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICAvLyBTYWZhcmkgPCAxMC4yICYgVUlXZWJWaWV3IGRvZXNuJ3QgZmlyZSBjb21wb3NpdGlvbmVuZCB3aGVuXG4gICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcbiAgICAgICAgLy8gdGhpcyBhbHNvIGZpeGVzIHRoZSBpc3N1ZSB3aGVyZSBzb21lIGJyb3dzZXJzIGUuZy4gaU9TIENocm9tZVxuICAgICAgICAvLyBmaXJlcyBcImNoYW5nZVwiIGluc3RlYWQgb2YgXCJpbnB1dFwiIG9uIGF1dG9jb21wbGV0ZS5cbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoaXNJRTkpIHtcbiAgICAgICAgICBlbC52bW9kZWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudFVwZGF0ZWQ6IGZ1bmN0aW9uIGNvbXBvbmVudFVwZGF0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICAvLyBpbiBjYXNlIHRoZSBvcHRpb25zIHJlbmRlcmVkIGJ5IHYtZm9yIGhhdmUgY2hhbmdlZCxcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgdmFsdWUgaXMgb3V0LW9mLXN5bmMgd2l0aCB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAgICAgIC8vIGRldGVjdCBzdWNoIGNhc2VzIGFuZCBmaWx0ZXIgb3V0IHZhbHVlcyB0aGF0IG5vIGxvbmdlciBoYXMgYSBtYXRjaGluZ1xuICAgICAgLy8gb3B0aW9uIGluIHRoZSBET00uXG4gICAgICB2YXIgcHJldk9wdGlvbnMgPSBlbC5fdk9wdGlvbnM7XG4gICAgICB2YXIgY3VyT3B0aW9ucyA9IGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKTtcbiAgICAgIGlmIChjdXJPcHRpb25zLnNvbWUoZnVuY3Rpb24gKG8sIGkpIHsgcmV0dXJuICFsb29zZUVxdWFsKG8sIHByZXZPcHRpb25zW2ldKTsgfSkpIHtcbiAgICAgICAgLy8gdHJpZ2dlciBjaGFuZ2UgZXZlbnQgaWZcbiAgICAgICAgLy8gbm8gbWF0Y2hpbmcgb3B0aW9uIGZvdW5kIGZvciBhdCBsZWFzdCBvbmUgdmFsdWVcbiAgICAgICAgdmFyIG5lZWRSZXNldCA9IGVsLm11bHRpcGxlXG4gICAgICAgICAgPyBiaW5kaW5nLnZhbHVlLnNvbWUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGhhc05vTWF0Y2hpbmdPcHRpb24odiwgY3VyT3B0aW9ucyk7IH0pXG4gICAgICAgICAgOiBiaW5kaW5nLnZhbHVlICE9PSBiaW5kaW5nLm9sZFZhbHVlICYmIGhhc05vTWF0Y2hpbmdPcHRpb24oYmluZGluZy52YWx1ZSwgY3VyT3B0aW9ucyk7XG4gICAgICAgIGlmIChuZWVkUmVzZXQpIHtcbiAgICAgICAgICB0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcbiAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzSUUgfHwgaXNFZGdlKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSk7XG4gICAgfSwgMCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWN0dWFsbHlTZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIHZhciB2YWx1ZSA9IGJpbmRpbmcudmFsdWU7XG4gIHZhciBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XG4gIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPVxcXCJcIiArIChiaW5kaW5nLmV4cHJlc3Npb24pICsgXCJcXFwiPiBcIiArXG4gICAgICBcImV4cGVjdHMgYW4gQXJyYXkgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBidXQgZ290IFwiICsgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpKSxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VsZWN0ZWQsIG9wdGlvbjtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgIHNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBnZXRWYWx1ZShvcHRpb24pKSA+IC0xO1xuICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSkge1xuICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzTXVsdGlwbGUpIHtcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzTm9NYXRjaGluZ09wdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuZXZlcnkoZnVuY3Rpb24gKG8pIHsgcmV0dXJuICFsb29zZUVxdWFsKG8sIHZhbHVlKTsgfSlcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWUgKG9wdGlvbikge1xuICByZXR1cm4gJ192YWx1ZScgaW4gb3B0aW9uXG4gICAgPyBvcHRpb24uX3ZhbHVlXG4gICAgOiBvcHRpb24udmFsdWVcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0IChlKSB7XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQgKGUpIHtcbiAgLy8gcHJldmVudCB0cmlnZ2VyaW5nIGFuIGlucHV0IGV2ZW50IGZvciBubyByZWFzb25cbiAgaWYgKCFlLnRhcmdldC5jb21wb3NpbmcpIHsgcmV0dXJuIH1cbiAgZS50YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XG4gIHRyaWdnZXIoZS50YXJnZXQsICdpbnB1dCcpO1xufVxuXG5mdW5jdGlvbiB0cmlnZ2VyIChlbCwgdHlwZSkge1xuICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gIGUuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xuICBlbC5kaXNwYXRjaEV2ZW50KGUpO1xufVxuXG4vKiAgKi9cblxuLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciBwb3NzaWJsZSB0cmFuc2l0aW9uIGRlZmluZWQgaW5zaWRlIHRoZSBjb21wb25lbnQgcm9vdFxuZnVuY3Rpb24gbG9jYXRlTm9kZSAodm5vZGUpIHtcbiAgcmV0dXJuIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmICghdm5vZGUuZGF0YSB8fCAhdm5vZGUuZGF0YS50cmFuc2l0aW9uKVxuICAgID8gbG9jYXRlTm9kZSh2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUpXG4gICAgOiB2bm9kZVxufVxuXG52YXIgc2hvdyA9IHtcbiAgYmluZDogZnVuY3Rpb24gYmluZCAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG5cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgdmFyIG9yaWdpbmFsRGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA9XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXk7XG4gICAgaWYgKHZhbHVlICYmIHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxEaXNwbGF5O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IG9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuICAgIHZhciBvbGRWYWx1ZSA9IHJlZi5vbGRWYWx1ZTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghdmFsdWUgPT09ICFvbGRWYWx1ZSkgeyByZXR1cm4gfVxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICBpZiAodHJhbnNpdGlvbiQkMSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVhdmUodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWwuX192T3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCAoXG4gICAgZWwsXG4gICAgYmluZGluZyxcbiAgICB2bm9kZSxcbiAgICBvbGRWbm9kZSxcbiAgICBpc0Rlc3Ryb3lcbiAgKSB7XG4gICAgaWYgKCFpc0Rlc3Ryb3kpIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwbGF0Zm9ybURpcmVjdGl2ZXMgPSB7XG4gIG1vZGVsOiBkaXJlY3RpdmUsXG4gIHNob3c6IHNob3dcbn1cblxuLyogICovXG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgYSBzaW5nbGUgZWxlbWVudC9jb21wb25lbnQuXG4vLyBzdXBwb3J0cyB0cmFuc2l0aW9uIG1vZGUgKG91dC1pbiAvIGluLW91dClcblxudmFyIHRyYW5zaXRpb25Qcm9wcyA9IHtcbiAgbmFtZTogU3RyaW5nLFxuICBhcHBlYXI6IEJvb2xlYW4sXG4gIGNzczogQm9vbGVhbixcbiAgbW9kZTogU3RyaW5nLFxuICB0eXBlOiBTdHJpbmcsXG4gIGVudGVyQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVDbGFzczogU3RyaW5nLFxuICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVUb0NsYXNzOiBTdHJpbmcsXG4gIGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJDbGFzczogU3RyaW5nLFxuICBhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXG4gIGR1cmF0aW9uOiBbTnVtYmVyLCBTdHJpbmcsIE9iamVjdF1cbn07XG5cbi8vIGluIGNhc2UgdGhlIGNoaWxkIGlzIGFsc28gYW4gYWJzdHJhY3QgY29tcG9uZW50LCBlLmcuIDxrZWVwLWFsaXZlPlxuLy8gd2Ugd2FudCB0byByZWN1cnNpdmVseSByZXRyaWV2ZSB0aGUgcmVhbCBjb21wb25lbnQgdG8gYmUgcmVuZGVyZWRcbmZ1bmN0aW9uIGdldFJlYWxDaGlsZCAodm5vZGUpIHtcbiAgdmFyIGNvbXBPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGNvbXBPcHRpb25zICYmIGNvbXBPcHRpb25zLkN0b3Iub3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHJldHVybiBnZXRSZWFsQ2hpbGQoZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChjb21wT3B0aW9ucy5jaGlsZHJlbikpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZub2RlXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdFRyYW5zaXRpb25EYXRhIChjb21wKSB7XG4gIHZhciBkYXRhID0ge307XG4gIHZhciBvcHRpb25zID0gY29tcC4kb3B0aW9ucztcbiAgLy8gcHJvcHNcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMucHJvcHNEYXRhKSB7XG4gICAgZGF0YVtrZXldID0gY29tcFtrZXldO1xuICB9XG4gIC8vIGV2ZW50cy5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMgYW5kIHBhc3MgdGhlbSBkaXJlY3RseSB0byB0aGUgdHJhbnNpdGlvbiBtZXRob2RzXG4gIHZhciBsaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGZvciAodmFyIGtleSQxIGluIGxpc3RlbmVycykge1xuICAgIGRhdGFbY2FtZWxpemUoa2V5JDEpXSA9IGxpc3RlbmVyc1trZXkkMV07XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gcGxhY2Vob2xkZXIgKGgsIHJhd0NoaWxkKSB7XG4gIGlmICgvXFxkLWtlZXAtYWxpdmUkLy50ZXN0KHJhd0NoaWxkLnRhZykpIHtcbiAgICByZXR1cm4gaCgna2VlcC1hbGl2ZScsIHtcbiAgICAgIHByb3BzOiByYXdDaGlsZC5jb21wb25lbnRPcHRpb25zLnByb3BzRGF0YVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzUGFyZW50VHJhbnNpdGlvbiAodm5vZGUpIHtcbiAgd2hpbGUgKCh2bm9kZSA9IHZub2RlLnBhcmVudCkpIHtcbiAgICBpZiAodm5vZGUuZGF0YS50cmFuc2l0aW9uKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1NhbWVDaGlsZCAoY2hpbGQsIG9sZENoaWxkKSB7XG4gIHJldHVybiBvbGRDaGlsZC5rZXkgPT09IGNoaWxkLmtleSAmJiBvbGRDaGlsZC50YWcgPT09IGNoaWxkLnRhZ1xufVxuXG52YXIgVHJhbnNpdGlvbiA9IHtcbiAgbmFtZTogJ3RyYW5zaXRpb24nLFxuICBwcm9wczogdHJhbnNpdGlvblByb3BzLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcbiAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIgb3V0IHRleHQgbm9kZXMgKHBvc3NpYmxlIHdoaXRlc3BhY2VzKVxuICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRhZyB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYyk7IH0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3YXJuIG11bHRpcGxlIGVsZW1lbnRzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgd2FybihcbiAgICAgICAgJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQuIFVzZSAnICtcbiAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBtb2RlID0gdGhpcy5tb2RlO1xuXG4gICAgLy8gd2FybiBpbnZhbGlkIG1vZGVcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgbW9kZSAmJiBtb2RlICE9PSAnaW4tb3V0JyAmJiBtb2RlICE9PSAnb3V0LWluJ1xuICAgICkge1xuICAgICAgd2FybihcbiAgICAgICAgJ2ludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICcgKyBtb2RlLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHJhd0NoaWxkID0gY2hpbGRyZW5bMF07XG5cbiAgICAvLyBpZiB0aGlzIGlzIGEgY29tcG9uZW50IHJvb3Qgbm9kZSBhbmQgdGhlIGNvbXBvbmVudCdzXG4gICAgLy8gcGFyZW50IGNvbnRhaW5lciBub2RlIGFsc28gaGFzIHRyYW5zaXRpb24sIHNraXAuXG4gICAgaWYgKGhhc1BhcmVudFRyYW5zaXRpb24odGhpcy4kdm5vZGUpKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICAvLyBhcHBseSB0cmFuc2l0aW9uIGRhdGEgdG8gY2hpbGRcbiAgICAvLyB1c2UgZ2V0UmVhbENoaWxkKCkgdG8gaWdub3JlIGFic3RyYWN0IGNvbXBvbmVudHMgZS5nLiBrZWVwLWFsaXZlXG4gICAgdmFyIGNoaWxkID0gZ2V0UmVhbENoaWxkKHJhd0NoaWxkKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGVhdmluZykge1xuICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgIH1cblxuICAgIC8vIGVuc3VyZSBhIGtleSB0aGF0IGlzIHVuaXF1ZSB0byB0aGUgdm5vZGUgdHlwZSBhbmQgdG8gdGhpcyB0cmFuc2l0aW9uXG4gICAgLy8gY29tcG9uZW50IGluc3RhbmNlLiBUaGlzIGtleSB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHBlbmRpbmcgbGVhdmluZyBub2Rlc1xuICAgIC8vIGR1cmluZyBlbnRlcmluZy5cbiAgICB2YXIgaWQgPSBcIl9fdHJhbnNpdGlvbi1cIiArICh0aGlzLl91aWQpICsgXCItXCI7XG4gICAgY2hpbGQua2V5ID0gY2hpbGQua2V5ID09IG51bGxcbiAgICAgID8gY2hpbGQuaXNDb21tZW50XG4gICAgICAgID8gaWQgKyAnY29tbWVudCdcbiAgICAgICAgOiBpZCArIGNoaWxkLnRhZ1xuICAgICAgOiBpc1ByaW1pdGl2ZShjaGlsZC5rZXkpXG4gICAgICAgID8gKFN0cmluZyhjaGlsZC5rZXkpLmluZGV4T2YoaWQpID09PSAwID8gY2hpbGQua2V5IDogaWQgKyBjaGlsZC5rZXkpXG4gICAgICAgIDogY2hpbGQua2V5O1xuXG4gICAgdmFyIGRhdGEgPSAoY2hpbGQuZGF0YSB8fCAoY2hpbGQuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcbiAgICB2YXIgb2xkUmF3Q2hpbGQgPSB0aGlzLl92bm9kZTtcbiAgICB2YXIgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xuXG4gICAgLy8gbWFyayB2LXNob3dcbiAgICAvLyBzbyB0aGF0IHRoZSB0cmFuc2l0aW9uIG1vZHVsZSBjYW4gaGFuZCBvdmVyIHRoZSBjb250cm9sIHRvIHRoZSBkaXJlY3RpdmVcbiAgICBpZiAoY2hpbGQuZGF0YS5kaXJlY3RpdmVzICYmIGNoaWxkLmRhdGEuZGlyZWN0aXZlcy5zb21lKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdzaG93JzsgfSkpIHtcbiAgICAgIGNoaWxkLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgb2xkQ2hpbGQgJiZcbiAgICAgIG9sZENoaWxkLmRhdGEgJiZcbiAgICAgICFpc1NhbWVDaGlsZChjaGlsZCwgb2xkQ2hpbGQpICYmXG4gICAgICAhaXNBc3luY1BsYWNlaG9sZGVyKG9sZENoaWxkKSAmJlxuICAgICAgLy8gIzY2ODcgY29tcG9uZW50IHJvb3QgaXMgYSBjb21tZW50IG5vZGVcbiAgICAgICEob2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UgJiYgb2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlLmlzQ29tbWVudClcbiAgICApIHtcbiAgICAgIC8vIHJlcGxhY2Ugb2xkIGNoaWxkIHRyYW5zaXRpb24gZGF0YSB3aXRoIGZyZXNoIG9uZVxuICAgICAgLy8gaW1wb3J0YW50IGZvciBkeW5hbWljIHRyYW5zaXRpb25zIVxuICAgICAgdmFyIG9sZERhdGEgPSBvbGRDaGlsZC5kYXRhLnRyYW5zaXRpb24gPSBleHRlbmQoe30sIGRhdGEpO1xuICAgICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gbW9kZVxuICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XG4gICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xuICAgICAgICB0aGlzLl9sZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2FmdGVyTGVhdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcyQxLl9sZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcyQxLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAnaW4tb3V0Jykge1xuICAgICAgICBpZiAoaXNBc3luY1BsYWNlaG9sZGVyKGNoaWxkKSkge1xuICAgICAgICAgIHJldHVybiBvbGRSYXdDaGlsZFxuICAgICAgICB9XG4gICAgICAgIHZhciBkZWxheWVkTGVhdmU7XG4gICAgICAgIHZhciBwZXJmb3JtTGVhdmUgPSBmdW5jdGlvbiAoKSB7IGRlbGF5ZWRMZWF2ZSgpOyB9O1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnYWZ0ZXJFbnRlcicsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdlbnRlckNhbmNlbGxlZCcsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdkZWxheUxlYXZlJywgZnVuY3Rpb24gKGxlYXZlKSB7IGRlbGF5ZWRMZWF2ZSA9IGxlYXZlOyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmF3Q2hpbGRcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBsaXN0IGl0ZW1zLlxuLy8gc3VwcG9ydHMgbW92ZSB0cmFuc2l0aW9ucyB1c2luZyB0aGUgRkxJUCB0ZWNobmlxdWUuXG5cbi8vIEJlY2F1c2UgdGhlIHZkb20ncyBjaGlsZHJlbiB1cGRhdGUgYWxnb3JpdGhtIGlzIFwidW5zdGFibGVcIiAtIGkuZS5cbi8vIGl0IGRvZXNuJ3QgZ3VhcmFudGVlIHRoZSByZWxhdGl2ZSBwb3NpdGlvbmluZyBvZiByZW1vdmVkIGVsZW1lbnRzLFxuLy8gd2UgZm9yY2UgdHJhbnNpdGlvbi1ncm91cCB0byB1cGRhdGUgaXRzIGNoaWxkcmVuIGludG8gdHdvIHBhc3Nlczpcbi8vIGluIHRoZSBmaXJzdCBwYXNzLCB3ZSByZW1vdmUgYWxsIG5vZGVzIHRoYXQgbmVlZCB0byBiZSByZW1vdmVkLFxuLy8gdHJpZ2dlcmluZyB0aGVpciBsZWF2aW5nIHRyYW5zaXRpb247IGluIHRoZSBzZWNvbmQgcGFzcywgd2UgaW5zZXJ0L21vdmVcbi8vIGludG8gdGhlIGZpbmFsIGRlc2lyZWQgc3RhdGUuIFRoaXMgd2F5IGluIHRoZSBzZWNvbmQgcGFzcyByZW1vdmVkXG4vLyBub2RlcyB3aWxsIHJlbWFpbiB3aGVyZSB0aGV5IHNob3VsZCBiZS5cblxudmFyIHByb3BzID0gZXh0ZW5kKHtcbiAgdGFnOiBTdHJpbmcsXG4gIG1vdmVDbGFzczogU3RyaW5nXG59LCB0cmFuc2l0aW9uUHJvcHMpO1xuXG5kZWxldGUgcHJvcHMubW9kZTtcblxudmFyIFRyYW5zaXRpb25Hcm91cCA9IHtcbiAgcHJvcHM6IHByb3BzLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRhZyA9IHRoaXMudGFnIHx8IHRoaXMuJHZub2RlLmRhdGEudGFnIHx8ICdzcGFuJztcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgIHZhciByYXdDaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHZhciB0cmFuc2l0aW9uRGF0YSA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gcmF3Q2hpbGRyZW5baV07XG4gICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgaWYgKGMua2V5ICE9IG51bGwgJiYgU3RyaW5nKGMua2V5KS5pbmRleE9mKCdfX3ZsaXN0JykgIT09IDApIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGMpO1xuICAgICAgICAgIG1hcFtjLmtleV0gPSBjXG4gICAgICAgICAgOyhjLmRhdGEgfHwgKGMuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB2YXIgb3B0cyA9IGMuY29tcG9uZW50T3B0aW9ucztcbiAgICAgICAgICB2YXIgbmFtZSA9IG9wdHMgPyAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZyB8fCAnJykgOiBjLnRhZztcbiAgICAgICAgICB3YXJuKChcIjx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkOiA8XCIgKyBuYW1lICsgXCI+XCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHZhciBrZXB0ID0gW107XG4gICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgdmFyIGMkMSA9IHByZXZDaGlsZHJlbltpJDFdO1xuICAgICAgICBjJDEuZGF0YS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIGMkMS5kYXRhLnBvcyA9IGMkMS5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtYXBbYyQxLmtleV0pIHtcbiAgICAgICAgICBrZXB0LnB1c2goYyQxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmVkLnB1c2goYyQxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5rZXB0ID0gaCh0YWcsIG51bGwsIGtlcHQpO1xuICAgICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gaCh0YWcsIG51bGwsIGNoaWxkcmVuKVxuICB9LFxuXG4gIGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24gYmVmb3JlVXBkYXRlICgpIHtcbiAgICAvLyBmb3JjZSByZW1vdmluZyBwYXNzXG4gICAgdGhpcy5fX3BhdGNoX18oXG4gICAgICB0aGlzLl92bm9kZSxcbiAgICAgIHRoaXMua2VwdCxcbiAgICAgIGZhbHNlLCAvLyBoeWRyYXRpbmdcbiAgICAgIHRydWUgLy8gcmVtb3ZlT25seSAoIWltcG9ydGFudCwgYXZvaWRzIHVubmVjZXNzYXJ5IG1vdmVzKVxuICAgICk7XG4gICAgdGhpcy5fdm5vZGUgPSB0aGlzLmtlcHQ7XG4gIH0sXG5cbiAgdXBkYXRlZDogZnVuY3Rpb24gdXBkYXRlZCAoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW47XG4gICAgdmFyIG1vdmVDbGFzcyA9IHRoaXMubW92ZUNsYXNzIHx8ICgodGhpcy5uYW1lIHx8ICd2JykgKyAnLW1vdmUnKTtcbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCB8fCAhdGhpcy5oYXNNb3ZlKGNoaWxkcmVuWzBdLmVsbSwgbW92ZUNsYXNzKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2UgZGl2aWRlIHRoZSB3b3JrIGludG8gdGhyZWUgbG9vcHMgdG8gYXZvaWQgbWl4aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzXG4gICAgLy8gaW4gZWFjaCBpdGVyYXRpb24gLSB3aGljaCBoZWxwcyBwcmV2ZW50IGxheW91dCB0aHJhc2hpbmcuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChhcHBseVRyYW5zbGF0aW9uKTtcblxuICAgIC8vIGZvcmNlIHJlZmxvdyB0byBwdXQgZXZlcnl0aGluZyBpbiBwb3NpdGlvblxuICAgIC8vIGFzc2lnbiB0byB0aGlzIHRvIGF2b2lkIGJlaW5nIHJlbW92ZWQgaW4gdHJlZS1zaGFraW5nXG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgdGhpcy5fcmVmbG93ID0gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ7XG5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICBpZiAoYy5kYXRhLm1vdmVkKSB7XG4gICAgICAgIHZhciBlbCA9IGMuZWxtO1xuICAgICAgICB2YXIgcyA9IGVsLnN0eWxlO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcnO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgZWwuX21vdmVDYiA9IGZ1bmN0aW9uIGNiIChlKSB7XG4gICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGNiKTtcbiAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xuICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGhhc01vdmU6IGZ1bmN0aW9uIGhhc01vdmUgKGVsLCBtb3ZlQ2xhc3MpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFoYXNUcmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAodGhpcy5faGFzTW92ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzTW92ZVxuICAgICAgfVxuICAgICAgLy8gRGV0ZWN0IHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBtb3ZlIGNsYXNzIGFwcGxpZWQgaGFzXG4gICAgICAvLyBDU1MgdHJhbnNpdGlvbnMuIFNpbmNlIHRoZSBlbGVtZW50IG1heSBiZSBpbnNpZGUgYW4gZW50ZXJpbmdcbiAgICAgIC8vIHRyYW5zaXRpb24gYXQgdGhpcyB2ZXJ5IG1vbWVudCwgd2UgbWFrZSBhIGNsb25lIG9mIGl0IGFuZCByZW1vdmVcbiAgICAgIC8vIGFsbCBvdGhlciB0cmFuc2l0aW9uIGNsYXNzZXMgYXBwbGllZCB0byBlbnN1cmUgb25seSB0aGUgbW92ZSBjbGFzc1xuICAgICAgLy8gaXMgYXBwbGllZC5cbiAgICAgIHZhciBjbG9uZSA9IGVsLmNsb25lTm9kZSgpO1xuICAgICAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgICAgICBlbC5fdHJhbnNpdGlvbkNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7IHJlbW92ZUNsYXNzKGNsb25lLCBjbHMpOyB9KTtcbiAgICAgIH1cbiAgICAgIGFkZENsYXNzKGNsb25lLCBtb3ZlQ2xhc3MpO1xuICAgICAgY2xvbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIHRoaXMuJGVsLmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICAgIHZhciBpbmZvID0gZ2V0VHJhbnNpdGlvbkluZm8oY2xvbmUpO1xuICAgICAgdGhpcy4kZWwucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgICAgcmV0dXJuICh0aGlzLl9oYXNNb3ZlID0gaW5mby5oYXNUcmFuc2Zvcm0pXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxQZW5kaW5nQ2JzIChjKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX21vdmVDYikge1xuICAgIGMuZWxtLl9tb3ZlQ2IoKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9lbnRlckNiKSB7XG4gICAgYy5lbG0uX2VudGVyQ2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRQb3NpdGlvbiAoYykge1xuICBjLmRhdGEubmV3UG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRpb24gKGMpIHtcbiAgdmFyIG9sZFBvcyA9IGMuZGF0YS5wb3M7XG4gIHZhciBuZXdQb3MgPSBjLmRhdGEubmV3UG9zO1xuICB2YXIgZHggPSBvbGRQb3MubGVmdCAtIG5ld1Bvcy5sZWZ0O1xuICB2YXIgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcbiAgaWYgKGR4IHx8IGR5KSB7XG4gICAgYy5kYXRhLm1vdmVkID0gdHJ1ZTtcbiAgICB2YXIgcyA9IGMuZWxtLnN0eWxlO1xuICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIGR4ICsgXCJweCxcIiArIGR5ICsgXCJweClcIjtcbiAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XG4gIH1cbn1cblxudmFyIHBsYXRmb3JtQ29tcG9uZW50cyA9IHtcbiAgVHJhbnNpdGlvbjogVHJhbnNpdGlvbixcbiAgVHJhbnNpdGlvbkdyb3VwOiBUcmFuc2l0aW9uR3JvdXBcbn1cblxuLyogICovXG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcblZ1ZS5jb25maWcubXVzdFVzZVByb3AgPSBtdXN0VXNlUHJvcDtcblZ1ZS5jb25maWcuaXNSZXNlcnZlZFRhZyA9IGlzUmVzZXJ2ZWRUYWc7XG5WdWUuY29uZmlnLmlzUmVzZXJ2ZWRBdHRyID0gaXNSZXNlcnZlZEF0dHI7XG5WdWUuY29uZmlnLmdldFRhZ05hbWVzcGFjZSA9IGdldFRhZ05hbWVzcGFjZTtcblZ1ZS5jb25maWcuaXNVbmtub3duRWxlbWVudCA9IGlzVW5rbm93bkVsZW1lbnQ7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xuZXh0ZW5kKFZ1ZS5vcHRpb25zLmRpcmVjdGl2ZXMsIHBsYXRmb3JtRGlyZWN0aXZlcyk7XG5leHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgcGxhdGZvcm1Db21wb25lbnRzKTtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBwYXRjaCBmdW5jdGlvblxuVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCA6IG5vb3A7XG5cbi8vIHB1YmxpYyBtb3VudCBtZXRob2RcblZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBpbkJyb3dzZXIgPyBxdWVyeShlbCkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBtb3VudENvbXBvbmVudCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLy8gZGV2dG9vbHMgZ2xvYmFsIGhvb2tcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5pZiAoaW5Ccm93c2VyKSB7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmIChjb25maWcuZGV2dG9vbHMpIHtcbiAgICAgIGlmIChkZXZ0b29scykge1xuICAgICAgICBkZXZ0b29scy5lbWl0KCdpbml0JywgVnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJlxuICAgICAgICBpc0Nocm9tZVxuICAgICAgKSB7XG4gICAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgICAgICdEb3dubG9hZCB0aGUgVnVlIERldnRvb2xzIGV4dGVuc2lvbiBmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTpcXG4nICtcbiAgICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scydcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiZcbiAgICAgIGNvbmZpZy5wcm9kdWN0aW9uVGlwICE9PSBmYWxzZSAmJlxuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnXG4gICAgKSB7XG4gICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgXCJZb3UgYXJlIHJ1bm5pbmcgVnVlIGluIGRldmVsb3BtZW50IG1vZGUuXFxuXCIgK1xuICAgICAgICBcIk1ha2Ugc3VyZSB0byB0dXJuIG9uIHByb2R1Y3Rpb24gbW9kZSB3aGVuIGRlcGxveWluZyBmb3IgcHJvZHVjdGlvbi5cXG5cIiArXG4gICAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIlxuICAgICAgKTtcbiAgICB9XG4gIH0sIDApO1xufVxuXG4vKiAgKi9cblxuZXhwb3J0IGRlZmF1bHQgVnVlO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///28\\n\")},,,,,function(module,exports,__webpack_require__){\"use strict\";eval(\"\\n\\nvar _vue = __webpack_require__(28);\\n\\nvar _vue2 = _interopRequireDefault(_vue);\\n\\nvar _weexVueRender = __webpack_require__(24);\\n\\nvar _weexVueRender2 = _interopRequireDefault(_weexVueRender);\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\n_weexVueRender2.default.init(_vue2.default);\\n\\nvar App = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\\\"Cannot find module '../../src/components/HelloWorld.vue'\\\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\\nnew _vue2.default(_vue2.default.util.extend({ el: '#root' }, App));//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi8udGVtcC9jb21wb25lbnRzL0hlbGxvV29ybGQud2ViLmpzPzFkOWMiXSwibmFtZXMiOlsid2VleCIsImluaXQiLCJWdWUiLCJBcHAiLCJyZXF1aXJlIiwidXRpbCIsImV4dGVuZCIsImVsIl0sIm1hcHBpbmdzIjoiOztBQUFBOzs7O0FBQ0E7Ozs7OztBQUVBQSx3QkFBS0MsSUFBTCxDQUFVQyxhQUFWOztBQUVBLElBQU1DLE1BQU0sbUJBQUFDLENBQVEsNkpBQVIsQ0FBWjtBQUNBLElBQUlGLGFBQUosQ0FBUUEsY0FBSUcsSUFBSixDQUFTQyxNQUFULENBQWdCLEVBQUNDLElBQUksT0FBTCxFQUFoQixFQUErQkosR0FBL0IsQ0FBUiIsImZpbGUiOiIzMy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBWdWUgZnJvbSAndnVlJ1xuaW1wb3J0IHdlZXggZnJvbSAnd2VleC12dWUtcmVuZGVyJ1xuXG53ZWV4LmluaXQoVnVlKVxuXG5jb25zdCBBcHAgPSByZXF1aXJlKCcuLi8uLi9zcmMvY29tcG9uZW50cy9IZWxsb1dvcmxkLnZ1ZScpO1xubmV3IFZ1ZShWdWUudXRpbC5leHRlbmQoe2VsOiAnI3Jvb3QnfSwgQXBwKSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///33\\n\")},function(n,B,I){I(23),n.exports=I(33)}]);","extractedComments":[]}